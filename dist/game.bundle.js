(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["exagaming"] = factory();
	else
		root["exagaming"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 7480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const GLHook_1 = __importDefault(__webpack_require__(7411));
const TextureHook_1 = __importDefault(__webpack_require__(68035));
class BaseHooks {
    constructor() {
        this._drawCalls = -1;
        this._maxDeltaDrawCalls = -1;
    }
    attach(gl) {
        this.glhook = new GLHook_1.default(gl);
        this.texturehook = new TextureHook_1.default(gl);
    }
    get drawCalls() {
        if (this.glhook && this.glhook.isInit) {
            return this.glhook.drawPasses;
        }
        return -1;
    }
    get maxDeltaDrawCalls() {
        return this._maxDeltaDrawCalls;
    }
    get deltaDrawCalls() {
        if (this._drawCalls == -1) {
            this._drawCalls = this.drawCalls;
            return 0;
        }
        var dc = this.drawCalls;
        var delta = dc - this._drawCalls;
        this._drawCalls = dc;
        this._maxDeltaDrawCalls = Math.max(this._maxDeltaDrawCalls, delta);
        return delta;
    }
    get maxTextureCount() {
        if (this.texturehook && this.texturehook.isInit)
            return this.texturehook.maxTexturesCount;
        return 0;
    }
    get texturesCount() {
        if (this.texturehook && this.texturehook.isInit)
            return this.texturehook.currentTextureCount;
        return 0;
    }
    reset() {
        this._maxDeltaDrawCalls = -1;
        this._drawCalls = -1;
        if (this.glhook)
            this.glhook.reset();
        if (this.texturehook)
            this.texturehook.reset();
    }
    release() {
        if (this.glhook)
            this.glhook.release();
        if (this.texturehook)
            this.texturehook.release();
    }
}
exports["default"] = BaseHooks;
//# sourceMappingURL=BaseHooks.js.map

/***/ }),

/***/ 7411:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class GLHook {
    constructor(_gl) {
        this.drawPasses = 0;
        this.isInit = false;
        this.realGLDrawElements = function () { };
        if (_gl) {
            if (_gl.__proto__.drawElements) {
                this.gl = _gl;
                this.realGLDrawElements = _gl.__proto__.drawElements;
                //replace to new function
                _gl.__proto__.drawElements = this.fakeGLdrawElements.bind(this);
                this.isInit = true;
                console.log("[GLHook] GL was Hooked!");
            }
        }
        else {
            console.error("[GLHook] GL can't be NULL");
        }
    }
    fakeGLdrawElements(mode, count, type, offset) {
        this.drawPasses++;
        this.realGLDrawElements.call(this.gl, mode, count, type, offset);
    }
    reset() {
        this.drawPasses = 0;
    }
    release() {
        if (this.isInit) {
            this.gl.__proto__.drawElements = this.realGLDrawElements;
            console.log("[GLHook] Hook was removed!");
        }
        this.isInit = false;
    }
}
exports["default"] = GLHook;
//# sourceMappingURL=GLHook.js.map

/***/ }),

/***/ 68035:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class TextureHook {
    constructor(_gl) {
        this.createdTextures = new Array();
        this.maxTexturesCount = 0;
        this.isInit = false;
        this.realGLCreateTexture = function () { };
        this.realGLDeleteTexture = function () { };
        if (_gl) {
            if (_gl.__proto__.createTexture) {
                this.gl = _gl;
                this.realGLCreateTexture = _gl.__proto__.createTexture;
                this.realGLDeleteTexture = _gl.__proto__.deleteTexture;
                //replace to new function
                _gl.__proto__.createTexture = this.fakeGLCreateTexture.bind(this);
                _gl.__proto__.deleteTexture = this.fakeGLDeleteTexture.bind(this);
                this.isInit = true;
                console.log("[TextureHook] GL was Hooked!");
            }
        }
        else {
            console.error("[TextureHook] GL can't be NULL");
        }
    }
    get currentTextureCount() {
        return this.createdTextures.length;
    }
    registerTexture(texture) {
        this.createdTextures.push(texture); // ++;
        this.maxTexturesCount = Math.max(this.createdTextures.length, this.maxTexturesCount);
    }
    fakeGLCreateTexture() {
        var texture = this.realGLCreateTexture.call(this.gl);
        this.registerTexture(texture);
        return texture;
    }
    fakeGLDeleteTexture(texture) {
        var index = this.createdTextures.indexOf(texture);
        if (index > -1) {
            this.createdTextures.splice(index, 1);
        }
        this.realGLDeleteTexture.call(this.gl, texture);
    }
    reset() {
        this.createdTextures = new Array();
        this.maxTexturesCount = 0;
    }
    release() {
        if (this.isInit) {
            this.gl.__proto__.createTexture = this.realGLCreateTexture;
            this.gl.__proto__.deleteTexture = this.realGLDeleteTexture;
            console.log("[TextureHook] Hook was removed!");
        }
        this.isInit = false;
    }
}
exports["default"] = TextureHook;
//# sourceMappingURL=TextureHook.js.map

/***/ }),

/***/ 50637:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var AttachmentType = __webpack_require__(90854);
var TextureRegion = __webpack_require__(86936);
var Utils = __webpack_require__(22302);
var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var sprite = __webpack_require__(64441);
var meshExtras = __webpack_require__(42683);
var graphics = __webpack_require__(47997);
var settings = __webpack_require__(30358);

const tempRgb = [0, 0, 0];
class SpineSprite extends sprite.Sprite {
  constructor() {
    super(...arguments);
    this.region = null;
    this.attachment = null;
  }
}
class SpineMesh extends meshExtras.SimpleMesh {
  constructor(texture, vertices, uvs, indices, drawMode) {
    super(texture, vertices, uvs, indices, drawMode);
    this.region = null;
    this.attachment = null;
  }
}
const _SpineBase = class extends display.Container {
  constructor(spineData) {
    super();
    if (!spineData) {
      throw new Error("The spineData param is required.");
    }
    if (typeof spineData === "string") {
      throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
    }
    this.spineData = spineData;
    this.createSkeleton(spineData);
    this.slotContainers = [];
    this.tempClipContainers = [];
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.newContainer();
      this.slotContainers.push(slotContainer);
      this.addChild(slotContainer);
      this.tempClipContainers.push(null);
      if (!attachment) {
        continue;
      }
      if (attachment.type === AttachmentType.AttachmentType.Region) {
        const spriteName = attachment.name;
        const sprite = this.createSprite(slot, attachment, spriteName);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
      } else if (attachment.type === AttachmentType.AttachmentType.Mesh) {
        const mesh = this.createMesh(slot, attachment);
        slot.currentMesh = mesh;
        slot.currentMeshId = attachment.id;
        slot.currentMeshName = attachment.name;
        slotContainer.addChild(mesh);
      } else if (attachment.type === AttachmentType.AttachmentType.Clipping) {
        this.createGraphics(slot, attachment);
        slotContainer.addChild(slot.clippingContainer);
        slotContainer.addChild(slot.currentGraphics);
      }
    }
    this.tintRgb = new Float32Array([1, 1, 1]);
    this.autoUpdate = true;
    this.visible = true;
  }
  get debug() {
    return this._debug;
  }
  set debug(value) {
    if (value == this._debug) {
      return;
    }
    this._debug?.unregisterSpine(this);
    value?.registerSpine(this);
    this._debug = value;
  }
  /**
   * If this flag is set to true, the spine animation will be automatically updated every
   * time the object id drawn. The down side of this approach is that the delta time is
   * automatically calculated and you could miss out on cool effects like slow motion,
   * pause, skip ahead and the sorts. Most of these effects can be achieved even with
   * autoUpdate enabled but are harder to achieve.
   *
   * @member {boolean}
   * @memberof spine.Spine#
   * @default true
   */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      this.updateTransform = value ? _SpineBase.prototype.autoUpdateTransform : display.Container.prototype.updateTransform;
    }
  }
  /**
   * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
   *
   * @member {number}
   * @memberof spine.Spine#
   * @default 0xFFFFFF
   */
  get tint() {
    return core.utils.rgb2hex(this.tintRgb);
  }
  set tint(value) {
    this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);
  }
  /**
   * Limit value for the update dt with Spine.globalDelayLimit
   * that can be overridden with localDelayLimit
   * @return {number} - Maximum processed dt value for the update
   */
  get delayLimit() {
    const limit = typeof this.localDelayLimit !== "undefined" ? this.localDelayLimit : settings.settings.GLOBAL_DELAY_LIMIT;
    return limit || Number.MAX_VALUE;
  }
  /**
   * Update the spine skeleton and its animations by delta time (dt)
   *
   * @param dt {number} Delta time. Time by which the animation should be updated
   */
  update(dt) {
    const delayLimit = this.delayLimit;
    if (dt > delayLimit)
      dt = delayLimit;
    this.state.update(dt);
    this.state.apply(this.skeleton);
    if (!this.skeleton) {
      return;
    }
    this.skeleton.updateWorldTransform();
    const slots = this.skeleton.slots;
    const globalClr = this.color;
    let light = null;
    let dark = null;
    if (globalClr) {
      light = globalClr.light;
      dark = globalClr.dark;
    } else {
      light = this.tintRgb;
    }
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.slotContainers[i];
      if (!attachment) {
        slotContainer.visible = false;
        continue;
      }
      let spriteColor = null;
      if (attachment.sequence) {
        attachment.sequence.apply(slot, attachment);
      }
      let region = attachment.region;
      const attColor = attachment.color;
      switch (attachment != null && attachment.type) {
        case AttachmentType.AttachmentType.Region:
          const transform = slotContainer.transform;
          transform.setFromMatrix(slot.bone.matrix);
          region = attachment.region;
          if (slot.currentMesh) {
            slot.currentMesh.visible = false;
            slot.currentMesh = null;
            slot.currentMeshId = void 0;
            slot.currentMeshName = void 0;
          }
          if (!region) {
            if (slot.currentSprite) {
              slot.currentSprite.renderable = false;
            }
            break;
          }
          if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {
            const spriteName = attachment.name;
            if (slot.currentSprite) {
              slot.currentSprite.visible = false;
            }
            slot.sprites = slot.sprites || {};
            if (slot.sprites[spriteName] !== void 0) {
              slot.sprites[spriteName].visible = true;
            } else {
              const sprite = this.createSprite(slot, attachment, spriteName);
              slotContainer.addChild(sprite);
            }
            slot.currentSprite = slot.sprites[spriteName];
            slot.currentSpriteName = spriteName;
          }
          slot.currentSprite.renderable = true;
          if (!slot.hackRegion) {
            this.setSpriteRegion(attachment, slot.currentSprite, region);
          }
          if (slot.currentSprite.color) {
            spriteColor = slot.currentSprite.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentSprite.tint = core.utils.rgb2hex(tempRgb);
          }
          slot.currentSprite.blendMode = slot.blendMode;
          break;
        case AttachmentType.AttachmentType.Mesh:
          if (slot.currentSprite) {
            slot.currentSprite.visible = false;
            slot.currentSprite = null;
            slot.currentSpriteName = void 0;
            const transform2 = new core.Transform();
            transform2._parentID = -1;
            transform2._worldID = slotContainer.transform._worldID;
            slotContainer.transform = transform2;
          }
          if (!region) {
            if (slot.currentMesh) {
              slot.currentMesh.renderable = false;
            }
            break;
          }
          const id = attachment.id;
          if (slot.currentMeshId === void 0 || slot.currentMeshId !== id) {
            const meshId = id;
            if (slot.currentMesh) {
              slot.currentMesh.visible = false;
            }
            slot.meshes = slot.meshes || {};
            if (slot.meshes[meshId] !== void 0) {
              slot.meshes[meshId].visible = true;
            } else {
              const mesh = this.createMesh(slot, attachment);
              slotContainer.addChild(mesh);
            }
            slot.currentMesh = slot.meshes[meshId];
            slot.currentMeshName = attachment.name;
            slot.currentMeshId = meshId;
          }
          slot.currentMesh.renderable = true;
          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
          if (slot.currentMesh.color) {
            spriteColor = slot.currentMesh.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentMesh.tint = core.utils.rgb2hex(tempRgb);
          }
          slot.currentMesh.blendMode = slot.blendMode;
          if (!slot.hackRegion) {
            this.setMeshRegion(attachment, slot.currentMesh, region);
          }
          break;
        case AttachmentType.AttachmentType.Clipping:
          if (!slot.currentGraphics) {
            this.createGraphics(slot, attachment);
            slotContainer.addChild(slot.clippingContainer);
            slotContainer.addChild(slot.currentGraphics);
          }
          this.updateGraphics(slot, attachment);
          slotContainer.alpha = 1;
          slotContainer.visible = true;
          continue;
        default:
          slotContainer.visible = false;
          continue;
      }
      slotContainer.visible = true;
      if (spriteColor) {
        let r0 = slot.color.r * attColor.r;
        let g0 = slot.color.g * attColor.g;
        let b0 = slot.color.b * attColor.b;
        spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
        if (slot.darkColor) {
          r0 = slot.darkColor.r;
          g0 = slot.darkColor.g;
          b0 = slot.darkColor.b;
        } else {
          r0 = 0;
          g0 = 0;
          b0 = 0;
        }
        spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
      }
      slotContainer.alpha = slot.color.a;
    }
    const drawOrder = this.skeleton.drawOrder;
    let clippingAttachment = null;
    let clippingContainer = null;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = slots[drawOrder[i].data.index];
      const slotContainer = this.slotContainers[drawOrder[i].data.index];
      if (!clippingContainer) {
        if (slotContainer.parent !== null && slotContainer.parent !== this) {
          slotContainer.parent.removeChild(slotContainer);
          slotContainer.parent = this;
        }
      }
      if (slot.currentGraphics && slot.getAttachment()) {
        clippingContainer = slot.clippingContainer;
        clippingAttachment = slot.getAttachment();
        clippingContainer.children.length = 0;
        this.children[i] = slotContainer;
        if (clippingAttachment.endSlot === slot.data) {
          clippingAttachment.endSlot = null;
        }
      } else if (clippingContainer) {
        let c = this.tempClipContainers[i];
        if (!c) {
          c = this.tempClipContainers[i] = this.newContainer();
          c.visible = false;
        }
        this.children[i] = c;
        slotContainer.parent = null;
        clippingContainer.addChild(slotContainer);
        if (clippingAttachment.endSlot == slot.data) {
          clippingContainer.renderable = true;
          clippingContainer = null;
          clippingAttachment = null;
        }
      } else {
        this.children[i] = slotContainer;
      }
    }
    this._debug?.renderDebug(this);
  }
  setSpriteRegion(attachment, sprite, region) {
    if (sprite.attachment === attachment && sprite.region === region) {
      return;
    }
    sprite.region = region;
    sprite.attachment = attachment;
    sprite.texture = region.texture;
    sprite.rotation = attachment.rotation * Utils.MathUtils.degRad;
    sprite.position.x = attachment.x;
    sprite.position.y = attachment.y;
    sprite.alpha = attachment.color.a;
    if (!region.size) {
      sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
      sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;
    } else {
      sprite.scale.x = region.size.width / region.originalWidth;
      sprite.scale.y = -region.size.height / region.originalHeight;
    }
  }
  setMeshRegion(attachment, mesh, region) {
    if (mesh.attachment === attachment && mesh.region === region) {
      return;
    }
    mesh.region = region;
    mesh.attachment = attachment;
    mesh.texture = region.texture;
    region.texture.updateUvs();
    mesh.uvBuffer.update(attachment.regionUVs);
  }
  /**
   * When autoupdate is set to yes this function is used as pixi's updateTransform function
   *
   * @private
   */
  autoUpdateTransform() {
    if (settings.settings.GLOBAL_AUTO_UPDATE) {
      this.lastTime = this.lastTime || Date.now();
      const timeDelta = (Date.now() - this.lastTime) * 1e-3;
      this.lastTime = Date.now();
      this.update(timeDelta);
    } else {
      this.lastTime = 0;
    }
    display.Container.prototype.updateTransform.call(this);
  }
  /**
   * Create a new sprite to be used with core.RegionAttachment
   *
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createSprite(slot, attachment, defName) {
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
    }
    const texture = region ? region.texture : null;
    const sprite = this.newSprite(texture);
    sprite.anchor.set(0.5);
    if (region) {
      this.setSpriteRegion(attachment, sprite, attachment.region);
    }
    slot.sprites = slot.sprites || {};
    slot.sprites[defName] = sprite;
    return sprite;
  }
  /**
   * Creates a Strip from the spine data
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createMesh(slot, attachment) {
    if (!attachment.region && attachment.sequence) {
      attachment.sequence.apply(slot, attachment);
    }
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
      slot.hackAttachment = null;
      slot.hackRegion = null;
    }
    const strip = this.newMesh(
      region ? region.texture : null,
      new Float32Array(attachment.regionUVs.length),
      attachment.regionUVs,
      new Uint16Array(attachment.triangles),
      core.DRAW_MODES.TRIANGLES
    );
    if (typeof strip._canvasPadding !== "undefined") {
      strip._canvasPadding = 1.5;
    }
    strip.alpha = attachment.color.a;
    strip.region = attachment.region;
    if (region) {
      this.setMeshRegion(attachment, strip, region);
    }
    slot.meshes = slot.meshes || {};
    slot.meshes[attachment.id] = strip;
    return strip;
  }
  // @ts-ignore
  createGraphics(slot, clip) {
    const graphics = this.newGraphics();
    const poly = new core.Polygon([]);
    graphics.clear();
    graphics.beginFill(16777215, 1);
    graphics.drawPolygon(poly);
    graphics.renderable = false;
    slot.currentGraphics = graphics;
    slot.clippingContainer = this.newContainer();
    slot.clippingContainer.mask = slot.currentGraphics;
    return graphics;
  }
  updateGraphics(slot, clip) {
    const geom = slot.currentGraphics.geometry;
    const vertices = geom.graphicsData[0].shape.points;
    const n = clip.worldVerticesLength;
    vertices.length = n;
    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
    geom.invalidate();
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotIndex {number}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotIndex(slotIndex, texture = null, size = null) {
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const attachment = slot.getAttachment();
    let region = attachment.region;
    if (texture) {
      region = new TextureRegion.TextureRegion();
      region.texture = texture;
      region.size = size;
      slot.hackRegion = region;
      slot.hackAttachment = attachment;
    } else {
      slot.hackRegion = null;
      slot.hackAttachment = null;
    }
    if (slot.currentSprite) {
      this.setSpriteRegion(attachment, slot.currentSprite, region);
    } else if (slot.currentMesh) {
      this.setMeshRegion(attachment, slot.currentMesh, region);
    }
    return true;
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotName(slotName, texture = null, size = null) {
    const index = this.skeleton.findSlotIndex(slotName);
    if (index == -1) {
      return false;
    }
    return this.hackTextureBySlotIndex(index, texture, size);
  }
  /**
   * Changes texture of an attachment
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param attachmentName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureAttachment(slotName, attachmentName, texture, size = null) {
    const slotIndex = this.skeleton.findSlotIndex(slotName);
    const attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);
    attachment.region.texture = texture;
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const currentAttachment = slot.getAttachment();
    if (attachmentName === currentAttachment.name) {
      let region = attachment.region;
      if (texture) {
        region = new TextureRegion.TextureRegion();
        region.texture = texture;
        region.size = size;
        slot.hackRegion = region;
        slot.hackAttachment = currentAttachment;
      } else {
        slot.hackRegion = null;
        slot.hackAttachment = null;
      }
      if (slot.currentSprite && slot.currentSprite.region != region) {
        this.setSpriteRegion(currentAttachment, slot.currentSprite, region);
        slot.currentSprite.region = region;
      } else if (slot.currentMesh && slot.currentMesh.region != region) {
        this.setMeshRegion(currentAttachment, slot.currentMesh, region);
      }
      return true;
    }
    return false;
  }
  // those methods can be overriden to spawn different classes
  newContainer() {
    return new display.Container();
  }
  newSprite(tex) {
    return new SpineSprite(tex);
  }
  newGraphics() {
    return new graphics.Graphics();
  }
  newMesh(texture, vertices, uvs, indices, drawMode) {
    return new SpineMesh(texture, vertices, uvs, indices, drawMode);
  }
  transformHack() {
    return 1;
  }
  /**
   * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer
   * @param nameSuffix
   * @param group
   * @param outGroup
   */
  hackAttachmentGroups(nameSuffix, group, outGroup) {
    if (!nameSuffix) {
      return void 0;
    }
    const list_d = [];
    const list_n = [];
    for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {
      const slot = this.skeleton.slots[i];
      const name = slot.currentSpriteName || slot.currentMeshName || "";
      const target = slot.currentSprite || slot.currentMesh;
      if (name.endsWith(nameSuffix)) {
        target.parentGroup = group;
        list_n.push(target);
      } else if (outGroup && target) {
        target.parentGroup = outGroup;
        list_d.push(target);
      }
    }
    return [list_d, list_n];
  }
  destroy(options) {
    this.debug = null;
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      for (const name in slot.meshes) {
        slot.meshes[name].destroy(options);
      }
      slot.meshes = null;
      for (const name in slot.sprites) {
        slot.sprites[name].destroy(options);
      }
      slot.sprites = null;
    }
    for (let i = 0, n = this.slotContainers.length; i < n; i++) {
      this.slotContainers[i].destroy(options);
    }
    this.spineData = null;
    this.skeleton = null;
    this.slotContainers = null;
    this.stateData = null;
    this.state = null;
    this.tempClipContainers = null;
    super.destroy(options);
  }
};
let SpineBase = _SpineBase;
SpineBase.clippingPolygon = [];
Object.defineProperty(SpineBase.prototype, "visible", {
  get() {
    return this._visible;
  },
  set(value) {
    if (value !== this._visible) {
      this._visible = value;
      if (value) {
        this.lastTime = 0;
      }
    }
  }
});

exports.SpineBase = SpineBase;
exports.SpineMesh = SpineMesh;
exports.SpineSprite = SpineSprite;
//# sourceMappingURL=SpineBase.js.map


/***/ }),

/***/ 2838:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);
var graphics = __webpack_require__(47997);
var AttachmentType = __webpack_require__(90854);
var SkeletonBoundsBase = __webpack_require__(35652);

class SpineDebugRenderer {
  constructor() {
    this.registeredSpines = /* @__PURE__ */ new Map();
    this.drawDebug = true;
    this.drawMeshHull = true;
    this.drawMeshTriangles = true;
    this.drawBones = true;
    this.drawPaths = true;
    this.drawBoundingBoxes = true;
    this.drawClipping = true;
    this.drawRegionAttachments = true;
    this.lineWidth = 1;
    this.regionAttachmentsColor = 30975;
    this.meshHullColor = 30975;
    this.meshTrianglesColor = 16763904;
    this.clippingPolygonColor = 16711935;
    this.boundingBoxesRectColor = 65280;
    this.boundingBoxesPolygonColor = 65280;
    this.boundingBoxesCircleColor = 65280;
    this.pathsCurveColor = 16711680;
    this.pathsLineColor = 16711935;
    this.skeletonXYColor = 16711680;
    this.bonesColor = 61132;
  }
  /**
   * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update
   */
  registerSpine(spine) {
    if (this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!", spine);
    }
    const debugDisplayObjects = {
      parentDebugContainer: new display.Container(),
      bones: new display.Container(),
      skeletonXY: new graphics.Graphics(),
      regionAttachmentsShape: new graphics.Graphics(),
      meshTrianglesLine: new graphics.Graphics(),
      meshHullLine: new graphics.Graphics(),
      clippingPolygon: new graphics.Graphics(),
      boundingBoxesRect: new graphics.Graphics(),
      boundingBoxesCircle: new graphics.Graphics(),
      boundingBoxesPolygon: new graphics.Graphics(),
      pathsCurve: new graphics.Graphics(),
      pathsLine: new graphics.Graphics()
    };
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);
    spine.addChild(debugDisplayObjects.parentDebugContainer);
    this.registeredSpines.set(spine, debugDisplayObjects);
  }
  renderDebug(spine) {
    if (!this.registeredSpines.has(spine)) {
      this.registerSpine(spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.skeletonXY.clear();
    debugDisplayObjects.regionAttachmentsShape.clear();
    debugDisplayObjects.meshTrianglesLine.clear();
    debugDisplayObjects.meshHullLine.clear();
    debugDisplayObjects.clippingPolygon.clear();
    debugDisplayObjects.boundingBoxesRect.clear();
    debugDisplayObjects.boundingBoxesCircle.clear();
    debugDisplayObjects.boundingBoxesPolygon.clear();
    debugDisplayObjects.pathsCurve.clear();
    debugDisplayObjects.pathsLine.clear();
    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {
      debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });
    }
    const scale = spine.scale.x || spine.scale.y || 1;
    const lineWidth = this.lineWidth / scale;
    if (this.drawBones) {
      this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);
    }
    if (this.drawPaths) {
      this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawBoundingBoxes) {
      this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawClipping) {
      this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawMeshHull || this.drawMeshTriangles) {
      this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawRegionAttachments) {
      this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);
    }
  }
  drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale) {
    const skeleton = spine.skeleton;
    const skeletonX = skeleton.x;
    const skeletonY = skeleton.y;
    const bones = skeleton.bones;
    debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);
    for (let i = 0, len = bones.length; i < len; i++) {
      const bone = bones[i];
      const boneLen = bone.data.length;
      const starX = skeletonX + bone.matrix.tx;
      const starY = skeletonY + bone.matrix.ty;
      const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;
      const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;
      if (bone.data.name === "root" || bone.data.parent === null) {
        continue;
      }
      const w = Math.abs(starX - endX);
      const h = Math.abs(starY - endY);
      const a2 = Math.pow(w, 2);
      const b = h;
      const b2 = Math.pow(h, 2);
      const c = Math.sqrt(a2 + b2);
      const c2 = Math.pow(c, 2);
      const rad = Math.PI / 180;
      const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;
      if (c === 0) {
        continue;
      }
      const gp = new graphics.Graphics();
      debugDisplayObjects.bones.addChild(gp);
      const refRation = c / 50 / scale;
      gp.beginFill(this.bonesColor, 1);
      gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);
      gp.endFill();
      gp.x = starX;
      gp.y = starY;
      gp.pivot.y = c;
      let rotation = 0;
      if (starX < endX && starY < endY) {
        rotation = -B + 180 * rad;
      } else if (starX > endX && starY < endY) {
        rotation = 180 * rad + B;
      } else if (starX > endX && starY > endY) {
        rotation = -B;
      } else if (starX < endX && starY > endY) {
        rotation = B;
      } else if (starY === endY && starX < endX) {
        rotation = 90 * rad;
      } else if (starY === endY && starX > endX) {
        rotation = -90 * rad;
      } else if (starX === endX && starY < endY) {
        rotation = 180 * rad;
      } else if (starX === endX && starY > endY) {
        rotation = 0;
      }
      gp.rotation = rotation;
      gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);
      gp.beginFill(0, 0.6);
      gp.drawCircle(0, c, refRation * 1.2);
      gp.endFill();
    }
    const startDotSize = lineWidth * 3;
    debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);
    debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);
  }
  drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.AttachmentType.Region) {
        continue;
      }
      const regionAttachment = attachment;
      const vertices = new Float32Array(8);
      if (regionAttachment.updateOffset)
        regionAttachment.updateOffset();
      regionAttachment.computeWorldVertices(slot, vertices, 0, 2);
      debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));
    }
  }
  drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);
    debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.AttachmentType.Mesh) {
        continue;
      }
      const meshAttachment = attachment;
      const vertices = new Float32Array(meshAttachment.worldVerticesLength);
      const triangles = meshAttachment.triangles;
      let hullLength = meshAttachment.hullLength;
      meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);
      if (this.drawMeshTriangles) {
        for (let i2 = 0, len2 = triangles.length; i2 < len2; i2 += 3) {
          const v1 = triangles[i2] * 2;
          const v2 = triangles[i2 + 1] * 2;
          const v3 = triangles[i2 + 2] * 2;
          debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);
        }
      }
      if (this.drawMeshHull && hullLength > 0) {
        hullLength = (hullLength >> 1) * 2;
        let lastX = vertices[hullLength - 2];
        let lastY = vertices[hullLength - 1];
        for (let i2 = 0, len2 = hullLength; i2 < len2; i2 += 2) {
          const x = vertices[i2];
          const y = vertices[i2 + 1];
          debugDisplayObjects.meshHullLine.moveTo(x, y);
          debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);
          lastX = x;
          lastY = y;
        }
      }
    }
  }
  drawClippingFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.AttachmentType.Clipping) {
        continue;
      }
      const clippingAttachment = attachment;
      const nn = clippingAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));
    }
  }
  drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth) {
    debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);
    const bounds = new SkeletonBoundsBase.SkeletonBoundsBase();
    bounds.update(spine.skeleton, true);
    debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());
    const polygons = bounds.polygons;
    const drawPolygon = (polygonVertices, _offset, count) => {
      debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);
      debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);
      if (count < 3) {
        throw new Error("Polygon must contain at least 3 vertices");
      }
      const paths = [];
      const dotSize = lineWidth * 2;
      for (let i = 0, len = polygonVertices.length; i < len; i += 2) {
        const x1 = polygonVertices[i];
        const y1 = polygonVertices[i + 1];
        debugDisplayObjects.boundingBoxesCircle.lineStyle(0);
        debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);
        debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);
        debugDisplayObjects.boundingBoxesCircle.endFill();
        paths.push(x1, y1);
      }
      debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);
      debugDisplayObjects.boundingBoxesPolygon.endFill();
    };
    for (let i = 0, len = polygons.length; i < len; i++) {
      const polygon = polygons[i];
      drawPolygon(polygon, 0, polygon.length);
    }
  }
  drawPathsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);
    debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.AttachmentType.Path) {
        continue;
      }
      const pathAttachment = attachment;
      let nn = pathAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      let x1 = world[2];
      let y1 = world[3];
      let x2 = 0;
      let y2 = 0;
      if (pathAttachment.closed) {
        const cx1 = world[0];
        const cy1 = world[1];
        const cx2 = world[nn - 2];
        const cy2 = world[nn - 1];
        x2 = world[nn - 4];
        y2 = world[nn - 3];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
      }
      nn -= 4;
      for (let ii = 4; ii < nn; ii += 6) {
        const cx1 = world[ii];
        const cy1 = world[ii + 1];
        const cx2 = world[ii + 2];
        const cy2 = world[ii + 3];
        x2 = world[ii + 4];
        y2 = world[ii + 5];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
        x1 = x2;
        y1 = y2;
      }
    }
  }
  unregisterSpine(spine) {
    if (!this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!", spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });
    this.registeredSpines.delete(spine);
  }
}

exports.SpineDebugRenderer = SpineDebugRenderer;
//# sourceMappingURL=SpineDebugRenderer.js.map


/***/ }),

/***/ 90854:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var AttachmentType = /* @__PURE__ */ ((AttachmentType2) => {
  AttachmentType2[AttachmentType2["Region"] = 0] = "Region";
  AttachmentType2[AttachmentType2["BoundingBox"] = 1] = "BoundingBox";
  AttachmentType2[AttachmentType2["Mesh"] = 2] = "Mesh";
  AttachmentType2[AttachmentType2["LinkedMesh"] = 3] = "LinkedMesh";
  AttachmentType2[AttachmentType2["Path"] = 4] = "Path";
  AttachmentType2[AttachmentType2["Point"] = 5] = "Point";
  AttachmentType2[AttachmentType2["Clipping"] = 6] = "Clipping";
  return AttachmentType2;
})(AttachmentType || {});

exports.AttachmentType = AttachmentType;
//# sourceMappingURL=AttachmentType.js.map


/***/ }),

/***/ 30616:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class BinaryInput {
  constructor(data, strings = new Array(), index = 0, buffer = new DataView(data.buffer)) {
    this.strings = strings;
    this.index = index;
    this.buffer = buffer;
  }
  readByte() {
    return this.buffer.getInt8(this.index++);
  }
  readUnsignedByte() {
    return this.buffer.getUint8(this.index++);
  }
  readShort() {
    const value = this.buffer.getInt16(this.index);
    this.index += 2;
    return value;
  }
  readInt32() {
    const value = this.buffer.getInt32(this.index);
    this.index += 4;
    return value;
  }
  readInt(optimizePositive) {
    let b = this.readByte();
    let result = b & 127;
    if ((b & 128) != 0) {
      b = this.readByte();
      result |= (b & 127) << 7;
      if ((b & 128) != 0) {
        b = this.readByte();
        result |= (b & 127) << 14;
        if ((b & 128) != 0) {
          b = this.readByte();
          result |= (b & 127) << 21;
          if ((b & 128) != 0) {
            b = this.readByte();
            result |= (b & 127) << 28;
          }
        }
      }
    }
    return optimizePositive ? result : result >>> 1 ^ -(result & 1);
  }
  readStringRef() {
    const index = this.readInt(true);
    return index == 0 ? null : this.strings[index - 1];
  }
  readString() {
    let byteCount = this.readInt(true);
    switch (byteCount) {
      case 0:
        return null;
      case 1:
        return "";
    }
    byteCount--;
    let chars = "";
    for (let i = 0; i < byteCount; ) {
      const b = this.readUnsignedByte();
      switch (b >> 4) {
        case 12:
        case 13:
          chars += String.fromCharCode((b & 31) << 6 | this.readByte() & 63);
          i += 2;
          break;
        case 14:
          chars += String.fromCharCode((b & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
          i += 3;
          break;
        default:
          chars += String.fromCharCode(b);
          i++;
      }
    }
    return chars;
  }
  readFloat() {
    const value = this.buffer.getFloat32(this.index);
    this.index += 4;
    return value;
  }
  readBoolean() {
    return this.readByte() != 0;
  }
}

exports.BinaryInput = BinaryInput;
//# sourceMappingURL=BinaryInput.js.map


/***/ }),

/***/ 82976:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var MixBlend = /* @__PURE__ */ ((MixBlend2) => {
  MixBlend2[MixBlend2["setup"] = 0] = "setup";
  MixBlend2[MixBlend2["first"] = 1] = "first";
  MixBlend2[MixBlend2["replace"] = 2] = "replace";
  MixBlend2[MixBlend2["add"] = 3] = "add";
  return MixBlend2;
})(MixBlend || {});
var MixDirection = /* @__PURE__ */ ((MixDirection2) => {
  MixDirection2[MixDirection2["mixIn"] = 0] = "mixIn";
  MixDirection2[MixDirection2["mixOut"] = 1] = "mixOut";
  return MixDirection2;
})(MixDirection || {});

exports.MixBlend = MixBlend;
exports.MixDirection = MixDirection;
//# sourceMappingURL=IAnimation.js.map


/***/ }),

/***/ 43079:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var PositionMode = /* @__PURE__ */ ((PositionMode2) => {
  PositionMode2[PositionMode2["Fixed"] = 0] = "Fixed";
  PositionMode2[PositionMode2["Percent"] = 1] = "Percent";
  return PositionMode2;
})(PositionMode || {});
var RotateMode = /* @__PURE__ */ ((RotateMode2) => {
  RotateMode2[RotateMode2["Tangent"] = 0] = "Tangent";
  RotateMode2[RotateMode2["Chain"] = 1] = "Chain";
  RotateMode2[RotateMode2["ChainScale"] = 2] = "ChainScale";
  return RotateMode2;
})(RotateMode || {});

exports.PositionMode = PositionMode;
exports.RotateMode = RotateMode;
//# sourceMappingURL=IConstraint.js.map


/***/ }),

/***/ 75123:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var TransformMode = /* @__PURE__ */ ((TransformMode2) => {
  TransformMode2[TransformMode2["Normal"] = 0] = "Normal";
  TransformMode2[TransformMode2["OnlyTranslation"] = 1] = "OnlyTranslation";
  TransformMode2[TransformMode2["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
  TransformMode2[TransformMode2["NoScale"] = 3] = "NoScale";
  TransformMode2[TransformMode2["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
  return TransformMode2;
})(TransformMode || {});

exports.TransformMode = TransformMode;
//# sourceMappingURL=ISkeleton.js.map


/***/ }),

/***/ 35652:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var AttachmentType = __webpack_require__(90854);
var Utils = __webpack_require__(22302);

class SkeletonBoundsBase {
  constructor() {
    /** The left edge of the axis aligned bounding box. */
    this.minX = 0;
    /** The bottom edge of the axis aligned bounding box. */
    this.minY = 0;
    /** The right edge of the axis aligned bounding box. */
    this.maxX = 0;
    /** The top edge of the axis aligned bounding box. */
    this.maxY = 0;
    /** The visible bounding boxes. */
    this.boundingBoxes = new Array();
    /** The world vertices for the bounding box polygons. */
    this.polygons = new Array();
    this.polygonPool = new Utils.Pool(() => Utils.Utils.newFloatArray(16));
  }
  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding
   * box's polygon.
   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the
   *           SkeletonBounds AABB methods will always return true. */
  update(skeleton, updateAabb) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    const boundingBoxes = this.boundingBoxes;
    const polygons = this.polygons;
    const polygonPool = this.polygonPool;
    const slots = skeleton.slots;
    const slotCount = slots.length;
    boundingBoxes.length = 0;
    polygonPool.freeAll(polygons);
    polygons.length = 0;
    for (let i = 0; i < slotCount; i++) {
      const slot = slots[i];
      if (!slot.bone.active)
        continue;
      const attachment = slot.getAttachment();
      if (attachment != null && attachment.type === AttachmentType.AttachmentType.BoundingBox) {
        const boundingBox = attachment;
        boundingBoxes.push(boundingBox);
        let polygon = polygonPool.obtain();
        if (polygon.length != boundingBox.worldVerticesLength) {
          polygon = Utils.Utils.newFloatArray(boundingBox.worldVerticesLength);
        }
        polygons.push(polygon);
        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
      }
    }
    if (updateAabb) {
      this.aabbCompute();
    } else {
      this.minX = Number.POSITIVE_INFINITY;
      this.minY = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.maxY = Number.NEGATIVE_INFINITY;
    }
  }
  aabbCompute() {
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      const polygon = polygons[i];
      const vertices = polygon;
      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {
        const x = vertices[ii];
        const y = vertices[ii + 1];
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /** Returns true if the axis aligned bounding box contains the point. */
  aabbContainsPoint(x, y) {
    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
  }
  /** Returns true if the axis aligned bounding box intersects the line segment. */
  aabbIntersectsSegment(x1, y1, x2, y2) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {
      return false;
    }
    const m = (y2 - y1) / (x2 - x1);
    let y = m * (minX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    y = m * (maxX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    let x = (minY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    x = (maxY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    return false;
  }
  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
  aabbIntersectsSkeleton(bounds) {
    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
  }
  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.
   * Cannot be done here because BoundingBoxAttachment is not a thing yet*/
  containsPoint(x, y) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.containsPointPolygon(polygons[i], x, y))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains the point. */
  containsPointPolygon(polygon, x, y) {
    const vertices = polygon;
    const nn = polygon.length;
    let prevIndex = nn - 2;
    let inside = false;
    for (let ii = 0; ii < nn; ii += 2) {
      const vertexY = vertices[ii + 1];
      const prevY = vertices[prevIndex + 1];
      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
        const vertexX = vertices[ii];
        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
          inside = !inside;
      }
      prevIndex = ii;
    }
    return inside;
  }
  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it
   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns
   * true. */
  intersectsSegment(x1, y1, x2, y2) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains any part of the line segment. */
  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {
    const vertices = polygon;
    const nn = polygon.length;
    const width12 = x1 - x2;
    const height12 = y1 - y2;
    const det1 = x1 * y2 - y1 * x2;
    let x3 = vertices[nn - 2];
    let y3 = vertices[nn - 1];
    for (let ii = 0; ii < nn; ii += 2) {
      const x4 = vertices[ii];
      const y4 = vertices[ii + 1];
      const det2 = x3 * y4 - y3 * x4;
      const width34 = x3 - x4;
      const height34 = y3 - y4;
      const det3 = width12 * height34 - height12 * width34;
      const x = (det1 * width34 - width12 * det2) / det3;
      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
        const y = (det1 * height34 - height12 * det2) / det3;
        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1))
          return true;
      }
      x3 = x4;
      y3 = y4;
    }
    return false;
  }
  /** Returns the polygon for the specified bounding box, or null. */
  getPolygon(boundingBox) {
    if (!boundingBox)
      throw new Error("boundingBox cannot be null.");
    const index = this.boundingBoxes.indexOf(boundingBox);
    return index == -1 ? null : this.polygons[index];
  }
  /** The width of the axis aligned bounding box. */
  getWidth() {
    return this.maxX - this.minX;
  }
  /** The height of the axis aligned bounding box. */
  getHeight() {
    return this.maxY - this.minY;
  }
}

exports.SkeletonBoundsBase = SkeletonBoundsBase;
//# sourceMappingURL=SkeletonBoundsBase.js.map


/***/ }),

/***/ 20845:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var TextureRegion = __webpack_require__(86936);

class RegionFields {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.originalWidth = 0;
    this.originalHeight = 0;
    this.rotate = 0;
    this.index = 0;
  }
}
class TextureAtlas {
  constructor(atlasText, textureLoader, callback) {
    this.pages = new Array();
    this.regions = new Array();
    if (atlasText) {
      this.addSpineAtlas(atlasText, textureLoader, callback);
    }
  }
  addTexture(name, texture) {
    const pages = this.pages;
    let page = null;
    for (let i = 0; i < pages.length; i++) {
      if (pages[i].baseTexture === texture.baseTexture) {
        page = pages[i];
        break;
      }
    }
    if (page === null) {
      page = new TextureAtlasPage();
      page.name = "texturePage";
      const baseTexture = texture.baseTexture;
      page.width = baseTexture.realWidth;
      page.height = baseTexture.realHeight;
      page.baseTexture = baseTexture;
      page.minFilter = page.magFilter = TextureRegion.TextureFilter.Nearest;
      page.uWrap = TextureRegion.TextureWrap.ClampToEdge;
      page.vWrap = TextureRegion.TextureWrap.ClampToEdge;
      pages.push(page);
    }
    const region = new TextureAtlasRegion();
    region.name = name;
    region.page = page;
    region.texture = texture;
    region.index = -1;
    this.regions.push(region);
    return region;
  }
  addTextureHash(textures, stripExtension) {
    for (const key in textures) {
      if (textures.hasOwnProperty(key)) {
        this.addTexture(stripExtension && key.indexOf(".") !== -1 ? key.substr(0, key.lastIndexOf(".")) : key, textures[key]);
      }
    }
  }
  addSpineAtlas(atlasText, textureLoader, callback) {
    return this.load(atlasText, textureLoader, callback);
  }
  load(atlasText, textureLoader, callback) {
    if (textureLoader == null) {
      throw new Error("textureLoader cannot be null.");
    }
    const reader = new TextureAtlasReader(atlasText);
    const entry = new Array(4);
    let page = null;
    const pageFields = {};
    let region = null;
    pageFields.size = () => {
      page.width = parseInt(entry[1]);
      page.height = parseInt(entry[2]);
    };
    pageFields.format = () => {
    };
    pageFields.filter = () => {
      page.minFilter = TextureRegion.filterFromString(entry[1]);
      page.magFilter = TextureRegion.filterFromString(entry[2]);
    };
    pageFields.repeat = () => {
      if (entry[1].indexOf("x") != -1)
        page.uWrap = TextureRegion.TextureWrap.Repeat;
      if (entry[1].indexOf("y") != -1)
        page.vWrap = TextureRegion.TextureWrap.Repeat;
    };
    pageFields.pma = () => {
      page.pma = entry[1] == "true";
    };
    const regionFields = {};
    regionFields.xy = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
    };
    regionFields.size = () => {
      region.width = parseInt(entry[1]);
      region.height = parseInt(entry[2]);
    };
    regionFields.bounds = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
      region.width = parseInt(entry[3]);
      region.height = parseInt(entry[4]);
    };
    regionFields.offset = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
    };
    regionFields.orig = () => {
      region.originalWidth = parseInt(entry[1]);
      region.originalHeight = parseInt(entry[2]);
    };
    regionFields.offsets = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
      region.originalWidth = parseInt(entry[3]);
      region.originalHeight = parseInt(entry[4]);
    };
    regionFields.rotate = () => {
      const rotateValue = entry[1];
      let rotate = 0;
      if (rotateValue.toLocaleLowerCase() == "true") {
        rotate = 6;
      } else if (rotateValue.toLocaleLowerCase() == "false") {
        rotate = 0;
      } else {
        rotate = (720 - parseFloat(rotateValue)) % 360 / 45;
      }
      region.rotate = rotate;
    };
    regionFields.index = () => {
      region.index = parseInt(entry[1]);
    };
    let line = reader.readLine();
    while (line != null && line.trim().length == 0) {
      line = reader.readLine();
    }
    while (true) {
      if (line == null || line.trim().length == 0)
        break;
      if (reader.readEntry(entry, line) == 0)
        break;
      line = reader.readLine();
    }
    const iterateParser = () => {
      while (true) {
        if (line == null) {
          return callback && callback(this);
        }
        if (line.trim().length == 0) {
          page = null;
          line = reader.readLine();
        } else if (page === null) {
          page = new TextureAtlasPage();
          page.name = line.trim();
          while (true) {
            if (reader.readEntry(entry, line = reader.readLine()) == 0)
              break;
            const field = pageFields[entry[0]];
            if (field)
              field();
          }
          this.pages.push(page);
          textureLoader(page.name, (texture) => {
            if (texture === null) {
              this.pages.splice(this.pages.indexOf(page), 1);
              return callback && callback(null);
            }
            page.baseTexture = texture;
            if (page.pma) {
              texture.alphaMode = core.ALPHA_MODES.PMA;
            }
            if (!texture.valid) {
              texture.setSize(page.width, page.height);
            }
            page.setFilters();
            if (!page.width || !page.height) {
              page.width = texture.realWidth;
              page.height = texture.realHeight;
              if (!page.width || !page.height) {
                console.log(
                  `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`
                );
              }
            }
            iterateParser();
          });
          break;
        } else {
          region = new RegionFields();
          const atlasRegion = new TextureAtlasRegion();
          atlasRegion.name = line;
          atlasRegion.page = page;
          let names = null;
          let values = null;
          while (true) {
            const count = reader.readEntry(entry, line = reader.readLine());
            if (count == 0)
              break;
            const field = regionFields[entry[0]];
            if (field) {
              field();
            } else {
              if (names == null) {
                names = [];
                values = [];
              }
              names.push(entry[0]);
              const entryValues = [];
              for (let i = 0; i < count; i++) {
                entryValues.push(parseInt(entry[i + 1]));
              }
              values.push(entryValues);
            }
          }
          if (region.originalWidth == 0 && region.originalHeight == 0) {
            region.originalWidth = region.width;
            region.originalHeight = region.height;
          }
          const resolution = page.baseTexture.resolution;
          region.x /= resolution;
          region.y /= resolution;
          region.width /= resolution;
          region.height /= resolution;
          region.originalWidth /= resolution;
          region.originalHeight /= resolution;
          region.offsetX /= resolution;
          region.offsetY /= resolution;
          const swapWH = region.rotate % 4 !== 0;
          const frame = new core.Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);
          const orig = new core.Rectangle(0, 0, region.originalWidth, region.originalHeight);
          const trim = new core.Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);
          atlasRegion.texture = new core.Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);
          atlasRegion.index = region.index;
          atlasRegion.texture.updateUvs();
          this.regions.push(atlasRegion);
        }
      }
    };
    iterateParser();
  }
  findRegion(name) {
    for (let i = 0; i < this.regions.length; i++) {
      if (this.regions[i].name == name) {
        return this.regions[i];
      }
    }
    return null;
  }
  dispose() {
    for (let i = 0; i < this.pages.length; i++) {
      this.pages[i].baseTexture.dispose();
    }
  }
}
class TextureAtlasReader {
  constructor(text) {
    this.index = 0;
    this.lines = text.split(/\r\n|\r|\n/);
  }
  readLine() {
    if (this.index >= this.lines.length) {
      return null;
    }
    return this.lines[this.index++];
  }
  readEntry(entry, line) {
    if (line == null)
      return 0;
    line = line.trim();
    if (line.length == 0)
      return 0;
    const colon = line.indexOf(":");
    if (colon == -1)
      return 0;
    entry[0] = line.substr(0, colon).trim();
    for (let i = 1, lastMatch = colon + 1; ; i++) {
      const comma = line.indexOf(",", lastMatch);
      if (comma == -1) {
        entry[i] = line.substr(lastMatch).trim();
        return i;
      }
      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();
      lastMatch = comma + 1;
      if (i == 4)
        return 4;
    }
  }
}
class TextureAtlasPage {
  constructor() {
    this.minFilter = TextureRegion.TextureFilter.Nearest;
    this.magFilter = TextureRegion.TextureFilter.Nearest;
    this.uWrap = TextureRegion.TextureWrap.ClampToEdge;
    this.vWrap = TextureRegion.TextureWrap.ClampToEdge;
  }
  setFilters() {
    const tex = this.baseTexture;
    const filter = this.minFilter;
    if (filter == TextureRegion.TextureFilter.Linear) {
      tex.scaleMode = core.SCALE_MODES.LINEAR;
    } else if (this.minFilter == TextureRegion.TextureFilter.Nearest) {
      tex.scaleMode = core.SCALE_MODES.NEAREST;
    } else {
      tex.mipmap = core.MIPMAP_MODES.POW2;
      if (filter == TextureRegion.TextureFilter.MipMapNearestNearest) {
        tex.scaleMode = core.SCALE_MODES.NEAREST;
      } else {
        tex.scaleMode = core.SCALE_MODES.LINEAR;
      }
    }
  }
}
class TextureAtlasRegion extends TextureRegion.TextureRegion {
}

exports.TextureAtlas = TextureAtlas;
exports.TextureAtlasPage = TextureAtlasPage;
exports.TextureAtlasRegion = TextureAtlasRegion;
//# sourceMappingURL=TextureAtlas.js.map


/***/ }),

/***/ 86936:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function filterFromString(text) {
  switch (text.toLowerCase()) {
    case "nearest":
      return TextureFilter.Nearest;
    case "linear":
      return TextureFilter.Linear;
    case "mipmap":
      return TextureFilter.MipMap;
    case "mipmapnearestnearest":
      return TextureFilter.MipMapNearestNearest;
    case "mipmaplinearnearest":
      return TextureFilter.MipMapLinearNearest;
    case "mipmapnearestlinear":
      return TextureFilter.MipMapNearestLinear;
    case "mipmaplinearlinear":
      return TextureFilter.MipMapLinearLinear;
    default:
      throw new Error(`Unknown texture filter ${text}`);
  }
}
function wrapFromString(text) {
  switch (text.toLowerCase()) {
    case "mirroredtepeat":
      return TextureWrap.MirroredRepeat;
    case "clamptoedge":
      return TextureWrap.ClampToEdge;
    case "repeat":
      return TextureWrap.Repeat;
    default:
      throw new Error(`Unknown texture wrap ${text}`);
  }
}
var TextureFilter = /* @__PURE__ */ ((TextureFilter2) => {
  TextureFilter2[TextureFilter2["Nearest"] = 9728] = "Nearest";
  TextureFilter2[TextureFilter2["Linear"] = 9729] = "Linear";
  TextureFilter2[TextureFilter2["MipMap"] = 9987] = "MipMap";
  TextureFilter2[TextureFilter2["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
  TextureFilter2[TextureFilter2["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
  TextureFilter2[TextureFilter2["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
  TextureFilter2[TextureFilter2["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
  return TextureFilter2;
})(TextureFilter || {});
var TextureWrap = /* @__PURE__ */ ((TextureWrap2) => {
  TextureWrap2[TextureWrap2["MirroredRepeat"] = 33648] = "MirroredRepeat";
  TextureWrap2[TextureWrap2["ClampToEdge"] = 33071] = "ClampToEdge";
  TextureWrap2[TextureWrap2["Repeat"] = 10497] = "Repeat";
  return TextureWrap2;
})(TextureWrap || {});
class TextureRegion {
  constructor() {
    // thats for overrides
    this.size = null;
    this.names = null;
    this.values = null;
    this.renderObject = null;
  }
  get width() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.width;
    }
    return tex.orig.width;
  }
  get height() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.height;
    }
    return tex.orig.height;
  }
  get u() {
    return this.texture._uvs.x0;
  }
  get v() {
    return this.texture._uvs.y0;
  }
  get u2() {
    return this.texture._uvs.x2;
  }
  get v2() {
    return this.texture._uvs.y2;
  }
  get offsetX() {
    const tex = this.texture;
    return tex.trim ? tex.trim.x : 0;
  }
  get offsetY() {
    return this.spineOffsetY;
  }
  get pixiOffsetY() {
    const tex = this.texture;
    return tex.trim ? tex.trim.y : 0;
  }
  get spineOffsetY() {
    const tex = this.texture;
    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
  }
  get originalWidth() {
    return this.texture.orig.width;
  }
  get originalHeight() {
    return this.texture.orig.height;
  }
  get x() {
    return this.texture.frame.x;
  }
  get y() {
    return this.texture.frame.y;
  }
  get rotate() {
    return this.texture.rotate !== 0;
  }
  get degrees() {
    return (360 - this.texture.rotate * 45) % 360;
  }
}

exports.TextureFilter = TextureFilter;
exports.TextureRegion = TextureRegion;
exports.TextureWrap = TextureWrap;
exports.filterFromString = filterFromString;
exports.wrapFromString = wrapFromString;
//# sourceMappingURL=TextureRegion.js.map


/***/ }),

/***/ 22302:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class IntSet {
  constructor() {
    this.array = new Array();
  }
  add(value) {
    const contains = this.contains(value);
    this.array[value | 0] = value | 0;
    return !contains;
  }
  contains(value) {
    return this.array[value | 0] != void 0;
  }
  remove(value) {
    this.array[value | 0] = void 0;
  }
  clear() {
    this.array.length = 0;
  }
}
class StringSet {
  constructor() {
    this.entries = {};
    this.size = 0;
  }
  add(value) {
    const contains = this.entries[value];
    this.entries[value] = true;
    if (!contains) {
      this.size++;
      return true;
    }
    return false;
  }
  addAll(values) {
    const oldSize = this.size;
    for (let i = 0, n = values.length; i < n; i++) {
      this.add(values[i]);
    }
    return oldSize != this.size;
  }
  contains(value) {
    return this.entries[value];
  }
  clear() {
    this.entries = {};
    this.size = 0;
  }
}
const _Color = class {
  constructor(r = 0, g = 0, b = 0, a = 0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  set(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this.clamp();
  }
  setFromColor(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    this.a = c.a;
    return this;
  }
  setFromString(hex) {
    hex = hex.charAt(0) == "#" ? hex.substr(1) : hex;
    this.r = parseInt(hex.substr(0, 2), 16) / 255;
    this.g = parseInt(hex.substr(2, 2), 16) / 255;
    this.b = parseInt(hex.substr(4, 2), 16) / 255;
    this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;
    return this;
  }
  add(r, g, b, a) {
    this.r += r;
    this.g += g;
    this.b += b;
    this.a += a;
    return this.clamp();
  }
  clamp() {
    if (this.r < 0)
      this.r = 0;
    else if (this.r > 1)
      this.r = 1;
    if (this.g < 0)
      this.g = 0;
    else if (this.g > 1)
      this.g = 1;
    if (this.b < 0)
      this.b = 0;
    else if (this.b > 1)
      this.b = 1;
    if (this.a < 0)
      this.a = 0;
    else if (this.a > 1)
      this.a = 1;
    return this;
  }
  static rgba8888ToColor(color, value) {
    color.r = ((value & 4278190080) >>> 24) / 255;
    color.g = ((value & 16711680) >>> 16) / 255;
    color.b = ((value & 65280) >>> 8) / 255;
    color.a = (value & 255) / 255;
  }
  static rgb888ToColor(color, value) {
    color.r = ((value & 16711680) >>> 16) / 255;
    color.g = ((value & 65280) >>> 8) / 255;
    color.b = (value & 255) / 255;
  }
  static fromString(hex) {
    return new _Color().setFromString(hex);
  }
};
let Color = _Color;
Color.WHITE = new _Color(1, 1, 1, 1);
Color.RED = new _Color(1, 0, 0, 1);
Color.GREEN = new _Color(0, 1, 0, 1);
Color.BLUE = new _Color(0, 0, 1, 1);
Color.MAGENTA = new _Color(1, 0, 1, 1);
const _MathUtils = class {
  static clamp(value, min, max) {
    if (value < min)
      return min;
    if (value > max)
      return max;
    return value;
  }
  static cosDeg(degrees) {
    return Math.cos(degrees * _MathUtils.degRad);
  }
  static sinDeg(degrees) {
    return Math.sin(degrees * _MathUtils.degRad);
  }
  static signum(value) {
    return Math.sign(value);
  }
  static toInt(x) {
    return x > 0 ? Math.floor(x) : Math.ceil(x);
  }
  static cbrt(x) {
    const y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  }
  static randomTriangular(min, max) {
    return _MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
  }
  static randomTriangularWith(min, max, mode) {
    const u = Math.random();
    const d = max - min;
    if (u <= (mode - min) / d)
      return min + Math.sqrt(u * d * (mode - min));
    return max - Math.sqrt((1 - u) * d * (max - mode));
  }
  static isPowerOfTwo(value) {
    return value && (value & value - 1) === 0;
  }
};
let MathUtils = _MathUtils;
MathUtils.PI = 3.1415927;
MathUtils.PI2 = _MathUtils.PI * 2;
MathUtils.radiansToDegrees = 180 / _MathUtils.PI;
MathUtils.radDeg = _MathUtils.radiansToDegrees;
MathUtils.degreesToRadians = _MathUtils.PI / 180;
MathUtils.degRad = _MathUtils.degreesToRadians;
class Interpolation {
  apply(start, end, a) {
    return start + (end - start) * this.applyInternal(a);
  }
}
class Pow extends Interpolation {
  constructor(power) {
    super();
    this.power = 2;
    this.power = power;
  }
  applyInternal(a) {
    if (a <= 0.5)
      return Math.pow(a * 2, this.power) / 2;
    return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
  }
}
class PowOut extends Pow {
  applyInternal(a) {
    return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
  }
}
const _Utils = class {
  static arrayCopy(source, sourceStart, dest, destStart, numElements) {
    for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
      dest[j] = source[i];
    }
  }
  static arrayFill(array, fromIndex, toIndex, value) {
    for (let i = fromIndex; i < toIndex; i++) {
      array[i] = value;
    }
  }
  static setArraySize(array, size, value = 0) {
    const oldSize = array.length;
    if (oldSize == size)
      return array;
    array.length = size;
    if (oldSize < size) {
      for (let i = oldSize; i < size; i++)
        array[i] = value;
    }
    return array;
  }
  static ensureArrayCapacity(array, size, value = 0) {
    if (array.length >= size)
      return array;
    return _Utils.setArraySize(array, size, value);
  }
  static newArray(size, defaultValue) {
    const array = new Array(size);
    for (let i = 0; i < size; i++)
      array[i] = defaultValue;
    return array;
  }
  static newFloatArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Float32Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static newShortArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Int16Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static toFloatArray(array) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
  }
  static toSinglePrecision(value) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
  }
  // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109
  static webkit602BugfixHelper(alpha, blend) {
  }
  static contains(array, element, identity = true) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] == element)
        return true;
    }
    return false;
  }
  static enumValue(type, name) {
    return type[name[0].toUpperCase() + name.slice(1)];
  }
};
let Utils = _Utils;
Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
class DebugUtils {
  static logBones(skeleton) {
    for (let i = 0; i < skeleton.bones.length; i++) {
      const bone = skeleton.bones[i];
      const mat = bone.matrix;
      console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);
    }
  }
}
class Pool {
  constructor(instantiator) {
    this.items = new Array();
    this.instantiator = instantiator;
  }
  obtain() {
    return this.items.length > 0 ? this.items.pop() : this.instantiator();
  }
  free(item) {
    if (item.reset)
      item.reset();
    this.items.push(item);
  }
  freeAll(items) {
    for (let i = 0; i < items.length; i++) {
      this.free(items[i]);
    }
  }
  clear() {
    this.items.length = 0;
  }
}
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  length() {
    const x = this.x;
    const y = this.y;
    return Math.sqrt(x * x + y * y);
  }
  normalize() {
    const len = this.length();
    if (len != 0) {
      this.x /= len;
      this.y /= len;
    }
    return this;
  }
}
class TimeKeeper {
  constructor() {
    this.maxDelta = 0.064;
    this.framesPerSecond = 0;
    this.delta = 0;
    this.totalTime = 0;
    this.lastTime = Date.now() / 1e3;
    this.frameCount = 0;
    this.frameTime = 0;
  }
  update() {
    const now = Date.now() / 1e3;
    this.delta = now - this.lastTime;
    this.frameTime += this.delta;
    this.totalTime += this.delta;
    if (this.delta > this.maxDelta)
      this.delta = this.maxDelta;
    this.lastTime = now;
    this.frameCount++;
    if (this.frameTime > 1) {
      this.framesPerSecond = this.frameCount / this.frameTime;
      this.frameTime = 0;
      this.frameCount = 0;
    }
  }
}
class WindowedMean {
  constructor(windowSize = 32) {
    this.addedValues = 0;
    this.lastValue = 0;
    this.mean = 0;
    this.dirty = true;
    this.values = new Array(windowSize);
  }
  hasEnoughData() {
    return this.addedValues >= this.values.length;
  }
  addValue(value) {
    if (this.addedValues < this.values.length)
      this.addedValues++;
    this.values[this.lastValue++] = value;
    if (this.lastValue > this.values.length - 1)
      this.lastValue = 0;
    this.dirty = true;
  }
  getMean() {
    if (this.hasEnoughData()) {
      if (this.dirty) {
        let mean = 0;
        for (let i = 0; i < this.values.length; i++) {
          mean += this.values[i];
        }
        this.mean = mean / this.values.length;
        this.dirty = false;
      }
      return this.mean;
    }
    return 0;
  }
}

exports.Color = Color;
exports.DebugUtils = DebugUtils;
exports.IntSet = IntSet;
exports.Interpolation = Interpolation;
exports.MathUtils = MathUtils;
exports.Pool = Pool;
exports.Pow = Pow;
exports.PowOut = PowOut;
exports.StringSet = StringSet;
exports.TimeKeeper = TimeKeeper;
exports.Utils = Utils;
exports.Vector2 = Vector2;
exports.WindowedMean = WindowedMean;
//# sourceMappingURL=Utils.js.map


/***/ }),

/***/ 55075:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var AttachmentType = __webpack_require__(90854);
var BinaryInput = __webpack_require__(30616);
var IAnimation = __webpack_require__(82976);
var IConstraint = __webpack_require__(43079);
var ISkeleton = __webpack_require__(75123);
var TextureAtlas = __webpack_require__(20845);
var TextureRegion = __webpack_require__(86936);
var Utils = __webpack_require__(22302);
var SkeletonBoundsBase = __webpack_require__(35652);
var settings = __webpack_require__(30358);
var SpineBase = __webpack_require__(50637);
var SpineDebugRenderer = __webpack_require__(2838);



exports.AttachmentType = AttachmentType.AttachmentType;
exports.BinaryInput = BinaryInput.BinaryInput;
exports.MixBlend = IAnimation.MixBlend;
exports.MixDirection = IAnimation.MixDirection;
exports.PositionMode = IConstraint.PositionMode;
exports.RotateMode = IConstraint.RotateMode;
exports.TransformMode = ISkeleton.TransformMode;
exports.TextureAtlas = TextureAtlas.TextureAtlas;
exports.TextureAtlasPage = TextureAtlas.TextureAtlasPage;
exports.TextureAtlasRegion = TextureAtlas.TextureAtlasRegion;
exports.TextureFilter = TextureRegion.TextureFilter;
exports.TextureRegion = TextureRegion.TextureRegion;
exports.TextureWrap = TextureRegion.TextureWrap;
exports.filterFromString = TextureRegion.filterFromString;
exports.wrapFromString = TextureRegion.wrapFromString;
exports.Color = Utils.Color;
exports.DebugUtils = Utils.DebugUtils;
exports.IntSet = Utils.IntSet;
exports.Interpolation = Utils.Interpolation;
exports.MathUtils = Utils.MathUtils;
exports.Pool = Utils.Pool;
exports.Pow = Utils.Pow;
exports.PowOut = Utils.PowOut;
exports.StringSet = Utils.StringSet;
exports.TimeKeeper = Utils.TimeKeeper;
exports.Utils = Utils.Utils;
exports.Vector2 = Utils.Vector2;
exports.WindowedMean = Utils.WindowedMean;
exports.SkeletonBoundsBase = SkeletonBoundsBase.SkeletonBoundsBase;
exports.settings = settings.settings;
exports.SpineBase = SpineBase.SpineBase;
exports.SpineMesh = SpineBase.SpineMesh;
exports.SpineSprite = SpineBase.SpineSprite;
exports.SpineDebugRenderer = SpineDebugRenderer.SpineDebugRenderer;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 30358:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const settings = {
  yDown: true,
  /**
   * pixi-spine gives option to not fail at certain parsing errors
   * spine-ts fails here
   */
  FAIL_ON_NON_EXISTING_SKIN: false,
  /**
   * past Spine.globalAutoUpdate
   */
  GLOBAL_AUTO_UPDATE: true,
  /**
   * past Spine.globalDelayLimit
   */
  GLOBAL_DELAY_LIMIT: 0,
  /**
   * shows error in console if atlas page loading somehow failed
   */
  REPORT_TEXTURE_LOADER_ERROR: true
};

exports.settings = settings;
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ 41307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var assets = __webpack_require__(13369);
var core = __webpack_require__(11491);
var atlasLoader = __webpack_require__(28781);

function isJson(resource) {
  return resource.hasOwnProperty("bones");
}
function isBuffer(resource) {
  return resource instanceof ArrayBuffer;
}
class SpineLoaderAbstract {
  constructor() {
  }
  installLoader() {
    const spineAdapter = this;
    const spineLoaderExtension = {
      extension: core.ExtensionType.Asset,
      loader: {
        extension: {
          type: core.ExtensionType.LoadParser,
          priority: assets.LoaderParserPriority.Normal
        },
        // #region Downloading skel buffer data
        test(url) {
          return assets.checkExtension(url, ".skel");
        },
        async load(url) {
          const response = await core.settings.ADAPTER.fetch(url);
          const buffer = await response.arrayBuffer();
          return buffer;
        },
        // #endregion
        // #region Parsing spine data
        testParse(asset, options) {
          const isJsonSpineModel = assets.checkExtension(options.src, ".json") && isJson(asset);
          const isBinarySpineModel = assets.checkExtension(options.src, ".skel") && isBuffer(asset);
          const isMetadataAngry = options.data?.spineAtlas === false;
          return Promise.resolve(isJsonSpineModel && !isMetadataAngry || isBinarySpineModel);
        },
        async parse(asset, loadAsset, loader) {
          const fileExt = core.utils.path.extname(loadAsset.src).toLowerCase();
          const fileName = core.utils.path.basename(loadAsset.src, fileExt);
          let basePath = core.utils.path.dirname(loadAsset.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          const isJsonSpineModel = assets.checkExtension(loadAsset.src, ".json") && isJson(asset);
          let parser = null;
          let dataToParse = asset;
          if (isJsonSpineModel) {
            parser = spineAdapter.createJsonParser();
          } else {
            parser = spineAdapter.createBinaryParser();
            dataToParse = new Uint8Array(asset);
          }
          const metadata = loadAsset.data || {};
          const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;
          if (metadataSkeletonScale) {
            parser.scale = metadataSkeletonScale;
          }
          const metadataAtlas = metadata.spineAtlas;
          if (metadataAtlas && metadataAtlas.pages) {
            return spineAdapter.parseData(parser, metadataAtlas, dataToParse);
          }
          const textAtlas = metadata.atlasRawData;
          if (textAtlas) {
            let auxResolve = null;
            let auxReject = null;
            const atlasPromise = new Promise((resolve, reject) => {
              auxResolve = resolve;
              auxReject = reject;
            });
            const atlas = new base.TextureAtlas(textAtlas, atlasLoader.makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), (newAtlas) => {
              if (!newAtlas) {
                auxReject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
              }
              auxResolve(atlas);
            });
            const textureAtlas2 = await atlasPromise;
            return spineAdapter.parseData(parser, textureAtlas2, dataToParse);
          }
          let atlasPath = metadata.spineAtlasFile;
          if (!atlasPath) {
            atlasPath = `${basePath + fileName}.atlas`;
          }
          const textureAtlas = await loader.load({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });
          return spineAdapter.parseData(parser, textureAtlas, dataToParse);
        }
        // #endregion
        // unload(asset: ISpineResource<SKD>, loadAsset, loader) {
        // 	???
        // },
      }
    };
    core.extensions.add(spineLoaderExtension);
    return spineLoaderExtension;
  }
}

exports.SpineLoaderAbstract = SpineLoaderAbstract;
//# sourceMappingURL=SpineLoaderAbstract.js.map


/***/ }),

/***/ 28781:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var assets = __webpack_require__(13369);
var core = __webpack_require__(11491);

const spineTextureAtlasLoader = {
  extension: core.ExtensionType.Asset,
  // cache: {
  //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,
  //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),
  // },
  loader: {
    extension: {
      type: core.ExtensionType.LoadParser,
      priority: assets.LoaderParserPriority.Normal
    },
    test(url) {
      return assets.checkExtension(url, ".atlas");
    },
    async load(url) {
      const response = await core.settings.ADAPTER.fetch(url);
      const txt = await response.text();
      return txt;
    },
    testParse(asset, options) {
      const isExtensionRight = assets.checkExtension(options.src, ".atlas");
      const isString = typeof asset === "string";
      return Promise.resolve(isExtensionRight && isString);
    },
    async parse(asset, options, loader) {
      const metadata = options.data;
      let basePath = core.utils.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let resolve = null;
      let reject = null;
      const retPromise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      let retval;
      const resolveCallback = (newAtlas) => {
        if (!newAtlas) {
          reject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
        }
        resolve(retval);
      };
      if (metadata.image || metadata.images) {
        const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);
        retval = new base.TextureAtlas(
          asset,
          (line, callback) => {
            const page = pages[line] || pages.default;
            if (page && page.baseTexture)
              callback(page.baseTexture);
            else
              callback(page);
          },
          resolveCallback
        );
      } else {
        retval = new base.TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);
      }
      return await retPromise;
    },
    unload(atlas) {
      atlas.dispose();
    }
  }
};
const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader, atlasBasePath, imageMetadata) => {
  return async (pageName, textureLoadedCallback) => {
    try {
      const url = core.utils.path.normalize([...atlasBasePath.split(core.utils.path.sep), pageName].join(core.utils.path.sep));
      const texture = await loader.load({ src: url, data: imageMetadata });
      textureLoadedCallback(texture.baseTexture);
    } catch (e) {
      if (base.settings.REPORT_TEXTURE_LOADER_ERROR) {
        console.error("Spine: error in texture loader", e);
      }
      textureLoadedCallback(null);
    }
  };
};
core.extensions.add(spineTextureAtlasLoader);

exports.makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject;
//# sourceMappingURL=atlasLoader.js.map


/***/ }),

/***/ 92941:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var atlasLoader = __webpack_require__(28781);
var SpineLoaderAbstract = __webpack_require__(41307);



exports.makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = atlasLoader.makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject;
exports.SpineLoaderAbstract = SpineLoaderAbstract.SpineLoaderAbstract;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 18269:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var spine38 = __webpack_require__(51816);
var spine37 = __webpack_require__(35049);
var spine41 = __webpack_require__(77954);
var versions = __webpack_require__(68977);

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var spine38__namespace = /*#__PURE__*/_interopNamespaceDefault(spine38);
var spine37__namespace = /*#__PURE__*/_interopNamespaceDefault(spine37);
var spine41__namespace = /*#__PURE__*/_interopNamespaceDefault(spine41);

class Spine extends base.SpineBase {
  createSkeleton(spineData) {
    const ver = versions.detectSpineVersion(spineData.version);
    let spine = null;
    if (ver === versions.SPINE_VERSION.VER37) {
      spine = spine37__namespace;
    }
    if (ver === versions.SPINE_VERSION.VER38) {
      spine = spine38__namespace;
    }
    if (ver === versions.SPINE_VERSION.VER40 || ver === versions.SPINE_VERSION.VER41) {
      spine = spine41__namespace;
    }
    if (!spine) {
      const error = `Cant detect version of spine model ${spineData.version}`;
      console.error(error);
    }
    this.skeleton = new spine.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new spine.AnimationStateData(spineData);
    this.state = new spine.AnimationState(this.stateData);
  }
}

exports.Spine = Spine;
//# sourceMappingURL=Spine.js.map


/***/ }),

/***/ 23670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var loaderBase = __webpack_require__(92941);
var base = __webpack_require__(55075);
var spine38 = __webpack_require__(51816);
var spine37 = __webpack_require__(35049);
var spine41 = __webpack_require__(77954);
var versions = __webpack_require__(68977);

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var spine38__namespace = /*#__PURE__*/_interopNamespaceDefault(spine38);
var spine37__namespace = /*#__PURE__*/_interopNamespaceDefault(spine37);
var spine41__namespace = /*#__PURE__*/_interopNamespaceDefault(spine41);

class UniBinaryParser {
  constructor() {
    this.scale = 1;
  }
  readSkeletonData(atlas, dataToParse) {
    let parser = null;
    let version = this.readVersionOldFormat(dataToParse);
    let ver = versions.detectSpineVersion(version);
    if (ver === versions.SPINE_VERSION.VER38) {
      parser = new spine38__namespace.SkeletonBinary(new spine38__namespace.AtlasAttachmentLoader(atlas));
    }
    version = this.readVersionNewFormat(dataToParse);
    ver = versions.detectSpineVersion(version);
    if (ver === versions.SPINE_VERSION.VER40 || ver === versions.SPINE_VERSION.VER41) {
      parser = new spine41__namespace.SkeletonBinary(new spine41__namespace.AtlasAttachmentLoader(atlas));
    }
    if (!parser) {
      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;
      console.error(error);
    }
    parser.scale = this.scale;
    return parser.readSkeletonData(dataToParse);
  }
  readVersionOldFormat(dataToParse) {
    const input = new base.BinaryInput(dataToParse);
    let version;
    try {
      input.readString();
      version = input.readString();
    } catch (e) {
      version = "";
    }
    return version || "";
  }
  readVersionNewFormat(dataToParse) {
    const input = new base.BinaryInput(dataToParse);
    input.readInt32();
    input.readInt32();
    let version;
    try {
      version = input.readString();
    } catch (e) {
      version = "";
    }
    return version || "";
  }
}
class UniJsonParser {
  constructor() {
    this.scale = 1;
  }
  readSkeletonData(atlas, dataToParse) {
    const version = dataToParse.skeleton.spine;
    const ver = versions.detectSpineVersion(version);
    let parser = null;
    if (ver === versions.SPINE_VERSION.VER37) {
      parser = new spine37__namespace.SkeletonJson(new spine37__namespace.AtlasAttachmentLoader(atlas));
    }
    if (ver === versions.SPINE_VERSION.VER38) {
      parser = new spine38__namespace.SkeletonJson(new spine38__namespace.AtlasAttachmentLoader(atlas));
    }
    if (ver === versions.SPINE_VERSION.VER40 || ver === versions.SPINE_VERSION.VER41) {
      parser = new spine41__namespace.SkeletonJson(new spine41__namespace.AtlasAttachmentLoader(atlas));
    }
    if (!parser) {
      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;
      console.error(error);
    }
    parser.scale = this.scale;
    return parser.readSkeletonData(dataToParse);
  }
}
class SpineLoader extends loaderBase.SpineLoaderAbstract {
  createBinaryParser() {
    return new UniBinaryParser();
  }
  createJsonParser() {
    return new UniJsonParser();
  }
  parseData(parser, atlas, dataToParse) {
    const parserCast = parser;
    return {
      spineData: parserCast.readSkeletonData(atlas, dataToParse),
      spineAtlas: atlas
    };
  }
}

exports.SpineLoader = SpineLoader;
//# sourceMappingURL=SpineLoader.js.map


/***/ }),

/***/ 23494:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(92941);
var SpineLoader = __webpack_require__(23670);
var Spine = __webpack_require__(18269);
var versions = __webpack_require__(68977);

new SpineLoader.SpineLoader().installLoader();

exports.Spine = Spine.Spine;
exports.SPINE_VERSION = versions.SPINE_VERSION;
exports.detectSpineVersion = versions.detectSpineVersion;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 68977:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var SPINE_VERSION = /* @__PURE__ */ ((SPINE_VERSION2) => {
  SPINE_VERSION2[SPINE_VERSION2["UNKNOWN"] = 0] = "UNKNOWN";
  SPINE_VERSION2[SPINE_VERSION2["VER37"] = 37] = "VER37";
  SPINE_VERSION2[SPINE_VERSION2["VER38"] = 38] = "VER38";
  SPINE_VERSION2[SPINE_VERSION2["VER40"] = 40] = "VER40";
  SPINE_VERSION2[SPINE_VERSION2["VER41"] = 41] = "VER41";
  return SPINE_VERSION2;
})(SPINE_VERSION || {});
function detectSpineVersion(version) {
  const ver3 = version.substr(0, 3);
  const verNum = Math.floor(Number(ver3) * 10 + 1e-3);
  if (ver3 === "3.7") {
    return 37 /* VER37 */;
  }
  if (ver3 === "3.8") {
    return 38 /* VER38 */;
  }
  if (ver3 === "4.0") {
    return 40 /* VER40 */;
  }
  if (ver3 === "4.1") {
    return 41 /* VER41 */;
  }
  if (verNum < 37 /* VER37 */) {
    return 37 /* VER37 */;
  }
  return 0 /* UNKNOWN */;
}

exports.SPINE_VERSION = SPINE_VERSION;
exports.detectSpineVersion = detectSpineVersion;
//# sourceMappingURL=versions.js.map


/***/ }),

/***/ 65774:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var Skeleton = __webpack_require__(57174);
var AnimationState = __webpack_require__(39330);
var AnimationStateData = __webpack_require__(49122);

class Spine extends base.SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new Skeleton.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new AnimationStateData.AnimationStateData(spineData);
    this.state = new AnimationState.AnimationState(this.stateData);
  }
}

exports.Spine = Spine;
//# sourceMappingURL=Spine.js.map


/***/ }),

/***/ 94203:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var base = __webpack_require__(55075);
__webpack_require__(17487);

class Animation {
  constructor(name, timelines, duration) {
    if (name == null)
      throw new Error("name cannot be null.");
    if (timelines == null)
      throw new Error("timelines cannot be null.");
    this.name = name;
    this.timelines = timelines;
    this.duration = duration;
  }
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
  static binarySearch(values, target, step = 1) {
    let low = 0;
    let high = values.length / step - 2;
    if (high == 0)
      return step;
    let current = high >>> 1;
    while (true) {
      if (values[(current + 1) * step] <= target)
        low = current + 1;
      else
        high = current;
      if (low == high)
        return (low + 1) * step;
      current = low + high >>> 1;
    }
  }
  static linearSearch(values, target, step) {
    for (let i = 0, last = values.length - step; i <= last; i += step)
      if (values[i] > target)
        return i;
    return -1;
  }
}
var TimelineType = /* @__PURE__ */ ((TimelineType2) => {
  TimelineType2[TimelineType2["rotate"] = 0] = "rotate";
  TimelineType2[TimelineType2["translate"] = 1] = "translate";
  TimelineType2[TimelineType2["scale"] = 2] = "scale";
  TimelineType2[TimelineType2["shear"] = 3] = "shear";
  TimelineType2[TimelineType2["attachment"] = 4] = "attachment";
  TimelineType2[TimelineType2["color"] = 5] = "color";
  TimelineType2[TimelineType2["deform"] = 6] = "deform";
  TimelineType2[TimelineType2["event"] = 7] = "event";
  TimelineType2[TimelineType2["drawOrder"] = 8] = "drawOrder";
  TimelineType2[TimelineType2["ikConstraint"] = 9] = "ikConstraint";
  TimelineType2[TimelineType2["transformConstraint"] = 10] = "transformConstraint";
  TimelineType2[TimelineType2["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType2[TimelineType2["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType2[TimelineType2["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType2[TimelineType2["twoColor"] = 14] = "twoColor";
  return TimelineType2;
})(TimelineType || {});
const _CurveTimeline = class {
  constructor(frameCount) {
    if (frameCount <= 0)
      throw new Error(`frameCount must be > 0: ${frameCount}`);
    this.curves = base.Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);
  }
  getFrameCount() {
    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;
  }
  setLinear(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;
  }
  setStepped(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;
  }
  getCurveType(frameIndex) {
    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;
    if (index == this.curves.length)
      return _CurveTimeline.LINEAR;
    const type = this.curves[index];
    if (type == _CurveTimeline.LINEAR)
      return _CurveTimeline.LINEAR;
    if (type == _CurveTimeline.STEPPED)
      return _CurveTimeline.STEPPED;
    return _CurveTimeline.BEZIER;
  }
  /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
   * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
   * the difference between the keyframe's values. */
  setCurve(frameIndex, cx1, cy1, cx2, cy2) {
    const tmpx = (-cx1 * 2 + cx2) * 0.03;
    const tmpy = (-cy1 * 2 + cy2) * 0.03;
    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;
    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
    let ddfx = tmpx * 2 + dddfx;
    let ddfy = tmpy * 2 + dddfy;
    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;
    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const curves = this.curves;
    curves[i++] = _CurveTimeline.BEZIER;
    let x = dfx;
    let y = dfy;
    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      x += dfx;
      y += dfy;
    }
  }
  getCurvePercent(frameIndex, percent) {
    percent = base.MathUtils.clamp(percent, 0, 1);
    const curves = this.curves;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const type = curves[i];
    if (type == _CurveTimeline.LINEAR)
      return percent;
    if (type == _CurveTimeline.STEPPED)
      return 0;
    i++;
    let x = 0;
    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      x = curves[i];
      if (x >= percent) {
        let prevX;
        let prevY;
        if (i == start) {
          prevX = 0;
          prevY = 0;
        } else {
          prevX = curves[i - 2];
          prevY = curves[i - 1];
        }
        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
      }
    }
    const y = curves[i - 1];
    return y + (1 - y) * (percent - x) / (1 - x);
  }
};
let CurveTimeline = _CurveTimeline;
CurveTimeline.LINEAR = 0;
CurveTimeline.STEPPED = 1;
CurveTimeline.BEZIER = 2;
CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
const _RotateTimeline = class extends CurveTimeline {
  // time, degrees, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount << 1);
  }
  getPropertyId() {
    return (0 /* rotate */ << 24) + this.boneIndex;
  }
  /** Sets the time and angle of the specified keyframe. */
  setFrame(frameIndex, time, degrees) {
    frameIndex <<= 1;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case base.MixBlend.first:
          const r2 = bone.data.rotation - bone.rotation;
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;
      }
      return;
    }
    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {
      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation + r2 * alpha;
          break;
        case base.MixBlend.first:
        case base.MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        case base.MixBlend.add:
          bone.rotation += r2 * alpha;
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);
    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));
    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;
    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
    switch (blend) {
      case base.MixBlend.setup:
        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case base.MixBlend.add:
        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
    }
  }
};
let RotateTimeline = _RotateTimeline;
RotateTimeline.ENTRIES = 2;
RotateTimeline.PREV_TIME = -2;
RotateTimeline.PREV_ROTATION = -1;
RotateTimeline.ROTATION = 1;
const _TranslateTimeline = class extends CurveTimeline {
  // time, x, y, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);
  }
  getPropertyId() {
    return (1 /* translate */ << 24) + this.boneIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, x, y) {
    frameIndex *= _TranslateTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TranslateTimeline.X] = x;
    this.frames[frameIndex + _TranslateTimeline.Y] = y;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case base.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {
      x = frames[frames.length + _TranslateTimeline.PREV_X];
      y = frames[frames.length + _TranslateTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);
      x = frames[frame + _TranslateTimeline.PREV_X];
      y = frames[frame + _TranslateTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));
      x += (frames[frame + _TranslateTimeline.X] - x) * percent;
      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case base.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case base.MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
};
let TranslateTimeline = _TranslateTimeline;
TranslateTimeline.ENTRIES = 3;
TranslateTimeline.PREV_TIME = -3;
TranslateTimeline.PREV_X = -2;
TranslateTimeline.PREV_Y = -1;
TranslateTimeline.X = 1;
TranslateTimeline.Y = 2;
class ScaleTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (2 /* scale */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case base.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
      x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
      y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
    } else {
      const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
      x = frames[frame + ScaleTimeline.PREV_X];
      y = frames[frame + ScaleTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
      x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
      y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
    }
    if (alpha == 1) {
      if (blend == base.MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == base.MixDirection.mixOut) {
        switch (blend) {
          case base.MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.add:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bone.data.scaleX) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case base.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * base.MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * base.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * base.MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * base.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.add:
            bx = base.MathUtils.signum(x);
            by = base.MathUtils.signum(y);
            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
        }
      }
    }
  }
}
class ShearTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (3 /* shear */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case base.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
      x = frames[frames.length + ShearTimeline.PREV_X];
      y = frames[frames.length + ShearTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
      x = frames[frame + ShearTimeline.PREV_X];
      y = frames[frame + ShearTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
      x = x + (frames[frame + ShearTimeline.X] - x) * percent;
      y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case base.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case base.MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
}
const _ColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (5 /* color */ << 24) + this.slotIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, r, g, b, a) {
    frameIndex *= _ColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _ColorTimeline.R] = r;
    this.frames[frameIndex + _ColorTimeline.G] = g;
    this.frames[frameIndex + _ColorTimeline.B] = b;
    this.frames[frameIndex + _ColorTimeline.A] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          return;
        case base.MixBlend.first:
          const color = slot.color;
          const setup = slot.data.color;
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _ColorTimeline.PREV_R];
      g = frames[i + _ColorTimeline.PREV_G];
      b = frames[i + _ColorTimeline.PREV_B];
      a = frames[i + _ColorTimeline.PREV_A];
    } else {
      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);
      r = frames[frame + _ColorTimeline.PREV_R];
      g = frames[frame + _ColorTimeline.PREV_G];
      b = frames[frame + _ColorTimeline.PREV_B];
      a = frames[frame + _ColorTimeline.PREV_A];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _ColorTimeline.R] - r) * percent;
      g += (frames[frame + _ColorTimeline.G] - g) * percent;
      b += (frames[frame + _ColorTimeline.B] - b) * percent;
      a += (frames[frame + _ColorTimeline.A] - a) * percent;
    }
    if (alpha == 1)
      slot.color.set(r, g, b, a);
    else {
      const color = slot.color;
      if (blend == base.MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
};
let ColorTimeline = _ColorTimeline;
ColorTimeline.ENTRIES = 5;
ColorTimeline.PREV_TIME = -5;
ColorTimeline.PREV_R = -4;
ColorTimeline.PREV_G = -3;
ColorTimeline.PREV_B = -2;
ColorTimeline.PREV_A = -1;
ColorTimeline.R = 1;
ColorTimeline.G = 2;
ColorTimeline.B = 3;
ColorTimeline.A = 4;
const _TwoColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, r2, g2, b2, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (14 /* twoColor */ << 24) + this.slotIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {
    frameIndex *= _TwoColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TwoColorTimeline.R] = r;
    this.frames[frameIndex + _TwoColorTimeline.G] = g;
    this.frames[frameIndex + _TwoColorTimeline.B] = b;
    this.frames[frameIndex + _TwoColorTimeline.A] = a;
    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;
    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;
    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          slot.darkColor.setFromColor(slot.data.darkColor);
          return;
        case base.MixBlend.first:
          const light = slot.color;
          const dark = slot.darkColor;
          const setupLight = slot.data.color;
          const setupDark = slot.data.darkColor;
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _TwoColorTimeline.PREV_R];
      g = frames[i + _TwoColorTimeline.PREV_G];
      b = frames[i + _TwoColorTimeline.PREV_B];
      a = frames[i + _TwoColorTimeline.PREV_A];
      r2 = frames[i + _TwoColorTimeline.PREV_R2];
      g2 = frames[i + _TwoColorTimeline.PREV_G2];
      b2 = frames[i + _TwoColorTimeline.PREV_B2];
    } else {
      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);
      r = frames[frame + _TwoColorTimeline.PREV_R];
      g = frames[frame + _TwoColorTimeline.PREV_G];
      b = frames[frame + _TwoColorTimeline.PREV_B];
      a = frames[frame + _TwoColorTimeline.PREV_A];
      r2 = frames[frame + _TwoColorTimeline.PREV_R2];
      g2 = frames[frame + _TwoColorTimeline.PREV_G2];
      b2 = frames[frame + _TwoColorTimeline.PREV_B2];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;
      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;
      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;
      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;
      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;
      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;
      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;
    }
    if (alpha == 1) {
      slot.color.set(r, g, b, a);
      slot.darkColor.set(r2, g2, b2, 1);
    } else {
      const light = slot.color;
      const dark = slot.darkColor;
      if (blend == base.MixBlend.setup) {
        light.setFromColor(slot.data.color);
        dark.setFromColor(slot.data.darkColor);
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
    }
  }
};
let TwoColorTimeline = _TwoColorTimeline;
TwoColorTimeline.ENTRIES = 8;
TwoColorTimeline.PREV_TIME = -8;
TwoColorTimeline.PREV_R = -7;
TwoColorTimeline.PREV_G = -6;
TwoColorTimeline.PREV_B = -5;
TwoColorTimeline.PREV_A = -4;
TwoColorTimeline.PREV_R2 = -3;
TwoColorTimeline.PREV_G2 = -2;
TwoColorTimeline.PREV_B2 = -1;
TwoColorTimeline.R = 1;
TwoColorTimeline.G = 2;
TwoColorTimeline.B = 3;
TwoColorTimeline.A = 4;
TwoColorTimeline.R2 = 5;
TwoColorTimeline.G2 = 6;
TwoColorTimeline.B2 = 7;
class AttachmentTimeline {
  constructor(frameCount) {
    this.frames = base.Utils.newFloatArray(frameCount);
    this.attachmentNames = new Array(frameCount);
  }
  getPropertyId() {
    return (4 /* attachment */ << 24) + this.slotIndex;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, attachmentName) {
    this.frames[frameIndex] = time;
    this.attachmentNames[frameIndex] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (direction == base.MixDirection.mixOut && blend == base.MixBlend.setup) {
      const attachmentName2 = slot.data.attachmentName;
      slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first) {
        const attachmentName2 = slot.data.attachmentName;
        slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));
      }
      return;
    }
    let frameIndex = 0;
    if (time >= frames[frames.length - 1])
      frameIndex = frames.length - 1;
    else
      frameIndex = Animation.binarySearch(frames, time, 1) - 1;
    const attachmentName = this.attachmentNames[frameIndex];
    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
}
let zeros = null;
class DeformTimeline extends CurveTimeline {
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount);
    this.frameVertices = new Array(frameCount);
    if (zeros == null)
      zeros = base.Utils.newFloatArray(64);
  }
  getPropertyId() {
    return (6 /* deform */ << 27) + Number(this.attachment.id) + this.slotIndex;
  }
  /** Sets the time of the specified keyframe. */
  setFrame(frameIndex, time, vertices) {
    this.frames[frameIndex] = time;
    this.frameVertices[frameIndex] = vertices;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const slotAttachment = slot.getAttachment();
    if (!(slotAttachment instanceof Attachment.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))
      return;
    const verticesArray = slot.attachmentVertices;
    if (verticesArray.length == 0)
      blend = base.MixBlend.setup;
    const frameVertices = this.frameVertices;
    const vertexCount = frameVertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      const vertexAttachment = slotAttachment;
      switch (blend) {
        case base.MixBlend.setup:
          verticesArray.length = 0;
          return;
        case base.MixBlend.first:
          if (alpha == 1) {
            verticesArray.length = 0;
            break;
          }
          const vertices2 = base.Utils.setArraySize(verticesArray, vertexCount);
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              vertices2[i] += (setupVertices[i] - vertices2[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              vertices2[i] *= alpha;
          }
      }
      return;
    }
    const vertices = base.Utils.setArraySize(verticesArray, vertexCount);
    if (time >= frames[frames.length - 1]) {
      const lastVertices = frameVertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == base.MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              vertices[i] += lastVertices[i] - setupVertices[i];
            }
          } else {
            for (let i = 0; i < vertexCount; i++)
              vertices[i] += lastVertices[i];
          }
        } else {
          base.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
        }
      } else {
        switch (blend) {
          case base.MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (vertexAttachment2.bones == null) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                vertices[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                vertices[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case base.MixBlend.first:
          case base.MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
          case base.MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++) {
                vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                vertices[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time);
    const prevVertices = frameVertices[frame - 1];
    const nextVertices = frameVertices[frame];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
    if (alpha == 1) {
      if (blend == base.MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (vertexAttachment.bones == null) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          vertices[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case base.MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (vertexAttachment2.bones == null) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case base.MixBlend.first:
        case base.MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
          }
          break;
        case base.MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
}
class EventTimeline {
  constructor(frameCount) {
    this.frames = base.Utils.newFloatArray(frameCount);
    this.events = new Array(frameCount);
  }
  getPropertyId() {
    return 7 /* event */ << 24;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time of the specified keyframe. */
  setFrame(frameIndex, event) {
    this.frames[frameIndex] = event.time;
    this.events[frameIndex] = event;
  }
  /** Fires events for frames > lastTime and <= time. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (firedEvents == null)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let frame = 0;
    if (lastTime < frames[0])
      frame = 0;
    else {
      frame = Animation.binarySearch(frames, lastTime);
      const frameTime = frames[frame];
      while (frame > 0) {
        if (frames[frame - 1] != frameTime)
          break;
        frame--;
      }
    }
    for (; frame < frameCount && time >= frames[frame]; frame++)
      firedEvents.push(this.events[frame]);
  }
}
class DrawOrderTimeline {
  constructor(frameCount) {
    this.frames = base.Utils.newFloatArray(frameCount);
    this.drawOrders = new Array(frameCount);
  }
  getPropertyId() {
    return 8 /* drawOrder */ << 24;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time of the specified keyframe.
   * @param drawOrder May be null to use bind pose draw order. */
  setFrame(frameIndex, time, drawOrder) {
    this.frames[frameIndex] = time;
    this.drawOrders[frameIndex] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const drawOrder = skeleton.drawOrder;
    const slots = skeleton.slots;
    if (direction == base.MixDirection.mixOut && blend == base.MixBlend.setup) {
      base.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        base.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    let frame = 0;
    if (time >= frames[frames.length - 1])
      frame = frames.length - 1;
    else
      frame = Animation.binarySearch(frames, time) - 1;
    const drawOrderToSetupIndex = this.drawOrders[frame];
    if (drawOrderToSetupIndex == null)
      base.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
    else {
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
}
const _IkConstraintTimeline = class extends CurveTimeline {
  // time, mix, bendDirection, compress, stretch, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (9 /* ikConstraint */ << 24) + this.ikConstraintIndex;
  }
  /** Sets the time, mix and bend direction of the specified keyframe. */
  setFrame(frameIndex, time, mix, bendDirection, compress, stretch) {
    frameIndex *= _IkConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;
    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
    this.frames[frameIndex + _IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;
    this.frames[frameIndex + _IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case base.MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {
      if (blend == base.MixBlend.setup) {
        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
        if (direction == base.MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
        if (direction == base.MixDirection.mixIn) {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);
    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));
    if (blend == base.MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
      if (direction == base.MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    } else {
      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
      if (direction == base.MixDirection.mixIn) {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    }
  }
};
let IkConstraintTimeline = _IkConstraintTimeline;
IkConstraintTimeline.ENTRIES = 5;
IkConstraintTimeline.PREV_TIME = -5;
IkConstraintTimeline.PREV_MIX = -4;
IkConstraintTimeline.PREV_BEND_DIRECTION = -3;
IkConstraintTimeline.PREV_COMPRESS = -2;
IkConstraintTimeline.PREV_STRETCH = -1;
IkConstraintTimeline.MIX = 1;
IkConstraintTimeline.BEND_DIRECTION = 2;
IkConstraintTimeline.COMPRESS = 3;
IkConstraintTimeline.STRETCH = 4;
const _TransformConstraintTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, scale mix, shear mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (10 /* transformConstraint */ << 24) + this.transformConstraintIndex;
  }
  /** Sets the time and mixes of the specified keyframe. */
  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
    frameIndex *= _TransformConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case base.MixBlend.setup:
          constraint.rotateMix = data.rotateMix;
          constraint.translateMix = data.translateMix;
          constraint.scaleMix = data.scaleMix;
          constraint.shearMix = data.shearMix;
          return;
        case base.MixBlend.first:
          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    let scale = 0;
    let shear = 0;
    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {
      const i = frames.length;
      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];
    } else {
      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);
      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _TransformConstraintTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;
      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;
      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;
    }
    if (blend == base.MixBlend.setup) {
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
      constraint.shearMix += (shear - constraint.shearMix) * alpha;
    }
  }
};
let TransformConstraintTimeline = _TransformConstraintTimeline;
TransformConstraintTimeline.ENTRIES = 5;
TransformConstraintTimeline.PREV_TIME = -5;
TransformConstraintTimeline.PREV_ROTATE = -4;
TransformConstraintTimeline.PREV_TRANSLATE = -3;
TransformConstraintTimeline.PREV_SCALE = -2;
TransformConstraintTimeline.PREV_SHEAR = -1;
TransformConstraintTimeline.ROTATE = 1;
TransformConstraintTimeline.TRANSLATE = 2;
TransformConstraintTimeline.SCALE = 3;
TransformConstraintTimeline.SHEAR = 4;
const _PathConstraintPositionTimeline = class extends CurveTimeline {
  // time, position, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);
  }
  getPropertyId() {
    return (11 /* pathConstraintPosition */ << 24) + this.pathConstraintIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, value) {
    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case base.MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    let position = 0;
    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])
      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);
      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintPositionTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)
      );
      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;
    }
    if (blend == base.MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
};
let PathConstraintPositionTimeline = _PathConstraintPositionTimeline;
PathConstraintPositionTimeline.ENTRIES = 2;
PathConstraintPositionTimeline.PREV_TIME = -2;
PathConstraintPositionTimeline.PREV_VALUE = -1;
PathConstraintPositionTimeline.VALUE = 1;
class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (12 /* pathConstraintSpacing */ << 24) + this.pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case base.MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    let spacing = 0;
    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])
      spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
      spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / PathConstraintSpacingTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)
      );
      spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
    }
    if (blend == base.MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
}
const _PathConstraintMixTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);
  }
  getPropertyId() {
    return (13 /* pathConstraintMix */ << 24) + this.pathConstraintIndex;
  }
  /** Sets the time and mixes of the specified keyframe. */
  setFrame(frameIndex, time, rotateMix, translateMix) {
    frameIndex *= _PathConstraintMixTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.rotateMix = constraint.data.rotateMix;
          constraint.translateMix = constraint.data.translateMix;
          return;
        case base.MixBlend.first:
          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {
      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];
    } else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);
      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintMixTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
    }
    if (blend == base.MixBlend.setup) {
      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
    }
  }
};
let PathConstraintMixTimeline = _PathConstraintMixTimeline;
PathConstraintMixTimeline.ENTRIES = 3;
PathConstraintMixTimeline.PREV_TIME = -3;
PathConstraintMixTimeline.PREV_ROTATE = -2;
PathConstraintMixTimeline.PREV_TRANSLATE = -1;
PathConstraintMixTimeline.ROTATE = 1;
PathConstraintMixTimeline.TRANSLATE = 2;

exports.Animation = Animation;
exports.AttachmentTimeline = AttachmentTimeline;
exports.ColorTimeline = ColorTimeline;
exports.CurveTimeline = CurveTimeline;
exports.DeformTimeline = DeformTimeline;
exports.DrawOrderTimeline = DrawOrderTimeline;
exports.EventTimeline = EventTimeline;
exports.IkConstraintTimeline = IkConstraintTimeline;
exports.PathConstraintMixTimeline = PathConstraintMixTimeline;
exports.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
exports.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
exports.RotateTimeline = RotateTimeline;
exports.ScaleTimeline = ScaleTimeline;
exports.ShearTimeline = ShearTimeline;
exports.TimelineType = TimelineType;
exports.TransformConstraintTimeline = TransformConstraintTimeline;
exports.TranslateTimeline = TranslateTimeline;
exports.TwoColorTimeline = TwoColorTimeline;
//# sourceMappingURL=Animation.js.map


/***/ }),

/***/ 39330:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var Animation = __webpack_require__(94203);

const _AnimationState = class {
  constructor(data) {
    this.tracks = new Array();
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new base.IntSet();
    this.animationsChanged = false;
    this.timeScale = 1;
    this.trackEntryPool = new base.Pool(() => new TrackEntry());
    this.data = data;
  }
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next != null) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom != null) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
        tracks[i] = null;
        this.queue.end(current);
        this.disposeNext(current);
        continue;
      }
      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from != null)
          from.mixingTo = null;
        while (from != null) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (from == null)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom != null)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  apply(skeleton) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? base.MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom != null)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && current.next == null)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      const timelineCount = current.animation.timelines.length;
      const timelines = current.animation.timelines;
      if (i == 0 && mix == 1 || blend == base.MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          base.Utils.webkit602BugfixHelper(mix, blend);
          timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, base.MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const firstFrame = current.timelinesRotation.length == 0;
        if (firstFrame)
          base.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
        const timelinesRotation = current.timelinesRotation;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : base.MixBlend.setup;
          if (timeline instanceof Animation.RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
          } else {
            base.Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, base.MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom != null)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == base.MixBlend.first)
        blend = base.MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != base.MixBlend.first)
        blend = from.mixBlend;
    }
    const events = mix < from.eventThreshold ? this.events : null;
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    const timelineCount = from.animation.timelines.length;
    const timelines = from.animation.timelines;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    if (blend == base.MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, base.MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const firstFrame = from.timelinesRotation.length == 0;
      if (firstFrame)
        base.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
      const timelinesRotation = from.timelinesRotation;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = base.MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case _AnimationState.SUBSEQUENT:
            if (!attachments && timeline instanceof Animation.AttachmentTimeline)
              continue;
            if (!drawOrder && timeline instanceof Animation.DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case _AnimationState.FIRST:
            timelineBlend = base.MixBlend.setup;
            alpha = alphaMix;
            break;
          case _AnimationState.HOLD:
            timelineBlend = base.MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = base.MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (timeline instanceof Animation.RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
        else {
          base.Utils.webkit602BugfixHelper(alpha, blend);
          if (timelineBlend == base.MixBlend.setup) {
            if (timeline instanceof Animation.AttachmentTimeline) {
              if (attachments)
                direction = base.MixDirection.mixOut;
            } else if (timeline instanceof Animation.DrawOrderTimeline) {
              if (drawOrder)
                direction = base.MixDirection.mixOut;
            }
          }
          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, base.MixDirection.mixIn);
      return;
    }
    const rotateTimeline = timeline;
    const frames = rotateTimeline.frames;
    const bone = skeleton.bones[rotateTimeline.boneIndex];
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case base.MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == base.MixBlend.setup ? bone.data.rotation : bone.rotation;
      if (time >= frames[frames.length - Animation.RotateTimeline.ENTRIES])
        r2 = bone.data.rotation + frames[frames.length + Animation.RotateTimeline.PREV_ROTATION];
      else {
        const frame = Animation.Animation.binarySearch(frames, time, Animation.RotateTimeline.ENTRIES);
        const prevRotation = frames[frame + Animation.RotateTimeline.PREV_ROTATION];
        const frameTime = frames[frame];
        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + Animation.RotateTimeline.PREV_TIME] - frameTime));
        r2 = frames[frame + Animation.RotateTimeline.ROTATION] - prevRotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        r2 = prevRotation + r2 * percent + bone.data.rotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
      }
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (base.MathUtils.signum(lastDiff) != base.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * base.MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * base.MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    r1 += total * alpha;
    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, events[i]);
    }
  }
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (current == null)
      return;
    this.queue.end(current);
    this.disposeNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (from == null)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    if (from != null) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom != null && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  setAnimation(trackIndex, animationName, loop) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  setAnimationWith(trackIndex, animation, loop) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current != null) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.disposeNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.disposeNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  addAnimation(trackIndex, animationName, loop, delay) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  addAnimationWith(trackIndex, animation, loop, delay) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last != null) {
      while (last.next != null)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (last == null) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      if (delay <= 0) {
        const duration = last.animationEnd - last.animationStart;
        if (duration != 0) {
          if (last.loop)
            delay += duration * (1 + (last.trackTime / duration | 0));
          else
            delay += Math.max(duration, last.trackTime);
          delay -= this.data.getMix(last.animation, animation);
        } else
          delay = last.trackTime;
      }
    }
    entry.delay = delay;
    return entry;
  }
  setEmptyAnimation(trackIndex, mixDuration) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  addEmptyAnimation(trackIndex, mixDuration, delay) {
    if (delay <= 0)
      delay -= mixDuration;
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  setEmptyAnimations(mixDuration) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current != null)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    base.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.interruptAlpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
    return entry;
  }
  disposeNext(entry) {
    let next = entry.next;
    while (next != null) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      let entry = this.tracks[i];
      if (entry == null)
        continue;
      while (entry.mixingFrom != null)
        entry = entry.mixingFrom;
      do {
        if (entry.mixingFrom == null || entry.mixBlend != base.MixBlend.add)
          this.setTimelineModes(entry);
        entry = entry.mixingTo;
      } while (entry != null);
    }
  }
  setTimelineModes(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = base.Utils.setArraySize(entry.timelineMode, timelinesCount);
    entry.timelineHoldMix.length = 0;
    const timelineDipMix = base.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
    const propertyIDs = this.propertyIDs;
    if (to != null && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++) {
        propertyIDs.add(timelines[i].getPropertyId());
        timelineMode[i] = _AnimationState.HOLD;
      }
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const id = timelines[i].getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = _AnimationState.SUBSEQUENT;
        else if (to == null || !this.hasTimeline(to, id))
          timelineMode[i] = _AnimationState.FIRST;
        else {
          for (let next = to.mixingTo; next != null; next = next.mixingTo) {
            if (this.hasTimeline(next, id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = _AnimationState.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = _AnimationState.HOLD;
        }
      }
  }
  hasTimeline(entry, id) {
    const timelines = entry.animation.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      if (timelines[i].getPropertyId() == id)
        return true;
    return false;
  }
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  addListener(listener) {
    if (listener == null)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  clearListeners() {
    this.listeners.length = 0;
  }
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
let AnimationState = _AnimationState;
AnimationState.emptyAnimation = new Animation.Animation("<empty>", [], 0);
AnimationState.SUBSEQUENT = 0;
AnimationState.FIRST = 1;
AnimationState.HOLD = 2;
AnimationState.HOLD_MIX = 3;
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
const _TrackEntry = class {
  constructor() {
    this.mixBlend = base.MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
let TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
const _EventQueue = class {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  deprecateStuff() {
    if (!_EventQueue.deprecatedWarning1) {
      _EventQueue.deprecatedWarning1 = true;
      console.warn(
        "Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'"
      );
    }
    return true;
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener != null && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].start)
              listeners[ii].start(entry);
          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
          break;
        case EventType.interrupt:
          if (entry.listener != null && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].interrupt)
              listeners[ii].interrupt(entry);
          break;
        case EventType.end:
          if (entry.listener != null && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].end)
              listeners[ii].end(entry);
          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
        case EventType.dispose:
          if (entry.listener != null && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].dispose)
              listeners[ii].dispose(entry);
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener != null && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].complete)
              listeners[ii].complete(entry);
          const count = base.MathUtils.toInt(entry.loopsCount());
          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener != null && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].event)
              listeners[ii].event(entry, event);
          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);
          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
};
let EventQueue = _EventQueue;
EventQueue.deprecatedWarning1 = false;
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
  return EventType2;
})(EventType || {});
class AnimationStateAdapter2 {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
}

exports.AnimationState = AnimationState;
exports.AnimationStateAdapter2 = AnimationStateAdapter2;
exports.EventQueue = EventQueue;
exports.EventType = EventType;
exports.TrackEntry = TrackEntry;
//# sourceMappingURL=AnimationState.js.map


/***/ }),

/***/ 49122:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const _AnimationStateData = class {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    this.defaultMix = 0;
    if (skeletonData == null)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (from == null)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (to == null)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  setMixByName(fromName, toName, duration) {
    if (!_AnimationStateData.deprecatedWarning1) {
      _AnimationStateData.deprecatedWarning1 = true;
      console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
    }
    this.setMix(fromName, toName, duration);
  }
  setMixWith(from, to, duration) {
    if (from == null)
      throw new Error("from cannot be null.");
    if (to == null)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
};
let AnimationStateData = _AnimationStateData;
AnimationStateData.deprecatedWarning1 = false;

exports.AnimationStateData = AnimationStateData;
//# sourceMappingURL=AnimationStateData.js.map


/***/ }),

/***/ 3424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(93703);
var BoundingBoxAttachment = __webpack_require__(98932);
var ClippingAttachment = __webpack_require__(70213);
var MeshAttachment = __webpack_require__(81106);
var PathAttachment = __webpack_require__(45616);
var PointAttachment = __webpack_require__(90123);
var RegionAttachment = __webpack_require__(17487);

class AtlasAttachmentLoader {
  constructor(atlas) {
    this.atlas = atlas;
  }
  /** @return May be null to not load an attachment. */
  newRegionAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
    const attachment = new RegionAttachment.RegionAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newMeshAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
    const attachment = new MeshAttachment.MeshAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newBoundingBoxAttachment(skin, name) {
    return new BoundingBoxAttachment.BoundingBoxAttachment(name);
  }
  /** @return May be null to not load an attachment */
  newPathAttachment(skin, name) {
    return new PathAttachment.PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new PointAttachment.PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new ClippingAttachment.ClippingAttachment(name);
  }
}

exports.AtlasAttachmentLoader = AtlasAttachmentLoader;
//# sourceMappingURL=AtlasAttachmentLoader.js.map


/***/ }),

/***/ 96423:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var base = __webpack_require__(55075);

class Bone {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    // be careful! Spine b,c is c,b in pixi matrix
    this.matrix = new core.Matrix();
    this.children = new Array();
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 0;
    this.scaleY = 0;
    this.shearX = 0;
    this.shearY = 0;
    this.ax = 0;
    this.ay = 0;
    this.arotation = 0;
    this.ascaleX = 0;
    this.ascaleY = 0;
    this.ashearX = 0;
    this.ashearY = 0;
    this.appliedValid = false;
    this.sorted = false;
    /** NOT USED IN 3.7. Needed for the debug graph code */
    this.active = true;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */
  update() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = base.settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (parent == null) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = base.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = base.MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = base.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = base.MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case base.TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = base.MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = base.MathUtils.cosDeg(rotationY) * scaleY;
        const lc = base.MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = base.MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case base.TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = base.MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = base.MathUtils.cosDeg(rotationY) * scaleY;
        m.b = base.MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = base.MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case base.TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * base.MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * base.MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = base.MathUtils.cosDeg(rx) * scaleX;
        const lb = base.MathUtils.cosDeg(ry) * scaleY;
        const lc = base.MathUtils.sinDeg(rx) * scaleX;
        const ld = base.MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case base.TransformMode.NoScale:
      case base.TransformMode.NoScaleOrReflection: {
        const cos = base.MathUtils.cosDeg(rotation);
        const sin = base.MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == base.TransformMode.NoScale && pa * pd - pb * pc < 0 != (base.settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = base.MathUtils.cosDeg(shearX) * scaleX;
        const lb = base.MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = base.MathUtils.sinDeg(shearX) * scaleX;
        const ld = base.MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * base.MathUtils.radDeg;
  }
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * base.MathUtils.radDeg;
  }
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.c * m.c);
  }
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.b * m.b + m.d * m.d);
  }
  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using
   * the applied transform after the world transform has been modified directly (eg, by a constraint).
   * <p>
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */
  updateAppliedTransform() {
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    if (parent == null) {
      this.ax = m.tx;
      this.ay = m.ty;
      this.arotation = Math.atan2(m.b, m.a) * base.MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * base.MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * base.MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * base.MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * base.MathUtils.radDeg;
    }
  }
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  worldToLocalRotation(worldRotation) {
    const sin = base.MathUtils.sinDeg(worldRotation);
    const cos = base.MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * base.MathUtils.radDeg;
  }
  localToWorldRotation(localRotation) {
    const sin = base.MathUtils.sinDeg(localRotation);
    const cos = base.MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * base.MathUtils.radDeg;
  }
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = base.MathUtils.cosDeg(degrees);
    const sin = base.MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
    this.appliedValid = false;
  }
}

exports.Bone = Bone;
//# sourceMappingURL=Bone.js.map


/***/ }),

/***/ 11279:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class BoneData {
  constructor(index, name, parent) {
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.shearX = 0;
    this.shearY = 0;
    this.transformMode = base.TransformMode.Normal;
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
}

exports.BoneData = BoneData;
//# sourceMappingURL=BoneData.js.map


/***/ }),

/***/ 92869:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class Event {
  constructor(time, data) {
    if (data == null)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
}

exports.Event = Event;
//# sourceMappingURL=Event.js.map


/***/ }),

/***/ 52805:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class EventData {
  constructor(name) {
    this.name = name;
  }
}

exports.EventData = EventData;
//# sourceMappingURL=EventData.js.map


/***/ }),

/***/ 69506:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class IkConstraint {
  constructor(data, skeleton) {
    this.bendDirection = 0;
    this.compress = false;
    this.stretch = false;
    this.mix = 1;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  getOrder() {
    return this.data.order;
  }
  apply() {
    this.update();
  }
  update() {
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);
        break;
    }
  }
  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
   * coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    if (!bone.appliedValid)
      bone.updateAppliedTransform();
    const p = bone.parent.matrix;
    const id = 1 / (p.a * p.d - p.b * p.c);
    const x = targetX - p.tx;
    const y = targetY - p.ty;
    const tx = (x * p.d - y * p.c) * id - bone.ax;
    const ty = (y * p.a - x * p.b) * id - bone.ay;
    let rotationIK = Math.atan2(ty, tx) * base.MathUtils.radDeg - bone.ashearX - bone.arotation;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
   * target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, alpha) {
    if (alpha == 0) {
      child.updateWorldTransform();
      return;
    }
    if (!parent.appliedValid)
      parent.updateAppliedTransform();
    if (!child.appliedValid)
      child.updateAppliedTransform();
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let sx = psx;
    let psy = parent.ascaleY;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = targetX - pp.tx;
    let y = targetY - pp.ty;
    const tx = (x * d - y * b) * id - px;
    const ty = (y * a - x * c) * id - py;
    const dd = tx * tx + ty * ty;
    x = cwx - pp.tx;
    y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1 = 0;
    let a2 = 0;
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch && l1 + l2 > 1e-4)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = base.MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * base.MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * base.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
}

exports.IkConstraint = IkConstraint;
//# sourceMappingURL=IkConstraint.js.map


/***/ }),

/***/ 48962:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class IkConstraintData {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.bendDirection = 1;
    this.compress = false;
    this.stretch = false;
    this.uniform = false;
    this.mix = 1;
    this.name = name;
  }
}

exports.IkConstraintData = IkConstraintData;
//# sourceMappingURL=IkConstraintData.js.map


/***/ }),

/***/ 75557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(93703);
var base = __webpack_require__(55075);
var PathAttachment = __webpack_require__(45616);
__webpack_require__(17487);
var PathConstraintData = __webpack_require__(87045);

const _PathConstraint = class {
  constructor(data, skeleton) {
    this.position = 0;
    this.spacing = 0;
    this.rotateMix = 0;
    this.translateMix = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findSlot(data.target.name);
    this.position = data.position;
    this.spacing = data.spacing;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
  }
  apply() {
    this.update();
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof PathAttachment.PathAttachment))
      return;
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const translate = translateMix > 0;
    const rotate = rotateMix > 0;
    if (!translate && !rotate)
      return;
    const data = this.data;
    const spacingMode = data.spacingMode;
    const lengthSpacing = spacingMode == PathConstraintData.SpacingMode.Length;
    const rotateMode = data.rotateMode;
    const tangents = rotateMode == base.RotateMode.Tangent;
    const scale = rotateMode == base.RotateMode.ChainScale;
    const boneCount = this.bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const bones = this.bones;
    const spaces = base.Utils.setArraySize(this.spaces, spacesCount);
    let lengths = null;
    const spacing = this.spacing;
    if (scale || lengthSpacing) {
      if (scale)
        lengths = base.Utils.setArraySize(this.lengths, boneCount);
      for (let i = 0, n = spacesCount - 1; i < n; ) {
        const bone = bones[i];
        const setupLength = bone.data.length;
        if (setupLength < _PathConstraint.epsilon) {
          if (scale)
            lengths[i] = 0;
          spaces[++i] = 0;
        } else {
          const x = setupLength * bone.matrix.a;
          const y = setupLength * bone.matrix.b;
          const length = Math.sqrt(x * x + y * y);
          if (scale)
            lengths[i] = length;
          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
        }
      }
    } else {
      for (let i = 1; i < spacesCount; i++)
        spaces[i] = spacing;
    }
    const positions = this.computeWorldPositions(
      attachment,
      spacesCount,
      tangents,
      data.positionMode == base.PositionMode.Percent,
      spacingMode == PathConstraintData.SpacingMode.Percent
    );
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = rotateMode == base.RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * translateMix;
      mat.ty += (boneY - mat.ty) * translateMix;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (rotate) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;
          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;
        } else {
          r += offsetRotation;
        }
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= rotateMix;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.appliedValid = false;
    }
  }
  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = base.Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = null;
    const closed = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (percentPosition)
        position *= pathLength2;
      if (percentSpacing) {
        for (let i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength2;
      }
      world = base.Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i];
        position += space;
        let p = position;
        if (closed) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed) {
      verticesLength += 2;
      world = base.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = base.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = base.Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (percentPosition)
      position *= pathLength;
    if (percentSpacing) {
      for (let i = 0; i < spacesCount; i++)
        spaces[i] *= pathLength;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i];
      position += space;
      let p = position;
      if (closed) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p))
      p = 1e-4;
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents)
      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
  }
  getOrder() {
    return this.data.order;
  }
};
let PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;

exports.PathConstraint = PathConstraint;
//# sourceMappingURL=PathConstraint.js.map


/***/ }),

/***/ 87045:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class PathConstraintData {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.name = name;
  }
}
var SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  return SpacingMode2;
})(SpacingMode || {});

exports.PathConstraintData = PathConstraintData;
exports.SpacingMode = SpacingMode;
//# sourceMappingURL=PathConstraintData.js.map


/***/ }),

/***/ 57174:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(93703);
var base = __webpack_require__(55075);
var MeshAttachment = __webpack_require__(81106);
var PathAttachment = __webpack_require__(45616);
var RegionAttachment = __webpack_require__(17487);
var Bone = __webpack_require__(96423);
var Slot = __webpack_require__(14573);
var IkConstraint = __webpack_require__(69506);
var TransformConstraint = __webpack_require__(53678);
var PathConstraint = __webpack_require__(75557);

const _Skeleton = class {
  constructor(data) {
    this._updateCache = new Array();
    this.updateCacheReset = new Array();
    this.time = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    if (data == null)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (boneData.parent == null)
        bone = new Bone.Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new Bone.Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new Slot.Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new IkConstraint.IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new TransformConstraint.TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new PathConstraint.PathConstraint(pathConstraintData, this));
    }
    this.color = new base.Color(1, 1, 1, 1);
    this.updateCache();
  }
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    this.updateCacheReset.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].sorted = false;
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length > 1) {
      const child = constrained[constrained.length - 1];
      if (!(this._updateCache.indexOf(child) > -1))
        this.updateCacheReset.push(child);
    }
    this._updateCache.push(constraint);
    this.sortReset(parent.children);
    constrained[constrained.length - 1].sorted = true;
  }
  sortPathConstraint(constraint) {
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin != null)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof PathAttachment.PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let ii = 0; ii < boneCount; ii++)
      this.sortReset(constrained[ii].children);
    for (let ii = 0; ii < boneCount; ii++)
      constrained[ii].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof PathAttachment.PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (pathBones == null)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      let i = 0;
      while (i < pathBones.length) {
        const boneCount = pathBones[i++];
        for (let n = i + boneCount; i < n; i++) {
          const boneIndex = pathBones[i];
          this.sortBone(bones[boneIndex]);
        }
      }
    }
  }
  sortBone(bone) {
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent != null)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies constraints. */
  updateWorldTransform() {
    const updateCacheReset = this.updateCacheReset;
    for (let i = 0, n = updateCacheReset.length; i < n; i++) {
      const bone = updateCacheReset[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
      bone.appliedValid = true;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.mix = constraint.data.mix;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
      constraint.scaleMix = data.scaleMix;
      constraint.shearMix = data.shearMix;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
    }
  }
  setSlotsToSetupPose() {
    const slots = this.slots;
    base.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @return May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @return May be null. */
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** @return May be null. */
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   * @see #setSkin(Skin) */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (skin == null)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin != null) {
      if (this.skin != null)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name != null) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment != null)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
  }
  /** @return May be null. */
  getAttachmentByName(slotName, attachmentName) {
    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
  }
  /** @return May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (attachmentName == null)
      throw new Error("attachmentName cannot be null.");
    if (this.skin != null) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment != null)
        return attachment;
    }
    if (this.data.defaultSkin != null)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** @param attachmentName May be null. */
  setAttachment(slotName, attachmentName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName != null) {
          attachment = this.getAttachment(i, attachmentName);
          if (attachment == null)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** @return May be null. */
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** @return May be null. */
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** @return May be null. */
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size The width and height of the AABB.
   * @param temp Working memory */
  getBounds(offset, size, temp) {
    if (offset == null)
      throw new Error("offset cannot be null.");
    if (size == null)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof RegionAttachment.RegionAttachment) {
        verticesLength = 8;
        vertices = base.Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
      } else if (attachment instanceof MeshAttachment.MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = base.Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices != null) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  update(delta) {
    this.time += delta;
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
let Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;

exports.Skeleton = Skeleton;
//# sourceMappingURL=Skeleton.js.map


/***/ }),

/***/ 20615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class SkeletonBounds extends base.SkeletonBoundsBase {
}

exports.SkeletonBounds = SkeletonBounds;
//# sourceMappingURL=SkeletonBounds.js.map


/***/ }),

/***/ 69094:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class SkeletonData {
  constructor() {
    this.bones = new Array();
    // Ordered parents first.
    this.slots = new Array();
    // Setup pose draw order.
    this.skins = new Array();
    this.events = new Array();
    this.animations = new Array();
    this.ikConstraints = new Array();
    this.transformConstraints = new Array();
    this.pathConstraints = new Array();
    // Nonessential
    this.fps = 0;
  }
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  findSkin(skinName) {
    if (skinName == null)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  findEvent(eventDataName) {
    if (eventDataName == null)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  findAnimation(animationName) {
    if (animationName == null)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
}

exports.SkeletonData = SkeletonData;
//# sourceMappingURL=SkeletonData.js.map


/***/ }),

/***/ 62776:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Event = __webpack_require__(92869);
var SkeletonData = __webpack_require__(69094);
var SlotData = __webpack_require__(78573);
var BoneData = __webpack_require__(11279);
var IkConstraintData = __webpack_require__(48962);
var TransformConstraintData = __webpack_require__(37310);
var PathConstraintData = __webpack_require__(87045);
var Skin = __webpack_require__(19920);
var EventData = __webpack_require__(52805);
var Animation = __webpack_require__(94203);
var base = __webpack_require__(55075);
var core = __webpack_require__(11491);

class SkeletonJson {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new SkeletonData.SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap != null) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = this.getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new BoneData.BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = this.getValue(boneMap, "length", 0) * scale;
        data.x = this.getValue(boneMap, "x", 0) * scale;
        data.y = this.getValue(boneMap, "y", 0) * scale;
        data.rotation = this.getValue(boneMap, "rotation", 0);
        data.scaleX = this.getValue(boneMap, "scaleX", 1);
        data.scaleY = this.getValue(boneMap, "scaleY", 1);
        data.shearX = this.getValue(boneMap, "shearX", 0);
        data.shearY = this.getValue(boneMap, "shearY", 0);
        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const slotName = slotMap.name;
        const boneName = slotMap.bone;
        const boneData = skeletonData.findBone(boneName);
        if (boneData == null)
          throw new Error(`Slot bone not found: ${boneName}`);
        const data = new SlotData.SlotData(skeletonData.slots.length, slotName, boneData);
        const color = this.getValue(slotMap, "color", null);
        if (color != null)
          data.color.setFromString(color);
        const dark = this.getValue(slotMap, "dark", null);
        if (dark != null) {
          data.darkColor = new base.Color(1, 1, 1, 1);
          data.darkColor.setFromString(dark);
        }
        data.attachmentName = this.getValue(slotMap, "attachment", null);
        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new IkConstraintData.IkConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`IK target bone not found: ${targetName}`);
        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.mix = this.getValue(constraintMap, "mix", 1);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new TransformConstraintData.TransformConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`Transform constraint target bone not found: ${targetName}`);
        data.local = this.getValue(constraintMap, "local", false);
        data.relative = this.getValue(constraintMap, "relative", false);
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new PathConstraintData.PathConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findSlot(targetName);
        if (data.target == null)
          throw new Error(`Path target slot not found: ${targetName}`);
        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.position = this.getValue(constraintMap, "position", 0);
        if (data.positionMode == base.PositionMode.Fixed)
          data.position *= scale;
        data.spacing = this.getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
          data.spacing *= scale;
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (const skinName in root.skins) {
        const skinMap = root.skins[skinName];
        const skin = new Skin.Skin(skinName);
        for (const slotName in skinMap) {
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotName}`);
          const slotMap = skinMap[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
            if (attachment != null)
              skin.addAttachment(slotIndex, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new EventData.EventData(eventName);
        data.intValue = this.getValue(eventMap, "int", 0);
        data.floatValue = this.getValue(eventMap, "float", 0);
        data.stringValue = this.getValue(eventMap, "string", "");
        data.audioPath = this.getValue(eventMap, "audio", null);
        if (data.audioPath != null) {
          data.volume = this.getValue(eventMap, "volume", 1);
          data.balance = this.getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = this.getValue(map, "name", name);
    const type = this.getValue(map, "type", "region");
    switch (type) {
      case "region": {
        const path = this.getValue(map, "path", name);
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = this.getValue(map, "x", 0) * scale;
        region.y = this.getValue(map, "y", 0) * scale;
        region.scaleX = this.getValue(map, "scaleX", 1);
        region.scaleY = this.getValue(map, "scaleY", 1);
        region.rotation = this.getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        const color = this.getValue(map, "color", null);
        if (color != null)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = this.getValue(map, "path", name);
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        const color = this.getValue(map, "color", null);
        if (color != null)
          mesh.color.setFromString(color);
        const parent = this.getValue(map, "parent", null);
        if (parent != null) {
          mesh.inheritDeform = this.getValue(map, "deform", true);
          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = this.getValue(map, "closed", false);
        path.constantSpeed = this.getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = base.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = this.getValue(map, "color", null);
        if (color != null)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = this.getValue(map, "x", 0) * scale;
        point.y = this.getValue(map, "y", 0) * scale;
        point.rotation = this.getValue(map, "rotation", 0);
        const color = this.getValue(map, "color", null);
        if (color != null)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        const end = this.getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = base.Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = base.Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    let duration = 0;
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slotIndex = skeletonData.findSlotIndex(slotName);
        if (slotIndex == -1)
          throw new Error(`Slot not found: ${slotName}`);
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (timelineName == "attachment") {
            const timeline = new Animation.AttachmentTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          } else if (timelineName == "color") {
            const timeline = new Animation.ColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const color = new base.Color();
              color.setFromString(valueMap.color || "ffffffff");
              timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.ColorTimeline.ENTRIES]);
          } else if (timelineName == "twoColor") {
            const timeline = new Animation.TwoColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const light = new base.Color();
              const dark = new base.Color();
              light.setFromString(valueMap.light);
              dark.setFromString(valueMap.dark);
              timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.TwoColorTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const boneIndex = skeletonData.findBoneIndex(boneName);
        if (boneIndex == -1)
          throw new Error(`Bone not found: ${boneName}`);
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          if (timelineName === "rotate") {
            const timeline = new Animation.RotateTimeline(timelineMap.length);
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.RotateTimeline.ENTRIES]);
          } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "scale")
              timeline = new Animation.ScaleTimeline(timelineMap.length);
            else if (timelineName === "shear")
              timeline = new Animation.ShearTimeline(timelineMap.length);
            else {
              timeline = new Animation.TranslateTimeline(timelineMap.length);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const x = this.getValue(valueMap, "x", 0);
              const y = this.getValue(valueMap, "y", 0);
              timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.TranslateTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        const constraint = skeletonData.findIkConstraint(constraintName);
        const timeline = new Animation.IkConstraintTimeline(constraintMap.length);
        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            valueMap.time,
            this.getValue(valueMap, "mix", 1),
            this.getValue(valueMap, "bendPositive", true) ? 1 : -1,
            this.getValue(valueMap, "compress", false),
            this.getValue(valueMap, "stretch", false)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.IkConstraintTimeline.ENTRIES]);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const constraintMap = map.transform[constraintName];
        const constraint = skeletonData.findTransformConstraint(constraintName);
        const timeline = new Animation.TransformConstraintTimeline(constraintMap.length);
        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            valueMap.time,
            this.getValue(valueMap, "rotateMix", 1),
            this.getValue(valueMap, "translateMix", 1),
            this.getValue(valueMap, "scaleMix", 1),
            this.getValue(valueMap, "shearMix", 1)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.TransformConstraintTimeline.ENTRIES]);
      }
    }
    if (map.paths) {
      for (const constraintName in map.paths) {
        const constraintMap = map.paths[constraintName];
        const index = skeletonData.findPathConstraintIndex(constraintName);
        if (index == -1)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const data = skeletonData.pathConstraints[index];
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          if (timelineName === "position" || timelineName === "spacing") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "spacing") {
              timeline = new Animation.PathConstraintSpacingTimeline(timelineMap.length);
              if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new Animation.PathConstraintPositionTimeline(timelineMap.length);
              if (data.positionMode == base.PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.PathConstraintPositionTimeline.ENTRIES]);
          } else if (timelineName === "mix") {
            const timeline = new Animation.PathConstraintMixTimeline(timelineMap.length);
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.PathConstraintMixTimeline.ENTRIES]);
          }
        }
      }
    }
    if (map.deform) {
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const skin = skeletonData.findSkin(deformName);
        if (skin == null) {
          if (base.settings.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${deformName}`);
          } else {
            continue;
          }
        }
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotMap.name}`);
          for (const timelineName in slotMap) {
            const timelineMap = slotMap[timelineName];
            const attachment = skin.getAttachment(slotIndex, timelineName);
            if (attachment == null)
              throw new Error(`Deform attachment not found: ${timelineMap.name}`);
            const weighted = attachment.bones != null;
            const vertices = attachment.vertices;
            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            const timeline = new Animation.DeformTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            let frameIndex = 0;
            for (let j = 0; j < timelineMap.length; j++) {
              const valueMap = timelineMap[j];
              let deform;
              const verticesValue = this.getValue(valueMap, "vertices", null);
              if (verticesValue == null)
                deform = weighted ? base.Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = base.Utils.newFloatArray(deformLength);
                const start = this.getValue(valueMap, "offset", 0);
                base.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                if (scale != 1) {
                  for (let i = start, n = i + verticesValue.length; i < n; i++)
                    deform[i] *= scale;
                }
                if (!weighted) {
                  for (let i = 0; i < deformLength; i++)
                    deform[i] += vertices[i];
                }
              }
              timeline.setFrame(frameIndex, valueMap.time, deform);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
        }
      }
    }
    let drawOrderNode = map.drawOrder;
    if (drawOrderNode == null)
      drawOrderNode = map.draworder;
    if (drawOrderNode != null) {
      const timeline = new Animation.DrawOrderTimeline(drawOrderNode.length);
      const slotCount = skeletonData.slots.length;
      let frameIndex = 0;
      for (let j = 0; j < drawOrderNode.length; j++) {
        const drawOrderMap = drawOrderNode[j];
        let drawOrder = null;
        const offsets = this.getValue(drawOrderMap, "offsets", null);
        if (offsets != null) {
          drawOrder = base.Utils.newArray(slotCount, -1);
          const unchanged = base.Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let i = 0; i < offsets.length; i++) {
            const offsetMap = offsets[i];
            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
            if (slotIndex == -1)
              throw new Error(`Slot not found: ${offsetMap.slot}`);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let i = slotCount - 1; i >= 0; i--)
            if (drawOrder[i] == -1)
              drawOrder[i] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (map.events) {
      const timeline = new Animation.EventTimeline(map.events.length);
      let frameIndex = 0;
      for (let i = 0; i < map.events.length; i++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (eventData == null)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new Event.Event(base.Utils.toSinglePrecision(eventMap.time), eventData);
        event.intValue = this.getValue(eventMap, "int", eventData.intValue);
        event.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath != null) {
          event.volume = this.getValue(eventMap, "volume", 1);
          event.balance = this.getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frameIndex++, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new Animation.Animation(name, timelines, duration));
  }
  readCurve(map, timeline, frameIndex) {
    if (!map.curve)
      return;
    if (map.curve === "stepped")
      timeline.setStepped(frameIndex);
    else if (Object.prototype.toString.call(map.curve) === "[object Array]") {
      const curve = map.curve;
      timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
    }
  }
  getValue(map, prop, defaultValue) {
    return map[prop] !== void 0 ? map[prop] : defaultValue;
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return core.BLEND_MODES.NORMAL;
    if (str == "additive")
      return core.BLEND_MODES.ADD;
    if (str == "multiply")
      return core.BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return core.BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
  static positionModeFromString(str) {
    str = str.toLowerCase();
    if (str == "fixed")
      return base.PositionMode.Fixed;
    if (str == "percent")
      return base.PositionMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static spacingModeFromString(str) {
    str = str.toLowerCase();
    if (str == "length")
      return PathConstraintData.SpacingMode.Length;
    if (str == "fixed")
      return PathConstraintData.SpacingMode.Fixed;
    if (str == "percent")
      return PathConstraintData.SpacingMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static rotateModeFromString(str) {
    str = str.toLowerCase();
    if (str == "tangent")
      return base.RotateMode.Tangent;
    if (str == "chain")
      return base.RotateMode.Chain;
    if (str == "chainscale")
      return base.RotateMode.ChainScale;
    throw new Error(`Unknown rotate mode: ${str}`);
  }
  static transformModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return base.TransformMode.Normal;
    if (str == "onlytranslation")
      return base.TransformMode.OnlyTranslation;
    if (str == "norotationorreflection")
      return base.TransformMode.NoRotationOrReflection;
    if (str == "noscale")
      return base.TransformMode.NoScale;
    if (str == "noscaleorreflection")
      return base.TransformMode.NoScaleOrReflection;
    throw new Error(`Unknown transform mode: ${str}`);
  }
}
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
  }
}

exports.SkeletonJson = SkeletonJson;
//# sourceMappingURL=SkeletonJson.js.map


/***/ }),

/***/ 19920:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class Skin {
  constructor(name) {
    this.attachments = new Array();
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  addAttachment(slotIndex, name, attachment) {
    if (attachment == null)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  /** @return May be null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment != null)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
}

exports.Skin = Skin;
//# sourceMappingURL=Skin.js.map


/***/ }),

/***/ 14573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class Slot {
  constructor(data, bone) {
    this.attachmentVertices = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (bone == null)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new base.Color();
    this.darkColor = data.darkColor == null ? null : new base.Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** @return May be null. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.
   * @param attachment May be null. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    this.attachment = attachment;
    this.attachmentTime = this.bone.skeleton.time;
    this.attachmentVertices.length = 0;
  }
  setAttachmentTime(time) {
    this.attachmentTime = this.bone.skeleton.time - time;
  }
  /** Returns the time since the attachment was set. */
  getAttachmentTime() {
    return this.bone.skeleton.time - this.attachmentTime;
  }
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor != null)
      this.darkColor.setFromColor(this.data.darkColor);
    if (this.data.attachmentName == null)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
}

exports.Slot = Slot;
//# sourceMappingURL=Slot.js.map


/***/ }),

/***/ 78573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class SlotData {
  constructor(index, name, boneData) {
    this.color = new base.Color(1, 1, 1, 1);
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    if (boneData == null)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
}

exports.SlotData = SlotData;
//# sourceMappingURL=SlotData.js.map


/***/ }),

/***/ 53678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class TransformConstraint {
  constructor(data, skeleton) {
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.temp = new base.Vector2();
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
    this.scaleMix = data.scaleMix;
    this.shearMix = data.shearMix;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  apply() {
    this.update();
  }
  update() {
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * translateMix;
        mat.ty += (temp.y - mat.ty) * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        let ts = Math.sqrt(ta * ta + tc * tc);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
        mat.a *= s;
        mat.b *= s;
        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        ts = Math.sqrt(tb * tb + td * td);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r = by + (r + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyRelativeWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * translateMix;
        mat.ty += temp.y * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
        mat.a *= s;
        mat.b *= s;
        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - base.MathUtils.PI / 2 + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyAbsoluteLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * rotateMix;
      }
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax - x + this.data.offsetX) * translateMix;
        y += (target.ay - y + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
        if (scaleY > 1e-5)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
      }
      const shearY = bone.ashearY;
      if (shearMix > 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        bone.shearY += r * shearMix;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0)
        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax + this.data.offsetX) * translateMix;
        y += (target.ay + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
        if (scaleY > 1e-5)
          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
      }
      let shearY = bone.ashearY;
      if (shearMix > 0)
        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  getOrder() {
    return this.data.order;
  }
}

exports.TransformConstraint = TransformConstraint;
//# sourceMappingURL=TransformConstraint.js.map


/***/ }),

/***/ 37310:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class TransformConstraintData {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.offsetRotation = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.offsetScaleX = 0;
    this.offsetScaleY = 0;
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}

exports.TransformConstraintData = TransformConstraintData;
//# sourceMappingURL=TransformConstraintData.js.map


/***/ }),

/***/ 93703:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class Attachment {
  constructor(name) {
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}
const _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    this.id = (_VertexAttachment.nextID++ & 65535) << 11;
    this.worldVerticesLength = 0;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms local vertices to world coordinates.
   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.
   * @param worldVertices The output world vertices. Must have a length >= offset + count.
   * @param offset The worldVertices index to begin writing values. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.attachmentVertices;
    let vertices = this.vertices;
    const bones = this.bones;
    if (bones == null) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */
  applyDeform(sourceAttachment) {
    return this == sourceAttachment;
  }
};
let VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;

exports.Attachment = Attachment;
exports.VertexAttachment = VertexAttachment;
//# sourceMappingURL=Attachment.js.map


/***/ }),

/***/ 98932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var base = __webpack_require__(55075);

class BoundingBoxAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.BoundingBox;
    this.color = new base.Color(1, 1, 1, 1);
  }
}

exports.BoundingBoxAttachment = BoundingBoxAttachment;
//# sourceMappingURL=BoundingBoxAttachment.js.map


/***/ }),

/***/ 70213:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var base = __webpack_require__(55075);

class ClippingAttachment extends Attachment.VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Clipping;
    // Nonessential.
    this.color = new base.Color(0.2275, 0.2275, 0.8078, 1);
  }
}

exports.ClippingAttachment = ClippingAttachment;
//# sourceMappingURL=ClippingAttachment.js.map


/***/ }),

/***/ 81106:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var base = __webpack_require__(55075);

class MeshAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Mesh;
    this.color = new base.Color(1, 1, 1, 1);
    this.inheritDeform = false;
    this.tempColor = new base.Color(0, 0, 0, 0);
  }
  applyDeform(sourceAttachment) {
    return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;
  }
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh != null) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  // computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);
}

exports.MeshAttachment = MeshAttachment;
//# sourceMappingURL=MeshAttachment.js.map


/***/ }),

/***/ 45616:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var base = __webpack_require__(55075);

class PathAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Path;
    this.closed = false;
    this.constantSpeed = false;
    this.color = new base.Color(1, 1, 1, 1);
  }
}

exports.PathAttachment = PathAttachment;
//# sourceMappingURL=PathAttachment.js.map


/***/ }),

/***/ 90123:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var base = __webpack_require__(55075);

class PointAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Point;
    this.color = new base.Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = base.MathUtils.cosDeg(this.rotation);
    const sin = base.MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * base.MathUtils.radDeg;
  }
}

exports.PointAttachment = PointAttachment;
//# sourceMappingURL=PointAttachment.js.map


/***/ }),

/***/ 17487:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var base = __webpack_require__(55075);
var Slot = __webpack_require__(14573);

const _RegionAttachment = class extends Attachment.Attachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Region;
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.width = 0;
    this.height = 0;
    this.color = new base.Color(1, 1, 1, 1);
    this.offset = base.Utils.newFloatArray(8);
    this.uvs = base.Utils.newFloatArray(8);
    this.tempColor = new base.Color(1, 1, 1, 1);
  }
  updateOffset() {
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const localXCos = localX * cos + this.x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + this.y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + this.x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + this.y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[_RegionAttachment.OX1] = localXCos - localYSin;
    offset[_RegionAttachment.OY1] = localYCos + localXSin;
    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;
    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;
    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;
    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;
    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;
    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;
  }
  setRegion(region) {
    this.region = region;
    const uvs = this.uvs;
    if (region.rotate) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  computeWorldVertices(bone, worldVertices, offset, stride) {
    const vertexOffset = this.offset;
    const mat = bone instanceof Slot.Slot ? bone.bone.matrix : bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[_RegionAttachment.OX1];
    offsetY = vertexOffset[_RegionAttachment.OY1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX2];
    offsetY = vertexOffset[_RegionAttachment.OY2];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX3];
    offsetY = vertexOffset[_RegionAttachment.OY3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX4];
    offsetY = vertexOffset[_RegionAttachment.OY4];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
};
let RegionAttachment = _RegionAttachment;
RegionAttachment.OX1 = 0;
RegionAttachment.OY1 = 1;
RegionAttachment.OX2 = 2;
RegionAttachment.OY2 = 3;
RegionAttachment.OX3 = 4;
RegionAttachment.OY3 = 5;
RegionAttachment.OX4 = 6;
RegionAttachment.OY4 = 7;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;

exports.RegionAttachment = RegionAttachment;
//# sourceMappingURL=RegionAttachment.js.map


/***/ }),

/***/ 87995:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class JitterEffect {
  constructor(jitterX, jitterY) {
    this.jitterX = 0;
    this.jitterY = 0;
    this.jitterX = jitterX;
    this.jitterY = jitterY;
  }
  begin(skeleton) {
  }
  transform(position, uv, light, dark) {
    position.x += base.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    position.y += base.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
  }
  end() {
  }
}

exports.JitterEffect = JitterEffect;
//# sourceMappingURL=JitterEffect.js.map


/***/ }),

/***/ 31432:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

const _SwirlEffect = class {
  constructor(radius) {
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.angle = 0;
    this.worldX = 0;
    this.worldY = 0;
    this.radius = radius;
  }
  begin(skeleton) {
    this.worldX = skeleton.x + this.centerX;
    this.worldY = skeleton.y + this.centerY;
  }
  transform(position, uv, light, dark) {
    const radAngle = this.angle * base.MathUtils.degreesToRadians;
    const x = position.x - this.worldX;
    const y = position.y - this.worldY;
    const dist = Math.sqrt(x * x + y * y);
    if (dist < this.radius) {
      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);
      position.x = cos * x - sin * y + this.worldX;
      position.y = sin * x + cos * y + this.worldY;
    }
  }
  end() {
  }
};
let SwirlEffect = _SwirlEffect;
SwirlEffect.interpolation = new base.PowOut(2);

exports.SwirlEffect = SwirlEffect;
//# sourceMappingURL=SwirlEffect.js.map


/***/ }),

/***/ 35049:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(93703);
var BoundingBoxAttachment = __webpack_require__(98932);
var ClippingAttachment = __webpack_require__(70213);
var MeshAttachment = __webpack_require__(81106);
var PathAttachment = __webpack_require__(45616);
var PointAttachment = __webpack_require__(90123);
var RegionAttachment = __webpack_require__(17487);
var JitterEffect = __webpack_require__(87995);
var SwirlEffect = __webpack_require__(31432);
var Animation = __webpack_require__(94203);
var AnimationState = __webpack_require__(39330);
var AnimationStateData = __webpack_require__(49122);
var AtlasAttachmentLoader = __webpack_require__(3424);
var Bone = __webpack_require__(96423);
var BoneData = __webpack_require__(11279);
var Event = __webpack_require__(92869);
var EventData = __webpack_require__(52805);
var IkConstraint = __webpack_require__(69506);
var IkConstraintData = __webpack_require__(48962);
var PathConstraint = __webpack_require__(75557);
var PathConstraintData = __webpack_require__(87045);
var Skeleton = __webpack_require__(57174);
var SkeletonBounds = __webpack_require__(20615);
var SkeletonData = __webpack_require__(69094);
var SkeletonJson = __webpack_require__(62776);
var Skin = __webpack_require__(19920);
var Slot = __webpack_require__(14573);
var SlotData = __webpack_require__(78573);
var TransformConstraint = __webpack_require__(53678);
var TransformConstraintData = __webpack_require__(37310);
var Spine = __webpack_require__(65774);



exports.Attachment = Attachment.Attachment;
exports.VertexAttachment = Attachment.VertexAttachment;
exports.BoundingBoxAttachment = BoundingBoxAttachment.BoundingBoxAttachment;
exports.ClippingAttachment = ClippingAttachment.ClippingAttachment;
exports.MeshAttachment = MeshAttachment.MeshAttachment;
exports.PathAttachment = PathAttachment.PathAttachment;
exports.PointAttachment = PointAttachment.PointAttachment;
exports.RegionAttachment = RegionAttachment.RegionAttachment;
exports.JitterEffect = JitterEffect.JitterEffect;
exports.SwirlEffect = SwirlEffect.SwirlEffect;
exports.Animation = Animation.Animation;
exports.AttachmentTimeline = Animation.AttachmentTimeline;
exports.ColorTimeline = Animation.ColorTimeline;
exports.CurveTimeline = Animation.CurveTimeline;
exports.DeformTimeline = Animation.DeformTimeline;
exports.DrawOrderTimeline = Animation.DrawOrderTimeline;
exports.EventTimeline = Animation.EventTimeline;
exports.IkConstraintTimeline = Animation.IkConstraintTimeline;
exports.PathConstraintMixTimeline = Animation.PathConstraintMixTimeline;
exports.PathConstraintPositionTimeline = Animation.PathConstraintPositionTimeline;
exports.PathConstraintSpacingTimeline = Animation.PathConstraintSpacingTimeline;
exports.RotateTimeline = Animation.RotateTimeline;
exports.ScaleTimeline = Animation.ScaleTimeline;
exports.ShearTimeline = Animation.ShearTimeline;
exports.TimelineType = Animation.TimelineType;
exports.TransformConstraintTimeline = Animation.TransformConstraintTimeline;
exports.TranslateTimeline = Animation.TranslateTimeline;
exports.TwoColorTimeline = Animation.TwoColorTimeline;
exports.AnimationState = AnimationState.AnimationState;
exports.AnimationStateAdapter2 = AnimationState.AnimationStateAdapter2;
exports.EventQueue = AnimationState.EventQueue;
exports.EventType = AnimationState.EventType;
exports.TrackEntry = AnimationState.TrackEntry;
exports.AnimationStateData = AnimationStateData.AnimationStateData;
exports.AtlasAttachmentLoader = AtlasAttachmentLoader.AtlasAttachmentLoader;
exports.Bone = Bone.Bone;
exports.BoneData = BoneData.BoneData;
exports.Event = Event.Event;
exports.EventData = EventData.EventData;
exports.IkConstraint = IkConstraint.IkConstraint;
exports.IkConstraintData = IkConstraintData.IkConstraintData;
exports.PathConstraint = PathConstraint.PathConstraint;
exports.PathConstraintData = PathConstraintData.PathConstraintData;
exports.SpacingMode = PathConstraintData.SpacingMode;
exports.Skeleton = Skeleton.Skeleton;
exports.SkeletonBounds = SkeletonBounds.SkeletonBounds;
exports.SkeletonData = SkeletonData.SkeletonData;
exports.SkeletonJson = SkeletonJson.SkeletonJson;
exports.Skin = Skin.Skin;
exports.Slot = Slot.Slot;
exports.SlotData = SlotData.SlotData;
exports.TransformConstraint = TransformConstraint.TransformConstraint;
exports.TransformConstraintData = TransformConstraintData.TransformConstraintData;
exports.Spine = Spine.Spine;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 18843:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var Skeleton = __webpack_require__(40443);
var AnimationState = __webpack_require__(91259);
var AnimationStateData = __webpack_require__(16963);

class Spine extends base.SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new Skeleton.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new AnimationStateData.AnimationStateData(spineData);
    this.state = new AnimationState.AnimationState(this.stateData);
  }
}

exports.Spine = Spine;
//# sourceMappingURL=Spine.js.map


/***/ }),

/***/ 93816:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var base = __webpack_require__(55075);
__webpack_require__(95762);

class Animation {
  constructor(name, timelines, duration) {
    if (name == null)
      throw new Error("name cannot be null.");
    if (timelines == null)
      throw new Error("timelines cannot be null.");
    this.name = name;
    this.timelines = timelines;
    this.timelineIds = [];
    for (let i = 0; i < timelines.length; i++)
      this.timelineIds[timelines[i].getPropertyId()] = true;
    this.duration = duration;
  }
  hasTimeline(id) {
    return this.timelineIds[id] == true;
  }
  /** Applies all the animation's timelines to the specified skeleton.
   *
   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
   * @param loop If true, the animation repeats after {@link #getDuration()}.
   * @param events May be null to ignore fired events. */
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
  /** @param target After the first and before the last value.
   * @returns index of first value greater than the target. */
  static binarySearch(values, target, step = 1) {
    let low = 0;
    let high = values.length / step - 2;
    if (high == 0)
      return step;
    let current = high >>> 1;
    while (true) {
      if (values[(current + 1) * step] <= target)
        low = current + 1;
      else
        high = current;
      if (low == high)
        return (low + 1) * step;
      current = low + high >>> 1;
    }
  }
  static linearSearch(values, target, step) {
    for (let i = 0, last = values.length - step; i <= last; i += step)
      if (values[i] > target)
        return i;
    return -1;
  }
}
var TimelineType = /* @__PURE__ */ ((TimelineType2) => {
  TimelineType2[TimelineType2["rotate"] = 0] = "rotate";
  TimelineType2[TimelineType2["translate"] = 1] = "translate";
  TimelineType2[TimelineType2["scale"] = 2] = "scale";
  TimelineType2[TimelineType2["shear"] = 3] = "shear";
  TimelineType2[TimelineType2["attachment"] = 4] = "attachment";
  TimelineType2[TimelineType2["color"] = 5] = "color";
  TimelineType2[TimelineType2["deform"] = 6] = "deform";
  TimelineType2[TimelineType2["event"] = 7] = "event";
  TimelineType2[TimelineType2["drawOrder"] = 8] = "drawOrder";
  TimelineType2[TimelineType2["ikConstraint"] = 9] = "ikConstraint";
  TimelineType2[TimelineType2["transformConstraint"] = 10] = "transformConstraint";
  TimelineType2[TimelineType2["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType2[TimelineType2["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType2[TimelineType2["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType2[TimelineType2["twoColor"] = 14] = "twoColor";
  return TimelineType2;
})(TimelineType || {});
const _CurveTimeline = class {
  constructor(frameCount) {
    if (frameCount <= 0)
      throw new Error(`frameCount must be > 0: ${frameCount}`);
    this.curves = base.Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;
  }
  /** Sets the specified key frame to linear interpolation. */
  setLinear(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;
  }
  /** Sets the specified key frame to stepped interpolation. */
  setStepped(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;
  }
  /** Returns the interpolation type for the specified key frame.
   * @returns Linear is 0, stepped is 1, Bezier is 2. */
  getCurveType(frameIndex) {
    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;
    if (index == this.curves.length)
      return _CurveTimeline.LINEAR;
    const type = this.curves[index];
    if (type == _CurveTimeline.LINEAR)
      return _CurveTimeline.LINEAR;
    if (type == _CurveTimeline.STEPPED)
      return _CurveTimeline.STEPPED;
    return _CurveTimeline.BEZIER;
  }
  /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,
   * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the
   * difference between the key frame's values. */
  setCurve(frameIndex, cx1, cy1, cx2, cy2) {
    const tmpx = (-cx1 * 2 + cx2) * 0.03;
    const tmpy = (-cy1 * 2 + cy2) * 0.03;
    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;
    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
    let ddfx = tmpx * 2 + dddfx;
    let ddfy = tmpy * 2 + dddfy;
    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;
    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const curves = this.curves;
    curves[i++] = _CurveTimeline.BEZIER;
    let x = dfx;
    let y = dfy;
    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      x += dfx;
      y += dfy;
    }
  }
  /** Returns the interpolated percentage for the specified key frame and linear percentage. */
  getCurvePercent(frameIndex, percent) {
    percent = base.MathUtils.clamp(percent, 0, 1);
    const curves = this.curves;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const type = curves[i];
    if (type == _CurveTimeline.LINEAR)
      return percent;
    if (type == _CurveTimeline.STEPPED)
      return 0;
    i++;
    let x = 0;
    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      x = curves[i];
      if (x >= percent) {
        let prevX;
        let prevY;
        if (i == start) {
          prevX = 0;
          prevY = 0;
        } else {
          prevX = curves[i - 2];
          prevY = curves[i - 1];
        }
        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
      }
    }
    const y = curves[i - 1];
    return y + (1 - y) * (percent - x) / (1 - x);
  }
};
let CurveTimeline = _CurveTimeline;
CurveTimeline.LINEAR = 0;
CurveTimeline.STEPPED = 1;
CurveTimeline.BEZIER = 2;
CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
const _RotateTimeline = class extends CurveTimeline {
  // time, degrees, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount << 1);
  }
  getPropertyId() {
    return (0 /* rotate */ << 24) + this.boneIndex;
  }
  /** Sets the time and angle of the specified keyframe. */
  setFrame(frameIndex, time, degrees) {
    frameIndex <<= 1;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case base.MixBlend.first:
          const r2 = bone.data.rotation - bone.rotation;
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;
      }
      return;
    }
    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {
      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation + r2 * alpha;
          break;
        case base.MixBlend.first:
        case base.MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        case base.MixBlend.add:
          bone.rotation += r2 * alpha;
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);
    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));
    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;
    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
    switch (blend) {
      case base.MixBlend.setup:
        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case base.MixBlend.add:
        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
    }
  }
};
let RotateTimeline = _RotateTimeline;
RotateTimeline.ENTRIES = 2;
RotateTimeline.PREV_TIME = -2;
RotateTimeline.PREV_ROTATION = -1;
RotateTimeline.ROTATION = 1;
const _TranslateTimeline = class extends CurveTimeline {
  // time, x, y, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);
  }
  getPropertyId() {
    return (1 /* translate */ << 24) + this.boneIndex;
  }
  /** Sets the time in seconds, x, and y values for the specified key frame. */
  setFrame(frameIndex, time, x, y) {
    frameIndex *= _TranslateTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TranslateTimeline.X] = x;
    this.frames[frameIndex + _TranslateTimeline.Y] = y;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case base.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {
      x = frames[frames.length + _TranslateTimeline.PREV_X];
      y = frames[frames.length + _TranslateTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);
      x = frames[frame + _TranslateTimeline.PREV_X];
      y = frames[frame + _TranslateTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));
      x += (frames[frame + _TranslateTimeline.X] - x) * percent;
      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case base.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case base.MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
};
let TranslateTimeline = _TranslateTimeline;
TranslateTimeline.ENTRIES = 3;
TranslateTimeline.PREV_TIME = -3;
TranslateTimeline.PREV_X = -2;
TranslateTimeline.PREV_Y = -1;
TranslateTimeline.X = 1;
TranslateTimeline.Y = 2;
class ScaleTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (2 /* scale */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case base.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
      x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
      y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
    } else {
      const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
      x = frames[frame + ScaleTimeline.PREV_X];
      y = frames[frame + ScaleTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
      x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
      y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
    }
    if (alpha == 1) {
      if (blend == base.MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == base.MixDirection.mixOut) {
        switch (blend) {
          case base.MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.add:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bone.data.scaleX) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case base.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * base.MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * base.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * base.MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * base.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.add:
            bx = base.MathUtils.signum(x);
            by = base.MathUtils.signum(y);
            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
        }
      }
    }
  }
}
class ShearTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (3 /* shear */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case base.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
      x = frames[frames.length + ShearTimeline.PREV_X];
      y = frames[frames.length + ShearTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
      x = frames[frame + ShearTimeline.PREV_X];
      y = frames[frame + ShearTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
      x = x + (frames[frame + ShearTimeline.X] - x) * percent;
      y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case base.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case base.MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
}
const _ColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (5 /* color */ << 24) + this.slotIndex;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frameIndex, time, r, g, b, a) {
    frameIndex *= _ColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _ColorTimeline.R] = r;
    this.frames[frameIndex + _ColorTimeline.G] = g;
    this.frames[frameIndex + _ColorTimeline.B] = b;
    this.frames[frameIndex + _ColorTimeline.A] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          return;
        case base.MixBlend.first:
          const color = slot.color;
          const setup = slot.data.color;
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _ColorTimeline.PREV_R];
      g = frames[i + _ColorTimeline.PREV_G];
      b = frames[i + _ColorTimeline.PREV_B];
      a = frames[i + _ColorTimeline.PREV_A];
    } else {
      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);
      r = frames[frame + _ColorTimeline.PREV_R];
      g = frames[frame + _ColorTimeline.PREV_G];
      b = frames[frame + _ColorTimeline.PREV_B];
      a = frames[frame + _ColorTimeline.PREV_A];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _ColorTimeline.R] - r) * percent;
      g += (frames[frame + _ColorTimeline.G] - g) * percent;
      b += (frames[frame + _ColorTimeline.B] - b) * percent;
      a += (frames[frame + _ColorTimeline.A] - a) * percent;
    }
    if (alpha == 1)
      slot.color.set(r, g, b, a);
    else {
      const color = slot.color;
      if (blend == base.MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
};
let ColorTimeline = _ColorTimeline;
ColorTimeline.ENTRIES = 5;
ColorTimeline.PREV_TIME = -5;
ColorTimeline.PREV_R = -4;
ColorTimeline.PREV_G = -3;
ColorTimeline.PREV_B = -2;
ColorTimeline.PREV_A = -1;
ColorTimeline.R = 1;
ColorTimeline.G = 2;
ColorTimeline.B = 3;
ColorTimeline.A = 4;
const _TwoColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, r2, g2, b2, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (14 /* twoColor */ << 24) + this.slotIndex;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {
    frameIndex *= _TwoColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TwoColorTimeline.R] = r;
    this.frames[frameIndex + _TwoColorTimeline.G] = g;
    this.frames[frameIndex + _TwoColorTimeline.B] = b;
    this.frames[frameIndex + _TwoColorTimeline.A] = a;
    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;
    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;
    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          slot.darkColor.setFromColor(slot.data.darkColor);
          return;
        case base.MixBlend.first:
          const light = slot.color;
          const dark = slot.darkColor;
          const setupLight = slot.data.color;
          const setupDark = slot.data.darkColor;
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _TwoColorTimeline.PREV_R];
      g = frames[i + _TwoColorTimeline.PREV_G];
      b = frames[i + _TwoColorTimeline.PREV_B];
      a = frames[i + _TwoColorTimeline.PREV_A];
      r2 = frames[i + _TwoColorTimeline.PREV_R2];
      g2 = frames[i + _TwoColorTimeline.PREV_G2];
      b2 = frames[i + _TwoColorTimeline.PREV_B2];
    } else {
      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);
      r = frames[frame + _TwoColorTimeline.PREV_R];
      g = frames[frame + _TwoColorTimeline.PREV_G];
      b = frames[frame + _TwoColorTimeline.PREV_B];
      a = frames[frame + _TwoColorTimeline.PREV_A];
      r2 = frames[frame + _TwoColorTimeline.PREV_R2];
      g2 = frames[frame + _TwoColorTimeline.PREV_G2];
      b2 = frames[frame + _TwoColorTimeline.PREV_B2];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;
      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;
      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;
      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;
      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;
      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;
      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;
    }
    if (alpha == 1) {
      slot.color.set(r, g, b, a);
      slot.darkColor.set(r2, g2, b2, 1);
    } else {
      const light = slot.color;
      const dark = slot.darkColor;
      if (blend == base.MixBlend.setup) {
        light.setFromColor(slot.data.color);
        dark.setFromColor(slot.data.darkColor);
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
    }
  }
};
let TwoColorTimeline = _TwoColorTimeline;
TwoColorTimeline.ENTRIES = 8;
TwoColorTimeline.PREV_TIME = -8;
TwoColorTimeline.PREV_R = -7;
TwoColorTimeline.PREV_G = -6;
TwoColorTimeline.PREV_B = -5;
TwoColorTimeline.PREV_A = -4;
TwoColorTimeline.PREV_R2 = -3;
TwoColorTimeline.PREV_G2 = -2;
TwoColorTimeline.PREV_B2 = -1;
TwoColorTimeline.R = 1;
TwoColorTimeline.G = 2;
TwoColorTimeline.B = 3;
TwoColorTimeline.A = 4;
TwoColorTimeline.R2 = 5;
TwoColorTimeline.G2 = 6;
TwoColorTimeline.B2 = 7;
class AttachmentTimeline {
  constructor(frameCount) {
    this.frames = base.Utils.newFloatArray(frameCount);
    this.attachmentNames = new Array(frameCount);
  }
  getPropertyId() {
    return (4 /* attachment */ << 24) + this.slotIndex;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the attachment name for the specified key frame. */
  setFrame(frameIndex, time, attachmentName) {
    this.frames[frameIndex] = time;
    this.attachmentNames[frameIndex] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    if (direction == base.MixDirection.mixOut) {
      if (blend == base.MixBlend.setup)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    let frameIndex = 0;
    if (time >= frames[frames.length - 1])
      frameIndex = frames.length - 1;
    else
      frameIndex = Animation.binarySearch(frames, time, 1) - 1;
    const attachmentName = this.attachmentNames[frameIndex];
    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
  setAttachment(skeleton, slot, attachmentName) {
    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
}
let zeros = null;
class DeformTimeline extends CurveTimeline {
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount);
    this.frameVertices = new Array(frameCount);
    if (zeros == null)
      zeros = base.Utils.newFloatArray(64);
  }
  getPropertyId() {
    return (6 /* deform */ << 27) + Number(this.attachment.id) + this.slotIndex;
  }
  /** Sets the time in seconds and the vertices for the specified key frame.
   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
  setFrame(frameIndex, time, vertices) {
    this.frames[frameIndex] = time;
    this.frameVertices[frameIndex] = vertices;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.getAttachment();
    if (!(slotAttachment instanceof Attachment.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))
      return;
    const deformArray = slot.deform;
    if (deformArray.length == 0)
      blend = base.MixBlend.setup;
    const frameVertices = this.frameVertices;
    const vertexCount = frameVertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      const vertexAttachment = slotAttachment;
      switch (blend) {
        case base.MixBlend.setup:
          deformArray.length = 0;
          return;
        case base.MixBlend.first:
          if (alpha == 1) {
            deformArray.length = 0;
            break;
          }
          const deform2 = base.Utils.setArraySize(deformArray, vertexCount);
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform2[i] += (setupVertices[i] - deform2[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              deform2[i] *= alpha;
          }
      }
      return;
    }
    const deform = base.Utils.setArraySize(deformArray, vertexCount);
    if (time >= frames[frames.length - 1]) {
      const lastVertices = frameVertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == base.MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              deform[i] += lastVertices[i] - setupVertices[i];
            }
          } else {
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i];
          }
        } else {
          base.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
        }
      } else {
        switch (blend) {
          case base.MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (vertexAttachment2.bones == null) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                deform[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case base.MixBlend.first:
          case base.MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (lastVertices[i] - deform[i]) * alpha;
            break;
          case base.MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++) {
                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time);
    const prevVertices = frameVertices[frame - 1];
    const nextVertices = frameVertices[frame];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
    if (alpha == 1) {
      if (blend == base.MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (vertexAttachment.bones == null) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          deform[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case base.MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (vertexAttachment2.bones == null) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case base.MixBlend.first:
        case base.MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;
          }
          break;
        case base.MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
}
class EventTimeline {
  constructor(frameCount) {
    this.frames = base.Utils.newFloatArray(frameCount);
    this.events = new Array(frameCount);
  }
  getPropertyId() {
    return 7 /* event */ << 24;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the event for the specified key frame. */
  setFrame(frameIndex, event) {
    this.frames[frameIndex] = event.time;
    this.events[frameIndex] = event;
  }
  /** Fires events for frames > `lastTime` and <= `time`. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (firedEvents == null)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let frame = 0;
    if (lastTime < frames[0])
      frame = 0;
    else {
      frame = Animation.binarySearch(frames, lastTime);
      const frameTime = frames[frame];
      while (frame > 0) {
        if (frames[frame - 1] != frameTime)
          break;
        frame--;
      }
    }
    for (; frame < frameCount && time >= frames[frame]; frame++)
      firedEvents.push(this.events[frame]);
  }
}
class DrawOrderTimeline {
  constructor(frameCount) {
    this.frames = base.Utils.newFloatArray(frameCount);
    this.drawOrders = new Array(frameCount);
  }
  getPropertyId() {
    return 8 /* drawOrder */ << 24;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the draw order for the specified key frame.
   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
   *           draw order. */
  setFrame(frameIndex, time, drawOrder) {
    this.frames[frameIndex] = time;
    this.drawOrders[frameIndex] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const drawOrder = skeleton.drawOrder;
    const slots = skeleton.slots;
    if (direction == base.MixDirection.mixOut && blend == base.MixBlend.setup) {
      base.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        base.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    let frame = 0;
    if (time >= frames[frames.length - 1])
      frame = frames.length - 1;
    else
      frame = Animation.binarySearch(frames, time) - 1;
    const drawOrderToSetupIndex = this.drawOrders[frame];
    if (drawOrderToSetupIndex == null)
      base.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
    else {
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
}
const _IkConstraintTimeline = class extends CurveTimeline {
  // time, mix, softness, bendDirection, compress, stretch, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (9 /* ikConstraint */ << 24) + this.ikConstraintIndex;
  }
  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
  setFrame(frameIndex, time, mix, softness, bendDirection, compress, stretch) {
    frameIndex *= _IkConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;
    this.frames[frameIndex + _IkConstraintTimeline.SOFTNESS] = softness;
    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
    this.frames[frameIndex + _IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;
    this.frames[frameIndex + _IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.softness = constraint.data.softness;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case base.MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {
      if (blend == base.MixBlend.setup) {
        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
        constraint.softness = constraint.data.softness + (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;
        if (direction == base.MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
        constraint.softness += (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;
        if (direction == base.MixDirection.mixIn) {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);
    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];
    const softness = frames[frame + _IkConstraintTimeline.PREV_SOFTNESS];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));
    if (blend == base.MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
      constraint.softness = constraint.data.softness + (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;
      if (direction == base.MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    } else {
      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
      constraint.softness += (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;
      if (direction == base.MixDirection.mixIn) {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    }
  }
};
let IkConstraintTimeline = _IkConstraintTimeline;
IkConstraintTimeline.ENTRIES = 6;
IkConstraintTimeline.PREV_TIME = -6;
IkConstraintTimeline.PREV_MIX = -5;
IkConstraintTimeline.PREV_SOFTNESS = -4;
IkConstraintTimeline.PREV_BEND_DIRECTION = -3;
IkConstraintTimeline.PREV_COMPRESS = -2;
IkConstraintTimeline.PREV_STRETCH = -1;
IkConstraintTimeline.MIX = 1;
IkConstraintTimeline.SOFTNESS = 2;
IkConstraintTimeline.BEND_DIRECTION = 3;
IkConstraintTimeline.COMPRESS = 4;
IkConstraintTimeline.STRETCH = 5;
const _TransformConstraintTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, scale mix, shear mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (10 /* transformConstraint */ << 24) + this.transformConstraintIndex;
  }
  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
    frameIndex *= _TransformConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case base.MixBlend.setup:
          constraint.rotateMix = data.rotateMix;
          constraint.translateMix = data.translateMix;
          constraint.scaleMix = data.scaleMix;
          constraint.shearMix = data.shearMix;
          return;
        case base.MixBlend.first:
          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    let scale = 0;
    let shear = 0;
    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {
      const i = frames.length;
      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];
    } else {
      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);
      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _TransformConstraintTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;
      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;
      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;
    }
    if (blend == base.MixBlend.setup) {
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
      constraint.shearMix += (shear - constraint.shearMix) * alpha;
    }
  }
};
let TransformConstraintTimeline = _TransformConstraintTimeline;
TransformConstraintTimeline.ENTRIES = 5;
TransformConstraintTimeline.PREV_TIME = -5;
TransformConstraintTimeline.PREV_ROTATE = -4;
TransformConstraintTimeline.PREV_TRANSLATE = -3;
TransformConstraintTimeline.PREV_SCALE = -2;
TransformConstraintTimeline.PREV_SHEAR = -1;
TransformConstraintTimeline.ROTATE = 1;
TransformConstraintTimeline.TRANSLATE = 2;
TransformConstraintTimeline.SCALE = 3;
TransformConstraintTimeline.SHEAR = 4;
const _PathConstraintPositionTimeline = class extends CurveTimeline {
  // time, position, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);
  }
  getPropertyId() {
    return (11 /* pathConstraintPosition */ << 24) + this.pathConstraintIndex;
  }
  /** Sets the time in seconds and path constraint position for the specified key frame. */
  setFrame(frameIndex, time, value) {
    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case base.MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    let position = 0;
    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])
      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);
      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintPositionTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)
      );
      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;
    }
    if (blend == base.MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
};
let PathConstraintPositionTimeline = _PathConstraintPositionTimeline;
PathConstraintPositionTimeline.ENTRIES = 2;
PathConstraintPositionTimeline.PREV_TIME = -2;
PathConstraintPositionTimeline.PREV_VALUE = -1;
PathConstraintPositionTimeline.VALUE = 1;
class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (12 /* pathConstraintSpacing */ << 24) + this.pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case base.MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    let spacing = 0;
    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])
      spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
      spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / PathConstraintSpacingTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)
      );
      spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
    }
    if (blend == base.MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
}
const _PathConstraintMixTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = base.Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);
  }
  getPropertyId() {
    return (13 /* pathConstraintMix */ << 24) + this.pathConstraintIndex;
  }
  /** The time in seconds, rotate mix, and translate mix for the specified key frame. */
  setFrame(frameIndex, time, rotateMix, translateMix) {
    frameIndex *= _PathConstraintMixTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.rotateMix = constraint.data.rotateMix;
          constraint.translateMix = constraint.data.translateMix;
          return;
        case base.MixBlend.first:
          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {
      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];
    } else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);
      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintMixTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
    }
    if (blend == base.MixBlend.setup) {
      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
    }
  }
};
let PathConstraintMixTimeline = _PathConstraintMixTimeline;
PathConstraintMixTimeline.ENTRIES = 3;
PathConstraintMixTimeline.PREV_TIME = -3;
PathConstraintMixTimeline.PREV_ROTATE = -2;
PathConstraintMixTimeline.PREV_TRANSLATE = -1;
PathConstraintMixTimeline.ROTATE = 1;
PathConstraintMixTimeline.TRANSLATE = 2;

exports.Animation = Animation;
exports.AttachmentTimeline = AttachmentTimeline;
exports.ColorTimeline = ColorTimeline;
exports.CurveTimeline = CurveTimeline;
exports.DeformTimeline = DeformTimeline;
exports.DrawOrderTimeline = DrawOrderTimeline;
exports.EventTimeline = EventTimeline;
exports.IkConstraintTimeline = IkConstraintTimeline;
exports.PathConstraintMixTimeline = PathConstraintMixTimeline;
exports.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
exports.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
exports.RotateTimeline = RotateTimeline;
exports.ScaleTimeline = ScaleTimeline;
exports.ShearTimeline = ShearTimeline;
exports.TimelineType = TimelineType;
exports.TransformConstraintTimeline = TransformConstraintTimeline;
exports.TranslateTimeline = TranslateTimeline;
exports.TwoColorTimeline = TwoColorTimeline;
//# sourceMappingURL=Animation.js.map


/***/ }),

/***/ 91259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var Animation = __webpack_require__(93816);

const _AnimationState = class {
  constructor(data) {
    /** The list of tracks that currently have animations, which may contain null entries. */
    this.tracks = new Array();
    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
     * or faster. Defaults to 1.
     *
     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */
    this.timeScale = 1;
    this.unkeyedState = 0;
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new base.IntSet();
    this.animationsChanged = false;
    this.trackEntryPool = new base.Pool(() => new TrackEntry());
    this.data = data;
  }
  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next != null) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom != null) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
        tracks[i] = null;
        this.queue.end(current);
        this.disposeNext(current);
        continue;
      }
      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from != null)
          from.mixingTo = null;
        while (from != null) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  /** Returns true when all mixing from entries are complete. */
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (from == null)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom != null)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
   * animation state can be applied to multiple skeletons to pose them identically.
   * @returns True if any animations were applied. */
  apply(skeleton) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? base.MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom != null)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && current.next == null)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      const timelineCount = current.animation.timelines.length;
      const timelines = current.animation.timelines;
      if (i == 0 && mix == 1 || blend == base.MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          base.Utils.webkit602BugfixHelper(mix, blend);
          const timeline = timelines[ii];
          if (timeline instanceof Animation.AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
          else
            timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, base.MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const firstFrame = current.timelinesRotation.length == 0;
        if (firstFrame)
          base.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
        const timelinesRotation = current.timelinesRotation;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : base.MixBlend.setup;
          if (timeline instanceof Animation.RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
          } else if (timeline instanceof Animation.AttachmentTimeline) {
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
          } else {
            base.Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, base.MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    const setupState = this.unkeyedState + _AnimationState.SETUP;
    const slots = skeleton.slots;
    for (let i = 0, n = skeleton.slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.attachmentState == setupState) {
        const attachmentName = slot.data.attachmentName;
        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      }
    }
    this.unkeyedState += 2;
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom != null)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == base.MixBlend.first)
        blend = base.MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != base.MixBlend.first)
        blend = from.mixBlend;
    }
    const events = mix < from.eventThreshold ? this.events : null;
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    const timelineCount = from.animation.timelines.length;
    const timelines = from.animation.timelines;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    if (blend == base.MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, base.MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const firstFrame = from.timelinesRotation.length == 0;
      if (firstFrame)
        base.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
      const timelinesRotation = from.timelinesRotation;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = base.MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case _AnimationState.SUBSEQUENT:
            if (!drawOrder && timeline instanceof Animation.DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case _AnimationState.FIRST:
            timelineBlend = base.MixBlend.setup;
            alpha = alphaMix;
            break;
          case _AnimationState.HOLD_SUBSEQUENT:
            timelineBlend = blend;
            alpha = alphaHold;
            break;
          case _AnimationState.HOLD_FIRST:
            timelineBlend = base.MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = base.MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (timeline instanceof Animation.RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
        else if (timeline instanceof Animation.AttachmentTimeline)
          this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);
        else {
          base.Utils.webkit602BugfixHelper(alpha, blend);
          if (drawOrder && timeline instanceof Animation.DrawOrderTimeline && timelineBlend == base.MixBlend.setup)
            direction = base.MixDirection.mixIn;
          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {
    const slot = skeleton.slots[timeline.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = timeline.frames;
    if (time < frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
    } else {
      let frameIndex;
      if (time >= frames[frames.length - 1])
        frameIndex = frames.length - 1;
      else
        frameIndex = Animation.Animation.binarySearch(frames, time) - 1;
      this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
    }
    if (slot.attachmentState <= this.unkeyedState)
      slot.attachmentState = this.unkeyedState + _AnimationState.SETUP;
  }
  setAttachment(skeleton, slot, attachmentName, attachments) {
    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
    if (attachments)
      slot.attachmentState = this.unkeyedState + _AnimationState.CURRENT;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, base.MixDirection.mixIn);
      return;
    }
    const rotateTimeline = timeline;
    const frames = rotateTimeline.frames;
    const bone = skeleton.bones[rotateTimeline.boneIndex];
    if (!bone.active)
      return;
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case base.MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == base.MixBlend.setup ? bone.data.rotation : bone.rotation;
      if (time >= frames[frames.length - Animation.RotateTimeline.ENTRIES])
        r2 = bone.data.rotation + frames[frames.length + Animation.RotateTimeline.PREV_ROTATION];
      else {
        const frame = Animation.Animation.binarySearch(frames, time, Animation.RotateTimeline.ENTRIES);
        const prevRotation = frames[frame + Animation.RotateTimeline.PREV_ROTATION];
        const frameTime = frames[frame];
        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + Animation.RotateTimeline.PREV_TIME] - frameTime));
        r2 = frames[frame + Animation.RotateTimeline.ROTATION] - prevRotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        r2 = prevRotation + r2 * percent + bone.data.rotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
      }
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (base.MathUtils.signum(lastDiff) != base.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * base.MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * base.MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    r1 += total * alpha;
    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, events[i]);
    }
  }
  /** Removes all animations from all tracks, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  /** Removes all animations from the track, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (current == null)
      return;
    this.queue.end(current);
    this.disposeNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (from == null)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    if (from != null) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom != null && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  /** Sets an animation by name.
   *
   * {@link #setAnimationWith(}. */
  setAnimation(trackIndex, animationName, loop) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
   * applied to a skeleton, it is replaced (not mixed from).
   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  setAnimationWith(trackIndex, animation, loop) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current != null) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.disposeNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.disposeNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  /** Queues an animation by name.
   *
   * See {@link #addAnimationWith()}. */
  addAnimation(trackIndex, animationName, loop, delay) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
   * equivalent to calling {@link #setAnimationWith()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
   *           previous entry is looping, its next loop completion is used instead of its duration.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addAnimationWith(trackIndex, animation, loop, delay) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last != null) {
      while (last.next != null)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (last == null) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      if (delay <= 0) {
        const duration = last.animationEnd - last.animationStart;
        if (duration != 0) {
          if (last.loop)
            delay += duration * (1 + (last.trackTime / duration | 0));
          else
            delay += Math.max(duration, last.trackTime);
          delay -= this.data.getMix(last.animation, animation);
        } else
          delay = last.trackTime;
      }
    }
    entry.delay = delay;
    return entry;
  }
  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
   *
   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
   * 0 still mixes out over one frame.
   *
   * Mixing in is done by first setting an empty animation, then adding an animation using
   * {@link #addAnimation()} and on the returned track entry, set the
   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
  setEmptyAnimation(trackIndex, mixDuration) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
   * {@link #setEmptyAnimation()}.
   *
   * See {@link #setEmptyAnimation()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
   *           loop completion is used instead of its duration.
   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addEmptyAnimation(trackIndex, mixDuration, delay) {
    if (delay <= 0)
      delay -= mixDuration;
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
   * duration. */
  setEmptyAnimations(mixDuration) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current != null)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    base.Utils.ensureArrayCapacity(this.tracks, index + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  /** @param last May be null. */
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.interruptAlpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
    entry.mixBlend = base.MixBlend.replace;
    return entry;
  }
  disposeNext(entry) {
    let next = entry.next;
    while (next != null) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      let entry = this.tracks[i];
      if (entry == null)
        continue;
      while (entry.mixingFrom != null)
        entry = entry.mixingFrom;
      do {
        if (entry.mixingFrom == null || entry.mixBlend != base.MixBlend.add)
          this.computeHold(entry);
        entry = entry.mixingTo;
      } while (entry != null);
    }
  }
  computeHold(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = base.Utils.setArraySize(entry.timelineMode, timelinesCount);
    entry.timelineHoldMix.length = 0;
    const timelineDipMix = base.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
    const propertyIDs = this.propertyIDs;
    if (to != null && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++) {
        timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? _AnimationState.HOLD_FIRST : _AnimationState.HOLD_SUBSEQUENT;
      }
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const timeline = timelines[i];
        const id = timeline.getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = _AnimationState.SUBSEQUENT;
        else if (to == null || timeline instanceof Animation.AttachmentTimeline || timeline instanceof Animation.DrawOrderTimeline || timeline instanceof Animation.EventTimeline || !to.animation.hasTimeline(id)) {
          timelineMode[i] = _AnimationState.FIRST;
        } else {
          for (let next = to.mixingTo; next != null; next = next.mixingTo) {
            if (next.animation.hasTimeline(id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = _AnimationState.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = _AnimationState.HOLD_FIRST;
        }
      }
  }
  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  /** Adds a listener to receive events for all track entries. */
  addListener(listener) {
    if (listener == null)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener()}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  /** Removes all listeners added with {@link #addListener()}. */
  clearListeners() {
    this.listeners.length = 0;
  }
  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
   * are not wanted because new animations are being set. */
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
let AnimationState = _AnimationState;
AnimationState.emptyAnimation = new Animation.Animation("<empty>", [], 0);
/** 1. A previously applied timeline has set this property.
 *
 * Result: Mix from the current pose to the timeline pose. */
AnimationState.SUBSEQUENT = 0;
/** 1. This is the first timeline to set this property.
 * 2. The next track entry applied after this one does not have a timeline to set this property.
 *
 * Result: Mix from the setup pose to the timeline pose. */
AnimationState.FIRST = 1;
/** 1) A previously applied timeline has set this property.<br>
 * 2) The next track entry to be applied does have a timeline to set this property.<br>
 * 3) The next track entry after that one does not have a timeline to set this property.<br>
 * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids "dipping" when crossfading
 * animations that key the same property. A subsequent timeline will set this property using a mix. */
AnimationState.HOLD_SUBSEQUENT = 2;
/** 1) This is the first timeline to set this property.<br>
 * 2) The next track entry to be applied does have a timeline to set this property.<br>
 * 3) The next track entry after that one does not have a timeline to set this property.<br>
 * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids "dipping" when crossfading animations
 * that key the same property. A subsequent timeline will set this property using a mix. */
AnimationState.HOLD_FIRST = 3;
/** 1. This is the first timeline to set this property.
 * 2. The next track entry to be applied does have a timeline to set this property.
 * 3. The next track entry after that one does have a timeline to set this property.
 * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.
 *
 * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than
 * 2 track entries in a row have a timeline that sets the same property.
 *
 * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid
 * "dipping" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A
 * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into
 * place. */
AnimationState.HOLD_MIX = 4;
AnimationState.SETUP = 1;
AnimationState.CURRENT = 2;
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
const _TrackEntry = class {
  constructor() {
    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which
     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to
     * the values from the lower tracks.
     *
     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first
     * called. */
    this.mixBlend = base.MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
   * `animationStart` time. */
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  /** Returns true if at least one loop has been completed.
   *
   * See {@link AnimationStateListener#complete()}. */
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
   * long way around when using {@link #alpha} and starting animations on other tracks.
   *
   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
let TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
const _EventQueue = class {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  deprecateStuff() {
    if (!_EventQueue.deprecatedWarning1) {
      _EventQueue.deprecatedWarning1 = true;
      console.warn(
        "Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'"
      );
    }
    return true;
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener != null && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].start)
              listeners[ii].start(entry);
          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
          break;
        case EventType.interrupt:
          if (entry.listener != null && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].interrupt)
              listeners[ii].interrupt(entry);
          break;
        case EventType.end:
          if (entry.listener != null && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].end)
              listeners[ii].end(entry);
          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
        case EventType.dispose:
          if (entry.listener != null && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].dispose)
              listeners[ii].dispose(entry);
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener != null && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].complete)
              listeners[ii].complete(entry);
          const count = base.MathUtils.toInt(entry.loopsCount());
          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener != null && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].event)
              listeners[ii].event(entry, event);
          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);
          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
};
let EventQueue = _EventQueue;
EventQueue.deprecatedWarning1 = false;
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
  return EventType2;
})(EventType || {});
class AnimationStateAdapter {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
}

exports.AnimationState = AnimationState;
exports.AnimationStateAdapter = AnimationStateAdapter;
exports.EventQueue = EventQueue;
exports.EventType = EventType;
exports.TrackEntry = TrackEntry;
//# sourceMappingURL=AnimationState.js.map


/***/ }),

/***/ 16963:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const _AnimationStateData = class {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    this.defaultMix = 0;
    if (skeletonData == null)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (from == null)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (to == null)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  setMixByName(fromName, toName, duration) {
    if (!_AnimationStateData.deprecatedWarning1) {
      _AnimationStateData.deprecatedWarning1 = true;
      console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
    }
    this.setMix(fromName, toName, duration);
  }
  setMixWith(from, to, duration) {
    if (from == null)
      throw new Error("from cannot be null.");
    if (to == null)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
};
let AnimationStateData = _AnimationStateData;
AnimationStateData.deprecatedWarning1 = false;

exports.AnimationStateData = AnimationStateData;
//# sourceMappingURL=AnimationStateData.js.map


/***/ }),

/***/ 39371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(76678);
var BoundingBoxAttachment = __webpack_require__(10299);
var ClippingAttachment = __webpack_require__(20704);
var MeshAttachment = __webpack_require__(95887);
var PathAttachment = __webpack_require__(24229);
var PointAttachment = __webpack_require__(1632);
var RegionAttachment = __webpack_require__(95762);

class AtlasAttachmentLoader {
  constructor(atlas) {
    this.atlas = atlas;
  }
  /** @return May be null to not load an attachment. */
  newRegionAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
    const attachment = new RegionAttachment.RegionAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newMeshAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
    const attachment = new MeshAttachment.MeshAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newBoundingBoxAttachment(skin, name) {
    return new BoundingBoxAttachment.BoundingBoxAttachment(name);
  }
  /** @return May be null to not load an attachment */
  newPathAttachment(skin, name) {
    return new PathAttachment.PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new PointAttachment.PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new ClippingAttachment.ClippingAttachment(name);
  }
}

exports.AtlasAttachmentLoader = AtlasAttachmentLoader;
//# sourceMappingURL=AtlasAttachmentLoader.js.map


/***/ }),

/***/ 98522:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var base = __webpack_require__(55075);

class Bone {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    // be careful! Spine b,c is c,b in pixi matrix
    this.matrix = new core.Matrix();
    this.children = new Array();
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 0;
    this.scaleY = 0;
    this.shearX = 0;
    this.shearY = 0;
    this.ax = 0;
    this.ay = 0;
    this.arotation = 0;
    this.ascaleX = 0;
    this.ascaleY = 0;
    this.ashearX = 0;
    this.ashearY = 0;
    this.appliedValid = false;
    this.sorted = false;
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  isActive() {
    return this.active;
  }
  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */
  update() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = base.settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (parent == null) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = base.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = base.MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = base.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = base.MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case base.TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = base.MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = base.MathUtils.cosDeg(rotationY) * scaleY;
        const lc = base.MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = base.MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case base.TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = base.MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = base.MathUtils.cosDeg(rotationY) * scaleY;
        m.b = base.MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = base.MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case base.TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pa /= this.skeleton.scaleX;
          pc /= this.skeleton.scaleY;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * base.MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * base.MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = base.MathUtils.cosDeg(rx) * scaleX;
        const lb = base.MathUtils.cosDeg(ry) * scaleY;
        const lc = base.MathUtils.sinDeg(rx) * scaleX;
        const ld = base.MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case base.TransformMode.NoScale:
      case base.TransformMode.NoScaleOrReflection: {
        const cos = base.MathUtils.cosDeg(rotation);
        const sin = base.MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == base.TransformMode.NoScale && pa * pd - pb * pc < 0 != (base.settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = base.MathUtils.cosDeg(shearX) * scaleX;
        const lb = base.MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = base.MathUtils.sinDeg(shearX) * scaleX;
        const ld = base.MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * base.MathUtils.radDeg;
  }
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * base.MathUtils.radDeg;
  }
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.c * m.c);
  }
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.b * m.b + m.d * m.d);
  }
  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using
   * the applied transform after the world transform has been modified directly (eg, by a constraint).
   * <p>
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */
  updateAppliedTransform() {
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    if (parent == null) {
      this.ax = m.tx;
      this.ay = m.ty;
      this.arotation = Math.atan2(m.b, m.a) * base.MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * base.MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * base.MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * base.MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * base.MathUtils.radDeg;
    }
  }
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  worldToLocalRotation(worldRotation) {
    const sin = base.MathUtils.sinDeg(worldRotation);
    const cos = base.MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * base.MathUtils.radDeg;
  }
  localToWorldRotation(localRotation) {
    const sin = base.MathUtils.sinDeg(localRotation);
    const cos = base.MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * base.MathUtils.radDeg;
  }
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = base.MathUtils.cosDeg(degrees);
    const sin = base.MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
    this.appliedValid = false;
  }
}

exports.Bone = Bone;
//# sourceMappingURL=Bone.js.map


/***/ }),

/***/ 2426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class BoneData {
  constructor(index, name, parent) {
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.shearX = 0;
    this.shearY = 0;
    this.transformMode = base.TransformMode.Normal;
    this.skinRequired = false;
    this.color = new base.Color();
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
}

exports.BoneData = BoneData;
//# sourceMappingURL=BoneData.js.map


/***/ }),

/***/ 55119:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class ConstraintData {
  constructor(name, order, skinRequired) {
    this.name = name;
    this.order = order;
    this.skinRequired = skinRequired;
  }
}

exports.ConstraintData = ConstraintData;
//# sourceMappingURL=Constraint.js.map


/***/ }),

/***/ 4370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class Event {
  constructor(time, data) {
    if (data == null)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
}

exports.Event = Event;
//# sourceMappingURL=Event.js.map


/***/ }),

/***/ 8242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class EventData {
  constructor(name) {
    this.name = name;
  }
}

exports.EventData = EventData;
//# sourceMappingURL=EventData.js.map


/***/ }),

/***/ 13291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class IkConstraint {
  constructor(data, skeleton) {
    this.bendDirection = 0;
    this.compress = false;
    this.stretch = false;
    this.mix = 1;
    this.softness = 0;
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.softness = data.softness;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
        break;
    }
  }
  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
   * coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    if (!bone.appliedValid)
      bone.updateAppliedTransform();
    const p = bone.parent.matrix;
    const pa = p.a;
    let pb = p.c;
    const pc = p.b;
    let pd = p.d;
    let rotationIK = -bone.ashearX - bone.arotation;
    let tx = 0;
    let ty = 0;
    switch (bone.data.transformMode) {
      case base.TransformMode.OnlyTranslation:
        tx = targetX - bone.worldX;
        ty = targetY - bone.worldY;
        break;
      case base.TransformMode.NoRotationOrReflection:
        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
        const sa = pa / bone.skeleton.scaleX;
        const sc = pc / bone.skeleton.scaleY;
        pb = -sc * s * bone.skeleton.scaleX;
        pd = sa * s * bone.skeleton.scaleY;
        rotationIK += Math.atan2(sc, sa) * base.MathUtils.radDeg;
      default:
        const x = targetX - p.tx;
        const y = targetY - p.ty;
        const d = pa * pd - pb * pc;
        tx = (x * pd - y * pb) / d - bone.ax;
        ty = (y * pa - x * pc) / d - bone.ay;
    }
    rotationIK += Math.atan2(ty, tx) * base.MathUtils.radDeg;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      switch (bone.data.transformMode) {
        case base.TransformMode.NoScale:
        case base.TransformMode.NoScaleOrReflection:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
      }
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
   * target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
    if (alpha == 0) {
      child.updateWorldTransform();
      return;
    }
    if (!parent.appliedValid)
      parent.updateAppliedTransform();
    if (!child.appliedValid)
      child.updateAppliedTransform();
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let sx = psx;
    let psy = parent.ascaleY;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = cwx - pp.tx;
    let y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1;
    let a2;
    if (l1 < 1e-4) {
      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
      return;
    }
    x = targetX - pp.tx;
    y = targetY - pp.ty;
    let tx = (x * d - y * b) * id - px;
    let ty = (y * a - x * c) * id - py;
    let dd = tx * tx + ty * ty;
    if (softness != 0) {
      softness *= psx * (csx + 1) / 2;
      const td = Math.sqrt(dd);
      const sd = td - l1 - l2 * psx + softness;
      if (sd > 0) {
        let p = Math.min(1, sd / (softness * 2)) - 1;
        p = (sd - softness * (1 - p * p)) / td;
        tx -= p * tx;
        ty -= p * ty;
        dd = tx * tx + ty * ty;
      }
    }
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = base.MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * base.MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * base.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
}

exports.IkConstraint = IkConstraint;
//# sourceMappingURL=IkConstraint.js.map


/***/ }),

/***/ 48275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Constraint = __webpack_require__(55119);

class IkConstraintData extends Constraint.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this.bendDirection = 1;
    this.compress = false;
    this.stretch = false;
    this.uniform = false;
    this.mix = 1;
    this.softness = 0;
  }
}

exports.IkConstraintData = IkConstraintData;
//# sourceMappingURL=IkConstraintData.js.map


/***/ }),

/***/ 96112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(76678);
var base = __webpack_require__(55075);
var PathAttachment = __webpack_require__(24229);
__webpack_require__(95762);
var PathConstraintData = __webpack_require__(27992);

const _PathConstraint = class {
  constructor(data, skeleton) {
    this.position = 0;
    this.spacing = 0;
    this.rotateMix = 0;
    this.translateMix = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findSlot(data.target.name);
    this.position = data.position;
    this.spacing = data.spacing;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof PathAttachment.PathAttachment))
      return;
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const translate = translateMix > 0;
    const rotate = rotateMix > 0;
    if (!translate && !rotate)
      return;
    const data = this.data;
    const spacingMode = data.spacingMode;
    const lengthSpacing = spacingMode == PathConstraintData.SpacingMode.Length;
    const rotateMode = data.rotateMode;
    const tangents = rotateMode == base.RotateMode.Tangent;
    const scale = rotateMode == base.RotateMode.ChainScale;
    const boneCount = this.bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const bones = this.bones;
    const spaces = base.Utils.setArraySize(this.spaces, spacesCount);
    let lengths = null;
    const spacing = this.spacing;
    if (scale || lengthSpacing) {
      if (scale)
        lengths = base.Utils.setArraySize(this.lengths, boneCount);
      for (let i = 0, n = spacesCount - 1; i < n; ) {
        const bone = bones[i];
        const setupLength = bone.data.length;
        if (setupLength < _PathConstraint.epsilon) {
          if (scale)
            lengths[i] = 0;
          spaces[++i] = 0;
        } else {
          const x = setupLength * bone.matrix.a;
          const y = setupLength * bone.matrix.b;
          const length = Math.sqrt(x * x + y * y);
          if (scale)
            lengths[i] = length;
          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
        }
      }
    } else {
      for (let i = 1; i < spacesCount; i++)
        spaces[i] = spacing;
    }
    const positions = this.computeWorldPositions(
      attachment,
      spacesCount,
      tangents,
      data.positionMode == base.PositionMode.Percent,
      spacingMode == PathConstraintData.SpacingMode.Percent
    );
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = rotateMode == base.RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * translateMix;
      mat.ty += (boneY - mat.ty) * translateMix;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (rotate) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;
          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;
        } else {
          r += offsetRotation;
        }
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= rotateMix;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.appliedValid = false;
    }
  }
  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = base.Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = null;
    const closed = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (percentPosition)
        position *= pathLength2;
      if (percentSpacing) {
        for (let i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength2;
      }
      world = base.Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i];
        position += space;
        let p = position;
        if (closed) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed) {
      verticesLength += 2;
      world = base.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = base.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = base.Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (percentPosition)
      position *= pathLength;
    if (percentSpacing) {
      for (let i = 0; i < spacesCount; i++)
        spaces[i] *= pathLength;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i];
      position += space;
      let p = position;
      if (closed) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p))
      p = 1e-4;
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents)
      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
  }
};
let PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;

exports.PathConstraint = PathConstraint;
//# sourceMappingURL=PathConstraint.js.map


/***/ }),

/***/ 27992:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Constraint = __webpack_require__(55119);

class PathConstraintData extends Constraint.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
  }
}
var SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  return SpacingMode2;
})(SpacingMode || {});

exports.PathConstraintData = PathConstraintData;
exports.SpacingMode = SpacingMode;
//# sourceMappingURL=PathConstraintData.js.map


/***/ }),

/***/ 40443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(76678);
var base = __webpack_require__(55075);
var MeshAttachment = __webpack_require__(95887);
var PathAttachment = __webpack_require__(24229);
var RegionAttachment = __webpack_require__(95762);
var Bone = __webpack_require__(98522);
var Slot = __webpack_require__(70460);
var IkConstraint = __webpack_require__(13291);
var TransformConstraint = __webpack_require__(90653);
var PathConstraint = __webpack_require__(96112);

const _Skeleton = class {
  constructor(data) {
    this._updateCache = new Array();
    this.updateCacheReset = new Array();
    this.time = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    if (data == null)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (boneData.parent == null)
        bone = new Bone.Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new Bone.Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new Slot.Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new IkConstraint.IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new TransformConstraint.TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new PathConstraint.PathConstraint(pathConstraintData, this));
    }
    this.color = new base.Color(1, 1, 1, 1);
    this.updateCache();
  }
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    this.updateCacheReset.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.sorted = bone.data.skinRequired;
      bone.active = !bone.sorted;
    }
    if (this.skin != null) {
      const skinBones = this.skin.bones;
      for (let i = 0, n = this.skin.bones.length; i < n; i++) {
        let bone = this.bones[skinBones[i].index];
        do {
          bone.sorted = false;
          bone.active = true;
          bone = bone.parent;
        } while (bone != null);
      }
    }
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && base.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length > 1) {
      const child = constrained[constrained.length - 1];
      if (!(this._updateCache.indexOf(child) > -1))
        this.updateCacheReset.push(child);
    }
    this._updateCache.push(constraint);
    this.sortReset(parent.children);
    constrained[constrained.length - 1].sorted = true;
  }
  sortPathConstraint(constraint) {
    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && base.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin != null)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof PathAttachment.PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && base.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let ii = 0; ii < boneCount; ii++)
      this.sortReset(constrained[ii].children);
    for (let ii = 0; ii < boneCount; ii++)
      constrained[ii].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof PathAttachment.PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (pathBones == null)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      let i = 0;
      while (i < pathBones.length) {
        const boneCount = pathBones[i++];
        for (let n = i + boneCount; i < n; i++) {
          const boneIndex = pathBones[i];
          this.sortBone(bones[boneIndex]);
        }
      }
    }
  }
  sortBone(bone) {
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent != null)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.active)
        continue;
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies constraints. */
  updateWorldTransform() {
    const updateCacheReset = this.updateCacheReset;
    for (let i = 0, n = updateCacheReset.length; i < n; i++) {
      const bone = updateCacheReset[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
      bone.appliedValid = true;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.mix = constraint.data.mix;
      constraint.softness = constraint.data.softness;
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.compress = constraint.data.compress;
      constraint.stretch = constraint.data.stretch;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
      constraint.scaleMix = data.scaleMix;
      constraint.shearMix = data.shearMix;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
    }
  }
  setSlotsToSetupPose() {
    const slots = this.slots;
    base.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @return May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @return May be null. */
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** @return May be null. */
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   * @see #setSkin(Skin) */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (skin == null)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin == this.skin)
      return;
    if (newSkin != null) {
      if (this.skin != null)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name != null) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment != null)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
    this.updateCache();
  }
  /** @return May be null. */
  getAttachmentByName(slotName, attachmentName) {
    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
  }
  /** @return May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (attachmentName == null)
      throw new Error("attachmentName cannot be null.");
    if (this.skin != null) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment != null)
        return attachment;
    }
    if (this.data.defaultSkin != null)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** @param attachmentName May be null. */
  setAttachment(slotName, attachmentName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName != null) {
          attachment = this.getAttachment(i, attachmentName);
          if (attachment == null)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** @return May be null. */
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** @return May be null. */
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** @return May be null. */
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size The width and height of the AABB.
   * @param temp Working memory */
  getBounds(offset, size, temp = new Array(2)) {
    if (offset == null)
      throw new Error("offset cannot be null.");
    if (size == null)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      if (!slot.bone.active)
        continue;
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof RegionAttachment.RegionAttachment) {
        verticesLength = 8;
        vertices = base.Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
      } else if (attachment instanceof MeshAttachment.MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = base.Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices != null) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  update(delta) {
    this.time += delta;
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
let Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;

exports.Skeleton = Skeleton;
//# sourceMappingURL=Skeleton.js.map


/***/ }),

/***/ 71762:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Event = __webpack_require__(4370);
var SkeletonData = __webpack_require__(55459);
var SlotData = __webpack_require__(76292);
var BoneData = __webpack_require__(2426);
var IkConstraintData = __webpack_require__(48275);
var TransformConstraintData = __webpack_require__(40765);
var PathConstraintData = __webpack_require__(27992);
var Skin = __webpack_require__(56549);
var EventData = __webpack_require__(8242);
var Animation = __webpack_require__(93816);
var base = __webpack_require__(55075);
var core = __webpack_require__(11491);

const _SkeletonBinary = class {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(binary) {
    const scale = this.scale;
    const skeletonData = new SkeletonData.SkeletonData();
    skeletonData.name = "";
    const input = new base.BinaryInput(binary);
    skeletonData.hash = input.readString();
    skeletonData.version = input.readString();
    if (skeletonData.version === "3.8.75") {
      const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;
      console.error(error);
    }
    skeletonData.x = input.readFloat();
    skeletonData.y = input.readFloat();
    skeletonData.width = input.readFloat();
    skeletonData.height = input.readFloat();
    const nonessential = input.readBoolean();
    if (nonessential) {
      skeletonData.fps = input.readFloat();
      skeletonData.imagesPath = input.readString();
      skeletonData.audioPath = input.readString();
    }
    let n = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++)
      input.strings.push(input.readString());
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const name = input.readString();
      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];
      const data = new BoneData.BoneData(i, name, parent);
      data.rotation = input.readFloat();
      data.x = input.readFloat() * scale;
      data.y = input.readFloat() * scale;
      data.scaleX = input.readFloat();
      data.scaleY = input.readFloat();
      data.shearX = input.readFloat();
      data.shearY = input.readFloat();
      data.length = input.readFloat() * scale;
      data.transformMode = _SkeletonBinary.TransformModeValues[input.readInt(true)];
      data.skinRequired = input.readBoolean();
      if (nonessential)
        base.Color.rgba8888ToColor(data.color, input.readInt32());
      skeletonData.bones.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const slotName = input.readString();
      const boneData = skeletonData.bones[input.readInt(true)];
      const data = new SlotData.SlotData(i, slotName, boneData);
      base.Color.rgba8888ToColor(data.color, input.readInt32());
      const darkColor = input.readInt32();
      if (darkColor != -1)
        base.Color.rgb888ToColor(data.darkColor = new base.Color(), darkColor);
      data.attachmentName = input.readStringRef();
      data.blendMode = _SkeletonBinary.BlendModeValues[input.readInt(true)];
      skeletonData.slots.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new IkConstraintData.IkConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.mix = input.readFloat();
      data.softness = input.readFloat() * scale;
      data.bendDirection = input.readByte();
      data.compress = input.readBoolean();
      data.stretch = input.readBoolean();
      data.uniform = input.readBoolean();
      skeletonData.ikConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new TransformConstraintData.TransformConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.local = input.readBoolean();
      data.relative = input.readBoolean();
      data.offsetRotation = input.readFloat();
      data.offsetX = input.readFloat() * scale;
      data.offsetY = input.readFloat() * scale;
      data.offsetScaleX = input.readFloat();
      data.offsetScaleY = input.readFloat();
      data.offsetShearY = input.readFloat();
      data.rotateMix = input.readFloat();
      data.translateMix = input.readFloat();
      data.scaleMix = input.readFloat();
      data.shearMix = input.readFloat();
      skeletonData.transformConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new PathConstraintData.PathConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.slots[input.readInt(true)];
      data.positionMode = _SkeletonBinary.PositionModeValues[input.readInt(true)];
      data.spacingMode = _SkeletonBinary.SpacingModeValues[input.readInt(true)];
      data.rotateMode = _SkeletonBinary.RotateModeValues[input.readInt(true)];
      data.offsetRotation = input.readFloat();
      data.position = input.readFloat();
      if (data.positionMode == base.PositionMode.Fixed)
        data.position *= scale;
      data.spacing = input.readFloat();
      if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
        data.spacing *= scale;
      data.rotateMix = input.readFloat();
      data.translateMix = input.readFloat();
      skeletonData.pathConstraints.push(data);
    }
    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
    if (defaultSkin != null) {
      skeletonData.defaultSkin = defaultSkin;
      skeletonData.skins.push(defaultSkin);
    }
    {
      let i = skeletonData.skins.length;
      base.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
      for (; i < n; i++)
        skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);
    }
    n = this.linkedMeshes.length;
    for (let i = 0; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const data = new EventData.EventData(input.readStringRef());
      data.intValue = input.readInt(false);
      data.floatValue = input.readFloat();
      data.stringValue = input.readString();
      data.audioPath = input.readString();
      if (data.audioPath != null) {
        data.volume = input.readFloat();
        data.balance = input.readFloat();
      }
      skeletonData.events.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++)
      skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));
    return skeletonData;
  }
  readSkin(input, skeletonData, defaultSkin, nonessential) {
    let skin = null;
    let slotCount = 0;
    if (defaultSkin) {
      slotCount = input.readInt(true);
      if (slotCount == 0)
        return null;
      skin = new Skin.Skin("default");
    } else {
      skin = new Skin.Skin(input.readStringRef());
      skin.bones.length = input.readInt(true);
      for (let i = 0, n = skin.bones.length; i < n; i++)
        skin.bones[i] = skeletonData.bones[input.readInt(true)];
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
      slotCount = input.readInt(true);
    }
    for (let i = 0; i < slotCount; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const name = input.readStringRef();
        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
        if (attachment != null)
          skin.setAttachment(slotIndex, name, attachment);
      }
    }
    return skin;
  }
  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
    const scale = this.scale;
    let name = input.readStringRef();
    if (name == null)
      name = attachmentName;
    const typeIndex = input.readByte();
    const type = _SkeletonBinary.AttachmentTypeValues[typeIndex];
    switch (type) {
      case base.AttachmentType.Region: {
        let path = input.readStringRef();
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const scaleX = input.readFloat();
        const scaleY = input.readFloat();
        const width = input.readFloat();
        const height = input.readFloat();
        const color = input.readInt32();
        if (path == null)
          path = name;
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = x * scale;
        region.y = y * scale;
        region.scaleX = scaleX;
        region.scaleY = scaleY;
        region.rotation = rotation;
        region.width = width * scale;
        region.height = height * scale;
        base.Color.rgba8888ToColor(region.color, color);
        return region;
      }
      case base.AttachmentType.BoundingBox: {
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        box.worldVerticesLength = vertexCount << 1;
        box.vertices = vertices.vertices;
        box.bones = vertices.bones;
        if (nonessential)
          base.Color.rgba8888ToColor(box.color, color);
        return box;
      }
      case base.AttachmentType.Mesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const vertexCount = input.readInt(true);
        const uvs = this.readFloatArray(input, vertexCount << 1, 1);
        const triangles = this.readShortArray(input);
        const vertices = this.readVertices(input, vertexCount);
        const hullLength = input.readInt(true);
        let edges = null;
        let width = 0;
        let height = 0;
        if (nonessential) {
          edges = this.readShortArray(input);
          width = input.readFloat();
          height = input.readFloat();
        }
        if (path == null)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        base.Color.rgba8888ToColor(mesh.color, color);
        mesh.bones = vertices.bones;
        mesh.vertices = vertices.vertices;
        mesh.worldVerticesLength = vertexCount << 1;
        mesh.triangles = triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = hullLength << 1;
        if (nonessential) {
          mesh.edges = edges;
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        return mesh;
      }
      case base.AttachmentType.LinkedMesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const skinName = input.readStringRef();
        const parent = input.readStringRef();
        const inheritDeform = input.readBoolean();
        let width = 0;
        let height = 0;
        if (nonessential) {
          width = input.readFloat();
          height = input.readFloat();
        }
        if (path == null)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        base.Color.rgba8888ToColor(mesh.color, color);
        if (nonessential) {
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));
        return mesh;
      }
      case base.AttachmentType.Path: {
        const closed = input.readBoolean();
        const constantSpeed = input.readBoolean();
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const lengths = base.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0, n = lengths.length; i < n; i++)
          lengths[i] = input.readFloat() * scale;
        const color = nonessential ? input.readInt32() : 0;
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = closed;
        path.constantSpeed = constantSpeed;
        path.worldVerticesLength = vertexCount << 1;
        path.vertices = vertices.vertices;
        path.bones = vertices.bones;
        path.lengths = lengths;
        if (nonessential)
          base.Color.rgba8888ToColor(path.color, color);
        return path;
      }
      case base.AttachmentType.Point: {
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const color = nonessential ? input.readInt32() : 0;
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = x * scale;
        point.y = y * scale;
        point.rotation = rotation;
        if (nonessential)
          base.Color.rgba8888ToColor(point.color, color);
        return point;
      }
      case base.AttachmentType.Clipping: {
        const endSlotIndex = input.readInt(true);
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        clip.endSlot = skeletonData.slots[endSlotIndex];
        clip.worldVerticesLength = vertexCount << 1;
        clip.vertices = vertices.vertices;
        clip.bones = vertices.bones;
        if (nonessential)
          base.Color.rgba8888ToColor(clip.color, color);
        return clip;
      }
    }
    return null;
  }
  readVertices(input, vertexCount) {
    const verticesLength = vertexCount << 1;
    const vertices = new Vertices();
    const scale = this.scale;
    if (!input.readBoolean()) {
      vertices.vertices = this.readFloatArray(input, verticesLength, scale);
      return vertices;
    }
    const weights = new Array();
    const bonesArray = new Array();
    for (let i = 0; i < vertexCount; i++) {
      const boneCount = input.readInt(true);
      bonesArray.push(boneCount);
      for (let ii = 0; ii < boneCount; ii++) {
        bonesArray.push(input.readInt(true));
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat());
      }
    }
    vertices.vertices = base.Utils.toFloatArray(weights);
    vertices.bones = bonesArray;
    return vertices;
  }
  readFloatArray(input, n, scale) {
    const array = new Array(n);
    if (scale == 1) {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat();
    } else {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat() * scale;
    }
    return array;
  }
  readShortArray(input) {
    const n = input.readInt(true);
    const array = new Array(n);
    for (let i = 0; i < n; i++)
      array[i] = input.readShort();
    return array;
  }
  readAnimation(input, name, skeletonData) {
    const timelines = new Array();
    const scale = this.scale;
    let duration = 0;
    const tempColor1 = new base.Color();
    const tempColor2 = new base.Color();
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.SLOT_ATTACHMENT: {
            const timeline = new Animation.AttachmentTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++)
              timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[frameCount - 1]);
            break;
          }
          case _SkeletonBinary.SLOT_COLOR: {
            const timeline = new Animation.ColorTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              const time = input.readFloat();
              base.Color.rgba8888ToColor(tempColor1, input.readInt32());
              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.ColorTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.SLOT_TWO_COLOR: {
            const timeline = new Animation.TwoColorTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              const time = input.readFloat();
              base.Color.rgba8888ToColor(tempColor1, input.readInt32());
              base.Color.rgb888ToColor(tempColor2, input.readInt32());
              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.TwoColorTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const boneIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.BONE_ROTATE: {
            const timeline = new Animation.RotateTimeline(frameCount);
            timeline.boneIndex = boneIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.RotateTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.BONE_TRANSLATE:
          case _SkeletonBinary.BONE_SCALE:
          case _SkeletonBinary.BONE_SHEAR: {
            let timeline;
            let timelineScale = 1;
            if (timelineType == _SkeletonBinary.BONE_SCALE)
              timeline = new Animation.ScaleTimeline(frameCount);
            else if (timelineType == _SkeletonBinary.BONE_SHEAR)
              timeline = new Animation.ShearTimeline(frameCount);
            else {
              timeline = new Animation.TranslateTimeline(frameCount);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.TranslateTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const timeline = new Animation.IkConstraintTimeline(frameCount);
      timeline.ikConstraintIndex = index;
      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());
        if (frameIndex < frameCount - 1)
          this.readCurve(input, frameIndex, timeline);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.IkConstraintTimeline.ENTRIES]);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const timeline = new Animation.TransformConstraintTimeline(frameCount);
      timeline.transformConstraintIndex = index;
      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
        if (frameIndex < frameCount - 1)
          this.readCurve(input, frameIndex, timeline);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.TransformConstraintTimeline.ENTRIES]);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const data = skeletonData.pathConstraints[index];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.PATH_POSITION:
          case _SkeletonBinary.PATH_SPACING: {
            let timeline;
            let timelineScale = 1;
            if (timelineType == _SkeletonBinary.PATH_SPACING) {
              timeline = new Animation.PathConstraintSpacingTimeline(frameCount);
              if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new Animation.PathConstraintPositionTimeline(frameCount);
              if (data.positionMode == base.PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.PathConstraintPositionTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.PATH_MIX: {
            const timeline = new Animation.PathConstraintMixTimeline(frameCount);
            timeline.pathConstraintIndex = index;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * Animation.PathConstraintMixTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const skin = skeletonData.skins[input.readInt(true)];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const slotIndex = input.readInt(true);
        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          const attachment = skin.getAttachment(slotIndex, input.readStringRef());
          const weighted = attachment.bones != null;
          const vertices = attachment.vertices;
          const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
          const frameCount = input.readInt(true);
          const timeline = new Animation.DeformTimeline(frameCount);
          timeline.slotIndex = slotIndex;
          timeline.attachment = attachment;
          for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
            const time = input.readFloat();
            let deform;
            let end = input.readInt(true);
            if (end == 0)
              deform = weighted ? base.Utils.newFloatArray(deformLength) : vertices;
            else {
              deform = base.Utils.newFloatArray(deformLength);
              const start = input.readInt(true);
              end += start;
              if (scale == 1) {
                for (let v = start; v < end; v++)
                  deform[v] = input.readFloat();
              } else {
                for (let v = start; v < end; v++)
                  deform[v] = input.readFloat() * scale;
              }
              if (!weighted) {
                for (let v = 0, vn = deform.length; v < vn; v++)
                  deform[v] += vertices[v];
              }
            }
            timeline.setFrame(frameIndex, time, deform);
            if (frameIndex < frameCount - 1)
              this.readCurve(input, frameIndex, timeline);
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[frameCount - 1]);
        }
      }
    }
    const drawOrderCount = input.readInt(true);
    if (drawOrderCount > 0) {
      const timeline = new Animation.DrawOrderTimeline(drawOrderCount);
      const slotCount = skeletonData.slots.length;
      for (let i = 0; i < drawOrderCount; i++) {
        const time = input.readFloat();
        const offsetCount = input.readInt(true);
        const drawOrder = base.Utils.newArray(slotCount, 0);
        for (let ii = slotCount - 1; ii >= 0; ii--)
          drawOrder[ii] = -1;
        const unchanged = base.Utils.newArray(slotCount - offsetCount, 0);
        let originalIndex = 0;
        let unchangedIndex = 0;
        for (let ii = 0; ii < offsetCount; ii++) {
          const slotIndex = input.readInt(true);
          while (originalIndex != slotIndex)
            unchanged[unchangedIndex++] = originalIndex++;
          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
        }
        while (originalIndex < slotCount)
          unchanged[unchangedIndex++] = originalIndex++;
        for (let ii = slotCount - 1; ii >= 0; ii--)
          if (drawOrder[ii] == -1)
            drawOrder[ii] = unchanged[--unchangedIndex];
        timeline.setFrame(i, time, drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
    }
    const eventCount = input.readInt(true);
    if (eventCount > 0) {
      const timeline = new Animation.EventTimeline(eventCount);
      for (let i = 0; i < eventCount; i++) {
        const time = input.readFloat();
        const eventData = skeletonData.events[input.readInt(true)];
        const event = new Event.Event(time, eventData);
        event.intValue = input.readInt(false);
        event.floatValue = input.readFloat();
        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
        if (event.data.audioPath != null) {
          event.volume = input.readFloat();
          event.balance = input.readFloat();
        }
        timeline.setFrame(i, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[eventCount - 1]);
    }
    return new Animation.Animation(name, timelines, duration);
  }
  readCurve(input, frameIndex, timeline) {
    switch (input.readByte()) {
      case _SkeletonBinary.CURVE_STEPPED:
        timeline.setStepped(frameIndex);
        break;
      case _SkeletonBinary.CURVE_BEZIER:
        this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
        break;
    }
  }
  setCurve(timeline, frameIndex, cx1, cy1, cx2, cy2) {
    timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
  }
};
let SkeletonBinary = _SkeletonBinary;
SkeletonBinary.AttachmentTypeValues = [
  0,
  1,
  2,
  3,
  4,
  5,
  6
];
SkeletonBinary.TransformModeValues = [
  base.TransformMode.Normal,
  base.TransformMode.OnlyTranslation,
  base.TransformMode.NoRotationOrReflection,
  base.TransformMode.NoScale,
  base.TransformMode.NoScaleOrReflection
];
SkeletonBinary.PositionModeValues = [base.PositionMode.Fixed, base.PositionMode.Percent];
SkeletonBinary.SpacingModeValues = [PathConstraintData.SpacingMode.Length, PathConstraintData.SpacingMode.Fixed, PathConstraintData.SpacingMode.Percent];
SkeletonBinary.RotateModeValues = [base.RotateMode.Tangent, base.RotateMode.Chain, base.RotateMode.ChainScale];
SkeletonBinary.BlendModeValues = [core.BLEND_MODES.NORMAL, core.BLEND_MODES.ADD, core.BLEND_MODES.MULTIPLY, core.BLEND_MODES.SCREEN];
SkeletonBinary.BONE_ROTATE = 0;
SkeletonBinary.BONE_TRANSLATE = 1;
SkeletonBinary.BONE_SCALE = 2;
SkeletonBinary.BONE_SHEAR = 3;
SkeletonBinary.SLOT_ATTACHMENT = 0;
SkeletonBinary.SLOT_COLOR = 1;
SkeletonBinary.SLOT_TWO_COLOR = 2;
SkeletonBinary.PATH_POSITION = 0;
SkeletonBinary.PATH_SPACING = 1;
SkeletonBinary.PATH_MIX = 2;
SkeletonBinary.CURVE_LINEAR = 0;
SkeletonBinary.CURVE_STEPPED = 1;
SkeletonBinary.CURVE_BEZIER = 2;
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritDeform = inheritDeform;
  }
}
class Vertices {
  constructor(bones = null, vertices = null) {
    this.bones = bones;
    this.vertices = vertices;
  }
}

exports.SkeletonBinary = SkeletonBinary;
//# sourceMappingURL=SkeletonBinary.js.map


/***/ }),

/***/ 4742:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class SkeletonBounds extends base.SkeletonBoundsBase {
}

exports.SkeletonBounds = SkeletonBounds;
//# sourceMappingURL=SkeletonBounds.js.map


/***/ }),

/***/ 55459:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class SkeletonData {
  constructor() {
    this.bones = new Array();
    // Ordered parents first.
    this.slots = new Array();
    // Setup pose draw order.
    this.skins = new Array();
    this.events = new Array();
    this.animations = new Array();
    this.ikConstraints = new Array();
    this.transformConstraints = new Array();
    this.pathConstraints = new Array();
    // Nonessential
    this.fps = 0;
  }
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  findSkin(skinName) {
    if (skinName == null)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  findEvent(eventDataName) {
    if (eventDataName == null)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  findAnimation(animationName) {
    if (animationName == null)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
}

exports.SkeletonData = SkeletonData;
//# sourceMappingURL=SkeletonData.js.map


/***/ }),

/***/ 4417:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Event = __webpack_require__(4370);
var SkeletonData = __webpack_require__(55459);
var SlotData = __webpack_require__(76292);
var BoneData = __webpack_require__(2426);
var IkConstraintData = __webpack_require__(48275);
var TransformConstraintData = __webpack_require__(40765);
var PathConstraintData = __webpack_require__(27992);
var Skin = __webpack_require__(56549);
var EventData = __webpack_require__(8242);
var Animation = __webpack_require__(93816);
var base = __webpack_require__(55075);
var core = __webpack_require__(11491);

class SkeletonJson {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new SkeletonData.SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap != null) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      if (skeletonData.version.substr(0, 3) !== "3.8") {
        const error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;
        console.error(error);
      }
      if (skeletonData.version === "3.8.75") {
        const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;
        console.error(error);
      }
      skeletonData.x = skeletonMap.x;
      skeletonData.y = skeletonMap.y;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = this.getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new BoneData.BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = this.getValue(boneMap, "length", 0) * scale;
        data.x = this.getValue(boneMap, "x", 0) * scale;
        data.y = this.getValue(boneMap, "y", 0) * scale;
        data.rotation = this.getValue(boneMap, "rotation", 0);
        data.scaleX = this.getValue(boneMap, "scaleX", 1);
        data.scaleY = this.getValue(boneMap, "scaleY", 1);
        data.shearX = this.getValue(boneMap, "shearX", 0);
        data.shearY = this.getValue(boneMap, "shearY", 0);
        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
        data.skinRequired = this.getValue(boneMap, "skin", false);
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const slotName = slotMap.name;
        const boneName = slotMap.bone;
        const boneData = skeletonData.findBone(boneName);
        if (boneData == null)
          throw new Error(`Slot bone not found: ${boneName}`);
        const data = new SlotData.SlotData(skeletonData.slots.length, slotName, boneData);
        const color = this.getValue(slotMap, "color", null);
        if (color != null)
          data.color.setFromString(color);
        const dark = this.getValue(slotMap, "dark", null);
        if (dark != null) {
          data.darkColor = new base.Color(1, 1, 1, 1);
          data.darkColor.setFromString(dark);
        }
        data.attachmentName = this.getValue(slotMap, "attachment", null);
        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new IkConstraintData.IkConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`IK target bone not found: ${targetName}`);
        data.mix = this.getValue(constraintMap, "mix", 1);
        data.softness = this.getValue(constraintMap, "softness", 0) * scale;
        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.compress = this.getValue(constraintMap, "compress", false);
        data.stretch = this.getValue(constraintMap, "stretch", false);
        data.uniform = this.getValue(constraintMap, "uniform", false);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new TransformConstraintData.TransformConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`Transform constraint target bone not found: ${targetName}`);
        data.local = this.getValue(constraintMap, "local", false);
        data.relative = this.getValue(constraintMap, "relative", false);
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new PathConstraintData.PathConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findSlot(targetName);
        if (data.target == null)
          throw new Error(`Path target slot not found: ${targetName}`);
        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.position = this.getValue(constraintMap, "position", 0);
        if (data.positionMode == base.PositionMode.Fixed)
          data.position *= scale;
        data.spacing = this.getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
          data.spacing *= scale;
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (let i = 0; i < root.skins.length; i++) {
        const skinMap = root.skins[i];
        const skin = new Skin.Skin(skinMap.name);
        if (skinMap.bones) {
          for (let ii = 0; ii < skinMap.bones.length; ii++) {
            const bone = skeletonData.findBone(skinMap.bones[ii]);
            if (bone == null)
              throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);
            skin.bones.push(bone);
          }
        }
        if (skinMap.ik) {
          for (let ii = 0; ii < skinMap.ik.length; ii++) {
            const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);
            if (constraint == null)
              throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.transform) {
          for (let ii = 0; ii < skinMap.transform.length; ii++) {
            const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);
            if (constraint == null)
              throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.path) {
          for (let ii = 0; ii < skinMap.path.length; ii++) {
            const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);
            if (constraint == null)
              throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);
            skin.constraints.push(constraint);
          }
        }
        for (const slotName in skinMap.attachments) {
          const slot = skeletonData.findSlot(slotName);
          if (slot == null)
            throw new Error(`Slot not found: ${slotName}`);
          const slotMap = skinMap.attachments[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
            if (attachment != null)
              skin.setAttachment(slot.index, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new EventData.EventData(eventName);
        data.intValue = this.getValue(eventMap, "int", 0);
        data.floatValue = this.getValue(eventMap, "float", 0);
        data.stringValue = this.getValue(eventMap, "string", "");
        data.audioPath = this.getValue(eventMap, "audio", null);
        if (data.audioPath != null) {
          data.volume = this.getValue(eventMap, "volume", 1);
          data.balance = this.getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = this.getValue(map, "name", name);
    const type = this.getValue(map, "type", "region");
    switch (type) {
      case "region": {
        const path = this.getValue(map, "path", name);
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = this.getValue(map, "x", 0) * scale;
        region.y = this.getValue(map, "y", 0) * scale;
        region.scaleX = this.getValue(map, "scaleX", 1);
        region.scaleY = this.getValue(map, "scaleY", 1);
        region.rotation = this.getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        const color = this.getValue(map, "color", null);
        if (color != null)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = this.getValue(map, "path", name);
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        const color = this.getValue(map, "color", null);
        if (color != null)
          mesh.color.setFromString(color);
        mesh.width = this.getValue(map, "width", 0) * scale;
        mesh.height = this.getValue(map, "height", 0) * scale;
        const parent = this.getValue(map, "parent", null);
        if (parent != null) {
          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent, this.getValue(map, "deform", true)));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.edges = this.getValue(map, "edges", null);
        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = this.getValue(map, "closed", false);
        path.constantSpeed = this.getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = base.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = this.getValue(map, "color", null);
        if (color != null)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = this.getValue(map, "x", 0) * scale;
        point.y = this.getValue(map, "y", 0) * scale;
        point.rotation = this.getValue(map, "rotation", 0);
        const color = this.getValue(map, "color", null);
        if (color != null)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        const end = this.getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = base.Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = base.Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    let duration = 0;
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slotIndex = skeletonData.findSlotIndex(slotName);
        if (slotIndex == -1)
          throw new Error(`Slot not found: ${slotName}`);
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (timelineName == "attachment") {
            const timeline = new Animation.AttachmentTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          } else if (timelineName == "color") {
            const timeline = new Animation.ColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const color = new base.Color();
              color.setFromString(valueMap.color || "ffffffff");
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color.r, color.g, color.b, color.a);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.ColorTimeline.ENTRIES]);
          } else if (timelineName == "twoColor") {
            const timeline = new Animation.TwoColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const light = new base.Color();
              const dark = new base.Color();
              light.setFromString(valueMap.light);
              dark.setFromString(valueMap.dark);
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.TwoColorTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const boneIndex = skeletonData.findBoneIndex(boneName);
        if (boneIndex == -1)
          throw new Error(`Bone not found: ${boneName}`);
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          if (timelineName === "rotate") {
            const timeline = new Animation.RotateTimeline(timelineMap.length);
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.RotateTimeline.ENTRIES]);
          } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
            let timeline = null;
            let timelineScale = 1;
            let defaultValue = 0;
            if (timelineName === "scale") {
              timeline = new Animation.ScaleTimeline(timelineMap.length);
              defaultValue = 1;
            } else if (timelineName === "shear")
              timeline = new Animation.ShearTimeline(timelineMap.length);
            else {
              timeline = new Animation.TranslateTimeline(timelineMap.length);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const x = this.getValue(valueMap, "x", defaultValue);
              const y = this.getValue(valueMap, "y", defaultValue);
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.TranslateTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        const constraint = skeletonData.findIkConstraint(constraintName);
        const timeline = new Animation.IkConstraintTimeline(constraintMap.length);
        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            this.getValue(valueMap, "time", 0),
            this.getValue(valueMap, "mix", 1),
            this.getValue(valueMap, "softness", 0) * scale,
            this.getValue(valueMap, "bendPositive", true) ? 1 : -1,
            this.getValue(valueMap, "compress", false),
            this.getValue(valueMap, "stretch", false)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.IkConstraintTimeline.ENTRIES]);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const constraintMap = map.transform[constraintName];
        const constraint = skeletonData.findTransformConstraint(constraintName);
        const timeline = new Animation.TransformConstraintTimeline(constraintMap.length);
        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            this.getValue(valueMap, "time", 0),
            this.getValue(valueMap, "rotateMix", 1),
            this.getValue(valueMap, "translateMix", 1),
            this.getValue(valueMap, "scaleMix", 1),
            this.getValue(valueMap, "shearMix", 1)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.TransformConstraintTimeline.ENTRIES]);
      }
    }
    if (map.path) {
      for (const constraintName in map.path) {
        const constraintMap = map.path[constraintName];
        const index = skeletonData.findPathConstraintIndex(constraintName);
        if (index == -1)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const data = skeletonData.pathConstraints[index];
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          if (timelineName === "position" || timelineName === "spacing") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "spacing") {
              timeline = new Animation.PathConstraintSpacingTimeline(timelineMap.length);
              if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new Animation.PathConstraintPositionTimeline(timelineMap.length);
              if (data.positionMode == base.PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.PathConstraintPositionTimeline.ENTRIES]);
          } else if (timelineName === "mix") {
            const timeline = new Animation.PathConstraintMixTimeline(timelineMap.length);
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * Animation.PathConstraintMixTimeline.ENTRIES]);
          }
        }
      }
    }
    if (map.deform) {
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const skin = skeletonData.findSkin(deformName);
        if (skin == null) {
          if (base.settings.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${deformName}`);
          } else {
            continue;
          }
        }
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotMap.name}`);
          for (const timelineName in slotMap) {
            const timelineMap = slotMap[timelineName];
            const attachment = skin.getAttachment(slotIndex, timelineName);
            if (attachment == null)
              throw new Error(`Deform attachment not found: ${timelineMap.name}`);
            const weighted = attachment.bones != null;
            const vertices = attachment.vertices;
            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            const timeline = new Animation.DeformTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            let frameIndex = 0;
            for (let j = 0; j < timelineMap.length; j++) {
              const valueMap = timelineMap[j];
              let deform;
              const verticesValue = this.getValue(valueMap, "vertices", null);
              if (verticesValue == null)
                deform = weighted ? base.Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = base.Utils.newFloatArray(deformLength);
                const start = this.getValue(valueMap, "offset", 0);
                base.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                if (scale != 1) {
                  for (let i = start, n = i + verticesValue.length; i < n; i++)
                    deform[i] *= scale;
                }
                if (!weighted) {
                  for (let i = 0; i < deformLength; i++)
                    deform[i] += vertices[i];
                }
              }
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
        }
      }
    }
    let drawOrderNode = map.drawOrder;
    if (drawOrderNode == null)
      drawOrderNode = map.draworder;
    if (drawOrderNode != null) {
      const timeline = new Animation.DrawOrderTimeline(drawOrderNode.length);
      const slotCount = skeletonData.slots.length;
      let frameIndex = 0;
      for (let j = 0; j < drawOrderNode.length; j++) {
        const drawOrderMap = drawOrderNode[j];
        let drawOrder = null;
        const offsets = this.getValue(drawOrderMap, "offsets", null);
        if (offsets != null) {
          drawOrder = base.Utils.newArray(slotCount, -1);
          const unchanged = base.Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let i = 0; i < offsets.length; i++) {
            const offsetMap = offsets[i];
            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
            if (slotIndex == -1)
              throw new Error(`Slot not found: ${offsetMap.slot}`);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let i = slotCount - 1; i >= 0; i--)
            if (drawOrder[i] == -1)
              drawOrder[i] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (map.events) {
      const timeline = new Animation.EventTimeline(map.events.length);
      let frameIndex = 0;
      for (let i = 0; i < map.events.length; i++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (eventData == null)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new Event.Event(base.Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
        event.intValue = this.getValue(eventMap, "int", eventData.intValue);
        event.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath != null) {
          event.volume = this.getValue(eventMap, "volume", 1);
          event.balance = this.getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frameIndex++, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new Animation.Animation(name, timelines, duration));
  }
  readCurve(map, timeline, frameIndex) {
    if (!map.hasOwnProperty("curve"))
      return;
    if (map.curve === "stepped")
      timeline.setStepped(frameIndex);
    else {
      const curve = map.curve;
      timeline.setCurve(frameIndex, curve, this.getValue(map, "c2", 0), this.getValue(map, "c3", 1), this.getValue(map, "c4", 1));
    }
  }
  getValue(map, prop, defaultValue) {
    return map[prop] !== void 0 ? map[prop] : defaultValue;
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return core.BLEND_MODES.NORMAL;
    if (str == "additive")
      return core.BLEND_MODES.ADD;
    if (str == "multiply")
      return core.BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return core.BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
  static positionModeFromString(str) {
    str = str.toLowerCase();
    if (str == "fixed")
      return base.PositionMode.Fixed;
    if (str == "percent")
      return base.PositionMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static spacingModeFromString(str) {
    str = str.toLowerCase();
    if (str == "length")
      return PathConstraintData.SpacingMode.Length;
    if (str == "fixed")
      return PathConstraintData.SpacingMode.Fixed;
    if (str == "percent")
      return PathConstraintData.SpacingMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static rotateModeFromString(str) {
    str = str.toLowerCase();
    if (str == "tangent")
      return base.RotateMode.Tangent;
    if (str == "chain")
      return base.RotateMode.Chain;
    if (str == "chainscale")
      return base.RotateMode.ChainScale;
    throw new Error(`Unknown rotate mode: ${str}`);
  }
  static transformModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return base.TransformMode.Normal;
    if (str == "onlytranslation")
      return base.TransformMode.OnlyTranslation;
    if (str == "norotationorreflection")
      return base.TransformMode.NoRotationOrReflection;
    if (str == "noscale")
      return base.TransformMode.NoScale;
    if (str == "noscaleorreflection")
      return base.TransformMode.NoScaleOrReflection;
    throw new Error(`Unknown transform mode: ${str}`);
  }
}
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritDeform = inheritDeform;
  }
}

exports.SkeletonJson = SkeletonJson;
//# sourceMappingURL=SkeletonJson.js.map


/***/ }),

/***/ 56549:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(76678);
__webpack_require__(55075);
var MeshAttachment = __webpack_require__(95887);
__webpack_require__(95762);

class SkinEntry {
  constructor(slotIndex, name, attachment) {
    this.slotIndex = slotIndex;
    this.name = name;
    this.attachment = attachment;
  }
}
class Skin {
  constructor(name) {
    this.attachments = new Array();
    this.bones = Array();
    this.constraints = new Array();
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  setAttachment(slotIndex, name, attachment) {
    if (attachment == null)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  addSkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let j = 0; j < this.bones.length; j++) {
        if (this.bones[j] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let j = 0; j < this.constraints.length; j++) {
        if (this.constraints[j] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
    }
  }
  copySkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let j = 0; j < this.bones.length; j++) {
        if (this.bones[j] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let j = 0; j < this.constraints.length; j++) {
        if (this.constraints[j] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (attachment.attachment == null)
        continue;
      if (attachment.attachment instanceof MeshAttachment.MeshAttachment) {
        attachment.attachment = attachment.attachment.newLinkedMesh();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      } else {
        attachment.attachment = attachment.attachment.copy();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
  }
  /** @return May be null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  removeAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    if (dictionary)
      dictionary[name] = null;
  }
  getAttachments() {
    const entries = new Array();
    for (let i = 0; i < this.attachments.length; i++) {
      const slotAttachments = this.attachments[i];
      if (slotAttachments) {
        for (const name in slotAttachments) {
          const attachment = slotAttachments[name];
          if (attachment)
            entries.push(new SkinEntry(i, name, attachment));
        }
      }
    }
    return entries;
  }
  getAttachmentsForSlot(slotIndex, attachments) {
    const slotAttachments = this.attachments[slotIndex];
    if (slotAttachments) {
      for (const name in slotAttachments) {
        const attachment = slotAttachments[name];
        if (attachment)
          attachments.push(new SkinEntry(slotIndex, name, attachment));
      }
    }
  }
  clear() {
    this.attachments.length = 0;
    this.bones.length = 0;
    this.constraints.length = 0;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment != null)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
}

exports.Skin = Skin;
exports.SkinEntry = SkinEntry;
//# sourceMappingURL=Skin.js.map


/***/ }),

/***/ 70460:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class Slot {
  constructor(data, bone) {
    this.deform = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (bone == null)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new base.Color();
    this.darkColor = data.darkColor == null ? null : new base.Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** @return May be null. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.
   * @param attachment May be null. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    this.attachment = attachment;
    this.attachmentTime = this.bone.skeleton.time;
    this.deform.length = 0;
  }
  setAttachmentTime(time) {
    this.attachmentTime = this.bone.skeleton.time - time;
  }
  /** Returns the time since the attachment was set. */
  getAttachmentTime() {
    return this.bone.skeleton.time - this.attachmentTime;
  }
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor != null)
      this.darkColor.setFromColor(this.data.darkColor);
    if (this.data.attachmentName == null)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
}

exports.Slot = Slot;
//# sourceMappingURL=Slot.js.map


/***/ }),

/***/ 76292:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class SlotData {
  constructor(index, name, boneData) {
    this.color = new base.Color(1, 1, 1, 1);
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    if (boneData == null)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
}

exports.SlotData = SlotData;
//# sourceMappingURL=SlotData.js.map


/***/ }),

/***/ 90653:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class TransformConstraint {
  constructor(data, skeleton) {
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.temp = new base.Vector2();
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
    this.scaleMix = data.scaleMix;
    this.shearMix = data.shearMix;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * translateMix;
        mat.ty += (temp.y - mat.ty) * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        let ts = Math.sqrt(ta * ta + tc * tc);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
        mat.a *= s;
        mat.b *= s;
        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        ts = Math.sqrt(tb * tb + td * td);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r = by + (r + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyRelativeWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * translateMix;
        mat.ty += temp.y * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
        mat.a *= s;
        mat.b *= s;
        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - base.MathUtils.PI / 2 + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyAbsoluteLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * rotateMix;
      }
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax - x + this.data.offsetX) * translateMix;
        y += (target.ay - y + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
        if (scaleY > 1e-5)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
      }
      const shearY = bone.ashearY;
      if (shearMix > 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        bone.shearY += r * shearMix;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0)
        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax + this.data.offsetX) * translateMix;
        y += (target.ay + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
        if (scaleY > 1e-5)
          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
      }
      let shearY = bone.ashearY;
      if (shearMix > 0)
        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
}

exports.TransformConstraint = TransformConstraint;
//# sourceMappingURL=TransformConstraint.js.map


/***/ }),

/***/ 40765:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Constraint = __webpack_require__(55119);

class TransformConstraintData extends Constraint.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.offsetRotation = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.offsetScaleX = 0;
    this.offsetScaleY = 0;
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
  }
}

exports.TransformConstraintData = TransformConstraintData;
//# sourceMappingURL=TransformConstraintData.js.map


/***/ }),

/***/ 76678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class Attachment {
  constructor(name) {
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}
const _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    this.id = (_VertexAttachment.nextID++ & 65535) << 11;
    this.worldVerticesLength = 0;
    this.deformAttachment = this;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms local vertices to world coordinates.
   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.
   * @param worldVertices The output world vertices. Must have a length >= offset + count.
   * @param offset The worldVertices index to begin writing values. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.deform;
    let vertices = this.vertices;
    const bones = this.bones;
    if (bones == null) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  copyTo(attachment) {
    if (this.bones != null) {
      attachment.bones = new Array(this.bones.length);
      base.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
    } else
      attachment.bones = null;
    if (this.vertices != null) {
      attachment.vertices = base.Utils.newFloatArray(this.vertices.length);
      base.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
    } else
      attachment.vertices = null;
    attachment.worldVerticesLength = this.worldVerticesLength;
    attachment.deformAttachment = this.deformAttachment;
  }
};
let VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;

exports.Attachment = Attachment;
exports.VertexAttachment = VertexAttachment;
//# sourceMappingURL=Attachment.js.map


/***/ }),

/***/ 10299:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var base = __webpack_require__(55075);

class BoundingBoxAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.BoundingBox;
    this.color = new base.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new BoundingBoxAttachment(this.name);
    this.copyTo(copy);
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.BoundingBoxAttachment = BoundingBoxAttachment;
//# sourceMappingURL=BoundingBoxAttachment.js.map


/***/ }),

/***/ 20704:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var base = __webpack_require__(55075);

class ClippingAttachment extends Attachment.VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Clipping;
    // Nonessential.
    this.color = new base.Color(0.2275, 0.2275, 0.8078, 1);
  }
  copy() {
    const copy = new ClippingAttachment(this.name);
    this.copyTo(copy);
    copy.endSlot = this.endSlot;
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.ClippingAttachment = ClippingAttachment;
//# sourceMappingURL=ClippingAttachment.js.map


/***/ }),

/***/ 95887:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var base = __webpack_require__(55075);

class MeshAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Mesh;
    this.color = new base.Color(1, 1, 1, 1);
    this.tempColor = new base.Color(0, 0, 0, 0);
  }
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh != null) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  copy() {
    if (this.parentMesh != null)
      return this.newLinkedMesh();
    const copy = new MeshAttachment(this.name);
    copy.region = this.region;
    copy.path = this.path;
    copy.color.setFromColor(this.color);
    this.copyTo(copy);
    copy.regionUVs = new Float32Array(this.regionUVs.length);
    base.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
    copy.triangles = new Array(this.triangles.length);
    base.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
    copy.hullLength = this.hullLength;
    if (this.edges != null) {
      copy.edges = new Array(this.edges.length);
      base.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
    }
    copy.width = this.width;
    copy.height = this.height;
    return copy;
  }
  newLinkedMesh() {
    const copy = new MeshAttachment(this.name);
    copy.region = this.region;
    copy.path = this.path;
    copy.color.setFromColor(this.color);
    copy.deformAttachment = this.deformAttachment;
    copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);
    return copy;
  }
}

exports.MeshAttachment = MeshAttachment;
//# sourceMappingURL=MeshAttachment.js.map


/***/ }),

/***/ 24229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var base = __webpack_require__(55075);

class PathAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Path;
    this.closed = false;
    this.constantSpeed = false;
    this.color = new base.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new PathAttachment(this.name);
    this.copyTo(copy);
    copy.lengths = new Array(this.lengths.length);
    base.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
    copy.closed = closed;
    copy.constantSpeed = this.constantSpeed;
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.PathAttachment = PathAttachment;
//# sourceMappingURL=PathAttachment.js.map


/***/ }),

/***/ 1632:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var base = __webpack_require__(55075);

class PointAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Point;
    this.color = new base.Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = base.MathUtils.cosDeg(this.rotation);
    const sin = base.MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * base.MathUtils.radDeg;
  }
  copy() {
    const copy = new PointAttachment(this.name);
    copy.x = this.x;
    copy.y = this.y;
    copy.rotation = this.rotation;
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.PointAttachment = PointAttachment;
//# sourceMappingURL=PointAttachment.js.map


/***/ }),

/***/ 95762:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var base = __webpack_require__(55075);
var Slot = __webpack_require__(70460);

const _RegionAttachment = class extends Attachment.Attachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Region;
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.width = 0;
    this.height = 0;
    this.color = new base.Color(1, 1, 1, 1);
    this.offset = base.Utils.newFloatArray(8);
    this.uvs = base.Utils.newFloatArray(8);
    this.tempColor = new base.Color(1, 1, 1, 1);
  }
  updateOffset() {
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const localXCos = localX * cos + this.x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + this.y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + this.x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + this.y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[_RegionAttachment.OX1] = localXCos - localYSin;
    offset[_RegionAttachment.OY1] = localYCos + localXSin;
    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;
    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;
    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;
    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;
    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;
    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;
  }
  setRegion(region) {
    this.region = region;
    const uvs = this.uvs;
    if (region.rotate) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  computeWorldVertices(bone, worldVertices, offset, stride) {
    const vertexOffset = this.offset;
    const mat = bone instanceof Slot.Slot ? bone.bone.matrix : bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[_RegionAttachment.OX1];
    offsetY = vertexOffset[_RegionAttachment.OY1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX2];
    offsetY = vertexOffset[_RegionAttachment.OY2];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX3];
    offsetY = vertexOffset[_RegionAttachment.OY3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX4];
    offsetY = vertexOffset[_RegionAttachment.OY4];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
  copy() {
    const copy = new _RegionAttachment(this.name);
    copy.region = this.region;
    copy.rendererObject = this.rendererObject;
    copy.path = this.path;
    copy.x = this.x;
    copy.y = this.y;
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.width = this.width;
    copy.height = this.height;
    base.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
    base.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
    copy.color.setFromColor(this.color);
    return copy;
  }
};
let RegionAttachment = _RegionAttachment;
RegionAttachment.OX1 = 0;
RegionAttachment.OY1 = 1;
RegionAttachment.OX2 = 2;
RegionAttachment.OY2 = 3;
RegionAttachment.OX3 = 4;
RegionAttachment.OY3 = 5;
RegionAttachment.OX4 = 6;
RegionAttachment.OY4 = 7;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;

exports.RegionAttachment = RegionAttachment;
//# sourceMappingURL=RegionAttachment.js.map


/***/ }),

/***/ 82374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class JitterEffect {
  constructor(jitterX, jitterY) {
    this.jitterX = 0;
    this.jitterY = 0;
    this.jitterX = jitterX;
    this.jitterY = jitterY;
  }
  begin(skeleton) {
  }
  transform(position, uv, light, dark) {
    position.x += base.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    position.y += base.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
  }
  end() {
  }
}

exports.JitterEffect = JitterEffect;
//# sourceMappingURL=JitterEffect.js.map


/***/ }),

/***/ 35363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

const _SwirlEffect = class {
  constructor(radius) {
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.angle = 0;
    this.worldX = 0;
    this.worldY = 0;
    this.radius = radius;
  }
  begin(skeleton) {
    this.worldX = skeleton.x + this.centerX;
    this.worldY = skeleton.y + this.centerY;
  }
  transform(position, uv, light, dark) {
    const radAngle = this.angle * base.MathUtils.degreesToRadians;
    const x = position.x - this.worldX;
    const y = position.y - this.worldY;
    const dist = Math.sqrt(x * x + y * y);
    if (dist < this.radius) {
      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);
      position.x = cos * x - sin * y + this.worldX;
      position.y = sin * x + cos * y + this.worldY;
    }
  }
  end() {
  }
};
let SwirlEffect = _SwirlEffect;
SwirlEffect.interpolation = new base.PowOut(2);

exports.SwirlEffect = SwirlEffect;
//# sourceMappingURL=SwirlEffect.js.map


/***/ }),

/***/ 51816:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(76678);
var BoundingBoxAttachment = __webpack_require__(10299);
var ClippingAttachment = __webpack_require__(20704);
var MeshAttachment = __webpack_require__(95887);
var PathAttachment = __webpack_require__(24229);
var PointAttachment = __webpack_require__(1632);
var RegionAttachment = __webpack_require__(95762);
var JitterEffect = __webpack_require__(82374);
var SwirlEffect = __webpack_require__(35363);
var Animation = __webpack_require__(93816);
var AnimationState = __webpack_require__(91259);
var AnimationStateData = __webpack_require__(16963);
var AtlasAttachmentLoader = __webpack_require__(39371);
var Bone = __webpack_require__(98522);
var BoneData = __webpack_require__(2426);
var Constraint = __webpack_require__(55119);
var Event = __webpack_require__(4370);
var EventData = __webpack_require__(8242);
var IkConstraint = __webpack_require__(13291);
var IkConstraintData = __webpack_require__(48275);
var PathConstraint = __webpack_require__(96112);
var PathConstraintData = __webpack_require__(27992);
var Skeleton = __webpack_require__(40443);
var SkeletonBinary = __webpack_require__(71762);
var SkeletonBounds = __webpack_require__(4742);
var SkeletonData = __webpack_require__(55459);
var SkeletonJson = __webpack_require__(4417);
var Skin = __webpack_require__(56549);
var Slot = __webpack_require__(70460);
var SlotData = __webpack_require__(76292);
var TransformConstraint = __webpack_require__(90653);
var TransformConstraintData = __webpack_require__(40765);
var Spine = __webpack_require__(18843);



exports.Attachment = Attachment.Attachment;
exports.VertexAttachment = Attachment.VertexAttachment;
exports.BoundingBoxAttachment = BoundingBoxAttachment.BoundingBoxAttachment;
exports.ClippingAttachment = ClippingAttachment.ClippingAttachment;
exports.MeshAttachment = MeshAttachment.MeshAttachment;
exports.PathAttachment = PathAttachment.PathAttachment;
exports.PointAttachment = PointAttachment.PointAttachment;
exports.RegionAttachment = RegionAttachment.RegionAttachment;
exports.JitterEffect = JitterEffect.JitterEffect;
exports.SwirlEffect = SwirlEffect.SwirlEffect;
exports.Animation = Animation.Animation;
exports.AttachmentTimeline = Animation.AttachmentTimeline;
exports.ColorTimeline = Animation.ColorTimeline;
exports.CurveTimeline = Animation.CurveTimeline;
exports.DeformTimeline = Animation.DeformTimeline;
exports.DrawOrderTimeline = Animation.DrawOrderTimeline;
exports.EventTimeline = Animation.EventTimeline;
exports.IkConstraintTimeline = Animation.IkConstraintTimeline;
exports.PathConstraintMixTimeline = Animation.PathConstraintMixTimeline;
exports.PathConstraintPositionTimeline = Animation.PathConstraintPositionTimeline;
exports.PathConstraintSpacingTimeline = Animation.PathConstraintSpacingTimeline;
exports.RotateTimeline = Animation.RotateTimeline;
exports.ScaleTimeline = Animation.ScaleTimeline;
exports.ShearTimeline = Animation.ShearTimeline;
exports.TimelineType = Animation.TimelineType;
exports.TransformConstraintTimeline = Animation.TransformConstraintTimeline;
exports.TranslateTimeline = Animation.TranslateTimeline;
exports.TwoColorTimeline = Animation.TwoColorTimeline;
exports.AnimationState = AnimationState.AnimationState;
exports.AnimationStateAdapter = AnimationState.AnimationStateAdapter;
exports.EventQueue = AnimationState.EventQueue;
exports.EventType = AnimationState.EventType;
exports.TrackEntry = AnimationState.TrackEntry;
exports.AnimationStateData = AnimationStateData.AnimationStateData;
exports.AtlasAttachmentLoader = AtlasAttachmentLoader.AtlasAttachmentLoader;
exports.Bone = Bone.Bone;
exports.BoneData = BoneData.BoneData;
exports.ConstraintData = Constraint.ConstraintData;
exports.Event = Event.Event;
exports.EventData = EventData.EventData;
exports.IkConstraint = IkConstraint.IkConstraint;
exports.IkConstraintData = IkConstraintData.IkConstraintData;
exports.PathConstraint = PathConstraint.PathConstraint;
exports.PathConstraintData = PathConstraintData.PathConstraintData;
exports.SpacingMode = PathConstraintData.SpacingMode;
exports.Skeleton = Skeleton.Skeleton;
exports.SkeletonBinary = SkeletonBinary.SkeletonBinary;
exports.SkeletonBounds = SkeletonBounds.SkeletonBounds;
exports.SkeletonData = SkeletonData.SkeletonData;
exports.SkeletonJson = SkeletonJson.SkeletonJson;
exports.Skin = Skin.Skin;
exports.SkinEntry = Skin.SkinEntry;
exports.Slot = Slot.Slot;
exports.SlotData = SlotData.SlotData;
exports.TransformConstraint = TransformConstraint.TransformConstraint;
exports.TransformConstraintData = TransformConstraintData.TransformConstraintData;
exports.Spine = Spine.Spine;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 75553:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var Skeleton = __webpack_require__(8665);
var AnimationState = __webpack_require__(94649);
var AnimationStateData = __webpack_require__(11657);

class Spine extends base.SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new Skeleton.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new AnimationStateData.AnimationStateData(spineData);
    this.state = new AnimationState.AnimationState(this.stateData);
  }
}

exports.Spine = Spine;
//# sourceMappingURL=Spine.js.map


/***/ }),

/***/ 97294:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var base = __webpack_require__(55075);
__webpack_require__(40192);
var Sequence = __webpack_require__(89688);

class Animation {
  constructor(name, timelines, duration) {
    this.timelines = [];
    this.timelineIds = new base.StringSet();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
    this.setTimelines(timelines);
    this.duration = duration;
  }
  setTimelines(timelines) {
    if (!timelines)
      throw new Error("timelines cannot be null.");
    this.timelines = timelines;
    this.timelineIds.clear();
    for (let i = 0; i < timelines.length; i++)
      this.timelineIds.addAll(timelines[i].getPropertyIds());
  }
  hasTimeline(ids) {
    for (let i = 0; i < ids.length; i++)
      if (this.timelineIds.contains(ids[i]))
        return true;
    return false;
  }
  /** Applies all the animation's timelines to the specified skeleton.
   *
   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
   * @param loop If true, the animation repeats after {@link #getDuration()}.
   * @param events May be null to ignore fired events. */
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
}
const Property = {
  rotate: 0,
  x: 1,
  y: 2,
  scaleX: 3,
  scaleY: 4,
  shearX: 5,
  shearY: 6,
  rgb: 7,
  alpha: 8,
  rgb2: 9,
  attachment: 10,
  deform: 11,
  event: 12,
  drawOrder: 13,
  ikConstraint: 14,
  transformConstraint: 15,
  pathConstraintPosition: 16,
  pathConstraintSpacing: 17,
  pathConstraintMix: 18,
  sequence: 19
};
class Timeline {
  constructor(frameCount, propertyIds) {
    this.propertyIds = propertyIds;
    this.frames = base.Utils.newFloatArray(frameCount * this.getFrameEntries());
  }
  getPropertyIds() {
    return this.propertyIds;
  }
  getFrameEntries() {
    return 1;
  }
  getFrameCount() {
    return this.frames.length / this.getFrameEntries();
  }
  getDuration() {
    return this.frames[this.frames.length - this.getFrameEntries()];
  }
  static search1(frames, time) {
    const n = frames.length;
    for (let i = 1; i < n; i++)
      if (frames[i] > time)
        return i - 1;
    return n - 1;
  }
  static search(frames, time, step) {
    const n = frames.length;
    for (let i = step; i < n; i += step)
      if (frames[i] > time)
        return i - step;
    return n - step;
  }
}
class CurveTimeline extends Timeline {
  // type, x, y, ...
  constructor(frameCount, bezierCount, propertyIds) {
    super(frameCount, propertyIds);
    this.curves = base.Utils.newFloatArray(
      frameCount + bezierCount * 18
      /* BEZIER_SIZE*/
    );
    this.curves[frameCount - 1] = 1;
  }
  /** Sets the specified key frame to linear interpolation. */
  setLinear(frame) {
    this.curves[frame] = 0;
  }
  /** Sets the specified key frame to stepped interpolation. */
  setStepped(frame) {
    this.curves[frame] = 1;
  }
  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger
   * than the actual number of Bezier curves. */
  shrink(bezierCount) {
    const size = this.getFrameCount() + bezierCount * 18;
    if (this.curves.length > size) {
      const newCurves = base.Utils.newFloatArray(size);
      base.Utils.arrayCopy(this.curves, 0, newCurves, 0, size);
      this.curves = newCurves;
    }
  }
  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than
   * one curve per frame.
   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified
   *           in the constructor), inclusive.
   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.
   * @param value The index of the value for this frame that this curve is used for.
   * @param time1 The time for the first key.
   * @param value1 The value for the first key.
   * @param cx1 The time for the first Bezier handle.
   * @param cy1 The value for the first Bezier handle.
   * @param cx2 The time of the second Bezier handle.
   * @param cy2 The value for the second Bezier handle.
   * @param time2 The time for the second key.
   * @param value2 The value for the second key. */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = value1 + dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  /** Returns the Bezier interpolated value for the specified time.
   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.
   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.
   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */
  getBezierValue(time, frameIndex, valueOffset, i) {
    const curves = this.curves;
    if (curves[i] > time) {
      const x2 = this.frames[frameIndex];
      const y2 = this.frames[frameIndex + valueOffset];
      return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    frameIndex += this.getFrameEntries();
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);
  }
}
class CurveTimeline1 extends CurveTimeline {
  constructor(frameCount, bezierCount, propertyId) {
    super(frameCount, bezierCount, [propertyId]);
  }
  getFrameEntries() {
    return 2;
  }
  /** Sets the time and value for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value) {
    frame <<= 1;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE*/
    ] = value;
  }
  /** Returns the interpolated value for the specified time. */
  getCurveValue(time) {
    const frames = this.frames;
    let i = frames.length - 2;
    for (let ii = 2; ii <= i; ii += 2) {
      if (frames[ii] > time) {
        i = ii - 2;
        break;
      }
    }
    const curveType = this.curves[i >> 1];
    switch (curveType) {
      case 0:
        const before = frames[i];
        const value = frames[
          i + 1
          /* VALUE*/
        ];
        return value + (time - before) / (frames[
          i + 2
          /* ENTRIES*/
        ] - before) * (frames[
          i + 2 + 1
          /* VALUE*/
        ] - value);
      case 1:
        return frames[
          i + 1
          /* VALUE*/
        ];
    }
    return this.getBezierValue(
      time,
      i,
      1,
      curveType - 2
      /* BEZIER*/
    );
  }
}
class CurveTimeline2 extends CurveTimeline {
  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.
   * @param propertyIds Unique identifiers for the properties the timeline modifies. */
  constructor(frameCount, bezierCount, propertyId1, propertyId2) {
    super(frameCount, bezierCount, [propertyId1, propertyId2]);
  }
  getFrameEntries() {
    return 3;
  }
  /** Sets the time and values for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value1, value2) {
    frame *= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE1*/
    ] = value1;
    this.frames[
      frame + 2
      /* VALUE2*/
    ] = value2;
  }
}
class RotateTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case base.MixBlend.first:
          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;
      }
      return;
    }
    let r = this.getCurveValue(time);
    switch (blend) {
      case base.MixBlend.setup:
        bone.rotation = bone.data.rotation + r * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case base.MixBlend.add:
        bone.rotation += r * alpha;
    }
  }
}
class TranslateTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case base.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case base.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case base.MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
}
class TranslateXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.x = bone.data.x;
          return;
        case base.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case base.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        break;
      case base.MixBlend.add:
        bone.x += x * alpha;
    }
  }
}
class TranslateYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.y = bone.data.y;
          return;
        case base.MixBlend.first:
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case base.MixBlend.setup:
        bone.y = bone.data.y + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case base.MixBlend.add:
        bone.y += y * alpha;
    }
  }
}
class ScaleTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case base.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    x *= bone.data.scaleX;
    y *= bone.data.scaleY;
    if (alpha == 1) {
      if (blend == base.MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == base.MixDirection.mixOut) {
        switch (blend) {
          case base.MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case base.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * base.MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * base.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * base.MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * base.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
}
class ScaleXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          return;
        case base.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time) * bone.data.scaleX;
    if (alpha == 1) {
      if (blend == base.MixBlend.add)
        bone.scaleX += x - bone.data.scaleX;
      else
        bone.scaleX = x;
    } else {
      let bx = 0;
      if (direction == base.MixDirection.mixOut) {
        switch (blend) {
          case base.MixBlend.setup:
            bx = bone.data.scaleX;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = bone.scaleX;
            bone.scaleX = bx + (Math.abs(x) * base.MathUtils.signum(bx) - bx) * alpha;
            break;
          case base.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      } else {
        switch (blend) {
          case base.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * base.MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * base.MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case base.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      }
    }
  }
}
class ScaleYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.scaleY = bone.data.scaleY;
          return;
        case base.MixBlend.first:
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time) * bone.data.scaleY;
    if (alpha == 1) {
      if (blend == base.MixBlend.add)
        bone.scaleY += y - bone.data.scaleY;
      else
        bone.scaleY = y;
    } else {
      let by = 0;
      if (direction == base.MixDirection.mixOut) {
        switch (blend) {
          case base.MixBlend.setup:
            by = bone.data.scaleY;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            by = bone.scaleY;
            bone.scaleY = by + (Math.abs(y) * base.MathUtils.signum(by) - by) * alpha;
            break;
          case base.MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case base.MixBlend.setup:
            by = Math.abs(bone.data.scaleY) * base.MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.first:
          case base.MixBlend.replace:
            by = Math.abs(bone.scaleY) * base.MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case base.MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
}
class ShearTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case base.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case base.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case base.MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
}
class ShearXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          return;
        case base.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case base.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        break;
      case base.MixBlend.add:
        bone.shearX += x * alpha;
    }
  }
}
class ShearYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.shearY = bone.data.shearY;
          return;
        case base.MixBlend.first:
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case base.MixBlend.setup:
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case base.MixBlend.first:
      case base.MixBlend.replace:
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case base.MixBlend.add:
        bone.shearY += y * alpha;
    }
  }
}
class RGBATimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 5;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b, a) {
    frame *= 5;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case base.MixBlend.setup:
          color.setFromColor(setup);
          return;
        case base.MixBlend.first:
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    const i = Timeline.search(
      frames,
      time,
      5
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 5
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        const t = (time - before) / (frames[
          i + 5
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 5 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 5 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 5 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 5 + 4
          /* A*/
        ] - a) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1)
      color.set(r, g, b, a);
    else {
      if (blend == base.MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
}
class RGBTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 4;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b) {
    frame <<= 2;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case base.MixBlend.setup:
          color.r = setup.r;
          color.g = setup.g;
          color.b = setup.b;
          return;
        case base.MixBlend.first:
          color.r += (setup.r - color.r) * alpha;
          color.g += (setup.g - color.g) * alpha;
          color.b += (setup.b - color.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 4 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 4 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 4 + 3
          /* B*/
        ] - b) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      color.r = r;
      color.g = g;
      color.b = b;
    } else {
      if (blend == base.MixBlend.setup) {
        const setup = slot.data.color;
        color.r = setup.r;
        color.g = setup.g;
        color.b = setup.b;
      }
      color.r += (r - color.r) * alpha;
      color.g += (g - color.g) * alpha;
      color.b += (b - color.b) * alpha;
    }
  }
}
class AlphaTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const color = slot.color;
    if (time < this.frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case base.MixBlend.setup:
          color.a = setup.a;
          return;
        case base.MixBlend.first:
          color.a += (setup.a - color.a) * alpha;
      }
      return;
    }
    const a = this.getCurveValue(time);
    if (alpha == 1)
      color.a = a;
    else {
      if (blend == base.MixBlend.setup)
        color.a = slot.data.color.a;
      color.a += (a - color.a) * alpha;
    }
  }
}
class RGBA2Timeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 8;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, a, r2, g2, b2) {
    frame <<= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
    this.frames[
      frame + 5
      /* R2*/
    ] = r2;
    this.frames[
      frame + 6
      /* G2*/
    ] = g2;
    this.frames[
      frame + 7
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case base.MixBlend.setup:
          light.setFromColor(setupLight);
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case base.MixBlend.first:
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      8
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 3];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 8
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 8 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 8 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 8 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 8 + 4
          /* A*/
        ] - a) * t;
        r2 += (frames[
          i + 8 + 5
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 8 + 6
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 8 + 7
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          7,
          curveType + 18 * 6 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.set(r, g, b, a);
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == base.MixBlend.setup) {
        light.setFromColor(slot.data.color);
        const setupDark = slot.data.darkColor;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
}
class RGB2Timeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, r2, g2, b2) {
    frame *= 7;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* R2*/
    ] = r2;
    this.frames[
      frame + 5
      /* G2*/
    ] = g2;
    this.frames[
      frame + 6
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case base.MixBlend.setup:
          light.r = setupLight.r;
          light.g = setupLight.g;
          light.b = setupLight.b;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case base.MixBlend.first:
          light.r += (setupLight.r - light.r) * alpha;
          light.g += (setupLight.g - light.g) * alpha;
          light.b += (setupLight.b - light.b) * alpha;
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 7 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 7 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 7 + 3
          /* B*/
        ] - b) * t;
        r2 += (frames[
          i + 7 + 4
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 7 + 5
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 7 + 6
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.r = r;
      light.g = g;
      light.b = b;
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == base.MixBlend.setup) {
        const setupLight = slot.data.color;
        const setupDark = slot.data.darkColor;
        light.r = setupLight.r;
        light.g = setupLight.g;
        light.b = setupLight.b;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.r += (r - light.r) * alpha;
      light.g += (g - light.g) * alpha;
      light.b += (b - light.b) * alpha;
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
}
class AttachmentTimeline extends Timeline {
  constructor(frameCount, slotIndex) {
    super(frameCount, [`${Property.attachment}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachmentNames = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the attachment name for the specified key frame. */
  setFrame(frame, time, attachmentName) {
    this.frames[frame] = time;
    this.attachmentNames[frame] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    if (direction == base.MixDirection.mixOut) {
      if (blend == base.MixBlend.setup)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);
  }
  setAttachment(skeleton, slot, attachmentName) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
}
class DeformTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex, attachment) {
    super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachment = attachment;
    this.vertices = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the vertices for the specified key frame.
   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
  setFrame(frame, time, vertices) {
    this.frames[frame] = time;
    this.vertices[frame] = vertices;
  }
  /** @param value1 Ignored (0 is used for a deform timeline).
   * @param value2 Ignored (1 is used for a deform timeline). */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = cy2 * 0.03 - cy1 * 0.06;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = (cy1 - cy2 + 0.33333333) * 0.018;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  getCurvePercent(time, frame) {
    const curves = this.curves;
    let i = curves[frame];
    switch (i) {
      case 0:
        const x2 = this.frames[frame];
        return (time - x2) / (this.frames[frame + this.getFrameEntries()] - x2);
      case 1:
        return 0;
    }
    i -= 2;
    if (curves[i] > time) {
      const x2 = this.frames[frame];
      return curves[i + 1] * (time - x2) / (curves[i] - x2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.getAttachment();
    if (!slotAttachment)
      return;
    if (!(slotAttachment instanceof Attachment.VertexAttachment) || slotAttachment.timelineAttachment != this.attachment)
      return;
    const deform = slot.deform;
    if (deform.length == 0)
      blend = base.MixBlend.setup;
    const vertices = this.vertices;
    const vertexCount = vertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          deform.length = 0;
          return;
        case base.MixBlend.first:
          if (alpha == 1) {
            deform.length = 0;
            return;
          }
          deform.length = vertexCount;
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (setupVertices[i] - deform[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              deform[i] *= alpha;
          }
      }
      return;
    }
    deform.length = vertexCount;
    if (time >= frames[frames.length - 1]) {
      const lastVertices = vertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == base.MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i] - setupVertices[i];
          } else {
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i];
          }
        } else
          base.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
      } else {
        switch (blend) {
          case base.MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (!vertexAttachment2.bones) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                deform[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case base.MixBlend.first:
          case base.MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (lastVertices[i] - deform[i]) * alpha;
            break;
          case base.MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++)
                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Timeline.search1(frames, time);
    const percent = this.getCurvePercent(time, frame);
    const prevVertices = vertices[frame];
    const nextVertices = vertices[frame + 1];
    if (alpha == 1) {
      if (blend == base.MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (!vertexAttachment.bones) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          deform[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case base.MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (!vertexAttachment2.bones) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case base.MixBlend.first:
        case base.MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;
          }
          break;
        case base.MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
}
const _EventTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _EventTimeline.propertyIds);
    this.events = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the event for the specified key frame. */
  setFrame(frame, event) {
    this.frames[frame] = event.time;
    this.events[frame] = event;
  }
  /** Fires events for frames > `lastTime` and <= `time`. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (!firedEvents)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let i = 0;
    if (lastTime < frames[0])
      i = 0;
    else {
      i = Timeline.search1(frames, lastTime) + 1;
      const frameTime = frames[i];
      while (i > 0) {
        if (frames[i - 1] != frameTime)
          break;
        i--;
      }
    }
    for (; i < frameCount && time >= frames[i]; i++)
      firedEvents.push(this.events[i]);
  }
};
let EventTimeline = _EventTimeline;
EventTimeline.propertyIds = [`${Property.event}`];
const _DrawOrderTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _DrawOrderTimeline.propertyIds);
    this.drawOrders = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the draw order for the specified key frame.
   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
   *           draw order. */
  setFrame(frame, time, drawOrder) {
    this.frames[frame] = time;
    this.drawOrders[frame] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (direction == base.MixDirection.mixOut) {
      if (blend == base.MixBlend.setup)
        base.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        base.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const idx = Timeline.search1(this.frames, time);
    const drawOrderToSetupIndex = this.drawOrders[idx];
    if (!drawOrderToSetupIndex)
      base.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
    else {
      const drawOrder = skeleton.drawOrder;
      const slots = skeleton.slots;
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
};
let DrawOrderTimeline = _DrawOrderTimeline;
DrawOrderTimeline.propertyIds = [`${Property.drawOrder}`];
class IkConstraintTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, ikConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);
    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */
    this.ikConstraintIndex = 0;
    this.ikConstraintIndex = ikConstraintIndex;
  }
  getFrameEntries() {
    return 6;
  }
  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
  setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {
    frame *= 6;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* MIX*/
    ] = mix;
    this.frames[
      frame + 2
      /* SOFTNESS*/
    ] = softness;
    this.frames[
      frame + 3
      /* BEND_DIRECTION*/
    ] = bendDirection;
    this.frames[
      frame + 4
      /* COMPRESS*/
    ] = compress ? 1 : 0;
    this.frames[
      frame + 5
      /* STRETCH*/
    ] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.softness = constraint.data.softness;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case base.MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    let mix = 0;
    let softness = 0;
    const i = Timeline.search(
      frames,
      time,
      6
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 6
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        const t = (time - before) / (frames[
          i + 6
          /* ENTRIES*/
        ] - before);
        mix += (frames[
          i + 6 + 1
          /* MIX*/
        ] - mix) * t;
        softness += (frames[
          i + 6 + 2
          /* SOFTNESS*/
        ] - softness) * t;
        break;
      case 1:
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        break;
      default:
        mix = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        softness = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    if (blend == base.MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
      if (direction == base.MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    } else {
      constraint.mix += (mix - constraint.mix) * alpha;
      constraint.softness += (softness - constraint.softness) * alpha;
      if (direction == base.MixDirection.mixIn) {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    }
  }
}
class TransformConstraintTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, transformConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);
    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */
    this.transformConstraintIndex = 0;
    this.transformConstraintIndex = transformConstraintIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
  setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
    const frames = this.frames;
    frame *= 7;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
    frames[
      frame + 4
      /* SCALEX*/
    ] = mixScaleX;
    frames[
      frame + 5
      /* SCALEY*/
    ] = mixScaleY;
    frames[
      frame + 6
      /* SHEARY*/
    ] = mixShearY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case base.MixBlend.setup:
          constraint.mixRotate = data.mixRotate;
          constraint.mixX = data.mixX;
          constraint.mixY = data.mixY;
          constraint.mixScaleX = data.mixScaleX;
          constraint.mixScaleY = data.mixScaleY;
          constraint.mixShearY = data.mixShearY;
          return;
        case base.MixBlend.first:
          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (data.mixY - constraint.mixY) * alpha;
          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;
          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;
          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    let scaleX;
    let scaleY;
    let shearY;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 7 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 7 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 7 + 3
          /* Y*/
        ] - y) * t;
        scaleX += (frames[
          i + 7 + 4
          /* SCALEX*/
        ] - scaleX) * t;
        scaleY += (frames[
          i + 7 + 5
          /* SCALEY*/
        ] - scaleY) * t;
        shearY += (frames[
          i + 7 + 6
          /* SHEARY*/
        ] - shearY) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        scaleX = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        scaleY = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        shearY = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (blend == base.MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;
      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;
      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;
      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;
      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;
    }
  }
}
class PathConstraintPositionTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);
    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case base.MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    const position = this.getCurveValue(time);
    if (blend == base.MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
}
class PathConstraintSpacingTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);
    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case base.MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    const spacing = this.getCurveValue(time);
    if (blend == base.MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
}
class PathConstraintMixTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);
    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  getFrameEntries() {
    return 4;
  }
  setFrame(frame, time, mixRotate, mixX, mixY) {
    const frames = this.frames;
    frame <<= 2;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          constraint.mixRotate = constraint.data.mixRotate;
          constraint.mixX = constraint.data.mixX;
          constraint.mixY = constraint.data.mixY;
          return;
        case base.MixBlend.first:
          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 4 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 4 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 4 + 3
          /* Y*/
        ] - y) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (blend == base.MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
    }
  }
}
const _SequenceTimeline = class extends Timeline {
  constructor(frameCount, slotIndex, attachment) {
    super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);
    this.slotIndex = slotIndex;
    this.attachment = attachment;
  }
  getFrameEntries() {
    return _SequenceTimeline.ENTRIES;
  }
  getSlotIndex() {
    return this.slotIndex;
  }
  getAttachment() {
    return this.attachment;
  }
  /** Sets the time, mode, index, and frame time for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time Seconds between frames. */
  setFrame(frame, time, mode, index, delay) {
    const frames = this.frames;
    frame *= _SequenceTimeline.ENTRIES;
    frames[frame] = time;
    frames[frame + _SequenceTimeline.MODE] = mode | index << 4;
    frames[frame + _SequenceTimeline.DELAY] = delay;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.attachment;
    const attachment = this.attachment;
    if (slotAttachment != attachment) {
      if (!(slotAttachment instanceof Attachment.VertexAttachment) || slotAttachment.timelineAttachment != attachment)
        return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        slot.sequenceIndex = -1;
      return;
    }
    const i = Timeline.search(frames, time, _SequenceTimeline.ENTRIES);
    const before = frames[i];
    const modeAndIndex = frames[i + _SequenceTimeline.MODE];
    const delay = frames[i + _SequenceTimeline.DELAY];
    if (!this.attachment.sequence)
      return;
    let index = modeAndIndex >> 4;
    const count = this.attachment.sequence.regions.length;
    const mode = Sequence.SequenceModeValues[modeAndIndex & 15];
    if (mode != Sequence.SequenceMode.hold) {
      index += (time - before) / delay + 1e-5 | 0;
      switch (mode) {
        case Sequence.SequenceMode.once:
          index = Math.min(count - 1, index);
          break;
        case Sequence.SequenceMode.loop:
          index %= count;
          break;
        case Sequence.SequenceMode.pingpong: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : index % n;
          if (index >= count)
            index = n - index;
          break;
        }
        case Sequence.SequenceMode.onceReverse:
          index = Math.max(count - 1 - index, 0);
          break;
        case Sequence.SequenceMode.loopReverse:
          index = count - 1 - index % count;
          break;
        case Sequence.SequenceMode.pingpongReverse: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : (index + count - 1) % n;
          if (index >= count)
            index = n - index;
        }
      }
    }
    slot.sequenceIndex = index;
  }
};
let SequenceTimeline = _SequenceTimeline;
SequenceTimeline.ENTRIES = 3;
SequenceTimeline.MODE = 1;
SequenceTimeline.DELAY = 2;

exports.AlphaTimeline = AlphaTimeline;
exports.Animation = Animation;
exports.AttachmentTimeline = AttachmentTimeline;
exports.CurveTimeline = CurveTimeline;
exports.CurveTimeline1 = CurveTimeline1;
exports.CurveTimeline2 = CurveTimeline2;
exports.DeformTimeline = DeformTimeline;
exports.DrawOrderTimeline = DrawOrderTimeline;
exports.EventTimeline = EventTimeline;
exports.IkConstraintTimeline = IkConstraintTimeline;
exports.PathConstraintMixTimeline = PathConstraintMixTimeline;
exports.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
exports.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
exports.RGB2Timeline = RGB2Timeline;
exports.RGBA2Timeline = RGBA2Timeline;
exports.RGBATimeline = RGBATimeline;
exports.RGBTimeline = RGBTimeline;
exports.RotateTimeline = RotateTimeline;
exports.ScaleTimeline = ScaleTimeline;
exports.ScaleXTimeline = ScaleXTimeline;
exports.ScaleYTimeline = ScaleYTimeline;
exports.SequenceTimeline = SequenceTimeline;
exports.ShearTimeline = ShearTimeline;
exports.ShearXTimeline = ShearXTimeline;
exports.ShearYTimeline = ShearYTimeline;
exports.Timeline = Timeline;
exports.TransformConstraintTimeline = TransformConstraintTimeline;
exports.TranslateTimeline = TranslateTimeline;
exports.TranslateXTimeline = TranslateXTimeline;
exports.TranslateYTimeline = TranslateYTimeline;
//# sourceMappingURL=Animation.js.map


/***/ }),

/***/ 94649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var Animation = __webpack_require__(97294);

const _AnimationState = class {
  constructor(data) {
    /** The list of tracks that currently have animations, which may contain null entries. */
    this.tracks = new Array();
    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
     * or faster. Defaults to 1.
     *
     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */
    this.timeScale = 1;
    this.unkeyedState = 0;
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new base.StringSet();
    this.animationsChanged = false;
    this.trackEntryPool = new base.Pool(() => new TrackEntry());
    this.data = data;
  }
  static emptyAnimation() {
    return _AnimationState._emptyAnimation;
  }
  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {
        tracks[i] = null;
        this.queue.end(current);
        this.clearNext(current);
        continue;
      }
      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from)
          from.mixingTo = null;
        while (from) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  /** Returns true when all mixing from entries are complete. */
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (!from)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
   * animation state can be applied to multiple skeletons to pose them identically.
   * @returns True if any animations were applied. */
  apply(skeleton) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? base.MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && !current.next)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      let applyTime = animationTime;
      let applyEvents = events;
      if (current.reverse) {
        applyTime = current.animation.duration - applyTime;
        applyEvents = null;
      }
      const timelines = current.animation.timelines;
      const timelineCount = timelines.length;
      if (i == 0 && mix == 1 || blend == base.MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          base.Utils.webkit602BugfixHelper(mix, blend);
          const timeline = timelines[ii];
          if (timeline instanceof Animation.AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          else
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, base.MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const shortestRotation = current.shortestRotation;
        const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;
        if (firstFrame)
          current.timelinesRotation.length = timelineCount << 1;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : base.MixBlend.setup;
          if (!shortestRotation && timeline instanceof Animation.RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);
          } else if (timeline instanceof Animation.AttachmentTimeline) {
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          } else {
            base.Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, base.MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    const setupState = this.unkeyedState + SETUP;
    const slots = skeleton.slots;
    for (let i = 0, n = skeleton.slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.attachmentState == setupState) {
        const attachmentName = slot.data.attachmentName;
        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      }
    }
    this.unkeyedState += 2;
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == base.MixBlend.first)
        blend = base.MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != base.MixBlend.first)
        blend = from.mixBlend;
    }
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const timelines = from.animation.timelines;
    const timelineCount = timelines.length;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    let applyTime = animationTime;
    let events = null;
    if (from.reverse)
      applyTime = from.animation.duration - applyTime;
    else if (mix < from.eventThreshold)
      events = this.events;
    if (blend == base.MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, base.MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const shortestRotation = from.shortestRotation;
      const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;
      if (firstFrame)
        from.timelinesRotation.length = timelineCount << 1;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = base.MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case SUBSEQUENT:
            if (!drawOrder && timeline instanceof Animation.DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case FIRST:
            timelineBlend = base.MixBlend.setup;
            alpha = alphaMix;
            break;
          case HOLD_SUBSEQUENT:
            timelineBlend = blend;
            alpha = alphaHold;
            break;
          case HOLD_FIRST:
            timelineBlend = base.MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = base.MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (!shortestRotation && timeline instanceof Animation.RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);
        else if (timeline instanceof Animation.AttachmentTimeline)
          this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);
        else {
          base.Utils.webkit602BugfixHelper(alpha, blend);
          if (drawOrder && timeline instanceof Animation.DrawOrderTimeline && timelineBlend == base.MixBlend.setup)
            direction = base.MixDirection.mixIn;
          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {
    const slot = skeleton.slots[timeline.slotIndex];
    if (!slot.bone.active)
      return;
    if (time < timeline.frames[0]) {
      if (blend == base.MixBlend.setup || blend == base.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
    } else
      this.setAttachment(skeleton, slot, timeline.attachmentNames[Animation.Timeline.search1(timeline.frames, time)], attachments);
    if (slot.attachmentState <= this.unkeyedState)
      slot.attachmentState = this.unkeyedState + SETUP;
  }
  setAttachment(skeleton, slot, attachmentName, attachments) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
    if (attachments)
      slot.attachmentState = this.unkeyedState + CURRENT;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, base.MixDirection.mixIn);
      return;
    }
    const bone = skeleton.bones[timeline.boneIndex];
    if (!bone.active)
      return;
    const frames = timeline.frames;
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case base.MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case base.MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == base.MixBlend.setup ? bone.data.rotation : bone.rotation;
      r2 = bone.data.rotation + timeline.getCurveValue(time);
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (base.MathUtils.signum(lastDiff) != base.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * base.MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * base.MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    bone.rotation = r1 + total * alpha;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, event);
    }
  }
  /** Removes all animations from all tracks, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  /** Removes all animations from the track, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (!current)
      return;
    this.queue.end(current);
    this.clearNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (!from)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    current.previous = null;
    if (from) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  /** Sets an animation by name.
   *
   * See {@link #setAnimationWith()}. */
  setAnimation(trackIndex, animationName, loop = false) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
   * applied to a skeleton, it is replaced (not mixed from).
   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  setAnimationWith(trackIndex, animation, loop = false) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.clearNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.clearNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  /** Queues an animation by name.
   *
   * See {@link #addAnimationWith()}. */
  addAnimation(trackIndex, animationName, loop = false, delay = 0) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
   * equivalent to calling {@link #setAnimationWith()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
   *           previous entry is looping, its next loop completion is used instead of its duration.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addAnimationWith(trackIndex, animation, loop = false, delay = 0) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last) {
      while (last.next)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (!last) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      entry.previous = last;
      if (delay <= 0)
        delay += last.getTrackComplete() - entry.mixDuration;
    }
    entry.delay = delay;
    return entry;
  }
  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
   *
   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
   * 0 still mixes out over one frame.
   *
   * Mixing in is done by first setting an empty animation, then adding an animation using
   * {@link #addAnimation()} and on the returned track entry, set the
   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
  setEmptyAnimation(trackIndex, mixDuration = 0) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
   * {@link #setEmptyAnimation()}.
   *
   * See {@link #setEmptyAnimation()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
   *           loop completion is used instead of its duration.
   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false, delay);
    if (delay <= 0)
      entry.delay += entry.mixDuration - mixDuration;
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
   * duration. */
  setEmptyAnimations(mixDuration = 0) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    base.Utils.ensureArrayCapacity(this.tracks, index + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  /** @param last May be null. */
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.reset();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.reverse = false;
    entry.shortestRotation = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);
    entry.interruptAlpha = 1;
    entry.totalAlpha = 0;
    entry.mixBlend = base.MixBlend.replace;
    return entry;
  }
  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */
  clearNext(entry) {
    let next = entry.next;
    while (next) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      let entry = tracks[i];
      if (!entry)
        continue;
      while (entry.mixingFrom)
        entry = entry.mixingFrom;
      do {
        if (!entry.mixingTo || entry.mixBlend != base.MixBlend.add)
          this.computeHold(entry);
        entry = entry.mixingTo;
      } while (entry);
    }
  }
  computeHold(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = entry.timelineMode;
    timelineMode.length = timelinesCount;
    const timelineHoldMix = entry.timelineHoldMix;
    timelineHoldMix.length = 0;
    const propertyIDs = this.propertyIDs;
    if (to && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++)
        timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const timeline = timelines[i];
        const ids = timeline.getPropertyIds();
        if (!propertyIDs.addAll(ids))
          timelineMode[i] = SUBSEQUENT;
        else if (!to || timeline instanceof Animation.AttachmentTimeline || timeline instanceof Animation.DrawOrderTimeline || timeline instanceof Animation.EventTimeline || !to.animation.hasTimeline(ids)) {
          timelineMode[i] = FIRST;
        } else {
          for (let next = to.mixingTo; next; next = next.mixingTo) {
            if (next.animation.hasTimeline(ids))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = HOLD_MIX;
              timelineHoldMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = HOLD_FIRST;
        }
      }
  }
  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  /** Adds a listener to receive events for all track entries. */
  addListener(listener) {
    if (!listener)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener()}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  /** Removes all listeners added with {@link #addListener()}. */
  clearListeners() {
    this.listeners.length = 0;
  }
  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
   * are not wanted because new animations are being set. */
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
let AnimationState = _AnimationState;
AnimationState._emptyAnimation = new Animation.Animation("<empty>", [], 0);
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
const _TrackEntry = class {
  constructor() {
    /** The animation to apply for this track entry. */
    this.animation = null;
    this.previous = null;
    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */
    this.next = null;
    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */
    this.mixingFrom = null;
    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */
    this.mixingTo = null;
    /** The listener for events generated by this track entry, or null.
     *
     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation
     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */
    this.listener = null;
    /** The index of the track where this track entry is either current or queued.
     *
     * See {@link AnimationState#getCurrent()}. */
    this.trackIndex = 0;
    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
     * duration. */
    this.loop = false;
    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
     * of being mixed out.
     *
     * When mixing between animations that key the same property, if a lower track also keys that property then the value will
     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation
     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
     * keys the property, only when a higher track also keys the property.
     *
     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the
     * previous animation. */
    this.holdPrevious = false;
    this.reverse = false;
    this.shortestRotation = false;
    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
     * timelines are not applied while this animation is being mixed out. */
    this.eventThreshold = 0;
    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the
     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to
     * 0, so attachment timelines are not applied while this animation is being mixed out. */
    this.attachmentThreshold = 0;
    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,
     * so draw order timelines are not applied while this animation is being mixed out. */
    this.drawOrderThreshold = 0;
    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.
     *
     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same
     * value to prevent timeline keys before the start time from triggering. */
    this.animationStart = 0;
    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will
     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */
    this.animationEnd = 0;
    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and
     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
     * is applied. */
    this.animationLast = 0;
    this.nextAnimationLast = 0;
    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`
     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from
     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous
     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).
     *
     * {@link #timeScale} affects the delay. */
    this.delay = 0;
    /** Current time in seconds this track entry has been the current track entry. The track time determines
     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting
     * looping. */
    this.trackTime = 0;
    this.trackLast = 0;
    this.nextTrackLast = 0;
    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float
     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time
     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the
     * properties keyed by the animation are set to the setup pose and the track is cleared.
     *
     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation
     * abruptly cease being applied. */
    this.trackEnd = 0;
    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or
     * faster. Defaults to 1.
     *
     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to
     * match the animation speed.
     *
     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If
     * the time scale is not 1, the delay may need to be adjusted.
     *
     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */
    this.timeScale = 0;
    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults
     * to 1, which overwrites the skeleton's current pose with this animation.
     *
     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to
     * use alpha on track 0 if the skeleton pose is from the last frame render. */
    this.alpha = 0;
    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be
     * slightly more than `mixDuration` when the mix is complete. */
    this.mixTime = 0;
    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData
     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).
     *
     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the
     * properties it was animating.
     *
     * The `mixDuration` can be set manually rather than use the value from
     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new
     * track entry only before {@link AnimationState#update(float)} is first called.
     *
     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set
     * afterward. */
    this.mixDuration = 0;
    this.interruptAlpha = 0;
    this.totalAlpha = 0;
    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which
     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to
     * the values from the lower tracks.
     *
     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first
     * called. */
    this.mixBlend = base.MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.previous = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
   * `animationStart` time. */
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  /** Returns true if at least one loop has been completed.
   *
   * See {@link AnimationStateListener#complete()}. */
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
   * long way around when using {@link #alpha} and starting animations on other tracks.
   *
   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  getTrackComplete() {
    const duration = this.animationEnd - this.animationStart;
    if (duration != 0) {
      if (this.loop)
        return duration * (1 + (this.trackTime / duration | 0));
      if (this.trackTime < duration)
        return duration;
    }
    return this.trackTime;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
let TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
class EventQueue {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.start)
              listener.start(entry);
          }
          break;
        case EventType.interrupt:
          if (entry.listener && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.interrupt)
              listener.interrupt(entry);
          }
          break;
        case EventType.end:
          if (entry.listener && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.end)
              listener.end(entry);
          }
        case EventType.dispose:
          if (entry.listener && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.dispose)
              listener.dispose(entry);
          }
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.complete)
              listener.complete(entry);
          }
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.event)
              listener.event(entry, event);
          }
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
}
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
  return EventType2;
})(EventType || {});
class AnimationStateAdapter {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
}
const SUBSEQUENT = 0;
const FIRST = 1;
const HOLD_SUBSEQUENT = 2;
const HOLD_FIRST = 3;
const HOLD_MIX = 4;
const SETUP = 1;
const CURRENT = 2;

exports.AnimationState = AnimationState;
exports.AnimationStateAdapter = AnimationStateAdapter;
exports.EventQueue = EventQueue;
exports.EventType = EventType;
exports.TrackEntry = TrackEntry;
//# sourceMappingURL=AnimationState.js.map


/***/ }),

/***/ 11657:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class AnimationStateData {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    /** The mix duration to use when no mix duration has been defined between two animations. */
    this.defaultMix = 0;
    if (!skeletonData)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  /** Sets a mix duration by animation name.
   *
   * See {@link #setMixWith()}. */
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (!from)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (!to)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  /** Sets the mix duration when changing from the specified animation to the other.
   *
   * See {@link TrackEntry#mixDuration}. */
  setMixWith(from, to, duration) {
    if (!from)
      throw new Error("from cannot be null.");
    if (!to)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if
   * no mix duration has been set. */
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
}

exports.AnimationStateData = AnimationStateData;
//# sourceMappingURL=AnimationStateData.js.map


/***/ }),

/***/ 66265:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(79660);
var BoundingBoxAttachment = __webpack_require__(77761);
var ClippingAttachment = __webpack_require__(3434);
var MeshAttachment = __webpack_require__(36065);
var PathAttachment = __webpack_require__(70099);
var PointAttachment = __webpack_require__(64506);
var RegionAttachment = __webpack_require__(40192);
__webpack_require__(89688);

class AtlasAttachmentLoader {
  constructor(atlas) {
    this.atlas = atlas;
  }
  loadSequence(name, basePath, sequence) {
    const regions = sequence.regions;
    for (let i = 0, n = regions.length; i < n; i++) {
      const path = sequence.getPath(basePath, i);
      const region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);
      regions[i] = region;
      regions[i].renderObject = regions[i];
    }
  }
  newRegionAttachment(skin, name, path, sequence) {
    const attachment = new RegionAttachment.RegionAttachment(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newMeshAttachment(skin, name, path, sequence) {
    const attachment = new MeshAttachment.MeshAttachment(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newBoundingBoxAttachment(skin, name) {
    return new BoundingBoxAttachment.BoundingBoxAttachment(name);
  }
  newPathAttachment(skin, name) {
    return new PathAttachment.PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new PointAttachment.PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new ClippingAttachment.ClippingAttachment(name);
  }
}

exports.AtlasAttachmentLoader = AtlasAttachmentLoader;
//# sourceMappingURL=AtlasAttachmentLoader.js.map


/***/ }),

/***/ 28660:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var base = __webpack_require__(55075);

class Bone {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    // be careful! Spine b,c is c,b in pixi matrix
    this.matrix = new core.Matrix();
    /** The parent bone, or null if this is the root bone. */
    this.parent = null;
    /** The immediate children of this bone. */
    this.children = new Array();
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local rotation in degrees, counter clockwise. */
    this.rotation = 0;
    /** The local scaleX. */
    this.scaleX = 0;
    /** The local scaleY. */
    this.scaleY = 0;
    /** The local shearX. */
    this.shearX = 0;
    /** The local shearY. */
    this.shearY = 0;
    /** The applied local x translation. */
    this.ax = 0;
    /** The applied local y translation. */
    this.ay = 0;
    /** The applied local rotation in degrees, counter clockwise. */
    this.arotation = 0;
    /** The applied local scaleX. */
    this.ascaleX = 0;
    /** The applied local scaleY. */
    this.ascaleY = 0;
    /** The applied local shearX. */
    this.ashearX = 0;
    /** The applied local shearY. */
    this.ashearY = 0;
    this.sorted = false;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the
   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */
  isActive() {
    return this.active;
  }
  /** Computes the world transform using the parent bone and this bone's local applied transform. */
  update() {
    this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform.
   *
   * See {@link #updateWorldTransformWith()}. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the
   * specified local transform. Child bones are not updated.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = base.settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (!parent) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = base.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = base.MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = base.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = base.MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case base.TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = base.MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = base.MathUtils.cosDeg(rotationY) * scaleY;
        const lc = base.MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = base.MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case base.TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = base.MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = base.MathUtils.cosDeg(rotationY) * scaleY;
        m.b = base.MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = base.MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case base.TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pa /= sx;
          pc /= sy;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * base.MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * base.MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = base.MathUtils.cosDeg(rx) * scaleX;
        const lb = base.MathUtils.cosDeg(ry) * scaleY;
        const lc = base.MathUtils.sinDeg(rx) * scaleX;
        const ld = base.MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case base.TransformMode.NoScale:
      case base.TransformMode.NoScaleOrReflection: {
        const cos = base.MathUtils.cosDeg(rotation);
        const sin = base.MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == base.TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = base.MathUtils.cosDeg(shearX) * scaleX;
        const lb = base.MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = base.MathUtils.sinDeg(shearX) * scaleX;
        const ld = base.MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  /** Sets this bone's local transform to the setup pose. */
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * base.MathUtils.radDeg;
  }
  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * base.MathUtils.radDeg;
  }
  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.b * m.b);
  }
  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.c * m.c + m.d * m.d);
  }
  /** Computes the applied transform values from the world transform.
   *
   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so
   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other
   * constraints).
   *
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after
   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */
  updateAppliedTransform() {
    const parent = this.parent;
    const m = this.matrix;
    if (!parent) {
      this.ax = m.tx - this.skeleton.x;
      this.ay = m.ty - this.skeleton.y;
      this.arotation = Math.atan2(m.b, m.a) * base.MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * base.MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * base.MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * base.MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * base.MathUtils.radDeg;
    }
  }
  /** Transforms a point from world coordinates to the bone's local coordinates. */
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  /** Transforms a point from the bone's local coordinates to world coordinates. */
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  /** Transforms a world rotation to a local rotation. */
  worldToLocalRotation(worldRotation) {
    const sin = base.MathUtils.sinDeg(worldRotation);
    const cos = base.MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * base.MathUtils.radDeg;
  }
  /** Transforms a local rotation to a world rotation. */
  localToWorldRotation(localRotation) {
    localRotation -= this.rotation - this.shearX;
    const sin = base.MathUtils.sinDeg(localRotation);
    const cos = base.MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * base.MathUtils.radDeg;
  }
  /** Rotates the world transform the specified amount.
   * <p>
   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will
   * need to be called on any child bones, recursively. */
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = base.MathUtils.cosDeg(degrees);
    const sin = base.MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
  }
}

exports.Bone = Bone;
//# sourceMappingURL=Bone.js.map


/***/ }),

/***/ 53916:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class BoneData {
  constructor(index, name, parent) {
    /** The index of the bone in {@link Skeleton#getBones()}. */
    this.index = 0;
    /** @returns May be null. */
    this.parent = null;
    /** The bone's length. */
    this.length = 0;
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local rotation. */
    this.rotation = 0;
    /** The local scaleX. */
    this.scaleX = 1;
    /** The local scaleY. */
    this.scaleY = 1;
    /** The local shearX. */
    this.shearX = 0;
    /** The local shearX. */
    this.shearY = 0;
    /** The transform mode for how parent world transforms affect this bone. */
    this.transformMode = base.TransformMode.Normal;
    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this
     * bone.
     * @see Skin#bones */
    this.skinRequired = false;
    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually
     * rendered at runtime. */
    this.color = new base.Color();
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
}

exports.BoneData = BoneData;
//# sourceMappingURL=BoneData.js.map


/***/ }),

/***/ 14101:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class ConstraintData {
  constructor(name, order, skinRequired) {
    this.name = name;
    this.order = order;
    this.skinRequired = skinRequired;
  }
}

exports.ConstraintData = ConstraintData;
//# sourceMappingURL=ConstraintData.js.map


/***/ }),

/***/ 2684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class Event {
  constructor(time, data) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.time = 0;
    this.volume = 0;
    this.balance = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
}

exports.Event = Event;
//# sourceMappingURL=Event.js.map


/***/ }),

/***/ 26628:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class EventData {
  constructor(name) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.audioPath = null;
    this.volume = 0;
    this.balance = 0;
    this.name = name;
  }
}

exports.EventData = EventData;
//# sourceMappingURL=EventData.js.map


/***/ }),

/***/ 49821:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class IkConstraint {
  constructor(data, skeleton) {
    /** Controls the bend direction of the IK bones, either 1 or -1. */
    this.bendDirection = 0;
    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
    this.compress = false;
    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
     * and the parent bone has local nonuniform scale, stretch is not applied. */
    this.stretch = false;
    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
    this.mix = 1;
    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
    this.softness = 0;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.softness = data.softness;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find bone ${data.target.name}`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mix == 0)
      return;
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
        break;
    }
  }
  /** Applies 1 bone IK. The target is specified in the world coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    const p = bone.parent.matrix;
    if (!p)
      throw new Error("IK bone must have parent.");
    const pa = p.a;
    let pb = p.c;
    const pc = p.b;
    let pd = p.d;
    let rotationIK = -bone.ashearX - bone.arotation;
    let tx = 0;
    let ty = 0;
    const skelX = bone.skeleton.scaleX;
    const skelY = base.settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;
    switch (bone.data.transformMode) {
      case base.TransformMode.OnlyTranslation:
        tx = (targetX - bone.worldX) * base.MathUtils.signum(skelX);
        ty = (targetY - bone.worldY) * base.MathUtils.signum(skelY);
        break;
      case base.TransformMode.NoRotationOrReflection:
        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
        const sa = pa / skelX;
        const sc = pc / skelY;
        pb = -sc * s * skelX;
        pd = sa * s * skelY;
        rotationIK += Math.atan2(sc, sa) * base.MathUtils.radDeg;
      default:
        const x = targetX - p.tx;
        const y = targetY - p.ty;
        const d = pa * pd - pb * pc;
        tx = (x * pd - y * pb) / d - bone.ax;
        ty = (y * pa - x * pc) / d - bone.ay;
    }
    rotationIK += Math.atan2(ty, tx) * base.MathUtils.radDeg;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      switch (bone.data.transformMode) {
        case base.TransformMode.NoScale:
        case base.TransformMode.NoScaleOrReflection:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
      }
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Applies 2 bone IK. The target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let psy = parent.ascaleY;
    let sx = psx;
    let sy = psy;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u || stretch) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    if (!pp)
      throw new Error("IK parent must itself have a parent.");
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = cwx - pp.tx;
    let y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1;
    let a2;
    if (l1 < 1e-4) {
      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
      return;
    }
    x = targetX - pp.tx;
    y = targetY - pp.ty;
    let tx = (x * d - y * b) * id - px;
    let ty = (y * a - x * c) * id - py;
    let dd = tx * tx + ty * ty;
    if (softness != 0) {
      softness *= psx * (csx + 1) * 0.5;
      const td = Math.sqrt(dd);
      const sd = td - l1 - l2 * psx + softness;
      if (sd > 0) {
        let p = Math.min(1, sd / (softness * 2)) - 1;
        p = (sd - softness * (1 - p * p)) / td;
        tx -= p * tx;
        ty -= p * ty;
        dd = tx * tx + ty * ty;
      }
    }
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1) {
          cos = -1;
          a2 = Math.PI * bendDir;
        } else if (cos > 1) {
          cos = 1;
          a2 = 0;
          if (stretch) {
            a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
            sx *= a;
            if (uniform)
              sy *= a;
          }
        } else
          a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) * 0.5;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = base.MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) * 0.5) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * base.MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * base.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
}

exports.IkConstraint = IkConstraint;
//# sourceMappingURL=IkConstraint.js.map


/***/ }),

/***/ 12957:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var ConstraintData = __webpack_require__(14101);

class IkConstraintData extends ConstraintData.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that are constrained by this IK constraint. */
    this.bones = new Array();
    /** The bone that is the IK target. */
    this._target = null;
    /** Controls the bend direction of the IK bones, either 1 or -1. */
    this.bendDirection = 1;
    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
    this.compress = false;
    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
     * and the parent bone has local nonuniform scale, stretch is not applied. */
    this.stretch = false;
    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone
     * is scaled on both the X and Y axes. */
    this.uniform = false;
    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
    this.mix = 1;
    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
    this.softness = 0;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
}

exports.IkConstraintData = IkConstraintData;
//# sourceMappingURL=IkConstraintData.js.map


/***/ }),

/***/ 22990:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(79660);
var base = __webpack_require__(55075);
var PathAttachment = __webpack_require__(70099);
__webpack_require__(40192);
__webpack_require__(89688);
var PathConstraintData = __webpack_require__(85502);

const _PathConstraint = class {
  constructor(data, skeleton) {
    /** The position along the path. */
    this.position = 0;
    /** The spacing between bones. */
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findSlot(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}`);
    this.target = target;
    this.position = data.position;
    this.spacing = data.spacing;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
  }
  isActive() {
    return this.active;
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof PathAttachment.PathAttachment))
      return;
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    if (mixRotate == 0 && mixX == 0 && mixY == 0)
      return;
    const data = this.data;
    const tangents = data.rotateMode == base.RotateMode.Tangent;
    const scale = data.rotateMode == base.RotateMode.ChainScale;
    const bones = this.bones;
    const boneCount = bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const spaces = base.Utils.setArraySize(this.spaces, spacesCount);
    const lengths = scale ? this.lengths = base.Utils.setArraySize(this.lengths, boneCount) : [];
    const spacing = this.spacing;
    switch (data.spacingMode) {
      case PathConstraintData.SpacingMode.Percent:
        if (scale) {
          for (let i = 0, n = spacesCount - 1; i < n; i++) {
            const bone = bones[i];
            const setupLength = bone.data.length;
            if (setupLength < _PathConstraint.epsilon)
              lengths[i] = 0;
            else {
              const x = setupLength * bone.matrix.a;
              const y = setupLength * bone.matrix.b;
              lengths[i] = Math.sqrt(x * x + y * y);
            }
          }
        }
        base.Utils.arrayFill(spaces, 1, spacesCount, spacing);
        break;
      case PathConstraintData.SpacingMode.Proportional:
        let sum = 0;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = length;
            sum += length;
          }
        }
        if (sum > 0) {
          sum = spacesCount / sum * spacing;
          for (let i = 1; i < spacesCount; i++)
            spaces[i] *= sum;
        }
        break;
      default:
        const lengthSpacing = data.spacingMode == PathConstraintData.SpacingMode.Length;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
          }
        }
    }
    const positions = this.computeWorldPositions(attachment, spacesCount, tangents);
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = data.rotateMode == base.RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * mixX;
      mat.ty += (boneY - mat.ty) * mixY;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (mixRotate > 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          r = positions[p - 1];
        else if (spaces[i + 1] == 0)
          r = positions[p + 2];
        else
          r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;
          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;
        } else {
          r += offsetRotation;
        }
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= mixRotate;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.updateAppliedTransform();
    }
  }
  computeWorldPositions(path, spacesCount, tangents) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = base.Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = this.world;
    const closed = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (this.data.positionMode == base.PositionMode.Percent)
        position *= pathLength2;
      let multiplier2;
      switch (this.data.spacingMode) {
        case PathConstraintData.SpacingMode.Percent:
          multiplier2 = pathLength2;
          break;
        case PathConstraintData.SpacingMode.Proportional:
          multiplier2 = pathLength2 / spacesCount;
          break;
        default:
          multiplier2 = 1;
      }
      world = base.Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i] * multiplier2;
        position += space;
        let p = position;
        if (closed) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed) {
      verticesLength += 2;
      world = base.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = base.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = base.Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (this.data.positionMode == base.PositionMode.Percent)
      position *= pathLength;
    let multiplier;
    switch (this.data.spacingMode) {
      case PathConstraintData.SpacingMode.Percent:
        multiplier = pathLength;
        break;
      case PathConstraintData.SpacingMode.Proportional:
        multiplier = pathLength / spacesCount;
        break;
      default:
        multiplier = 1;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i] * multiplier;
      position += space;
      let p = position;
      if (closed) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p)) {
      out[o] = x1;
      out[o + 1] = y1;
      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      return;
    }
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents) {
      if (p < 1e-3)
        out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      else
        out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    }
  }
};
let PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;

exports.PathConstraint = PathConstraint;
//# sourceMappingURL=PathConstraint.js.map


/***/ }),

/***/ 85502:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var ConstraintData = __webpack_require__(14101);
var base = __webpack_require__(55075);

class PathConstraintData extends ConstraintData.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that will be modified by this path constraint. */
    this.bones = new Array();
    /** The slot whose path attachment will be used to constrained the bones. */
    this._target = null;
    /** The mode for positioning the first bone on the path. */
    this.positionMode = base.PositionMode.Fixed;
    /** The mode for positioning the bones after the first bone on the path. */
    this.spacingMode = SpacingMode.Fixed;
    /** The mode for adjusting the rotation of the bones. */
    this.rotateMode = base.RotateMode.Chain;
    /** An offset added to the constrained bone rotation. */
    this.offsetRotation = 0;
    /** The position along the path. */
    this.position = 0;
    /** The spacing between bones. */
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
  }
  set target(slotData) {
    this._target = slotData;
  }
  get target() {
    if (!this._target)
      throw new Error("SlotData not set.");
    else
      return this._target;
  }
}
var SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  SpacingMode2[SpacingMode2["Proportional"] = 3] = "Proportional";
  return SpacingMode2;
})(SpacingMode || {});

exports.PathConstraintData = PathConstraintData;
exports.SpacingMode = SpacingMode;
//# sourceMappingURL=PathConstraintData.js.map


/***/ }),

/***/ 8665:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(79660);
var base = __webpack_require__(55075);
var MeshAttachment = __webpack_require__(36065);
var PathAttachment = __webpack_require__(70099);
var RegionAttachment = __webpack_require__(40192);
__webpack_require__(89688);
var Bone = __webpack_require__(28660);
var Slot = __webpack_require__(7378);
var IkConstraint = __webpack_require__(49821);
var TransformConstraint = __webpack_require__(33615);
var PathConstraint = __webpack_require__(22990);

const _Skeleton = class {
  constructor(data) {
    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */
    this._updateCache = new Array();
    /** The skeleton's current skin. May be null. */
    this.skin = null;
    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale
     * inheritance. */
    this.scaleX = 1;
    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale
     * inheritance. */
    this.scaleY = 1;
    /** Sets the skeleton X position, which is added to the root bone worldX position. */
    this.x = 0;
    /** Sets the skeleton Y position, which is added to the root bone worldY position. */
    this.y = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (!boneData.parent)
        bone = new Bone.Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new Bone.Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new Slot.Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new IkConstraint.IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new TransformConstraint.TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new PathConstraint.PathConstraint(pathConstraintData, this));
    }
    this.color = new base.Color(1, 1, 1, 1);
    this.updateCache();
  }
  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,
   * constraints, or weighted path attachments are added or removed. */
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.sorted = bone.data.skinRequired;
      bone.active = !bone.sorted;
    }
    if (this.skin) {
      const skinBones = this.skin.bones;
      for (let i = 0, n = this.skin.bones.length; i < n; i++) {
        let bone = this.bones[skinBones[i].index];
        do {
          bone.sorted = false;
          bone.active = true;
          bone = bone.parent;
        } while (bone);
      }
    }
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && base.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length == 1) {
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
    } else {
      const child = constrained[constrained.length - 1];
      this.sortBone(child);
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      child.sorted = true;
    }
  }
  sortPathConstraint(constraint) {
    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && base.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof PathAttachment.PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && base.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        this.sortBone(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof PathAttachment.PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (!pathBones)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      for (let i = 0, n = pathBones.length; i < n; ) {
        let nn = pathBones[i++];
        nn += i;
        while (i < nn)
          this.sortBone(bones[pathBones[i++]]);
      }
    }
  }
  sortBone(bone) {
    if (!bone)
      return;
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.active)
        continue;
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies all constraints.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransform() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  updateWorldTransformWith(parent) {
    const rootBone = this.getRootBone();
    const pa = parent.matrix.a;
    const pb = parent.matrix.c;
    const pc = parent.matrix.b;
    const pd = parent.matrix.d;
    rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;
    rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;
    const rotationY = rootBone.rotation + 90 + rootBone.shearY;
    const la = base.MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const lb = base.MathUtils.cosDeg(rotationY) * rootBone.scaleY;
    const lc = base.MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const ld = base.MathUtils.sinDeg(rotationY) * rootBone.scaleY;
    const sx = this.scaleX;
    const sy = base.settings.yDown ? -this.scaleY : this.scaleY;
    rootBone.matrix.a = (pa * la + pb * lc) * sx;
    rootBone.matrix.c = (pa * lb + pb * ld) * sx;
    rootBone.matrix.b = (pc * la + pd * lc) * sy;
    rootBone.matrix.d = (pc * lb + pd * ld) * sy;
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++) {
      const updatable = updateCache[i];
      if (updatable != rootBone)
        updatable.update();
    }
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.mix = constraint.data.mix;
      constraint.softness = constraint.data.softness;
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.compress = constraint.data.compress;
      constraint.stretch = constraint.data.stretch;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
      constraint.mixScaleX = data.mixScaleX;
      constraint.mixScaleY = data.mixScaleY;
      constraint.mixShearY = data.mixShearY;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
    }
  }
  /** Sets the slots and draw order to their setup pose values. */
  setSlotsToSetupPose() {
    const slots = this.slots;
    base.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @returns May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * repeatedly.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   *
   * See {@link #setSkin()}. */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (!skin)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the
   * skin is changed, {@link #updateCache()} is called.
   *
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   *
   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the
   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin == this.skin)
      return;
    if (newSkin) {
      if (this.skin)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
    this.updateCache();
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment
   * name.
   *
   * See {@link #getAttachment()}.
   * @returns May be null. */
  getAttachmentByName(slotName, attachmentName) {
    const slot = this.data.findSlot(slotName);
    if (!slot)
      throw new Error(`Can't find slot with name ${slotName}`);
    return this.getAttachment(slot.index, attachmentName);
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and
   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.
   *
   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.
   * @returns May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (!attachmentName)
      throw new Error("attachmentName cannot be null.");
    if (this.skin) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment)
        return attachment;
    }
    if (this.data.defaultSkin)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with
   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.
   * @param attachmentName May be null to clear the slot's attachment. */
  setAttachment(slotName, attachmentName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName) {
          attachment = this.getAttachment(i, attachmentName);
          if (!attachment)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it repeatedly.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.
   * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */
  getBoundsRect() {
    const offset = new base.Vector2();
    const size = new base.Vector2();
    this.getBounds(offset, size);
    return { x: offset.x, y: offset.y, width: size.x, height: size.y };
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size An output value, the width and height of the AABB.
   * @param temp Working memory to temporarily store attachments' computed world vertices. */
  getBounds(offset, size, temp = new Array(2)) {
    if (!offset)
      throw new Error("offset cannot be null.");
    if (!size)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      if (!slot.bone.active)
        continue;
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof RegionAttachment.RegionAttachment) {
        verticesLength = 8;
        vertices = base.Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot, vertices, 0, 2);
      } else if (attachment instanceof MeshAttachment.MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = base.Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
let Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;

exports.Skeleton = Skeleton;
//# sourceMappingURL=Skeleton.js.map


/***/ }),

/***/ 25676:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Animation = __webpack_require__(97294);
var Event = __webpack_require__(2684);
var SkeletonData = __webpack_require__(93993);
var SlotData = __webpack_require__(65650);
var BoneData = __webpack_require__(53916);
var IkConstraintData = __webpack_require__(12957);
var TransformConstraintData = __webpack_require__(94519);
var PathConstraintData = __webpack_require__(85502);
var Skin = __webpack_require__(88799);
var EventData = __webpack_require__(26628);
var base = __webpack_require__(55075);
var core = __webpack_require__(11491);
__webpack_require__(79660);
__webpack_require__(40192);
var Sequence = __webpack_require__(89688);

class SkeletonBinary {
  constructor(attachmentLoader) {
    this.ver40 = false;
    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
     * runtime than were used in Spine.
     *
     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(binary) {
    const scale = this.scale;
    const skeletonData = new SkeletonData.SkeletonData();
    skeletonData.name = "";
    const input = new base.BinaryInput(binary);
    const lowHash = input.readInt32();
    const highHash = input.readInt32();
    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);
    skeletonData.version = input.readString();
    const verShort = skeletonData.version.substr(0, 3);
    if (verShort !== "4.0" && verShort !== "4.1") {
      const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;
      console.error(error);
    }
    this.ver40 = verShort === "4.0";
    skeletonData.x = input.readFloat();
    skeletonData.y = input.readFloat();
    skeletonData.width = input.readFloat();
    skeletonData.height = input.readFloat();
    const nonessential = input.readBoolean();
    if (nonessential) {
      skeletonData.fps = input.readFloat();
      skeletonData.imagesPath = input.readString();
      skeletonData.audioPath = input.readString();
    }
    let n = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const str = input.readString();
      if (!str)
        throw new Error("String in string table must not be null.");
      input.strings.push(str);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Bone name must not be null.");
      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];
      const data = new BoneData.BoneData(i, name, parent);
      data.rotation = input.readFloat();
      data.x = input.readFloat() * scale;
      data.y = input.readFloat() * scale;
      data.scaleX = input.readFloat();
      data.scaleY = input.readFloat();
      data.shearX = input.readFloat();
      data.shearY = input.readFloat();
      data.length = input.readFloat() * scale;
      data.transformMode = input.readInt(true);
      data.skinRequired = input.readBoolean();
      if (nonessential)
        base.Color.rgba8888ToColor(data.color, input.readInt32());
      skeletonData.bones.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const slotName = input.readString();
      if (!slotName)
        throw new Error("Slot name must not be null.");
      const boneData = skeletonData.bones[input.readInt(true)];
      const data = new SlotData.SlotData(i, slotName, boneData);
      base.Color.rgba8888ToColor(data.color, input.readInt32());
      const darkColor = input.readInt32();
      if (darkColor != -1)
        base.Color.rgb888ToColor(data.darkColor = new base.Color(), darkColor);
      data.attachmentName = input.readStringRef();
      data.blendMode = input.readInt(true);
      skeletonData.slots.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("IK constraint data name must not be null.");
      const data = new IkConstraintData.IkConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.mix = input.readFloat();
      data.softness = input.readFloat() * scale;
      data.bendDirection = input.readByte();
      data.compress = input.readBoolean();
      data.stretch = input.readBoolean();
      data.uniform = input.readBoolean();
      skeletonData.ikConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Transform constraint data name must not be null.");
      const data = new TransformConstraintData.TransformConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.local = input.readBoolean();
      data.relative = input.readBoolean();
      data.offsetRotation = input.readFloat();
      data.offsetX = input.readFloat() * scale;
      data.offsetY = input.readFloat() * scale;
      data.offsetScaleX = input.readFloat();
      data.offsetScaleY = input.readFloat();
      data.offsetShearY = input.readFloat();
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      data.mixScaleX = input.readFloat();
      data.mixScaleY = input.readFloat();
      data.mixShearY = input.readFloat();
      skeletonData.transformConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Path constraint data name must not be null.");
      const data = new PathConstraintData.PathConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.slots[input.readInt(true)];
      data.positionMode = input.readInt(true);
      data.spacingMode = input.readInt(true);
      data.rotateMode = input.readInt(true);
      data.offsetRotation = input.readFloat();
      data.position = input.readFloat();
      if (data.positionMode == base.PositionMode.Fixed)
        data.position *= scale;
      data.spacing = input.readFloat();
      if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
        data.spacing *= scale;
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      skeletonData.pathConstraints.push(data);
    }
    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
    if (defaultSkin) {
      skeletonData.defaultSkin = defaultSkin;
      skeletonData.skins.push(defaultSkin);
    }
    {
      let i = skeletonData.skins.length;
      base.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
      for (; i < n; i++) {
        const skin = this.readSkin(input, skeletonData, false, nonessential);
        if (!skin)
          throw new Error("readSkin() should not have returned null.");
        skeletonData.skins[i] = skin;
      }
    }
    n = this.linkedMeshes.length;
    for (let i = 0; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error("Not skin found for linked mesh.");
      if (!linkedMesh.parent)
        throw new Error("Linked mesh parent must not be null");
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const eventName = input.readStringRef();
      if (!eventName)
        throw new Error();
      const data = new EventData.EventData(eventName);
      data.intValue = input.readInt(false);
      data.floatValue = input.readFloat();
      data.stringValue = input.readString();
      data.audioPath = input.readString();
      if (data.audioPath) {
        data.volume = input.readFloat();
        data.balance = input.readFloat();
      }
      skeletonData.events.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const animationName = input.readString();
      if (!animationName)
        throw new Error("Animatio name must not be null.");
      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));
    }
    return skeletonData;
  }
  readSkin(input, skeletonData, defaultSkin, nonessential) {
    let skin = null;
    let slotCount = 0;
    if (defaultSkin) {
      slotCount = input.readInt(true);
      if (slotCount == 0)
        return null;
      skin = new Skin.Skin("default");
    } else {
      const skinName = input.readStringRef();
      if (!skinName)
        throw new Error("Skin name must not be null.");
      skin = new Skin.Skin(skinName);
      skin.bones.length = input.readInt(true);
      for (let i = 0, n = skin.bones.length; i < n; i++)
        skin.bones[i] = skeletonData.bones[input.readInt(true)];
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
      slotCount = input.readInt(true);
    }
    for (let i = 0; i < slotCount; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const name = input.readStringRef();
        if (!name)
          throw new Error("Attachment name must not be null");
        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
        if (attachment)
          skin.setAttachment(slotIndex, name, attachment);
      }
    }
    return skin;
  }
  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
    const scale = this.scale;
    let name = input.readStringRef();
    if (!name)
      name = attachmentName;
    switch (input.readByte()) {
      case base.AttachmentType.Region: {
        let path = input.readStringRef();
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const scaleX = input.readFloat();
        const scaleY = input.readFloat();
        const width = input.readFloat();
        const height = input.readFloat();
        const color = input.readInt32();
        const sequence = this.readSequence(input);
        if (!path)
          path = name;
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = x * scale;
        region.y = y * scale;
        region.scaleX = scaleX;
        region.scaleY = scaleY;
        region.rotation = rotation;
        region.width = width * scale;
        region.height = height * scale;
        base.Color.rgba8888ToColor(region.color, color);
        region.sequence = sequence;
        if (sequence == null)
          region.updateRegion();
        return region;
      }
      case base.AttachmentType.BoundingBox: {
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        box.worldVerticesLength = vertexCount << 1;
        box.vertices = vertices.vertices;
        box.bones = vertices.bones;
        if (nonessential)
          base.Color.rgba8888ToColor(box.color, color);
        return box;
      }
      case base.AttachmentType.Mesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const vertexCount = input.readInt(true);
        const uvs = this.readFloatArray(input, vertexCount << 1, 1);
        const triangles = this.readShortArray(input);
        const vertices = this.readVertices(input, vertexCount);
        const hullLength = input.readInt(true);
        const sequence = this.readSequence(input);
        let edges = [];
        let width = 0;
        let height = 0;
        if (nonessential) {
          edges = this.readShortArray(input);
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        base.Color.rgba8888ToColor(mesh.color, color);
        mesh.bones = vertices.bones;
        mesh.vertices = vertices.vertices;
        mesh.worldVerticesLength = vertexCount << 1;
        mesh.triangles = triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = hullLength << 1;
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.edges = edges;
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        return mesh;
      }
      case base.AttachmentType.LinkedMesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const skinName = input.readStringRef();
        const parent = input.readStringRef();
        const inheritTimelines = input.readBoolean();
        const sequence = this.readSequence(input);
        let width = 0;
        let height = 0;
        if (nonessential) {
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        base.Color.rgba8888ToColor(mesh.color, color);
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));
        return mesh;
      }
      case base.AttachmentType.Path: {
        const closed = input.readBoolean();
        const constantSpeed = input.readBoolean();
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const lengths = base.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0, n = lengths.length; i < n; i++)
          lengths[i] = input.readFloat() * scale;
        const color = nonessential ? input.readInt32() : 0;
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = closed;
        path.constantSpeed = constantSpeed;
        path.worldVerticesLength = vertexCount << 1;
        path.vertices = vertices.vertices;
        path.bones = vertices.bones;
        path.lengths = lengths;
        if (nonessential)
          base.Color.rgba8888ToColor(path.color, color);
        return path;
      }
      case base.AttachmentType.Point: {
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const color = nonessential ? input.readInt32() : 0;
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = x * scale;
        point.y = y * scale;
        point.rotation = rotation;
        if (nonessential)
          base.Color.rgba8888ToColor(point.color, color);
        return point;
      }
      case base.AttachmentType.Clipping: {
        const endSlotIndex = input.readInt(true);
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        clip.endSlot = skeletonData.slots[endSlotIndex];
        clip.worldVerticesLength = vertexCount << 1;
        clip.vertices = vertices.vertices;
        clip.bones = vertices.bones;
        if (nonessential)
          base.Color.rgba8888ToColor(clip.color, color);
        return clip;
      }
    }
    return null;
  }
  readSequence(input) {
    if (this.ver40 || !input.readBoolean())
      return null;
    const sequence = new Sequence.Sequence(input.readInt(true));
    sequence.start = input.readInt(true);
    sequence.digits = input.readInt(true);
    sequence.setupIndex = input.readInt(true);
    return sequence;
  }
  readDeformTimelineType(input) {
    if (this.ver40)
      return ATTACHMENT_DEFORM;
    return input.readByte();
  }
  readVertices(input, vertexCount) {
    const scale = this.scale;
    const verticesLength = vertexCount << 1;
    const vertices = new Vertices();
    if (!input.readBoolean()) {
      vertices.vertices = this.readFloatArray(input, verticesLength, scale);
      return vertices;
    }
    const weights = new Array();
    const bonesArray = new Array();
    for (let i = 0; i < vertexCount; i++) {
      const boneCount = input.readInt(true);
      bonesArray.push(boneCount);
      for (let ii = 0; ii < boneCount; ii++) {
        bonesArray.push(input.readInt(true));
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat());
      }
    }
    vertices.vertices = base.Utils.toFloatArray(weights);
    vertices.bones = bonesArray;
    return vertices;
  }
  readFloatArray(input, n, scale) {
    const array = new Array(n);
    if (scale == 1) {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat();
    } else {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat() * scale;
    }
    return array;
  }
  readShortArray(input) {
    const n = input.readInt(true);
    const array = new Array(n);
    for (let i = 0; i < n; i++)
      array[i] = input.readShort();
    return array;
  }
  readAnimation(input, name, skeletonData) {
    input.readInt(true);
    const timelines = new Array();
    const scale = this.scale;
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        const frameLast = frameCount - 1;
        switch (timelineType) {
          case SLOT_ATTACHMENT: {
            const timeline = new Animation.AttachmentTimeline(frameCount, slotIndex);
            for (let frame = 0; frame < frameCount; frame++)
              timeline.setFrame(frame, input.readFloat(), input.readStringRef());
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA: {
            const bezierCount = input.readInt(true);
            const timeline = new Animation.RGBATimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
              a = a2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB: {
            const bezierCount = input.readInt(true);
            const timeline = new Animation.RGBTimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA2: {
            const bezierCount = input.readInt(true);
            const timeline = new Animation.RGBA2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const na = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              a = na;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB2: {
            const bezierCount = input.readInt(true);
            const timeline = new Animation.RGB2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_ALPHA: {
            const timeline = new Animation.AlphaTimeline(frameCount, input.readInt(true), slotIndex);
            let time = input.readFloat();
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);
              }
              time = time2;
              a = a2;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const boneIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const type = input.readByte();
        const frameCount = input.readInt(true);
        const bezierCount = input.readInt(true);
        switch (type) {
          case BONE_ROTATE:
            timelines.push(readTimeline1(input, new Animation.RotateTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_TRANSLATE:
            timelines.push(readTimeline2(input, new Animation.TranslateTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEX:
            timelines.push(readTimeline1(input, new Animation.TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEY:
            timelines.push(readTimeline1(input, new Animation.TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_SCALE:
            timelines.push(readTimeline2(input, new Animation.ScaleTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEX:
            timelines.push(readTimeline1(input, new Animation.ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEY:
            timelines.push(readTimeline1(input, new Animation.ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEAR:
            timelines.push(readTimeline2(input, new Animation.ShearTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARX:
            timelines.push(readTimeline1(input, new Animation.ShearXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARY:
            timelines.push(readTimeline1(input, new Animation.ShearYTimeline(frameCount, bezierCount, boneIndex), 1));
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new Animation.IkConstraintTimeline(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mix = input.readFloat();
      let softness = input.readFloat() * scale;
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mix2 = input.readFloat();
        const softness2 = input.readFloat() * scale;
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);
        }
        time = time2;
        mix = mix2;
        softness = softness2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new Animation.TransformConstraintTimeline(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mixRotate = input.readFloat();
      let mixX = input.readFloat();
      let mixY = input.readFloat();
      let mixScaleX = input.readFloat();
      let mixScaleY = input.readFloat();
      let mixShearY = input.readFloat();
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mixRotate2 = input.readFloat();
        const mixX2 = input.readFloat();
        const mixY2 = input.readFloat();
        const mixScaleX2 = input.readFloat();
        const mixScaleY2 = input.readFloat();
        const mixShearY2 = input.readFloat();
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);
        }
        time = time2;
        mixRotate = mixRotate2;
        mixX = mixX2;
        mixY = mixY2;
        mixScaleX = mixScaleX2;
        mixScaleY = mixScaleY2;
        mixShearY = mixShearY2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const data = skeletonData.pathConstraints[index];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        switch (input.readByte()) {
          case PATH_POSITION:
            timelines.push(
              readTimeline1(
                input,
                new Animation.PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),
                data.positionMode == base.PositionMode.Fixed ? scale : 1
              )
            );
            break;
          case PATH_SPACING:
            timelines.push(
              readTimeline1(
                input,
                new Animation.PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),
                data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed ? scale : 1
              )
            );
            break;
          case PATH_MIX:
            const timeline = new Animation.PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);
            let time = input.readFloat();
            let mixRotate = input.readFloat();
            let mixX = input.readFloat();
            let mixY = input.readFloat();
            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const mixRotate2 = input.readFloat();
              const mixX2 = input.readFloat();
              const mixY2 = input.readFloat();
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
            }
            timelines.push(timeline);
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const skin = skeletonData.skins[input.readInt(true)];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const slotIndex = input.readInt(true);
        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          const attachmentName = input.readStringRef();
          if (!attachmentName)
            throw new Error("attachmentName must not be null.");
          const attachment = skin.getAttachment(slotIndex, attachmentName);
          const timelineType = this.readDeformTimelineType(input);
          const frameCount = input.readInt(true);
          const frameLast = frameCount - 1;
          switch (timelineType) {
            case ATTACHMENT_DEFORM: {
              const vertexAttachment = attachment;
              const weighted = vertexAttachment.bones;
              const vertices = vertexAttachment.vertices;
              const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              const bezierCount = input.readInt(true);
              const timeline = new Animation.DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);
              let time = input.readFloat();
              for (let frame = 0, bezier = 0; ; frame++) {
                let deform;
                let end = input.readInt(true);
                if (end == 0)
                  deform = weighted ? base.Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = base.Utils.newFloatArray(deformLength);
                  const start = input.readInt(true);
                  end += start;
                  if (scale == 1) {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat();
                  } else {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat() * scale;
                  }
                  if (!weighted) {
                    for (let v = 0, vn = deform.length; v < vn; v++)
                      deform[v] += vertices[v];
                  }
                }
                timeline.setFrame(frame, time, deform);
                if (frame == frameLast)
                  break;
                const time2 = input.readFloat();
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);
                }
                time = time2;
              }
              timelines.push(timeline);
              break;
            }
            case ATTACHMENT_SEQUENCE: {
              const timeline = new Animation.SequenceTimeline(frameCount, slotIndex, attachment);
              for (let frame = 0; frame < frameCount; frame++) {
                const time = input.readFloat();
                const modeAndIndex = input.readInt32();
                timeline.setFrame(frame, time, Sequence.SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());
              }
              timelines.push(timeline);
              break;
            }
          }
        }
      }
    }
    const drawOrderCount = input.readInt(true);
    if (drawOrderCount > 0) {
      const timeline = new Animation.DrawOrderTimeline(drawOrderCount);
      const slotCount = skeletonData.slots.length;
      for (let i = 0; i < drawOrderCount; i++) {
        const time = input.readFloat();
        const offsetCount = input.readInt(true);
        const drawOrder = base.Utils.newArray(slotCount, 0);
        for (let ii = slotCount - 1; ii >= 0; ii--)
          drawOrder[ii] = -1;
        const unchanged = base.Utils.newArray(slotCount - offsetCount, 0);
        let originalIndex = 0;
        let unchangedIndex = 0;
        for (let ii = 0; ii < offsetCount; ii++) {
          const slotIndex = input.readInt(true);
          while (originalIndex != slotIndex)
            unchanged[unchangedIndex++] = originalIndex++;
          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
        }
        while (originalIndex < slotCount)
          unchanged[unchangedIndex++] = originalIndex++;
        for (let ii = slotCount - 1; ii >= 0; ii--)
          if (drawOrder[ii] == -1)
            drawOrder[ii] = unchanged[--unchangedIndex];
        timeline.setFrame(i, time, drawOrder);
      }
      timelines.push(timeline);
    }
    const eventCount = input.readInt(true);
    if (eventCount > 0) {
      const timeline = new Animation.EventTimeline(eventCount);
      for (let i = 0; i < eventCount; i++) {
        const time = input.readFloat();
        const eventData = skeletonData.events[input.readInt(true)];
        const event = new Event.Event(time, eventData);
        event.intValue = input.readInt(false);
        event.floatValue = input.readFloat();
        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
        if (event.data.audioPath) {
          event.volume = input.readFloat();
          event.balance = input.readFloat();
        }
        timeline.setFrame(i, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    return new Animation.Animation(name, timelines, duration);
  }
}
SkeletonBinary.BlendModeValues = [core.BLEND_MODES.NORMAL, core.BLEND_MODES.ADD, core.BLEND_MODES.MULTIPLY, core.BLEND_MODES.SCREEN];
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
}
class Vertices {
  constructor(bones = null, vertices = null) {
    this.bones = bones;
    this.vertices = vertices;
  }
}
function readTimeline1(input, timeline, scale) {
  let time = input.readFloat();
  let value = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const value2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);
    }
    time = time2;
    value = value2;
  }
  return timeline;
}
function readTimeline2(input, timeline, scale) {
  let time = input.readFloat();
  let value1 = input.readFloat() * scale;
  let value2 = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const nvalue1 = input.readFloat() * scale;
    const nvalue2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);
        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
  }
  return timeline;
}
function setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);
}
const BONE_ROTATE = 0;
const BONE_TRANSLATE = 1;
const BONE_TRANSLATEX = 2;
const BONE_TRANSLATEY = 3;
const BONE_SCALE = 4;
const BONE_SCALEX = 5;
const BONE_SCALEY = 6;
const BONE_SHEAR = 7;
const BONE_SHEARX = 8;
const BONE_SHEARY = 9;
const SLOT_ATTACHMENT = 0;
const SLOT_RGBA = 1;
const SLOT_RGB = 2;
const SLOT_RGBA2 = 3;
const SLOT_RGB2 = 4;
const SLOT_ALPHA = 5;
const ATTACHMENT_DEFORM = 0;
const ATTACHMENT_SEQUENCE = 1;
const PATH_POSITION = 0;
const PATH_SPACING = 1;
const PATH_MIX = 2;
const CURVE_STEPPED = 1;
const CURVE_BEZIER = 2;

exports.SkeletonBinary = SkeletonBinary;
//# sourceMappingURL=SkeletonBinary.js.map


/***/ }),

/***/ 32476:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class SkeletonBounds extends base.SkeletonBoundsBase {
}

exports.SkeletonBounds = SkeletonBounds;
//# sourceMappingURL=SkeletonBounds.js.map


/***/ }),

/***/ 93993:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class SkeletonData {
  constructor() {
    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */
    this.name = null;
    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */
    this.bones = new Array();
    // Ordered parents first.
    /** The skeleton's slots. */
    this.slots = new Array();
    // Setup pose draw order.
    this.skins = new Array();
    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.
     *
     * See {@link Skeleton#getAttachmentByName()}.
     * May be null. */
    this.defaultSkin = null;
    /** The skeleton's events. */
    this.events = new Array();
    /** The skeleton's animations. */
    this.animations = new Array();
    /** The skeleton's IK constraints. */
    this.ikConstraints = new Array();
    /** The skeleton's transform constraints. */
    this.transformConstraints = new Array();
    /** The skeleton's path constraints. */
    this.pathConstraints = new Array();
    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */
    this.x = 0;
    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */
    this.y = 0;
    /** The width of the skeleton's axis aligned bounding box in the setup pose. */
    this.width = 0;
    /** The height of the skeleton's axis aligned bounding box in the setup pose. */
    this.height = 0;
    /** The Spine version used to export the skeleton data, or null. */
    this.version = null;
    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */
    this.hash = null;
    // Nonessential
    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */
    this.fps = 0;
    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */
    this.imagesPath = null;
    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */
    this.audioPath = null;
  }
  /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSkin(skinName) {
    if (!skinName)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findEvent(eventDataName) {
    if (!eventDataName)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to
   * call it multiple times.
   * @returns May be null. */
  findAnimation(animationName) {
    if (!animationName)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it multiple times.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
}

exports.SkeletonData = SkeletonData;
//# sourceMappingURL=SkeletonData.js.map


/***/ }),

/***/ 14631:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Animation = __webpack_require__(97294);
var Event = __webpack_require__(2684);
var SkeletonData = __webpack_require__(93993);
var SlotData = __webpack_require__(65650);
var BoneData = __webpack_require__(53916);
var IkConstraintData = __webpack_require__(12957);
var TransformConstraintData = __webpack_require__(94519);
var PathConstraintData = __webpack_require__(85502);
var Skin = __webpack_require__(88799);
var EventData = __webpack_require__(26628);
var base = __webpack_require__(55075);
var core = __webpack_require__(11491);
var Sequence = __webpack_require__(89688);

class SkeletonJson {
  constructor(attachmentLoader) {
    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
     * runtime than were used in Spine.
     *
     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new SkeletonData.SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      const verShort = skeletonData.version.substr(0, 3);
      if (verShort !== "4.0" && verShort !== "4.1") {
        const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;
        console.error(error);
      }
      skeletonData.x = skeletonMap.x;
      skeletonData.y = skeletonMap.y;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new BoneData.BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = getValue(boneMap, "length", 0) * scale;
        data.x = getValue(boneMap, "x", 0) * scale;
        data.y = getValue(boneMap, "y", 0) * scale;
        data.rotation = getValue(boneMap, "rotation", 0);
        data.scaleX = getValue(boneMap, "scaleX", 1);
        data.scaleY = getValue(boneMap, "scaleY", 1);
        data.shearX = getValue(boneMap, "shearX", 0);
        data.shearY = getValue(boneMap, "shearY", 0);
        data.transformMode = base.Utils.enumValue(base.TransformMode, getValue(boneMap, "transform", "Normal"));
        data.skinRequired = getValue(boneMap, "skin", false);
        const color = getValue(boneMap, "color", null);
        if (color)
          data.color.setFromString(color);
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const boneData = skeletonData.findBone(slotMap.bone);
        if (!boneData)
          throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);
        const data = new SlotData.SlotData(skeletonData.slots.length, slotMap.name, boneData);
        const color = getValue(slotMap, "color", null);
        if (color)
          data.color.setFromString(color);
        const dark = getValue(slotMap, "dark", null);
        if (dark)
          data.darkColor = base.Color.fromString(dark);
        data.attachmentName = getValue(slotMap, "attachment", null);
        data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new IkConstraintData.IkConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        data.target = skeletonData.findBone(constraintMap.target);
        data.mix = getValue(constraintMap, "mix", 1);
        data.softness = getValue(constraintMap, "softness", 0) * scale;
        data.bendDirection = getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.compress = getValue(constraintMap, "compress", false);
        data.stretch = getValue(constraintMap, "stretch", false);
        data.uniform = getValue(constraintMap, "uniform", false);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new TransformConstraintData.TransformConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findBone(targetName);
        if (!target)
          throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);
        data.target = target;
        data.local = getValue(constraintMap, "local", false);
        data.relative = getValue(constraintMap, "relative", false);
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.offsetX = getValue(constraintMap, "x", 0) * scale;
        data.offsetY = getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = getValue(constraintMap, "shearY", 0);
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        data.mixScaleX = getValue(constraintMap, "mixScaleX", 1);
        data.mixScaleY = getValue(constraintMap, "mixScaleY", data.mixScaleX);
        data.mixShearY = getValue(constraintMap, "mixShearY", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new PathConstraintData.PathConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findSlot(targetName);
        if (!target)
          throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);
        data.target = target;
        data.positionMode = base.Utils.enumValue(base.PositionMode, getValue(constraintMap, "positionMode", "Percent"));
        data.spacingMode = base.Utils.enumValue(PathConstraintData.SpacingMode, getValue(constraintMap, "spacingMode", "Length"));
        data.rotateMode = base.Utils.enumValue(base.RotateMode, getValue(constraintMap, "rotateMode", "Tangent"));
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.position = getValue(constraintMap, "position", 0);
        if (data.positionMode == base.PositionMode.Fixed)
          data.position *= scale;
        data.spacing = getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == PathConstraintData.SpacingMode.Length || data.spacingMode == PathConstraintData.SpacingMode.Fixed)
          data.spacing *= scale;
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (let i = 0; i < root.skins.length; i++) {
        const skinMap = root.skins[i];
        const skin = new Skin.Skin(skinMap.name);
        if (skinMap.bones) {
          for (let ii = 0; ii < skinMap.bones.length; ii++) {
            const boneName = skinMap.bones[ii];
            const bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);
            skin.bones.push(bone);
          }
        }
        if (skinMap.ik) {
          for (let ii = 0; ii < skinMap.ik.length; ii++) {
            const constraintName = skinMap.ik[ii];
            const constraint = skeletonData.findIkConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.transform) {
          for (let ii = 0; ii < skinMap.transform.length; ii++) {
            const constraintName = skinMap.transform[ii];
            const constraint = skeletonData.findTransformConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.path) {
          for (let ii = 0; ii < skinMap.path.length; ii++) {
            const constraintName = skinMap.path[ii];
            const constraint = skeletonData.findPathConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        for (const slotName in skinMap.attachments) {
          const slot = skeletonData.findSlot(slotName);
          if (!slot)
            throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);
          const slotMap = skinMap.attachments[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
            if (attachment)
              skin.setAttachment(slot.index, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new EventData.EventData(eventName);
        data.intValue = getValue(eventMap, "int", 0);
        data.floatValue = getValue(eventMap, "float", 0);
        data.stringValue = getValue(eventMap, "string", "");
        data.audioPath = getValue(eventMap, "audio", null);
        if (data.audioPath) {
          data.volume = getValue(eventMap, "volume", 1);
          data.balance = getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = getValue(map, "name", name);
    switch (getValue(map, "type", "region")) {
      case "region": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = getValue(map, "x", 0) * scale;
        region.y = getValue(map, "y", 0) * scale;
        region.scaleX = getValue(map, "scaleX", 1);
        region.scaleY = getValue(map, "scaleY", 1);
        region.rotation = getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        region.sequence = sequence;
        const color = getValue(map, "color", null);
        if (color)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        const color = getValue(map, "color", null);
        if (color)
          mesh.color.setFromString(color);
        mesh.width = getValue(map, "width", 0) * scale;
        mesh.height = getValue(map, "height", 0) * scale;
        mesh.sequence = sequence;
        const parent = getValue(map, "parent", null);
        if (parent) {
          this.linkedMeshes.push(new LinkedMesh(mesh, getValue(map, "skin", null), slotIndex, parent, getValue(map, "timelines", true)));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.edges = getValue(map, "edges", null);
        mesh.hullLength = getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = getValue(map, "closed", false);
        path.constantSpeed = getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = base.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = getValue(map, "color", null);
        if (color)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = getValue(map, "x", 0) * scale;
        point.y = getValue(map, "y", 0) * scale;
        point.rotation = getValue(map, "rotation", 0);
        const color = getValue(map, "color", null);
        if (color)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        const end = getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readSequence(map) {
    if (map == null)
      return null;
    const sequence = new Sequence.Sequence(getValue(map, "count", 0));
    sequence.start = getValue(map, "start", 1);
    sequence.digits = getValue(map, "digits", 0);
    sequence.setupIndex = getValue(map, "setup", 0);
    return sequence;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = base.Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = base.Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slot = skeletonData.findSlot(slotName);
        if (!slot)
          throw new Error(`Slot not found: ${slotName}`);
        const slotIndex = slot.index;
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (!timelineMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName == "attachment") {
            const timeline = new Animation.AttachmentTimeline(frames, slotIndex);
            for (let frame = 0; frame < frames; frame++) {
              const keyMap = timelineMap[frame];
              timeline.setFrame(frame, getValue(keyMap, "time", 0), getValue(keyMap, "name", null));
            }
            timelines.push(timeline);
          } else if (timelineName == "rgba") {
            const timeline = new Animation.RGBATimeline(frames, frames << 2, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = base.Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = base.Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb") {
            const timeline = new Animation.RGBTimeline(frames, frames * 3, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = base.Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = base.Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "alpha") {
            timelines.push(readTimeline1(timelineMap, new Animation.AlphaTimeline(frames, frames, slotIndex), 0, 1));
          } else if (timelineName == "rgba2") {
            const timeline = new Animation.RGBA2Timeline(frames, frames * 7, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = base.Color.fromString(keyMap.light);
            let color2 = base.Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = base.Color.fromString(nextMap.light);
              const newColor2 = base.Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb2") {
            const timeline = new Animation.RGB2Timeline(frames, frames * 6, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = base.Color.fromString(keyMap.light);
            let color2 = base.Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = base.Color.fromString(nextMap.light);
              const newColor2 = base.Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const bone = skeletonData.findBone(boneName);
        if (!bone)
          throw new Error(`Bone not found: ${boneName}`);
        const boneIndex = bone.index;
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          const frames = timelineMap.length;
          if (frames == 0)
            continue;
          if (timelineName === "rotate") {
            timelines.push(readTimeline1(timelineMap, new Animation.RotateTimeline(frames, frames, boneIndex), 0, 1));
          } else if (timelineName === "translate") {
            const timeline = new Animation.TranslateTimeline(frames, frames << 1, boneIndex);
            timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, scale));
          } else if (timelineName === "translatex") {
            const timeline = new Animation.TranslateXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
          } else if (timelineName === "translatey") {
            const timeline = new Animation.TranslateYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
          } else if (timelineName === "scale") {
            const timeline = new Animation.ScaleTimeline(frames, frames << 1, boneIndex);
            timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 1, 1));
          } else if (timelineName === "scalex") {
            const timeline = new Animation.ScaleXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
          } else if (timelineName === "scaley") {
            const timeline = new Animation.ScaleYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
          } else if (timelineName === "shear") {
            const timeline = new Animation.ShearTimeline(frames, frames << 1, boneIndex);
            timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, 1));
          } else if (timelineName === "shearx") {
            const timeline = new Animation.ShearXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
          } else if (timelineName === "sheary") {
            const timeline = new Animation.ShearYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
          }
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        let keyMap = constraintMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findIkConstraint(constraintName);
        if (!constraint)
          throw new Error(`IK Constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        const timeline = new Animation.IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mix = getValue(keyMap, "mix", 1);
        let softness = getValue(keyMap, "softness", 0) * scale;
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(
            frame,
            time,
            mix,
            softness,
            getValue(keyMap, "bendPositive", true) ? 1 : -1,
            getValue(keyMap, "compress", false),
            getValue(keyMap, "stretch", false)
          );
          const nextMap = constraintMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mix2 = getValue(nextMap, "mix", 1);
          const softness2 = getValue(nextMap, "softness", 0) * scale;
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);
          }
          time = time2;
          mix = mix2;
          softness = softness2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const timelineMap = map.transform[constraintName];
        let keyMap = timelineMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findTransformConstraint(constraintName);
        if (!constraint)
          throw new Error(`Transform constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        const timeline = new Animation.TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mixRotate = getValue(keyMap, "mixRotate", 1);
        let mixX = getValue(keyMap, "mixX", 1);
        let mixY = getValue(keyMap, "mixY", mixX);
        let mixScaleX = getValue(keyMap, "mixScaleX", 1);
        let mixScaleY = getValue(keyMap, "mixScaleY", mixScaleX);
        const mixShearY = getValue(keyMap, "mixShearY", 1);
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
          const nextMap = timelineMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mixRotate2 = getValue(nextMap, "mixRotate", 1);
          const mixX2 = getValue(nextMap, "mixX", 1);
          const mixY2 = getValue(nextMap, "mixY", mixX2);
          const mixScaleX2 = getValue(nextMap, "mixScaleX", 1);
          const mixScaleY2 = getValue(nextMap, "mixScaleY", mixScaleX2);
          const mixShearY2 = getValue(nextMap, "mixShearY", 1);
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);
          }
          time = time2;
          mixRotate = mixRotate2;
          mixX = mixX2;
          mixY = mixY2;
          mixScaleX = mixScaleX2;
          mixScaleY = mixScaleY2;
          mixScaleX = mixScaleX2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.path) {
      for (const constraintName in map.path) {
        const constraintMap = map.path[constraintName];
        const constraint = skeletonData.findPathConstraint(constraintName);
        if (!constraint)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          let keyMap = timelineMap[0];
          if (!keyMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName === "position") {
            const timeline = new Animation.PathConstraintPositionTimeline(frames, frames, constraintIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == base.PositionMode.Fixed ? scale : 1));
          } else if (timelineName === "spacing") {
            const timeline = new Animation.PathConstraintSpacingTimeline(frames, frames, constraintIndex);
            timelines.push(
              readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == PathConstraintData.SpacingMode.Length || constraint.spacingMode == PathConstraintData.SpacingMode.Fixed ? scale : 1)
            );
          } else if (timelineName === "mix") {
            const timeline = new Animation.PathConstraintMixTimeline(frames, frames * 3, constraintIndex);
            let time = getValue(keyMap, "time", 0);
            let mixRotate = getValue(keyMap, "mixRotate", 1);
            let mixX = getValue(keyMap, "mixX", 1);
            let mixY = getValue(keyMap, "mixY", mixX);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const mixRotate2 = getValue(nextMap, "mixRotate", 1);
              const mixX2 = getValue(nextMap, "mixX", 1);
              const mixY2 = getValue(nextMap, "mixY", mixX2);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.deform) {
      map.attachments = {};
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const outMap = map.attachments[deformName] = {};
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const outMap2 = outMap[slotName] = {};
          for (const innerMapName in slotMap) {
            outMap2[innerMapName] = {
              deform: slotMap[innerMapName]
            };
          }
        }
      }
    }
    if (map.attachments) {
      for (const attachmentsName in map.attachments) {
        const attachmentsMap = map.attachments[attachmentsName];
        const skin = skeletonData.findSkin(attachmentsName);
        if (skin == null) {
          if (base.settings.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${attachmentsName}`);
          } else {
            continue;
          }
        }
        for (const slotMapName in attachmentsMap) {
          const slotMap = attachmentsMap[slotMapName];
          const slot = skeletonData.findSlot(slotMapName);
          if (!slot)
            throw new Error(`Slot not found: ${slotMapName}`);
          const slotIndex = slot.index;
          for (const attachmentMapName in slotMap) {
            const attachmentMap = slotMap[attachmentMapName];
            const attachment = skin.getAttachment(slotIndex, attachmentMapName);
            for (const timelineMapName in attachmentMap) {
              const timelineMap = attachmentMap[timelineMapName];
              let keyMap = timelineMap[0];
              if (!keyMap)
                continue;
              if (timelineMapName == "deform") {
                const weighted = attachment.bones;
                const vertices = attachment.vertices;
                const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                const timeline = new Animation.DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);
                let time = getValue(keyMap, "time", 0);
                for (let frame = 0, bezier = 0; ; frame++) {
                  let deform;
                  const verticesValue = getValue(keyMap, "vertices", null);
                  if (!verticesValue)
                    deform = weighted ? base.Utils.newFloatArray(deformLength) : vertices;
                  else {
                    deform = base.Utils.newFloatArray(deformLength);
                    const start = getValue(keyMap, "offset", 0);
                    base.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                    if (scale != 1) {
                      for (let i = start, n = i + verticesValue.length; i < n; i++)
                        deform[i] *= scale;
                    }
                    if (!weighted) {
                      for (let i = 0; i < deformLength; i++)
                        deform[i] += vertices[i];
                    }
                  }
                  timeline.setFrame(frame, time, deform);
                  const nextMap = timelineMap[frame + 1];
                  if (!nextMap) {
                    timeline.shrink(bezier);
                    break;
                  }
                  const time2 = getValue(nextMap, "time", 0);
                  const curve = keyMap.curve;
                  if (curve)
                    bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);
                  time = time2;
                  keyMap = nextMap;
                }
                timelines.push(timeline);
              } else if (timelineMapName == "sequence") {
                const timeline = new Animation.SequenceTimeline(timelineMap.length, slotIndex, attachment);
                let lastDelay = 0;
                for (let frame = 0; frame < timelineMap.length; frame++) {
                  const delay = getValue(keyMap, "delay", lastDelay);
                  const time = getValue(keyMap, "time", 0);
                  const mode = Sequence.SequenceMode[getValue(keyMap, "mode", "hold")];
                  const index = getValue(keyMap, "index", 0);
                  timeline.setFrame(frame, time, mode, index, delay);
                  lastDelay = delay;
                  keyMap = timelineMap[frame + 1];
                }
                timelines.push(timeline);
              }
            }
          }
        }
      }
    }
    if (map.drawOrder) {
      const timeline = new Animation.DrawOrderTimeline(map.drawOrder.length);
      const slotCount = skeletonData.slots.length;
      let frame = 0;
      for (let i = 0; i < map.drawOrder.length; i++, frame++) {
        const drawOrderMap = map.drawOrder[i];
        let drawOrder = null;
        const offsets = getValue(drawOrderMap, "offsets", null);
        if (offsets) {
          drawOrder = base.Utils.newArray(slotCount, -1);
          const unchanged = base.Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let ii = 0; ii < offsets.length; ii++) {
            const offsetMap = offsets[ii];
            const slot = skeletonData.findSlot(offsetMap.slot);
            if (!slot)
              throw new Error(`Slot not found: ${slot}`);
            const slotIndex = slot.index;
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let ii = slotCount - 1; ii >= 0; ii--)
            if (drawOrder[ii] == -1)
              drawOrder[ii] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frame, getValue(drawOrderMap, "time", 0), drawOrder);
      }
      timelines.push(timeline);
    }
    if (map.events) {
      const timeline = new Animation.EventTimeline(map.events.length);
      let frame = 0;
      for (let i = 0; i < map.events.length; i++, frame++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (!eventData)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new Event.Event(base.Utils.toSinglePrecision(getValue(eventMap, "time", 0)), eventData);
        event.intValue = getValue(eventMap, "int", eventData.intValue);
        event.floatValue = getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath) {
          event.volume = getValue(eventMap, "volume", 1);
          event.balance = getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frame, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new Animation.Animation(name, timelines, duration));
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return core.BLEND_MODES.NORMAL;
    if (str == "additive")
      return core.BLEND_MODES.ADD;
    if (str == "multiply")
      return core.BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return core.BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
}
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
}
function readTimeline1(keys, timeline, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value = getValue(keyMap, "value", defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const value2 = getValue(nextMap, "value", defaultValue) * scale;
    if (keyMap.curve)
      bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);
    time = time2;
    value = value2;
    keyMap = nextMap;
  }
}
function readTimeline2(keys, timeline, name1, name2, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value1 = getValue(keyMap, name1, defaultValue) * scale;
  let value2 = getValue(keyMap, name2, defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;
    const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;
    const curve = keyMap.curve;
    if (curve) {
      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);
      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
    keyMap = nextMap;
  }
}
function readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  if (curve == "stepped") {
    timeline.setStepped(frame);
    return bezier;
  }
  const i = value << 2;
  const cx1 = curve[i];
  const cy1 = curve[i + 1] * scale;
  const cx2 = curve[i + 2];
  const cy2 = curve[i + 3] * scale;
  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
  return bezier + 1;
}
function getValue(map, property, defaultValue) {
  return map[property] !== void 0 ? map[property] : defaultValue;
}

exports.SkeletonJson = SkeletonJson;
//# sourceMappingURL=SkeletonJson.js.map


/***/ }),

/***/ 88799:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(79660);
__webpack_require__(55075);
var MeshAttachment = __webpack_require__(36065);
__webpack_require__(40192);
__webpack_require__(89688);

class SkinEntry {
  constructor(slotIndex, name, attachment) {
    this.slotIndex = slotIndex;
    this.name = name;
    this.attachment = attachment;
  }
}
class Skin {
  constructor(name) {
    this.attachments = new Array();
    this.bones = Array();
    this.constraints = new Array();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  /** Adds an attachment to the skin for the specified slot index and name. */
  setAttachment(slotIndex, name, attachment) {
    if (!attachment)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */
  addSkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
    }
  }
  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not
   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */
  copySkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (!attachment.attachment)
        continue;
      if (attachment.attachment instanceof MeshAttachment.MeshAttachment) {
        attachment.attachment = attachment.attachment.newLinkedMesh();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      } else {
        attachment.attachment = attachment.attachment.copy();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
  }
  /** Returns the attachment for the specified slot index and name, or null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  /** Removes the attachment in the skin for the specified slot index and name, if any. */
  removeAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    if (dictionary)
      delete dictionary[name];
  }
  /** Returns all attachments in this skin. */
  getAttachments() {
    const entries = new Array();
    for (let i = 0; i < this.attachments.length; i++) {
      const slotAttachments = this.attachments[i];
      if (slotAttachments) {
        for (const name in slotAttachments) {
          const attachment = slotAttachments[name];
          if (attachment)
            entries.push(new SkinEntry(i, name, attachment));
        }
      }
    }
    return entries;
  }
  /** Returns all attachments in this skin for the specified slot index. */
  getAttachmentsForSlot(slotIndex, attachments) {
    const slotAttachments = this.attachments[slotIndex];
    if (slotAttachments) {
      for (const name in slotAttachments) {
        const attachment = slotAttachments[name];
        if (attachment)
          attachments.push(new SkinEntry(slotIndex, name, attachment));
      }
    }
  }
  /** Clears all attachments, bones, and constraints. */
  clear() {
    this.attachments.length = 0;
    this.bones.length = 0;
    this.constraints.length = 0;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
}

exports.Skin = Skin;
exports.SkinEntry = SkinEntry;
//# sourceMappingURL=Skin.js.map


/***/ }),

/***/ 7378:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var Attachment = __webpack_require__(79660);

class Slot {
  constructor(data, bone) {
    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
     * color's alpha is not used. */
    this.darkColor = null;
    this.attachment = null;
    this.attachmentState = 0;
    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the
     * {@link Sequence#getSetupIndex()}. */
    this.sequenceIndex = -1;
    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a
     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.
     *
     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */
    this.deform = new Array();
    if (!data)
      throw new Error("data cannot be null.");
    if (!bone)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new base.Color();
    this.darkColor = !data.darkColor ? null : new base.Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** The skeleton this slot belongs to. */
  getSkeleton() {
    return this.bone.skeleton;
  }
  /** The current attachment for the slot, or null if the slot has no attachment. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.
   * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the
   * specified attachment. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    if (!(attachment instanceof Attachment.VertexAttachment) || !(this.attachment instanceof Attachment.VertexAttachment) || attachment.timelineAttachment != this.attachment.timelineAttachment) {
      this.deform.length = 0;
    }
    this.attachment = attachment;
    this.sequenceIndex = -1;
  }
  /** Sets this slot to the setup pose. */
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor)
      this.darkColor.setFromColor(this.data.darkColor);
    if (!this.data.attachmentName)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
}

exports.Slot = Slot;
//# sourceMappingURL=Slot.js.map


/***/ }),

/***/ 65650:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);
var core = __webpack_require__(11491);

class SlotData {
  constructor(index, name, boneData) {
    /** The index of the slot in {@link Skeleton#getSlots()}. */
    this.index = 0;
    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two
     * color tinting. */
    this.color = new base.Color(1, 1, 1, 1);
    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
     * color's alpha is not used. */
    this.darkColor = null;
    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */
    this.attachmentName = null;
    /** The blend mode for drawing the slot's attachment. */
    this.blendMode = core.BLEND_MODES.NORMAL;
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    if (!boneData)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
}

exports.SlotData = SlotData;
//# sourceMappingURL=SlotData.js.map


/***/ }),

/***/ 33615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class TransformConstraint {
  constructor(data, skeleton) {
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    this.temp = new base.Vector2();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
    this.mixScaleX = data.mixScaleX;
    this.mixScaleY = data.mixScaleY;
    this.mixShearY = data.mixShearY;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}.`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0)
      return;
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * mixX;
        mat.ty += (temp.y - mat.ty) * mixY;
      }
      if (mixScaleX != 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        if (s != 0)
          s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        if (s != 0)
          s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r = by + (r + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyRelativeWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? base.MathUtils.degRad : -base.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * mixX;
        mat.ty += temp.y * mixY;
      }
      if (mixScaleX != 0) {
        const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > base.MathUtils.PI)
          r -= base.MathUtils.PI2;
        else if (r < -base.MathUtils.PI)
          r += base.MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - base.MathUtils.PI / 2 + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyAbsoluteLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let rotation = bone.arotation;
      if (mixRotate != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * mixRotate;
      }
      let x = bone.ax;
      let y = bone.ay;
      x += (target.ax - x + this.data.offsetX) * mixX;
      y += (target.ay - y + this.data.offsetY) * mixY;
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (mixScaleX != 0 && scaleX != 0)
        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
      if (mixScaleY != 0 && scaleY != 0)
        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
      let shearY = bone.ashearY;
      if (mixShearY != 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        shearY += r * mixShearY;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
      const x = bone.ax + (target.ax + this.data.offsetX) * mixX;
      const y = bone.ay + (target.ay + this.data.offsetY) * mixY;
      const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);
      const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);
      const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
}

exports.TransformConstraint = TransformConstraint;
//# sourceMappingURL=TransformConstraint.js.map


/***/ }),

/***/ 94519:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var ConstraintData = __webpack_require__(14101);

class TransformConstraintData extends ConstraintData.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that will be modified by this transform constraint. */
    this.bones = new Array();
    /** The target bone whose world transform will be copied to the constrained bones. */
    this._target = null;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    /** An offset added to the constrained bone rotation. */
    this.offsetRotation = 0;
    /** An offset added to the constrained bone X translation. */
    this.offsetX = 0;
    /** An offset added to the constrained bone Y translation. */
    this.offsetY = 0;
    /** An offset added to the constrained bone scaleX. */
    this.offsetScaleX = 0;
    /** An offset added to the constrained bone scaleY. */
    this.offsetScaleY = 0;
    /** An offset added to the constrained bone shearY. */
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
}

exports.TransformConstraintData = TransformConstraintData;
//# sourceMappingURL=TransformConstraintData.js.map


/***/ }),

/***/ 79660:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

class Attachment {
  constructor(name) {
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}
const _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    /** The unique ID for this attachment. */
    this.id = _VertexAttachment.nextID++;
    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting
     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null
     * if this attachment has no weights. */
    this.bones = null;
    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`
     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting
     * each vertex. */
    this.vertices = [];
    /** The maximum number of world vertex values that can be output by
     * {@link #computeWorldVertices()} using the `count` parameter. */
    this.worldVerticesLength = 0;
    /** Timelines for the timeline attachment are also applied to this attachment.
     * May be null if no attachment-specific timelines should be applied. */
    this.timelineAttachment = this;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is
   * not empty, it is used to deform the vertices.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide.
   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.
   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *
   *           `stride` / 2.
   * @param offset The `worldVertices` index to begin writing values.
   * @param stride The number of `worldVertices` entries between the value pairs written. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.deform;
    let vertices = this.vertices;
    const bones = this.bones;
    if (!bones) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  /** Does not copy id (generated) or name (set on construction). **/
  copyTo(attachment) {
    if (this.bones) {
      attachment.bones = new Array(this.bones.length);
      base.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
    } else
      attachment.bones = null;
    if (this.vertices) {
      attachment.vertices = base.Utils.newFloatArray(this.vertices.length);
      base.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
    }
    attachment.worldVerticesLength = this.worldVerticesLength;
    attachment.timelineAttachment = this.timelineAttachment;
  }
};
let VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;

exports.Attachment = Attachment;
exports.VertexAttachment = VertexAttachment;
//# sourceMappingURL=Attachment.js.map


/***/ }),

/***/ 77761:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var base = __webpack_require__(55075);

class BoundingBoxAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.BoundingBox;
    this.color = new base.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new BoundingBoxAttachment(this.name);
    this.copyTo(copy);
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.BoundingBoxAttachment = BoundingBoxAttachment;
//# sourceMappingURL=BoundingBoxAttachment.js.map


/***/ }),

/***/ 3434:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var base = __webpack_require__(55075);

class ClippingAttachment extends Attachment.VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Clipping;
    /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of
     * the skeleton's rendering. */
    this.endSlot = null;
    // Nonessential.
    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons
     * are not usually rendered at runtime. */
    this.color = new base.Color(0.2275, 0.2275, 0.8078, 1);
  }
  copy() {
    const copy = new ClippingAttachment(this.name);
    this.copyTo(copy);
    copy.endSlot = this.endSlot;
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.ClippingAttachment = ClippingAttachment;
//# sourceMappingURL=ClippingAttachment.js.map


/***/ }),

/***/ 36065:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var base = __webpack_require__(55075);

class MeshAttachment extends Attachment.VertexAttachment {
  constructor(name, path) {
    super(name);
    this.type = base.AttachmentType.Mesh;
    this.region = null;
    /** Triplets of vertex indices which describe the mesh's triangulation. */
    this.triangles = [];
    /** The color to tint the mesh. */
    this.color = new base.Color(1, 1, 1, 1);
    /** The width of the mesh's image. Available only when nonessential data was exported. */
    this.width = 0;
    /** The height of the mesh's image. Available only when nonessential data was exported. */
    this.height = 0;
    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */
    this.hullLength = 0;
    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if
     * nonessential data was exported. Triangulation is not performed at runtime. */
    this.edges = [];
    this.parentMesh = null;
    this.sequence = null;
    this.tempColor = new base.Color(0, 0, 0, 0);
    this.path = path;
  }
  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},
   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the
   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  copy() {
    if (this.parentMesh)
      return this.newLinkedMesh();
    const copy = new MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    this.copyTo(copy);
    copy.regionUVs = new Float32Array(this.regionUVs.length);
    base.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
    copy.triangles = new Array(this.triangles.length);
    base.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
    copy.hullLength = this.hullLength;
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    if (this.edges) {
      copy.edges = new Array(this.edges.length);
      base.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
    }
    copy.width = this.width;
    copy.height = this.height;
    return copy;
  }
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);
  }
  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/
  newLinkedMesh() {
    const copy = new MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    copy.timelineAttachment = this.timelineAttachment;
    copy.setParentMesh(this.parentMesh ? this.parentMesh : this);
    return copy;
  }
}

exports.MeshAttachment = MeshAttachment;
//# sourceMappingURL=MeshAttachment.js.map


/***/ }),

/***/ 70099:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var base = __webpack_require__(55075);

class PathAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Path;
    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */
    this.lengths = [];
    /** If true, the start and end knots are connected. */
    this.closed = false;
    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer
     * calculations are performed but calculating positions along the path is less accurate. */
    this.constantSpeed = false;
    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually
     * rendered at runtime. */
    this.color = new base.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new PathAttachment(this.name);
    this.copyTo(copy);
    copy.lengths = new Array(this.lengths.length);
    base.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
    copy.closed = closed;
    copy.constantSpeed = this.constantSpeed;
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.PathAttachment = PathAttachment;
//# sourceMappingURL=PathAttachment.js.map


/***/ }),

/***/ 64506:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var base = __webpack_require__(55075);

class PointAttachment extends Attachment.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = base.AttachmentType.Point;
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments
     * are not usually rendered at runtime. */
    this.color = new base.Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = base.MathUtils.cosDeg(this.rotation);
    const sin = base.MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * base.MathUtils.radDeg;
  }
  copy() {
    const copy = new PointAttachment(this.name);
    copy.x = this.x;
    copy.y = this.y;
    copy.rotation = this.rotation;
    copy.color.setFromColor(this.color);
    return copy;
  }
}

exports.PointAttachment = PointAttachment;
//# sourceMappingURL=PointAttachment.js.map


/***/ }),

/***/ 40192:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var base = __webpack_require__(55075);

const _RegionAttachment = class extends Attachment.Attachment {
  constructor(name, path) {
    super(name);
    this.type = base.AttachmentType.Region;
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local scaleX. */
    this.scaleX = 1;
    /** The local scaleY. */
    this.scaleY = 1;
    /** The local rotation. */
    this.rotation = 0;
    /** The width of the region attachment in Spine. */
    this.width = 0;
    /** The height of the region attachment in Spine. */
    this.height = 0;
    /** The color to tint the region attachment. */
    this.color = new base.Color(1, 1, 1, 1);
    this.rendererObject = null;
    this.region = null;
    this.sequence = null;
    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.
     *
     * See {@link #updateOffset()}. */
    this.offset = base.Utils.newFloatArray(8);
    this.uvs = base.Utils.newFloatArray(8);
    this.tempColor = new base.Color(1, 1, 1, 1);
    this.path = path;
  }
  /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */
  updateRegion() {
    if (!this.region)
      throw new Error("Region not set.");
    const region = this.region;
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const x = this.x;
    const y = this.y;
    const localXCos = localX * cos + x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[0] = localXCos - localYSin;
    offset[1] = localYCos + localXSin;
    offset[2] = localXCos - localY2Sin;
    offset[3] = localY2Cos + localXSin;
    offset[4] = localX2Cos - localY2Sin;
    offset[5] = localY2Cos + localX2Sin;
    offset[6] = localX2Cos - localYSin;
    offset[7] = localYCos + localX2Sin;
    const uvs = this.uvs;
    if (region.degrees == 90) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may
   * be changed.
   * <p>
   * See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
   * Runtimes Guide.
   * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.
   * @param offset The <code>worldVertices</code> index to begin writing values.
   * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */
  computeWorldVertices(slot, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    const bone = slot.bone;
    const vertexOffset = this.offset;
    const mat = bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[0];
    offsetY = vertexOffset[1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[2];
    offsetY = vertexOffset[3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[4];
    offsetY = vertexOffset[5];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[6];
    offsetY = vertexOffset[7];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
  copy() {
    const copy = new _RegionAttachment(this.name, this.path);
    copy.region = this.region;
    copy.rendererObject = this.rendererObject;
    copy.x = this.x;
    copy.y = this.y;
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.width = this.width;
    copy.height = this.height;
    base.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
    base.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
    copy.color.setFromColor(this.color);
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    return copy;
  }
};
let RegionAttachment = _RegionAttachment;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;

exports.RegionAttachment = RegionAttachment;
//# sourceMappingURL=RegionAttachment.js.map


/***/ }),

/***/ 89688:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var base = __webpack_require__(55075);

const _Sequence = class {
  constructor(count) {
    this.id = _Sequence.nextID();
    this.start = 0;
    this.digits = 0;
    /** The index of the region to show for the setup pose. */
    this.setupIndex = 0;
    this.regions = new Array(count);
  }
  copy() {
    const copy = new _Sequence(this.regions.length);
    base.Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);
    copy.start = this.start;
    copy.digits = this.digits;
    copy.setupIndex = this.setupIndex;
    return copy;
  }
  apply(slot, attachment) {
    let index = slot.sequenceIndex;
    if (index == -1)
      index = this.setupIndex;
    if (index >= this.regions.length)
      index = this.regions.length - 1;
    const region = this.regions[index];
    if (attachment.region != region) {
      attachment.region = region;
    }
  }
  getPath(basePath, index) {
    let result = basePath;
    const frame = (this.start + index).toString();
    for (let i = this.digits - frame.length; i > 0; i--)
      result += "0";
    result += frame;
    return result;
  }
  static nextID() {
    return _Sequence._nextID++;
  }
};
let Sequence = _Sequence;
Sequence._nextID = 0;
var SequenceMode = /* @__PURE__ */ ((SequenceMode2) => {
  SequenceMode2[SequenceMode2["hold"] = 0] = "hold";
  SequenceMode2[SequenceMode2["once"] = 1] = "once";
  SequenceMode2[SequenceMode2["loop"] = 2] = "loop";
  SequenceMode2[SequenceMode2["pingpong"] = 3] = "pingpong";
  SequenceMode2[SequenceMode2["onceReverse"] = 4] = "onceReverse";
  SequenceMode2[SequenceMode2["loopReverse"] = 5] = "loopReverse";
  SequenceMode2[SequenceMode2["pingpongReverse"] = 6] = "pingpongReverse";
  return SequenceMode2;
})(SequenceMode || {});
const SequenceModeValues = [
  0 /* hold */,
  1 /* once */,
  2 /* loop */,
  3 /* pingpong */,
  4 /* onceReverse */,
  5 /* loopReverse */,
  6 /* pingpongReverse */
];

exports.Sequence = Sequence;
exports.SequenceMode = SequenceMode;
exports.SequenceModeValues = SequenceModeValues;
//# sourceMappingURL=Sequence.js.map


/***/ }),

/***/ 77954:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Attachment = __webpack_require__(79660);
var BoundingBoxAttachment = __webpack_require__(77761);
var ClippingAttachment = __webpack_require__(3434);
var MeshAttachment = __webpack_require__(36065);
var PathAttachment = __webpack_require__(70099);
var PointAttachment = __webpack_require__(64506);
var RegionAttachment = __webpack_require__(40192);
var Sequence = __webpack_require__(89688);
var Animation = __webpack_require__(97294);
var AnimationState = __webpack_require__(94649);
var AnimationStateData = __webpack_require__(11657);
var AtlasAttachmentLoader = __webpack_require__(66265);
var Bone = __webpack_require__(28660);
var BoneData = __webpack_require__(53916);
var ConstraintData = __webpack_require__(14101);
var Event = __webpack_require__(2684);
var EventData = __webpack_require__(26628);
var IkConstraint = __webpack_require__(49821);
var IkConstraintData = __webpack_require__(12957);
var PathConstraint = __webpack_require__(22990);
var PathConstraintData = __webpack_require__(85502);
var Skeleton = __webpack_require__(8665);
var SkeletonBinary = __webpack_require__(25676);
var SkeletonBounds = __webpack_require__(32476);
var SkeletonData = __webpack_require__(93993);
var SkeletonJson = __webpack_require__(14631);
var Skin = __webpack_require__(88799);
var Slot = __webpack_require__(7378);
var SlotData = __webpack_require__(65650);
var TransformConstraint = __webpack_require__(33615);
var TransformConstraintData = __webpack_require__(94519);
var Spine = __webpack_require__(75553);



exports.Attachment = Attachment.Attachment;
exports.VertexAttachment = Attachment.VertexAttachment;
exports.BoundingBoxAttachment = BoundingBoxAttachment.BoundingBoxAttachment;
exports.ClippingAttachment = ClippingAttachment.ClippingAttachment;
exports.MeshAttachment = MeshAttachment.MeshAttachment;
exports.PathAttachment = PathAttachment.PathAttachment;
exports.PointAttachment = PointAttachment.PointAttachment;
exports.RegionAttachment = RegionAttachment.RegionAttachment;
exports.Sequence = Sequence.Sequence;
exports.SequenceMode = Sequence.SequenceMode;
exports.SequenceModeValues = Sequence.SequenceModeValues;
exports.AlphaTimeline = Animation.AlphaTimeline;
exports.Animation = Animation.Animation;
exports.AttachmentTimeline = Animation.AttachmentTimeline;
exports.CurveTimeline = Animation.CurveTimeline;
exports.CurveTimeline1 = Animation.CurveTimeline1;
exports.CurveTimeline2 = Animation.CurveTimeline2;
exports.DeformTimeline = Animation.DeformTimeline;
exports.DrawOrderTimeline = Animation.DrawOrderTimeline;
exports.EventTimeline = Animation.EventTimeline;
exports.IkConstraintTimeline = Animation.IkConstraintTimeline;
exports.PathConstraintMixTimeline = Animation.PathConstraintMixTimeline;
exports.PathConstraintPositionTimeline = Animation.PathConstraintPositionTimeline;
exports.PathConstraintSpacingTimeline = Animation.PathConstraintSpacingTimeline;
exports.RGB2Timeline = Animation.RGB2Timeline;
exports.RGBA2Timeline = Animation.RGBA2Timeline;
exports.RGBATimeline = Animation.RGBATimeline;
exports.RGBTimeline = Animation.RGBTimeline;
exports.RotateTimeline = Animation.RotateTimeline;
exports.ScaleTimeline = Animation.ScaleTimeline;
exports.ScaleXTimeline = Animation.ScaleXTimeline;
exports.ScaleYTimeline = Animation.ScaleYTimeline;
exports.SequenceTimeline = Animation.SequenceTimeline;
exports.ShearTimeline = Animation.ShearTimeline;
exports.ShearXTimeline = Animation.ShearXTimeline;
exports.ShearYTimeline = Animation.ShearYTimeline;
exports.Timeline = Animation.Timeline;
exports.TransformConstraintTimeline = Animation.TransformConstraintTimeline;
exports.TranslateTimeline = Animation.TranslateTimeline;
exports.TranslateXTimeline = Animation.TranslateXTimeline;
exports.TranslateYTimeline = Animation.TranslateYTimeline;
exports.AnimationState = AnimationState.AnimationState;
exports.AnimationStateAdapter = AnimationState.AnimationStateAdapter;
exports.EventQueue = AnimationState.EventQueue;
exports.EventType = AnimationState.EventType;
exports.TrackEntry = AnimationState.TrackEntry;
exports.AnimationStateData = AnimationStateData.AnimationStateData;
exports.AtlasAttachmentLoader = AtlasAttachmentLoader.AtlasAttachmentLoader;
exports.Bone = Bone.Bone;
exports.BoneData = BoneData.BoneData;
exports.ConstraintData = ConstraintData.ConstraintData;
exports.Event = Event.Event;
exports.EventData = EventData.EventData;
exports.IkConstraint = IkConstraint.IkConstraint;
exports.IkConstraintData = IkConstraintData.IkConstraintData;
exports.PathConstraint = PathConstraint.PathConstraint;
exports.PathConstraintData = PathConstraintData.PathConstraintData;
exports.SpacingMode = PathConstraintData.SpacingMode;
exports.Skeleton = Skeleton.Skeleton;
exports.SkeletonBinary = SkeletonBinary.SkeletonBinary;
exports.SkeletonBounds = SkeletonBounds.SkeletonBounds;
exports.SkeletonData = SkeletonData.SkeletonData;
exports.SkeletonJson = SkeletonJson.SkeletonJson;
exports.Skin = Skin.Skin;
exports.SkinEntry = Skin.SkinEntry;
exports.Slot = Slot.Slot;
exports.SlotData = SlotData.SlotData;
exports.TransformConstraint = TransformConstraint.TransformConstraint;
exports.TransformConstraintData = TransformConstraintData.TransformConstraintData;
exports.Spine = Spine.Spine;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 12565:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var events = __webpack_require__(7065);
var accessibleTarget = __webpack_require__(17993);

display.DisplayObject.mixin(accessibleTarget.accessibleTarget);
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  constructor(renderer) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (core.utils.isMobile.tablet || core.utils.isMobile.phone) {
      this.createTouchHook();
    }
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`;
    div.style.height = `${DIV_TOUCH_SIZE}px`;
    div.style.position = "absolute";
    div.style.top = `${DIV_TOUCH_POS_X}px`;
    div.style.left = `${DIV_TOUCH_POS_Y}px`;
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this.activate();
      this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    this.renderer.view.parentNode?.appendChild(this.div);
  }
  deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    this.div.parentNode?.removeChild(this.div);
  }
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.isInteractive()) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    const children = displayObject.children;
    if (children) {
      for (let i = 0; i < children.length; i++) {
        this.updateAccessibleObjects(children[i]);
      }
    }
  }
  update() {
    const now = performance.now();
    if (core.utils.isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer.lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    }
    const { x, y, width, height } = this.renderer.view.getBoundingClientRect();
    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
    const sx = width / viewWidth * resolution;
    const sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x}px`;
    div.style.top = `${y}px`;
    div.style.width = `${viewWidth}px`;
    div.style.height = `${viewHeight}px`;
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        core.utils.removeItems(this.children, i, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i--;
      } else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
          div.style.width = `${hitArea.width * wt.a * sx}px`;
          div.style.height = `${hitArea.height * wt.d * sy}px`;
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = `${hitArea.x * sx}px`;
          div.style.top = `${hitArea.y * sy}px`;
          div.style.width = `${hitArea.width * sx}px`;
          div.style.height = `${hitArea.height * sy}px`;
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug)
            this.updateDebugHTML(div);
        }
      }
    }
    this.renderId++;
  }
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this.renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  addChild(displayObject) {
    let div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = `displayObject ${displayObject.tabIndex}`;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug)
      this.updateDebugHTML(div);
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  _dispatchEvent(e, type) {
    const { displayObject: target } = e.target;
    const boundry = this.renderer.events.rootBoundary;
    const event = Object.assign(new events.FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered;
    type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  _onFocus(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e, ["mouseover"]);
  }
  _onFocusOut(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e, ["mouseout"]);
  }
  _onKeyDown(e) {
    if (e.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  }
  _onMouseMove(e) {
    if (e.movementX === 0 && e.movementY === 0) {
      return;
    }
    this.deactivate();
  }
  destroy() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    core.ExtensionType.RendererPlugin,
    core.ExtensionType.CanvasRendererPlugin
  ]
};
core.extensions.add(AccessibilityManager);

exports.AccessibilityManager = AccessibilityManager;
//# sourceMappingURL=AccessibilityManager.js.map


/***/ }),

/***/ 17993:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};

exports.accessibleTarget = accessibleTarget;
//# sourceMappingURL=accessibleTarget.js.map


/***/ }),

/***/ 29252:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var AccessibilityManager = __webpack_require__(12565);
var accessibleTarget = __webpack_require__(17993);



exports.AccessibilityManager = AccessibilityManager.AccessibilityManager;
exports.accessibleTarget = accessibleTarget.accessibleTarget;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 70981:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);

const _Application = class {
  constructor(options) {
    this.stage = new display.Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = core.autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer.view;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(removeView, stageOptions) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  }
};
let Application = _Application;
Application._plugins = [];
core.extensions.handleByList(core.ExtensionType.Application, Application._plugins);

exports.Application = Application;
//# sourceMappingURL=Application.js.map


/***/ }),

/***/ 75196:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class ResizePlugin {
  static init(options) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this.cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
ResizePlugin.extension = core.ExtensionType.Application;
core.extensions.add(ResizePlugin);

exports.ResizePlugin = ResizePlugin;
//# sourceMappingURL=ResizePlugin.js.map


/***/ }),

/***/ 50415:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Application = __webpack_require__(70981);
var ResizePlugin = __webpack_require__(75196);



exports.Application = Application.Application;
exports.ResizePlugin = ResizePlugin.ResizePlugin;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 44420:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);

const assetKeyMap = {
  loader: core.ExtensionType.LoadParser,
  resolver: core.ExtensionType.ResolveParser,
  cache: core.ExtensionType.CacheParser,
  detection: core.ExtensionType.DetectionParser
};
core.extensions.handle(core.ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => core.extensions.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => core.extensions.remove(ref[key]));
});
//# sourceMappingURL=AssetExtension.js.map


/***/ }),

/***/ 78740:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var BackgroundLoader = __webpack_require__(1790);
var Cache = __webpack_require__(85574);
var Loader = __webpack_require__(50930);
__webpack_require__(84642);
var Resolver = __webpack_require__(84232);
var convertToList = __webpack_require__(87993);
var isSingleItem = __webpack_require__(33888);
var loadTextures = __webpack_require__(60135);

class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver.Resolver();
    this.loader = new Loader.Loader();
    this.cache = Cache.Cache;
    this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats = [];
    if (options.texturePreference?.format) {
      const formatPref = options.texturePreference?.format;
      formats = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats = await detection.remove(formats);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats = await detection.add(formats);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  add(keysIn, assetsIn, data) {
    this.resolver.add(keysIn, assetsIn, data);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem.isSingleItem(urls);
    const urlArray = convertToList.convertToList(urls).map((url) => {
      if (typeof url !== "string") {
        this.resolver.add(url.src, url);
        return url.src;
      }
      if (!this.resolver.hasKey(url)) {
        this.resolver.add(url, url);
      }
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.Cache.get(keys);
    }
    const assets = {};
    for (let i = 0; i < keys.length; i++) {
      assets[i] = Cache.Cache.get(keys[i]);
    }
    return assets;
  }
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult, i) => {
      const asset = loadedAssets[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out[resolveKeys[i]] = asset;
      Cache.Cache.set(keys, asset);
    });
    return out;
  }
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList.convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList.convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return loadTextures.loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    core.utils.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
    this.setPreferences({ preferWorkers: value });
  }
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
core.extensions.handleByList(core.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(core.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(core.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(core.ExtensionType.DetectionParser, Assets.detections);

exports.Assets = Assets;
exports.AssetsClass = AssetsClass;
//# sourceMappingURL=Assets.js.map


/***/ }),

/***/ 1790:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BackgroundLoader {
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  add(assetUrls) {
    assetUrls.forEach((a) => {
      this._assetList.push(a);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < toLoadAmount; i++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      this._next();
    }
  }
}

exports.BackgroundLoader = BackgroundLoader;
//# sourceMappingURL=BackgroundLoader.js.map


/***/ }),

/***/ 85574:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
__webpack_require__(41995);
var convertToList = __webpack_require__(87993);

class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value) {
    const keys = convertToList.convertToList(key);
    let cacheableAssets;
    for (let i = 0; i < this.parsers.length; i++) {
      const parser = this.parsers[i];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    if (!cacheableAssets) {
      cacheableAssets = {};
      keys.forEach((key2) => {
        cacheableAssets[key2] = value;
      });
    }
    const cacheKeys = Object.keys(cacheableAssets);
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      if (this._cache.has(key2) && this._cache.get(key2) !== value) {
        console.warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableAssets[key2]);
    });
    if (value instanceof core.Texture) {
      const texture = value;
      keys.forEach((key2) => {
        if (texture.baseTexture !== core.Texture.EMPTY.baseTexture) {
          core.BaseTexture.addToCache(texture.baseTexture, key2);
        }
        core.Texture.addToCache(texture, key2);
      });
    }
  }
  remove(key) {
    this._cacheMap.get(key);
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();

exports.Cache = Cache;
//# sourceMappingURL=Cache.js.map


/***/ }),

/***/ 90533:
/***/ (() => {

"use strict";


//# sourceMappingURL=CacheParser.js.map


/***/ }),

/***/ 23280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Cache = __webpack_require__(85574);
__webpack_require__(90533);
__webpack_require__(87031);



exports.Cache = Cache.Cache;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 22061:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const cacheTextureArray = {
  extension: core.ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof core.Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    keys.forEach((key) => {
      asset.forEach((item, i) => {
        out[key + (i === 0 ? "" : i + 1)] = item;
      });
    });
    return out;
  }
};
core.extensions.add(cacheTextureArray);

exports.cacheTextureArray = cacheTextureArray;
//# sourceMappingURL=cacheTextureArray.js.map


/***/ }),

/***/ 87031:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var cacheTextureArray = __webpack_require__(22061);



exports.cacheTextureArray = cacheTextureArray.cacheTextureArray;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 57750:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(87457);

//# sourceMappingURL=index.js.map


/***/ }),

/***/ 91642:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const detectAvif = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    const blob = await core.settings.ADAPTER.fetch(avifData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f) => f !== "avif")
};
core.extensions.add(detectAvif);

exports.detectAvif = detectAvif;
//# sourceMappingURL=detectAvif.js.map


/***/ }),

/***/ 56108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))
};
core.extensions.add(detectDefaults);

exports.detectDefaults = detectDefaults;
//# sourceMappingURL=detectDefaults.js.map


/***/ }),

/***/ 87744:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const detectWebp = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    const blob = await core.settings.ADAPTER.fetch(webpData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f) => f !== "webp")
};
core.extensions.add(detectWebp);

exports.detectWebp = detectWebp;
//# sourceMappingURL=detectWebp.js.map


/***/ }),

/***/ 87457:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var detectAvif = __webpack_require__(91642);
var detectWebp = __webpack_require__(87744);
var detectDefaults = __webpack_require__(56108);



exports.detectAvif = detectAvif.detectAvif;
exports.detectWebp = detectWebp.detectWebp;
exports.detectDefaults = detectDefaults.detectDefaults;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 13369:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(44420);
var Assets = __webpack_require__(78740);
__webpack_require__(23280);
__webpack_require__(57750);
__webpack_require__(8133);
__webpack_require__(69048);
__webpack_require__(41995);
var Cache = __webpack_require__(85574);
var cacheTextureArray = __webpack_require__(22061);
var detectAvif = __webpack_require__(91642);
var detectWebp = __webpack_require__(87744);
var detectDefaults = __webpack_require__(56108);
var LoaderParser = __webpack_require__(37308);
var loadJson = __webpack_require__(16226);
var loadTxt = __webpack_require__(50146);
var loadWebFont = __webpack_require__(63445);
var loadSVG = __webpack_require__(91897);
var loadTextures = __webpack_require__(60135);
var createTexture = __webpack_require__(97242);
var resolveTextureUrl = __webpack_require__(89947);
var checkDataUrl = __webpack_require__(27754);
var checkExtension = __webpack_require__(97446);
var convertToList = __webpack_require__(87993);
var copySearchParams = __webpack_require__(34004);
var createStringVariations = __webpack_require__(35628);
var isSingleItem = __webpack_require__(33888);



exports.Assets = Assets.Assets;
exports.AssetsClass = Assets.AssetsClass;
exports.Cache = Cache.Cache;
exports.cacheTextureArray = cacheTextureArray.cacheTextureArray;
exports.detectAvif = detectAvif.detectAvif;
exports.detectWebp = detectWebp.detectWebp;
exports.detectDefaults = detectDefaults.detectDefaults;
exports.LoaderParserPriority = LoaderParser.LoaderParserPriority;
exports.loadJson = loadJson.loadJson;
exports.loadTxt = loadTxt.loadTxt;
exports.getFontFamilyName = loadWebFont.getFontFamilyName;
exports.loadWebFont = loadWebFont.loadWebFont;
exports.loadSVG = loadSVG.loadSVG;
exports.loadImageBitmap = loadTextures.loadImageBitmap;
exports.loadTextures = loadTextures.loadTextures;
exports.createTexture = createTexture.createTexture;
exports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;
exports.checkDataUrl = checkDataUrl.checkDataUrl;
exports.checkExtension = checkExtension.checkExtension;
exports.convertToList = convertToList.convertToList;
exports.copySearchParams = copySearchParams.copySearchParams;
exports.createStringVariations = createStringVariations.createStringVariations;
exports.isSingleItem = isSingleItem.isSingleItem;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 50930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
__webpack_require__(41995);
var isSingleItem = __webpack_require__(33888);
var convertToList = __webpack_require__(87993);

class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
        }
      }
      if (!parser) {
        for (let i = 0; i < this.parsers.length; i++) {
          const parserX = this.parsers[i];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = isSingleItem.isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList.convertToList(assetsToLoadIn, (item) => ({
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url = core.utils.path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url]) {
            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
          }
          assets[asset.src] = await this.promiseCache[url].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e) {
          delete this.promiseCache[url];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url}.
${e}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList.convertToList(assetsToUnloadIn, (item) => ({
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url = core.utils.path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
        delete this.promiseCache[url];
      }
    });
    await Promise.all(promises);
  }
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (hash[parser.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
}

exports.Loader = Loader;
//# sourceMappingURL=Loader.js.map


/***/ }),

/***/ 8133:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(84642);
__webpack_require__(90988);

//# sourceMappingURL=index.js.map


/***/ }),

/***/ 37308:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});

exports.LoaderParserPriority = LoaderParserPriority;
//# sourceMappingURL=LoaderParser.js.map


/***/ }),

/***/ 85719:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let UUID = 0;
let MAX_WORKERS;
const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
const checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
};
const workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let workerURL;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this.workerPool = [];
    this.queue = [];
    this.resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve) => {
      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
      const worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate();
        URL.revokeObjectURL(workerURL2);
        resolve(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this.workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      if (!workerURL) {
        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
      }
      this._createdWorkers++;
      worker = new Worker(workerURL);
      worker.addEventListener("message", (event) => {
        this.complete(event.data);
        this.returnWorker(event.target);
        this.next();
      });
    }
    return worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    if (data.error !== void 0) {
      this.resolveHash[data.uuid].reject(data.error);
    } else {
      this.resolveHash[data.uuid].resolve(data.data);
    }
    this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve, reject) => {
      this.queue.push({ id, arguments: args, resolve, reject });
    });
    this.next();
    return promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker) {
      return;
    }
    const toDo = this.queue.pop();
    const id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();

exports.WorkerManager = WorkerManager;
//# sourceMappingURL=WorkerManager.js.map


/***/ }),

/***/ 84642:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var LoaderParser = __webpack_require__(37308);
var loadJson = __webpack_require__(16226);
var loadTxt = __webpack_require__(50146);
var loadWebFont = __webpack_require__(63445);
__webpack_require__(97383);



exports.LoaderParserPriority = LoaderParser.LoaderParserPriority;
exports.loadJson = loadJson.loadJson;
exports.loadTxt = loadTxt.loadTxt;
exports.getFontFamilyName = loadWebFont.getFontFamilyName;
exports.loadWebFont = loadWebFont.loadWebFont;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 16226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var checkDataUrl = __webpack_require__(27754);
var checkExtension = __webpack_require__(97446);
var LoaderParser = __webpack_require__(37308);

const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validJSONMIME) || checkExtension.checkExtension(url, validJSONExtension);
  },
  async load(url) {
    const response = await core.settings.ADAPTER.fetch(url);
    const json = await response.json();
    return json;
  }
};
core.extensions.add(loadJson);

exports.loadJson = loadJson;
//# sourceMappingURL=loadJson.js.map


/***/ }),

/***/ 50146:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var checkDataUrl = __webpack_require__(27754);
var checkExtension = __webpack_require__(97446);
var LoaderParser = __webpack_require__(37308);

const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  name: "loadTxt",
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  test(url) {
    return checkDataUrl.checkDataUrl(url, validTXTMIME) || checkExtension.checkExtension(url, validTXTExtension);
  },
  async load(url) {
    const response = await core.settings.ADAPTER.fetch(url);
    const txt = await response.text();
    return txt;
  }
};
core.extensions.add(loadTxt);

exports.loadTxt = loadTxt;
//# sourceMappingURL=loadTxt.js.map


/***/ }),

/***/ 63445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var checkDataUrl = __webpack_require__(27754);
var checkExtension = __webpack_require__(97446);
var LoaderParser = __webpack_require__(37308);

const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url) {
  const ext = core.utils.path.extname(url);
  const name = core.utils.path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const loadWebFont = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validFontMIMEs) || checkExtension.checkExtension(url, validFontExtensions);
  },
  async load(url, options) {
    const fonts = core.settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name = options.data?.family ?? getFontFamilyName(url);
      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
      const data = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        const weight = weights[i];
        const font = new FontFace(name, `url(${encodeURI(url)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t) => core.settings.ADAPTER.getFontFaceSet().delete(t));
  }
};
core.extensions.add(loadWebFont);

exports.getFontFamilyName = getFontFamilyName;
exports.loadWebFont = loadWebFont;
//# sourceMappingURL=loadWebFont.js.map


/***/ }),

/***/ 97383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var loadSVG = __webpack_require__(91897);
var loadTextures = __webpack_require__(60135);
__webpack_require__(68209);



exports.loadSVG = loadSVG.loadSVG;
exports.loadImageBitmap = loadTextures.loadImageBitmap;
exports.loadTextures = loadTextures.loadTextures;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 91897:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var checkDataUrl = __webpack_require__(27754);
var checkExtension = __webpack_require__(97446);
var LoaderParser = __webpack_require__(37308);
var loadTextures = __webpack_require__(60135);
var createTexture = __webpack_require__(97242);

const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSVG = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validSVGMIME) || checkExtension.checkExtension(url, validSVGExtension);
  },
  async testParse(data) {
    return core.SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    const src = new core.SVGResource(asset, data?.data?.resourceOptions);
    await src.load();
    const base = new core.BaseTexture(src, {
      resolution: core.utils.getResolutionOfUrl(asset),
      ...data?.data
    });
    base.resource.src = asset;
    const texture = createTexture.createTexture(base, loader, asset);
    return texture;
  },
  async load(url, _options) {
    const response = await core.settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload: loadTextures.loadTextures.unload
};
core.extensions.add(loadSVG);

exports.loadSVG = loadSVG;
//# sourceMappingURL=loadSVG.js.map


/***/ }),

/***/ 60135:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var checkDataUrl = __webpack_require__(27754);
var checkExtension = __webpack_require__(97446);
var LoaderParser = __webpack_require__(37308);
var WorkerManager = __webpack_require__(85719);
var createTexture = __webpack_require__(97242);

const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url) {
  const response = await core.settings.ADAPTER.fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url) {
    return checkDataUrl.checkDataUrl(url, validImageMIMEs) || checkExtension.checkExtension(url, validImageExtensions);
  },
  async load(url, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await WorkerManager.WorkerManager.isImageBitmapSupported()) {
        src = await WorkerManager.WorkerManager.loadImageBitmap(url);
      } else {
        src = await loadImageBitmap(url);
      }
    } else {
      src = await new Promise((resolve) => {
        src = new Image();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url;
        if (src.complete) {
          resolve(src);
        } else {
          src.onload = () => {
            resolve(src);
          };
        }
      });
    }
    const base = new core.BaseTexture(src, {
      resolution: core.utils.getResolutionOfUrl(url),
      ...asset.data
    });
    base.resource.src = url;
    return createTexture.createTexture(base, loader, url);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
core.extensions.add(loadTextures);

exports.loadImageBitmap = loadImageBitmap;
exports.loadTextures = loadTextures;
//# sourceMappingURL=loadTextures.js.map


/***/ }),

/***/ 97242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

function createTexture(base, loader, url) {
  const texture = new core.Texture(base);
  texture.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url];
  });
  return texture;
}

exports.createTexture = createTexture;
//# sourceMappingURL=createTexture.js.map


/***/ }),

/***/ 68209:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var createTexture = __webpack_require__(97242);



exports.createTexture = createTexture.createTexture;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 90988:
/***/ (() => {

"use strict";


//# sourceMappingURL=types.js.map


/***/ }),

/***/ 84232:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var convertToList = __webpack_require__(87993);
var createStringVariations = __webpack_require__(35628);
var isSingleItem = __webpack_require__(33888);

class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        if (typeof asset.name === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
          assetNames.push(bundleAssetId);
          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
        } else {
          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
          bundleIds.forEach((bundleId2) => {
            assetNames.push(bundleId2);
          });
          this.add([...asset.name, ...bundleIds], asset.srcs);
        }
      });
    } else {
      Object.keys(assets).forEach((key) => {
        assetNames.push(this._createBundleAssetId(bundleId, key));
        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  add(keysIn, assetsIn, data) {
    const keys = convertToList.convertToList(keysIn);
    keys.forEach((key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    });
    if (!Array.isArray(assetsIn)) {
      if (typeof assetsIn === "string") {
        assetsIn = createStringVariations.createStringVariations(assetsIn);
      } else {
        assetsIn = [assetsIn];
      }
    }
    const assetMap = assetsIn.map((asset) => {
      let formattedAsset = asset;
      if (typeof asset === "string") {
        let parsed = false;
        for (let i = 0; i < this._parsers.length; i++) {
          const parser = this._parsers[i];
          if (parser.test(asset)) {
            formattedAsset = parser.parse(asset);
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          formattedAsset = {
            src: asset
          };
        }
      }
      if (!formattedAsset.format) {
        formattedAsset.format = formattedAsset.src.split(".").pop();
      }
      if (!formattedAsset.alias) {
        formattedAsset.alias = keys;
      }
      if (this._basePath || this._rootPath) {
        formattedAsset.src = core.utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = formattedAsset.data ?? data;
      return formattedAsset;
    });
    keys.forEach((key) => {
      this._assetMap[key] = assetMap;
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem.isSingleItem(bundleIds);
    bundleIds = convertToList.convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i in result) {
        out[i] = result[i].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem.isSingleItem(keys);
    keys = convertToList.convertToList(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          const bestAsset = assets[0];
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          let src = key;
          if (this._basePath || this._rootPath) {
            src = core.utils.path.toAbsolute(src, this._basePath, this._rootPath);
          }
          src = this._appendDefaultSearchParams(src);
          this._resolverHash[key] = {
            src
          };
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
}

exports.Resolver = Resolver;
//# sourceMappingURL=Resolver.js.map


/***/ }),

/***/ 69048:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(83919);
__webpack_require__(31805);

//# sourceMappingURL=index.js.map


/***/ }),

/***/ 83919:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var resolveTextureUrl = __webpack_require__(89947);



exports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 89947:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
__webpack_require__(8133);
var loadTextures = __webpack_require__(60135);

const resolveTextureUrl = {
  extension: core.ExtensionType.ResolveParser,
  test: loadTextures.loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: value.split(".").pop(),
    src: value
  })
};
core.extensions.add(resolveTextureUrl);

exports.resolveTextureUrl = resolveTextureUrl;
//# sourceMappingURL=resolveTextureUrl.js.map


/***/ }),

/***/ 31805:
/***/ (() => {

"use strict";


//# sourceMappingURL=types.js.map


/***/ }),

/***/ 27754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}

exports.checkDataUrl = checkDataUrl;
//# sourceMappingURL=checkDataUrl.js.map


/***/ }),

/***/ 97446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = core.utils.path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}

exports.checkExtension = checkExtension;
//# sourceMappingURL=checkExtension.js.map


/***/ }),

/***/ 87993:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const convertToList = (input, transform) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string") {
      return transform(item);
    }
    return item;
  });
};

exports.convertToList = convertToList;
//# sourceMappingURL=convertToList.js.map


/***/ }),

/***/ 34004:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};

exports.copySearchParams = copySearchParams;
//# sourceMappingURL=copySearchParams.js.map


/***/ }),

/***/ 35628:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}

exports.createStringVariations = createStringVariations;
//# sourceMappingURL=createStringVariations.js.map


/***/ }),

/***/ 41995:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var checkDataUrl = __webpack_require__(27754);
var checkExtension = __webpack_require__(97446);
var convertToList = __webpack_require__(87993);
var copySearchParams = __webpack_require__(34004);
var createStringVariations = __webpack_require__(35628);
var isSingleItem = __webpack_require__(33888);



exports.checkDataUrl = checkDataUrl.checkDataUrl;
exports.checkExtension = checkExtension.checkExtension;
exports.convertToList = convertToList.convertToList;
exports.copySearchParams = copySearchParams.copySearchParams;
exports.createStringVariations = createStringVariations.createStringVariations;
exports.isSingleItem = isSingleItem.isSingleItem;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 33888:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const isSingleItem = (item) => !Array.isArray(item);

exports.isSingleItem = isSingleItem;
//# sourceMappingURL=isSingleItem.js.map


/***/ }),

/***/ 60620:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var colord = __webpack_require__(56284);
var namesPlugin = __webpack_require__(9439);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var namesPlugin__default = /*#__PURE__*/_interopDefaultLegacy(namesPlugin);

colord.extend([namesPlugin__default["default"]]);
const _Color = class {
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  set value(value) {
    if (value instanceof _Color) {
      this._value = this.cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set PIXI.Color#value to null");
    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {
      this.normalize(value);
      this._value = this.cloneSource(value);
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v, i) => v === value2[i]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r, g, b, a] = this._components;
    return { r, g, b, a };
  }
  toRgb() {
    const [r, g, b] = this._components;
    return { r, g, b };
  }
  toRgbaString() {
    const [r, g, b] = this.toUint8RgbArray();
    return `rgba(${r},${g},${b},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r, g, b] = this._components;
    out = out ?? [];
    out[0] = Math.round(r * 255);
    out[1] = Math.round(g * 255);
    out[2] = Math.round(b * 255);
    return out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r, g, b] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  multiply(value) {
    const [r, g, b, a] = _Color.temp.setValue(value)._components;
    this._components[0] *= r;
    this._components[1] *= g;
    this._components[2] *= b;
    this._components[3] *= a;
    this.refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r = this._int >> 16 & 255;
    let g = this._int >> 8 & 255;
    let b = this._int & 255;
    if (applyToRGB) {
      r = r * alpha + 0.5 | 0;
      g = g * alpha + 0.5 | 0;
      b = b * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  round(steps) {
    const [r, g, b] = this._components;
    this._components[0] = Math.round(r * steps) / steps;
    this._components[1] = Math.round(g * steps) / steps;
    this._components[2] = Math.round(b * steps) / steps;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toArray(out) {
    out = out ?? [];
    const [r, g, b, a] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
  }
  normalize(value) {
    let r;
    let g;
    let b;
    let a;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r = (int >> 16 & 255) / 255;
      g = (int >> 8 & 255) / 255;
      b = (int & 255) / 255;
      a = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r, g, b, a = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r, g, b, a = 255] = value;
      r /= 255;
      g /= 255;
      b /= 255;
      a /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = colord.colord(value);
      if (color.isValid()) {
        ({ r, g, b, a } = color.rgba);
        r /= 255;
        g /= 255;
        b /= 255;
      }
    }
    if (r !== void 0) {
      this._components[0] = r;
      this._components[1] = g;
      this._components[2] = b;
      this._components[3] = a;
      this.refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  refreshInt() {
    this._clamp(this._components);
    const [r, g, b] = this._components;
    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
  }
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v, i) => {
      value[i] = Math.min(Math.max(v, min), max);
    });
    return value;
  }
};
let Color = _Color;
Color.shared = new _Color();
Color.temp = new _Color();
Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;

exports.Color = Color;
//# sourceMappingURL=Color.js.map


/***/ }),

/***/ 61595:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Color = __webpack_require__(60620);



exports.Color = Color.Color;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 80311:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  return INTERNAL_FORMATS2;
})(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,
  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,
  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,
  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,
  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,
  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,
  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,
  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,
  [37488 /* COMPRESSED_R11_EAC */]: 0.5,
  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,
  [37490 /* COMPRESSED_RG11_EAC */]: 1,
  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,
  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,
  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,
  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,
  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,
  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */]: 0.5,
  [35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */]: 0.5,
  [35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */]: 0.25,
  [35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */]: 0.25,
  [36196 /* COMPRESSED_RGB_ETC1_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGB_ATC_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */]: 1,
  [34798 /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */]: 1,
  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1
};

exports.INTERNAL_FORMATS = INTERNAL_FORMATS;
exports.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ 39260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(80311);
__webpack_require__(69195);
__webpack_require__(67379);
__webpack_require__(62378);
var detectCompressedTextures = __webpack_require__(80637);
var loadDDS = __webpack_require__(75326);
var loadKTX = __webpack_require__(59194);
var resolveCompressedTextureUrl = __webpack_require__(10786);
var parseDDS = __webpack_require__(3955);
var parseKTX = __webpack_require__(24095);
var BlobResource = __webpack_require__(84167);
var CompressedTextureResource = __webpack_require__(26562);



exports.INTERNAL_FORMATS = _const.INTERNAL_FORMATS;
exports.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
exports.detectCompressedTextures = detectCompressedTextures.detectCompressedTextures;
exports.loadDDS = loadDDS.loadDDS;
exports.loadKTX = loadKTX.loadKTX;
exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;
exports.parseDDS = parseDDS.parseDDS;
exports.FORMATS_TO_COMPONENTS = parseKTX.FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = parseKTX.TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = parseKTX.TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX.parseKTX;
exports.BlobResource = BlobResource.BlobResource;
exports.CompressedTextureResource = CompressedTextureResource.CompressedTextureResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 51281:
/***/ (() => {

"use strict";


//# sourceMappingURL=compressedTextureExtensions.js.map


/***/ }),

/***/ 80637:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

let storedGl;
let extensions;
function getCompressedTextureExtensions() {
  extensions = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const canvas = core.settings.ADAPTER.createCanvas();
    const gl = canvas.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures.");
      return false;
    }
    storedGl = gl;
    return true;
  },
  add: async (formats) => {
    if (!extensions)
      getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions) {
      const extension = extensions[extensionName];
      if (!extension) {
        continue;
      }
      textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats];
  },
  remove: async (formats) => {
    if (!extensions)
      getCompressedTextureExtensions();
    return formats.filter((f) => !(f in extensions));
  }
};
core.extensions.add(detectCompressedTextures);

exports.detectCompressedTextures = detectCompressedTextures;
//# sourceMappingURL=detectCompressedTextures.js.map


/***/ }),

/***/ 69195:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(51281);
var detectCompressedTextures = __webpack_require__(80637);
var loadDDS = __webpack_require__(75326);
var loadKTX = __webpack_require__(59194);
var resolveCompressedTextureUrl = __webpack_require__(10786);



exports.detectCompressedTextures = detectCompressedTextures.detectCompressedTextures;
exports.loadDDS = loadDDS.loadDDS;
exports.loadKTX = loadKTX.loadKTX;
exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 75326:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(13369);
var core = __webpack_require__(11491);
__webpack_require__(67379);
var parseDDS = __webpack_require__(3955);

const loadDDS = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url) {
    return assets.checkExtension(url, ".dds");
  },
  async load(url, asset, loader) {
    const response = await core.settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const resources = parseDDS.parseDDS(arrayBuffer);
    const textures = resources.map((resource) => {
      const base = new core.BaseTexture(resource, {
        mipmap: core.MIPMAP_MODES.OFF,
        alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: core.utils.getResolutionOfUrl(url),
        ...asset.data
      });
      return assets.createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
core.extensions.add(loadDDS);

exports.loadDDS = loadDDS;
//# sourceMappingURL=loadDDS.js.map


/***/ }),

/***/ 59194:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(13369);
var core = __webpack_require__(11491);
__webpack_require__(67379);
var parseKTX = __webpack_require__(24095);

const loadKTX = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url) {
    return assets.checkExtension(url, ".ktx");
  },
  async load(url, asset, loader) {
    const response = await core.settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const { compressed, uncompressed, kvData } = parseKTX.parseKTX(url, arrayBuffer);
    const resources = compressed ?? uncompressed;
    const options = {
      mipmap: core.MIPMAP_MODES.OFF,
      alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: core.utils.getResolutionOfUrl(url),
      ...asset.data
    };
    const textures = resources.map((resource) => {
      if (resources === uncompressed) {
        Object.assign(options, {
          type: resource.type,
          format: resource.format
        });
      }
      const base = new core.BaseTexture(resource, options);
      base.ktxKeyValueData = kvData;
      return assets.createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
core.extensions.add(loadKTX);

exports.loadKTX = loadKTX;
//# sourceMappingURL=loadKTX.js.map


/***/ }),

/***/ 10786:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const resolveCompressedTextureUrl = {
  extension: core.ExtensionType.ResolveParser,
  test: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    if (extension === "ktx") {
      const extensions2 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions2.some((ext) => value.endsWith(ext))) {
        return {
          resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: extensions2.find((ext) => value.endsWith(ext)),
          src: value
        };
      }
    }
    return {
      resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: value.split(".").pop(),
      src: value
    };
  }
};
core.extensions.add(resolveCompressedTextureUrl);

exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl;
//# sourceMappingURL=resolveCompressedTextureUrl.js.map


/***/ }),

/***/ 67379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var parseDDS = __webpack_require__(3955);
var parseKTX = __webpack_require__(24095);



exports.parseDDS = parseDDS.parseDDS;
exports.FORMATS_TO_COMPONENTS = parseKTX.FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = parseKTX.TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = parseKTX.TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX.parseKTX;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 3955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(80311);
__webpack_require__(62378);
var CompressedTextureResource = __webpack_require__(26562);

const DDS_MAGIC_SIZE = 4;
const DDS_HEADER_SIZE = 124;
const DDS_HEADER_PF_SIZE = 32;
const DDS_HEADER_DX10_SIZE = 20;
const DDS_MAGIC = 542327876;
const DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
const DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
const DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
  return DXGI_FORMAT2;
})(DXGI_FORMAT || {});
var D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
  return D3D10_RESOURCE_DIMENSION2;
})(D3D10_RESOURCE_DIMENSION || {});
const PF_FLAGS = 1;
const DDPF_ALPHA = 2;
const DDPF_FOURCC = 4;
const DDPF_RGB = 64;
const DDPF_YUV = 512;
const DDPF_LUMINANCE = 131072;
const FOURCC_DXT1 = 827611204;
const FOURCC_DXT3 = 861165636;
const FOURCC_DXT5 = 894720068;
const FOURCC_DX10 = 808540228;
const DDS_RESOURCE_MISC_TEXTURECUBE = 4;
const FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
};
const DXGI_TO_FORMAT = {
  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [71 /* DXGI_FORMAT_BC1_UNORM */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [74 /* DXGI_FORMAT_BC2_UNORM */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [77 /* DXGI_FORMAT_BC3_UNORM */]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  const magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const height = header[DDS_FIELDS.HEIGHT];
  const width = header[DDS_FIELDS.WIDTH];
  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const texData = new Uint8Array(arrayBuffer, dataOffset2);
      const resource = new CompressedTextureResource.CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0) {
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === 6 /* DDS_DIMENSION_TEXTURE3D */) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    const imageBuffers = new Array();
    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      const pixelSize = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0;
      let levelWidth = width;
      let levelHeight = height;
      for (let i = 0; i < mipmapCount; i++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i = 0; i < arraySize; i++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map((buffer) => new CompressedTextureResource.CompressedTextureResource(buffer, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}

exports.parseDDS = parseDDS;
//# sourceMappingURL=parseDDS.js.map


/***/ }),

/***/ 24095:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var _const = __webpack_require__(80311);
__webpack_require__(62378);
var CompressedTextureResource = __webpack_require__(26562);

const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
const ENDIANNESS = 67305985;
const KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const TYPES_TO_BYTES_PER_COMPONENT = {
  [core.TYPES.UNSIGNED_BYTE]: 1,
  [core.TYPES.UNSIGNED_SHORT]: 2,
  [core.TYPES.INT]: 4,
  [core.TYPES.UNSIGNED_INT]: 4,
  [core.TYPES.FLOAT]: 4,
  [core.TYPES.HALF_FLOAT]: 8
};
const FORMATS_TO_COMPONENTS = {
  [core.FORMATS.RGBA]: 4,
  [core.FORMATS.RGB]: 3,
  [core.FORMATS.RG]: 2,
  [core.FORMATS.RED]: 1,
  [core.FORMATS.LUMINANCE]: 1,
  [core.FORMATS.LUMINANCE_ALPHA]: 2,
  [core.FORMATS.ALPHA]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
  [core.TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [core.TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [core.TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url, dataView)) {
    return null;
  }
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  const blockWidth = 4;
  const blockHeight = 4;
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  const imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  const imageByteSize = imagePixels * imagePixelByteSize;
  let mipByteSize = imageByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer = levelBuffers[0].levelBuffer;
        let convertToInt = false;
        if (glType === core.TYPES.FLOAT) {
          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === core.TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === core.TYPES.INT) {
          convertToInt = true;
          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new core.BufferResource(buffer, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource.CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function validate(url, dataView) {
  for (let i = 0; i < FILE_IDENTIFIER.length; i++) {
    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
      console.error(`${url} is not a valid *.ktx file!`);
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format) {
  switch (format) {
    case core.FORMATS.RGBA:
      return core.FORMATS.RGBA_INTEGER;
    case core.FORMATS.RGB:
      return core.FORMATS.RGB_INTEGER;
    case core.FORMATS.RG:
      return core.FORMATS.RG_INTEGER;
    case core.FORMATS.RED:
      return core.FORMATS.RED_INTEGER;
    default:
      return format;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}

exports.FORMATS_TO_COMPONENTS = FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX;
//# sourceMappingURL=parseKTX.js.map


/***/ }),

/***/ 84167:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class BlobResource extends core.BufferResource {
  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
    let origin;
    let data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    super(data, options);
    this.origin = origin;
    this.buffer = data ? new core.ViewableBuffer(data) : null;
    this._load = null;
    this.loaded = false;
    if (this.origin !== null && options.autoLoad !== false) {
      this.load();
    }
    if (this.origin === null && this.buffer) {
      this._load = Promise.resolve(this);
      this.loaded = true;
      this.onBlobLoaded(this.buffer.rawBinaryData);
    }
  }
  onBlobLoaded(_data) {
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new core.ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    });
    return this._load;
  }
}

exports.BlobResource = BlobResource;
//# sourceMappingURL=BlobResource.js.map


/***/ }),

/***/ 26562:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(80311);
var BlobResource = __webpack_require__(84167);

class CompressedTextureResource extends BlobResource.BlobResource {
  constructor(source, options) {
    super(source, options);
    this.format = options.format;
    this.levels = options.levels || 1;
    this._width = options.width;
    this._height = options.height;
    this._extension = CompressedTextureResource._formatToExtension(this.format);
    if (options.levelBuffers || this.buffer) {
      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
  }
  upload(renderer, _texture, _glTexture) {
    const gl = renderer.gl;
    const extension = renderer.context.extensions[this._extension];
    if (!extension) {
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (let i = 0, j = this.levels; i < j; i++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  }
  static _formatToExtension(format) {
    if (format >= 33776 && format <= 33779) {
      return "s3tc";
    } else if (format >= 37488 && format <= 37497) {
      return "etc";
    } else if (format >= 35840 && format <= 35843) {
      return "pvrtc";
    } else if (format >= 36196) {
      return "etc1";
    } else if (format >= 35986 && format <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer.byteOffset;
    let levelWidth = imageWidth;
    let levelHeight = imageHeight;
    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    let levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    for (let i = 0; i < levels; i++) {
      buffers[i] = {
        levelID: i,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    }
    return buffers;
  }
}

exports.CompressedTextureResource = CompressedTextureResource;
//# sourceMappingURL=CompressedTextureResource.js.map


/***/ }),

/***/ 62378:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BlobResource = __webpack_require__(84167);
var CompressedTextureResource = __webpack_require__(26562);



exports.BlobResource = BlobResource.BlobResource;
exports.CompressedTextureResource = CompressedTextureResource.CompressedTextureResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 21837:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ENV = /* @__PURE__ */ ((ENV2) => {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
  return ENV2;
})(ENV || {});
var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
  return RENDERER_TYPE2;
})(RENDERER_TYPE || {});
var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
  return BUFFER_BITS2;
})(BUFFER_BITS || {});
var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
  return BLEND_MODES2;
})(BLEND_MODES || {});
var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  return DRAW_MODES2;
})(DRAW_MODES || {});
var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return FORMATS2;
})(FORMATS || {});
var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return TARGETS2;
})(TARGETS || {});
var TYPES = /* @__PURE__ */ ((TYPES2) => {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return TYPES2;
})(TYPES || {});
var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
  return SAMPLER_TYPES2;
})(SAMPLER_TYPES || {});
var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
  return SCALE_MODES2;
})(SCALE_MODES || {});
var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return WRAP_MODES2;
})(WRAP_MODES || {});
var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
  return MIPMAP_MODES2;
})(MIPMAP_MODES || {});
var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  return ALPHA_MODES2;
})(ALPHA_MODES || {});
var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
  return CLEAR_MODES2;
})(CLEAR_MODES || {});
var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
  return GC_MODES2;
})(GC_MODES || {});
var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
  return PRECISION2;
})(PRECISION || {});
var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
  return MASK_TYPES2;
})(MASK_TYPES || {});
var COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
  return COLOR_MASK_BITS2;
})(COLOR_MASK_BITS || {});
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});

exports.ALPHA_MODES = ALPHA_MODES;
exports.BLEND_MODES = BLEND_MODES;
exports.BUFFER_BITS = BUFFER_BITS;
exports.BUFFER_TYPE = BUFFER_TYPE;
exports.CLEAR_MODES = CLEAR_MODES;
exports.COLOR_MASK_BITS = COLOR_MASK_BITS;
exports.DRAW_MODES = DRAW_MODES;
exports.ENV = ENV;
exports.FORMATS = FORMATS;
exports.GC_MODES = GC_MODES;
exports.MASK_TYPES = MASK_TYPES;
exports.MIPMAP_MODES = MIPMAP_MODES;
exports.MSAA_QUALITY = MSAA_QUALITY;
exports.PRECISION = PRECISION;
exports.RENDERER_TYPE = RENDERER_TYPE;
exports.SAMPLER_TYPES = SAMPLER_TYPES;
exports.SCALE_MODES = SCALE_MODES;
exports.TARGETS = TARGETS;
exports.TYPES = TYPES;
exports.WRAP_MODES = WRAP_MODES;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 82251:
/***/ (() => {

"use strict";


//# sourceMappingURL=IRenderer.js.map


/***/ }),

/***/ 21452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);
var settings = __webpack_require__(1405);
var utils = __webpack_require__(61973);
var UniformGroup = __webpack_require__(35842);
var SystemManager = __webpack_require__(80557);

const _Renderer = class extends SystemManager.SystemManager {
  constructor(options) {
    super();
    this.type = constants.RENDERER_TYPE.WEBGL;
    options = Object.assign({}, settings.settings.RENDER_OPTIONS, options);
    this.gl = null;
    this.CONTEXT_UID = 0;
    this.globalUniforms = new UniformGroup.UniformGroup({
      projectionMatrix: new math.Matrix()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig);
    if ("useContextAlpha" in options) {
      utils.deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
    }
    this._plugin.rendererPlugins = _Renderer.__plugins;
    this.options = options;
    this.startup.run(this.options);
  }
  static test(options) {
    if (options?.forceCanvas) {
      return false;
    }
    return utils.isWebGLSupported();
  }
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  reset() {
    this.runners.reset.emit();
    return this;
  }
  clear() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  }
  destroy(removeView = false) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    utils.deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
    return this.background.clearBeforeRender;
  }
  get useContextAlpha() {
    utils.deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
    return this.context.useContextAlpha;
  }
  get preserveDrawingBuffer() {
    utils.deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
    return this.context.preserveDrawingBuffer;
  }
  get backgroundColor() {
    utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    return this.background.color;
  }
  set backgroundColor(value) {
    utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    this.background.color = value;
  }
  get backgroundAlpha() {
    utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    return this.background.alpha;
  }
  set backgroundAlpha(value) {
    utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    this.background.alpha = value;
  }
  get powerPreference() {
    utils.deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
    return this.context.powerPreference;
  }
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
let Renderer = _Renderer;
Renderer.extension = {
  type: extensions.ExtensionType.Renderer,
  priority: 1
};
Renderer.__plugins = {};
Renderer.__systems = {};
extensions.extensions.handleByMap(extensions.ExtensionType.RendererPlugin, Renderer.__plugins);
extensions.extensions.handleByMap(extensions.ExtensionType.RendererSystem, Renderer.__systems);
extensions.extensions.add(Renderer);

exports.Renderer = Renderer;
//# sourceMappingURL=Renderer.js.map


/***/ }),

/***/ 24652:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);

const renderers = [];
extensions.extensions.handleByList(extensions.ExtensionType.Renderer, renderers);
function autoDetectRenderer(options) {
  for (const RendererType of renderers) {
    if (RendererType.test(options)) {
      return new RendererType(options);
    }
  }
  throw new Error("Unable to auto-detect a suitable renderer.");
}

exports.autoDetectRenderer = autoDetectRenderer;
//# sourceMappingURL=autoDetectRenderer.js.map


/***/ }),

/***/ 37399:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(61595);
var extensions = __webpack_require__(9498);

class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new color.Color(0);
    this.alpha = 1;
  }
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options;
    const color = background ?? backgroundColor;
    if (color !== void 0) {
      this.color = color;
    }
    this.alpha = backgroundAlpha;
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: true
};
BackgroundSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions.extensions.add(BackgroundSystem);

exports.BackgroundSystem = BackgroundSystem;
//# sourceMappingURL=BackgroundSystem.js.map


/***/ }),

/***/ 55438:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

class BatchDrawCall {
  constructor() {
    this.texArray = null;
    this.blend = 0;
    this.type = constants.DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
}

exports.BatchDrawCall = BatchDrawCall;
//# sourceMappingURL=BatchDrawCall.js.map


/***/ }),

/***/ 57304:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var Buffer = __webpack_require__(27112);
var Geometry = __webpack_require__(26818);

class BatchGeometry extends Geometry.Geometry {
  constructor(_static = false) {
    super();
    this._buffer = new Buffer.Buffer(null, _static, false);
    this._indexBuffer = new Buffer.Buffer(null, _static, true);
    this.addAttribute("aVertexPosition", this._buffer, 2, false, constants.TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, constants.TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, constants.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, constants.TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}

exports.BatchGeometry = BatchGeometry;
//# sourceMappingURL=BatchGeometry.js.map


/***/ }),

/***/ 17475:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(61595);
var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var settings = __webpack_require__(1405);
var utils = __webpack_require__(61973);
var ViewableBuffer = __webpack_require__(22109);
var checkMaxIfStatementsInShader = __webpack_require__(92970);
var State = __webpack_require__(45944);
var BaseTexture = __webpack_require__(96728);
var BatchDrawCall = __webpack_require__(55438);
var BatchGeometry = __webpack_require__(57304);
var BatchShaderGenerator = __webpack_require__(53464);
var BatchTextureArray = __webpack_require__(10776);
var canUploadSameBuffer = __webpack_require__(38155);
var maxRecommendedTextures = __webpack_require__(54831);
var ObjectRenderer = __webpack_require__(43474);
var texture$1 = __webpack_require__(45451);
var texture = __webpack_require__(94205);

const _BatchRenderer = class extends ObjectRenderer.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.setShaderGenerator();
    this.geometryClass = BatchGeometry.BatchGeometry;
    this.vertexSize = 6;
    this.state = State.State.for2d();
    this.size = _BatchRenderer.defaultBatchSize * 4;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._bufferedElements = [];
    this._bufferedTextures = [];
    this._bufferSize = 0;
    this._shader = null;
    this._packedGeometries = [];
    this._packedGeometryPoolSize = 2;
    this._flushId = 0;
    this._aBuffers = {};
    this._iBuffers = {};
    this.maxTextures = 1;
    this.renderer.on("prerender", this.onPrerender, this);
    renderer.runners.contextChange.add(this);
    this._dcIndex = 0;
    this._aIndex = 0;
    this._iIndex = 0;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    this._tempBoundTextures = [];
  }
  static get defaultMaxTextures() {
    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures.maxRecommendedTextures(32);
    return this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  static get canUploadSameBuffer() {
    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer.canUploadSameBuffer();
    return this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  get MAX_TEXTURES() {
    utils.deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
    return this.maxTextures;
  }
  static get defaultVertexSrc() {
    return texture["default"];
  }
  static get defaultFragmentTemplate() {
    return texture$1["default"];
  }
  setShaderGenerator({
    vertex = _BatchRenderer.defaultVertexSrc,
    fragment = _BatchRenderer.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator.BatchShaderGenerator(vertex, fragment);
  }
  contextChange() {
    const gl = this.renderer.gl;
    if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
      this.maxTextures = 1;
    } else {
      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
      this.maxTextures = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader(this.maxTextures, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      this._packedGeometries[i] = new this.geometryClass();
    }
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer;
    const MAX_SPRITES = this.size / 4;
    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall.BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray.BatchTextureArray());
    }
    for (let i = 0; i < this.maxTextures; i++) {
      this._tempBoundTextures[i] = null;
    }
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this;
    const textureArrays = _BatchRenderer._textureArrayPool;
    const batch = this.renderer.batch;
    const boundTextures = this._tempBoundTextures;
    const touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture.BaseTexture._globalBatch;
    let countTexArrays = 0;
    let texArray = textureArrays[0];
    let start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i = 0; i < this._bufferSize; ++i) {
      const tex = textures[i];
      textures[i] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= maxTextures) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start, i);
        start = i;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, maxTextures);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (let i = 0; i < boundTextures.length; i++) {
      boundTextures[i] = null;
    }
    BaseTexture.BaseTexture._globalBatch = TICK;
  }
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this;
    const drawCalls = _BatchRenderer._drawCallPool;
    let dcIndex = this._dcIndex;
    let aIndex = this._aIndex;
    let iIndex = this._iIndex;
    let drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (let i = start; i < finish; ++i) {
      const sprite = elements[i];
      const tex = sprite._texture.baseTexture;
      const spriteBlendMode = utils.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null;
      if (start < i && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  }
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j = 0; j < texArray.count; j++) {
      textureSystem.bind(texArray.elements[j], texArray.ids[j]);
      texArray.elements[j] = null;
    }
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    if (!_BatchRenderer.canUploadSameBuffer) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  }
  drawBatches() {
    const dcCount = this._dcIndex;
    const { gl, state: stateSystem } = this.renderer;
    const drawCalls = _BatchRenderer._drawCallPool;
    let curTexArray = null;
    for (let i = 0; i < dcCount; i++) {
      const { texArray, type, size, start, blend } = drawCalls[i];
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  flush() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  }
  start() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.maxTextures);
    this.renderer.shader.bind(this._shader);
    if (_BatchRenderer.canUploadSameBuffer) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      if (this._packedGeometries[i]) {
        this._packedGeometries[i].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    super.destroy();
  }
  getAttributeBuffer(size) {
    const roundedP2 = utils.nextPow2(Math.ceil(size / 8));
    const roundedSizeIndex = utils.log2(roundedP2);
    const roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new ViewableBuffer.ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  }
  getIndexBuffer(size) {
    const roundedP2 = utils.nextPow2(Math.ceil(size / 12));
    const roundedSizeIndex = utils.log2(roundedP2);
    const roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  }
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer;
    const packedVertices = aIndex / this.vertexSize;
    const uvs = element.uvs;
    const indicies = element.indices;
    const vertexData = element.vertexData;
    const textureId = element._texture.baseTexture._batchLocation;
    const alpha = Math.min(element.worldAlpha, 1);
    const argb = color.Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i = 0; i < vertexData.length; i += 2) {
      float32View[aIndex++] = vertexData[i];
      float32View[aIndex++] = vertexData[i + 1];
      float32View[aIndex++] = uvs[i];
      float32View[aIndex++] = uvs[i + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (let i = 0; i < indicies.length; i++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i];
    }
  }
};
let BatchRenderer = _BatchRenderer;
BatchRenderer.defaultBatchSize = 4096;
BatchRenderer.extension = {
  name: "batch",
  type: extensions.ExtensionType.RendererPlugin
};
BatchRenderer._drawCallPool = [];
BatchRenderer._textureArrayPool = [];
extensions.extensions.add(BatchRenderer);

exports.BatchRenderer = BatchRenderer;
//# sourceMappingURL=BatchRenderer.js.map


/***/ }),

/***/ 53464:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(23846);
var Program = __webpack_require__(69197);
var Shader = __webpack_require__(2520);
var UniformGroup = __webpack_require__(35842);

class BatchShaderGenerator {
  constructor(vertexSrc, fragTemplate) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (!fragTemplate.includes("%count%")) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (!fragTemplate.includes("%forloop%")) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program.Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new math.Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader.Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += `if(vTextureId < ${i}.5)`;
      }
      src += "\n{";
      src += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}

exports.BatchShaderGenerator = BatchShaderGenerator;
//# sourceMappingURL=BatchShaderGenerator.js.map


/***/ }),

/***/ 77117:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var ObjectRenderer = __webpack_require__(43474);

class BatchSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new ObjectRenderer.ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  setObjectRenderer(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i = maxTextures - 1; i >= 0; --i) {
      arr[i] = boundTextures[i] || null;
      if (arr[i]) {
        arr[i]._batchLocation = i;
      }
    }
  }
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j = 0;
    for (let i = 0; i < count; i++) {
      const tex = elements[i];
      const loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      while (j < maxTextures) {
        const bound = boundTextures[j];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
          j++;
          continue;
        }
        ids[i] = j;
        tex._batchLocation = j;
        boundTextures[j] = tex;
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "batch"
};
extensions.extensions.add(BatchSystem);

exports.BatchSystem = BatchSystem;
//# sourceMappingURL=BatchSystem.js.map


/***/ }),

/***/ 10776:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BatchTextureArray {
  constructor() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  clear() {
    for (let i = 0; i < this.count; i++) {
      this.elements[i] = null;
    }
    this.count = 0;
  }
}

exports.BatchTextureArray = BatchTextureArray;
//# sourceMappingURL=BatchTextureArray.js.map


/***/ }),

/***/ 43474:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class ObjectRenderer {
  constructor(renderer) {
    this.renderer = renderer;
  }
  flush() {
  }
  destroy() {
    this.renderer = null;
  }
  start() {
  }
  stop() {
    this.flush();
  }
  render(_object) {
  }
}

exports.ObjectRenderer = ObjectRenderer;
//# sourceMappingURL=ObjectRenderer.js.map


/***/ }),

/***/ 38155:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(1405);

function canUploadSameBuffer() {
  return !settings.isMobile.apple.device;
}

exports.canUploadSameBuffer = canUploadSameBuffer;
//# sourceMappingURL=canUploadSameBuffer.js.map


/***/ }),

/***/ 54831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(1405);

function maxRecommendedTextures(max) {
  let allowMax = true;
  const navigator = settings.settings.ADAPTER.getNavigator();
  if (settings.isMobile.tablet || settings.isMobile.phone) {
    if (settings.isMobile.apple.device) {
      const match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (settings.isMobile.android.device) {
      const match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}

exports.maxRecommendedTextures = maxRecommendedTextures;
//# sourceMappingURL=maxRecommendedTextures.js.map


/***/ }),

/***/ 45451:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";

exports["default"] = defaultFragment;
//# sourceMappingURL=texture.js.map


/***/ }),

/***/ 94205:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";

exports["default"] = defaultVertex;
//# sourceMappingURL=texture2.js.map


/***/ }),

/***/ 39305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var settings = __webpack_require__(1405);

let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this.renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      this.useContextAlpha = options.useContextAlpha;
      this.powerPreference = options.powerPreference;
      this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    if (view.addEventListener !== void 0) {
      view.addEventListener("webglcontextlost", this.handleContextLost, false);
      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
  }
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  createContext(canvas, options) {
    let gl;
    if (settings.settings.PREFER_ENV >= constants.ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    setTimeout(() => {
      if (this.gl.isContextLost() && this.extensions.loseContext) {
        this.extensions.loseContext.restoreContext();
      }
    }, 0);
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null;
    if (view.removeEventListener !== void 0) {
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    }
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  }
  postrender() {
    if (this.renderer.objectRenderer.renderingToScreen) {
      this.gl.flush();
    }
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
}
ContextSystem.defaultOptions = {
  context: null,
  antialias: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default"
};
ContextSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "context"
};
extensions.extensions.add(ContextSystem);

exports.ContextSystem = ContextSystem;
//# sourceMappingURL=ContextSystem.js.map


/***/ }),

/***/ 87705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var Program = __webpack_require__(69197);
var Shader = __webpack_require__(2520);
var State = __webpack_require__(45944);
var defaultFilter$1 = __webpack_require__(64272);
var defaultFilter = __webpack_require__(65912);

const _Filter = class extends Shader.Shader {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
    super(program, uniforms);
    this.padding = 0;
    this.resolution = _Filter.defaultResolution;
    this.multisample = _Filter.defaultMultisample;
    this.enabled = true;
    this.autoFit = true;
    this.state = new State.State();
  }
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  static get defaultVertexSrc() {
    return defaultFilter["default"];
  }
  static get defaultFragmentSrc() {
    return defaultFilter$1["default"];
  }
};
let Filter = _Filter;
Filter.defaultResolution = 1;
Filter.defaultMultisample = constants.MSAA_QUALITY.NONE;

exports.Filter = Filter;
//# sourceMappingURL=Filter.js.map


/***/ }),

/***/ 10216:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var math = __webpack_require__(23846);

class FilterState {
  constructor() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = constants.MSAA_QUALITY.NONE;
    this.sourceFrame = new math.Rectangle();
    this.destinationFrame = new math.Rectangle();
    this.bindingSourceFrame = new math.Rectangle();
    this.bindingDestinationFrame = new math.Rectangle();
    this.filters = [];
    this.transform = null;
  }
  clear() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  }
}

exports.FilterState = FilterState;
//# sourceMappingURL=FilterState.js.map


/***/ }),

/***/ 38132:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);
var RenderTexturePool = __webpack_require__(56662);
var UniformGroup = __webpack_require__(35842);
var Quad = __webpack_require__(50102);
var QuadUv = __webpack_require__(60357);
var FilterState = __webpack_require__(10216);

const tempPoints = [new math.Point(), new math.Point(), new math.Point(), new math.Point()];
const tempMatrix = new math.Matrix();
class FilterSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool.RenderTexturePool();
    this.statePool = [];
    this.quad = new Quad.Quad();
    this.quadUv = new QuadUv.QuadUv();
    this.tempRect = new math.Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup.UniformGroup({
      outputFrame: new math.Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(target, filters) {
    const renderer = this.renderer;
    const filterStack = this.defaultFilterStack;
    const state = this.statePool.pop() || new FilterState.FilterState();
    const renderTextureSystem = this.renderer.renderTexture;
    let resolution = filters[0].resolution;
    let multisample = filters[0].multisample;
    let padding = filters[0].padding;
    let autoFit = filters[0].autoFit;
    let legacy = filters[0].legacy ?? true;
    for (let i = 1; i < filters.length; i++) {
      const filter = filters[i];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || (filter.legacy ?? true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer.projection.transform) {
      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  }
  pop() {
    const filterStack = this.defaultFilterStack;
    const state = filterStack.pop();
    const filters = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize;
    const inputPixel = globalUniforms.inputPixel;
    const inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      let flip = state.renderTexture;
      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      let i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        if (i === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i].apply(this, flip, flop, constants.CLEAR_MODES.CLEAR, state);
        const t = flip;
        flip = flop;
        flop = t;
      }
      filters[i].apply(this, flip, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state);
      if (i > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  }
  bindAndClear(filterTexture, clearMode = constants.CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === constants.CLEAR_MODES.CLEAR || clearMode === constants.CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  }
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(constants.DRAW_MODES.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(constants.DRAW_MODES.TRIANGLE_STRIP);
    }
  }
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState;
    const { orig } = sprite._texture;
    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    const worldTransform = sprite.worldTransform.copyTo(math.Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this.renderer = null;
    this.texturePool.clear(false);
  }
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  getFilterTexture(input, resolution, multisample) {
    if (typeof input === "number") {
      const swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || constants.MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  emptyPool() {
    this.texturePool.clear(true);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(matrix, rect) {
    const lt = tempPoints[0];
    const lb = tempPoints[1];
    const rt = tempPoints[2];
    const rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      const { a, b, c, d } = transform;
      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  }
}
FilterSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "filter"
};
extensions.extensions.add(FilterSystem);

exports.FilterSystem = FilterSystem;
//# sourceMappingURL=FilterSystem.js.map


/***/ }),

/***/ 35947:
/***/ (() => {

"use strict";


//# sourceMappingURL=IFilterTarget.js.map


/***/ }),

/***/ 64272:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";

exports["default"] = defaultFragment;
//# sourceMappingURL=defaultFilter.js.map


/***/ }),

/***/ 65912:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

exports["default"] = defaultVertex;
//# sourceMappingURL=defaultFilter2.js.map


/***/ }),

/***/ 36778:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(23846);
var TextureMatrix = __webpack_require__(32518);
var Filter = __webpack_require__(87705);
var spriteMaskFilter$1 = __webpack_require__(72490);
var spriteMaskFilter = __webpack_require__(61977);

class SpriteMaskFilter extends Filter.Filter {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    super(vertexSrc || spriteMaskFilter["default"], fragmentSrc || spriteMaskFilter$1["default"], uniforms);
    this.maskSprite = sprite;
    this.maskMatrix = new math.Matrix();
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value;
    if (this._maskSprite) {
      this._maskSprite.renderable = false;
    }
  }
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite;
    const tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix.TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}

exports.SpriteMaskFilter = SpriteMaskFilter;
//# sourceMappingURL=SpriteMaskFilter.js.map


/***/ }),

/***/ 72490:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=spriteMaskFilter2.js.map


/***/ }),

/***/ 61977:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=spriteMaskFilter3.js.map


/***/ }),

/***/ 62684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

exports["default"] = $defaultVertex;
//# sourceMappingURL=default.js.map


/***/ }),

/***/ 53010:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

exports["default"] = $defaultFilterVertex;
//# sourceMappingURL=defaultFilter.js.map


/***/ }),

/***/ 81961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _default = __webpack_require__(62684);
var defaultFilter = __webpack_require__(53010);

const defaultVertex = _default["default"];
const defaultFilterVertex = defaultFilter["default"];

exports.defaultFilterVertex = defaultFilterVertex;
exports.defaultVertex = defaultVertex;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 71124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var runner = __webpack_require__(69866);
var BaseTexture = __webpack_require__(96728);
var DepthResource = __webpack_require__(92107);

class Framebuffer {
  constructor(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new runner.Runner("disposeFramebuffer");
    this.multisample = constants.MSAA_QUALITY.NONE;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(index = 0, texture) {
    this.colorTextures[index] = texture || new BaseTexture.BaseTexture(null, {
      scaleMode: constants.SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: constants.MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  addDepthTexture(texture) {
    this.depthTexture = texture || new BaseTexture.BaseTexture(new DepthResource.DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: constants.SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: constants.MIPMAP_MODES.OFF,
      format: constants.FORMATS.DEPTH_COMPONENT,
      type: constants.TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableDepth() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableStencil() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (let i = 0; i < this.colorTextures.length; i++) {
      const texture = this.colorTextures[i];
      const resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      const resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroyDepthTexture() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  }
}

exports.Framebuffer = Framebuffer;
//# sourceMappingURL=Framebuffer.js.map


/***/ }),

/***/ 39849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);
var settings = __webpack_require__(1405);
var Framebuffer = __webpack_require__(71124);
var GLFramebuffer = __webpack_require__(6633);

const tempRectangle = new math.Rectangle();
class FramebufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer.Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new math.Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension) {
        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
      } else {
        this.hasMRT = false;
        gl.drawBuffers = () => {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  }
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (let i = 0; i < framebuffer.colorTextures.length; i++) {
        const tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        const mipWidth = frame.width >> mipLevel;
        const mipHeight = frame.height >> mipLevel;
        const scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        const mipWidth = framebuffer.width >> mipLevel;
        const mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  }
  setViewport(x, y, width, height) {
    const v = this.viewport;
    x = Math.round(x);
    y = Math.round(y);
    width = Math.round(width);
    height = Math.round(height);
    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
      v.x = x;
      v.y = y;
      v.width = width;
      v.height = height;
      this.gl.viewport(x, y, width, height);
    }
  }
  get size() {
    if (this.current) {
      return { x: 0, y: 0, width: this.current.width, height: this.current.height };
    }
    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  clear(r, g, b, a, mask = constants.BUFFER_BITS.COLOR | constants.BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r, g, b, a);
    gl.clear(mask);
  }
  initFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = new GLFramebuffer.GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  }
  resizeFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
      }
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  }
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    const activeTextures = [];
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
      }
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      const writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        const depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  }
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = constants.MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (let i = 0; i < msaaSamples.length; i++) {
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    }
    if (res === 1) {
      res = constants.MSAA_QUALITY.NONE;
    }
    return res;
  }
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      const colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer.Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index = this.managedFramebuffers.indexOf(framebuffer);
    if (index >= 0) {
      this.managedFramebuffers.splice(index, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
    }
  }
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i = 0; i < list.length; i++) {
      this.disposeFramebuffer(list[i], contextLost);
    }
  }
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    const w = framebuffer.width;
    const h = framebuffer.height;
    const gl = this.gl;
    const stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  }
  reset() {
    this.current = this.unknownFramebuffer;
    this.viewport = new math.Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions.extensions.add(FramebufferSystem);

exports.FramebufferSystem = FramebufferSystem;
//# sourceMappingURL=FramebufferSystem.js.map


/***/ }),

/***/ 6633:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = constants.MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
}

exports.GLFramebuffer = GLFramebuffer;
//# sourceMappingURL=GLFramebuffer.js.map


/***/ }),

/***/ 74909:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);

class MultisampleSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= constants.MSAA_QUALITY.HIGH) {
      this.multisample = constants.MSAA_QUALITY.HIGH;
    } else if (samples >= constants.MSAA_QUALITY.MEDIUM) {
      this.multisample = constants.MSAA_QUALITY.MEDIUM;
    } else if (samples >= constants.MSAA_QUALITY.LOW) {
      this.multisample = constants.MSAA_QUALITY.LOW;
    } else {
      this.multisample = constants.MSAA_QUALITY.NONE;
    }
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions.extensions.add(MultisampleSystem);

exports.MultisampleSystem = MultisampleSystem;
//# sourceMappingURL=MultisampleSystem.js.map


/***/ }),

/***/ 49156:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

class Attribute {
  constructor(buffer, size = 0, normalized = false, type = constants.TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
    this.divisor = divisor;
  }
  destroy() {
    this.buffer = null;
  }
  static from(buffer, size, normalized, type, stride) {
    return new Attribute(buffer, size, normalized, type, stride);
  }
}

exports.Attribute = Attribute;
//# sourceMappingURL=Attribute.js.map


/***/ }),

/***/ 27112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var runner = __webpack_require__(69866);

let UID = 0;
class Buffer {
  constructor(data, _static = true, index = false) {
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index;
    this.static = _static;
    this.id = UID++;
    this.disposeRunner = new runner.Runner("disposeBuffer");
  }
  update(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.data = null;
  }
  set index(value) {
    this.type = value ? constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : constants.BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  static from(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer(data);
  }
}

exports.Buffer = Buffer;
//# sourceMappingURL=Buffer.js.map


/***/ }),

/***/ 27989:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var GLBuffer = __webpack_require__(6063);

class BufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  bindBufferBase(buffer, index) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index] !== buffer) {
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  bindBufferRange(buffer, index, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  }
  update(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  }
  dispose(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    const gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i = 0; i < all.length; i++) {
      this.dispose(this.managedBuffers[all[i]], contextLost);
    }
  }
  createGLBuffer(buffer) {
    const { CONTEXT_UID, gl } = this;
    buffer._glBuffers[CONTEXT_UID] = new GLBuffer.GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "buffer"
};
extensions.extensions.add(BufferSystem);

exports.BufferSystem = BufferSystem;
//# sourceMappingURL=BufferSystem.js.map


/***/ }),

/***/ 6063:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class GLBuffer {
  constructor(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
}

exports.GLBuffer = GLBuffer;
//# sourceMappingURL=GLBuffer.js.map


/***/ }),

/***/ 26818:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var runner = __webpack_require__(69866);
var utils = __webpack_require__(61973);
var Attribute = __webpack_require__(49156);
var Buffer = __webpack_require__(27112);
var interleaveTypedArrays = __webpack_require__(94739);

const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
let UID = 0;
const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new runner.Runner("disposeGeometry");
    this.refCount = 0;
  }
  addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof Buffer.Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new Buffer.Buffer(buffer);
    }
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i = 0; i < ids.length; i++) {
        this.addAttribute(ids[i], buffer, size, normalized, type);
      }
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute.Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  }
  getAttribute(id) {
    return this.attributes[id];
  }
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  addIndex(buffer) {
    if (!(buffer instanceof Buffer.Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new Buffer.Buffer(buffer);
    }
    buffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (!this.buffers.includes(buffer)) {
      this.buffers.push(buffer);
    }
    return this;
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [];
    const sizes = [];
    const interleavedBuffer = new Buffer.Buffer();
    let i;
    for (i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays.interleaveTypedArrays(arrays, sizes);
    for (i = 0; i < this.buffers.length; i++) {
      if (this.buffers[i] !== this.indexBuffer) {
        this.buffers[i].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  }
  getSize() {
    for (const i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  }
  clone() {
    const geometry = new Geometry();
    for (let i = 0; i < this.buffers.length; i++) {
      geometry.buffers[i] = new Buffer.Buffer(this.buffers[i].data.slice(0));
    }
    for (const i in this.attributes) {
      const attrib = this.attributes[i];
      geometry.attributes[i] = new Attribute.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  }
  static merge(geometries) {
    const geometryOut = new Geometry();
    const arrays = [];
    const sizes = [];
    const offsets = [];
    let geometry;
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        sizes[j] = sizes[j] || 0;
        sizes[j] += geometry.buffers[j].data.length;
        offsets[j] = 0;
      }
    }
    for (let i = 0; i < geometry.buffers.length; i++) {
      arrays[i] = new map[utils.getBufferType(geometry.buffers[i].data)](sizes[i]);
      geometryOut.buffers[i] = new Buffer.Buffer(arrays[i]);
    }
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        arrays[j].set(geometry.buffers[j].data, offsets[j]);
        offsets[j] += geometry.buffers[j].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0;
      let stride = 0;
      let offset2 = 0;
      let bufferIndexToCount = 0;
      for (let i = 0; i < geometry.buffers.length; i++) {
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      }
      for (const i in geometry.attributes) {
        const attribute = geometry.attributes[i];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap[attribute.type] / 4;
        }
      }
      for (let i = 0; i < geometries.length; i++) {
        const indexBufferData = geometries[i].indexBuffer.data;
        for (let j = 0; j < indexBufferData.length; j++) {
          geometryOut.indexBuffer.data[j + offset2] += offset;
        }
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}

exports.Geometry = Geometry;
//# sourceMappingURL=Geometry.js.map


/***/ }),

/***/ 96255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var settings = __webpack_require__(1405);

const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    const context = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {
        nativeVaoExtension = null;
      }
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      } else {
        this.hasVao = false;
        gl.createVertexArray = () => null;
        gl.bindVertexArray = () => null;
        gl.deleteVertexArray = () => null;
      }
    }
    if (context.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt) {
        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);
        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);
        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;
  }
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this.renderer.buffer;
    for (let i = 0; i < geometry.buffers.length; i++) {
      const buffer = geometry.buffers[i];
      bufferSystem.update(buffer);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program.attributeData;
    for (const j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program.attributeData;
    const strings = ["g", geometry.id];
    for (const i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  }
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    const tempStride = {};
    const tempStart = {};
    for (const j in buffers) {
      tempStride[j] = 0;
      tempStart[j] = 0;
    }
    for (const j in attributes) {
      if (!attributes[j].size && program.attributeData[j]) {
        attributes[j].size = program.attributeData[j].size;
      } else if (!attributes[j].size) {
        console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);
      }
      tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
    }
    for (const j in attributes) {
      const attribute = attributes[j];
      const attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    bufferSystem.unbind(constants.BUFFER_TYPE.ARRAY_BUFFER);
    return vao;
  }
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    const gl = this.gl;
    const buffers = geometry.buffers;
    const bufferSystem = this.renderer?.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (let i = 0; i < buffers.length; i++) {
        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (const vaoId in vaos) {
        if (vaoId[0] === "g") {
          const vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i = 0; i < all.length; i++) {
      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
    }
  }
  activateVao(geometry, program) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j in attributes) {
      const attribute = attributes[j];
      const buffer = buffers[attribute.buffer];
      const glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location = program.attributeData[j].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, attribute.divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(type, size, start, instanceCount) {
    const { gl } = this;
    const geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "geometry"
};
extensions.extensions.add(GeometrySystem);

exports.GeometrySystem = GeometrySystem;
//# sourceMappingURL=GeometrySystem.js.map


/***/ }),

/***/ 22109:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get uint16View() {
    if (!this._uint16View) {
      this._uint16View = new Uint16Array(this.rawBinaryData);
    }
    return this._uint16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}

exports.ViewableBuffer = ViewableBuffer;
//# sourceMappingURL=ViewableBuffer.js.map


/***/ }),

/***/ 94739:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var utils = __webpack_require__(61973);

const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = utils.getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}

exports.interleaveTypedArrays = interleaveTypedArrays;
//# sourceMappingURL=interleaveTypedArrays.js.map


/***/ }),

/***/ 11491:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(28086);
var color = __webpack_require__(61595);
var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);
var runner = __webpack_require__(69866);
var settings = __webpack_require__(1405);
var ticker = __webpack_require__(47158);
var utils$1 = __webpack_require__(61973);
var autoDetectRenderer = __webpack_require__(24652);
var BackgroundSystem = __webpack_require__(37399);
var BatchDrawCall = __webpack_require__(55438);
var BatchGeometry = __webpack_require__(57304);
var BatchRenderer = __webpack_require__(17475);
var BatchShaderGenerator = __webpack_require__(53464);
var BatchSystem = __webpack_require__(77117);
var BatchTextureArray = __webpack_require__(10776);
var ObjectRenderer = __webpack_require__(43474);
var ContextSystem = __webpack_require__(39305);
var Filter = __webpack_require__(87705);
var FilterState = __webpack_require__(10216);
var FilterSystem = __webpack_require__(38132);
__webpack_require__(35947);
var SpriteMaskFilter = __webpack_require__(36778);
var index = __webpack_require__(81961);
var Framebuffer = __webpack_require__(71124);
var FramebufferSystem = __webpack_require__(39849);
var GLFramebuffer = __webpack_require__(6633);
var MultisampleSystem = __webpack_require__(74909);
var Attribute = __webpack_require__(49156);
var Buffer = __webpack_require__(27112);
var BufferSystem = __webpack_require__(27989);
var Geometry = __webpack_require__(26818);
var GeometrySystem = __webpack_require__(96255);
var ViewableBuffer = __webpack_require__(22109);
__webpack_require__(82251);
var MaskData = __webpack_require__(57938);
var MaskSystem = __webpack_require__(90991);
var ScissorSystem = __webpack_require__(91551);
var StencilSystem = __webpack_require__(31173);
var PluginSystem = __webpack_require__(98713);
var ProjectionSystem = __webpack_require__(57477);
var ObjectRendererSystem = __webpack_require__(80903);
var Renderer = __webpack_require__(21452);
var BaseRenderTexture = __webpack_require__(36167);
var GenerateTextureSystem = __webpack_require__(56064);
var RenderTexture = __webpack_require__(76676);
var RenderTexturePool = __webpack_require__(56662);
var RenderTextureSystem = __webpack_require__(61625);
var GLProgram = __webpack_require__(21444);
var Program = __webpack_require__(69197);
var Shader = __webpack_require__(2520);
var ShaderSystem = __webpack_require__(89797);
var UniformGroup = __webpack_require__(35842);
var checkMaxIfStatementsInShader = __webpack_require__(92970);
var generateProgram = __webpack_require__(7250);
var generateUniformBufferSync = __webpack_require__(50471);
var getTestContext = __webpack_require__(34464);
var uniformParsers = __webpack_require__(60851);
var unsafeEvalSupported = __webpack_require__(13265);
var StartupSystem = __webpack_require__(4337);
var State = __webpack_require__(45944);
var StateSystem = __webpack_require__(82949);
__webpack_require__(86783);
__webpack_require__(16465);
var BaseTexture = __webpack_require__(96728);
var GLTexture = __webpack_require__(59890);
__webpack_require__(37598);
var Texture = __webpack_require__(48147);
var TextureGCSystem = __webpack_require__(37012);
var TextureMatrix = __webpack_require__(32518);
var TextureSystem = __webpack_require__(72798);
var TextureUvs = __webpack_require__(1755);
var TransformFeedback = __webpack_require__(13812);
var TransformFeedbackSystem = __webpack_require__(233);
var Quad = __webpack_require__(50102);
var QuadUv = __webpack_require__(60357);
var ViewSystem = __webpack_require__(32741);
var SystemManager = __webpack_require__(80557);
var BaseImageResource = __webpack_require__(80856);
var Resource = __webpack_require__(80312);
var AbstractMultiResource = __webpack_require__(48077);
var ArrayResource = __webpack_require__(46831);
var autoDetectResource = __webpack_require__(92308);
var BufferResource = __webpack_require__(63278);
var CanvasResource = __webpack_require__(39276);
var CubeResource = __webpack_require__(10373);
var ImageBitmapResource = __webpack_require__(40424);
var ImageResource = __webpack_require__(38703);
var SVGResource = __webpack_require__(19148);
var VideoResource = __webpack_require__(63997);

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n["default"] = e;
	return n;
}

var utils__namespace = /*#__PURE__*/_interopNamespace(utils$1);

const VERSION = "7.2.4";

exports.utils = utils__namespace;
exports.autoDetectRenderer = autoDetectRenderer.autoDetectRenderer;
exports.BackgroundSystem = BackgroundSystem.BackgroundSystem;
exports.BatchDrawCall = BatchDrawCall.BatchDrawCall;
exports.BatchGeometry = BatchGeometry.BatchGeometry;
exports.BatchRenderer = BatchRenderer.BatchRenderer;
exports.BatchShaderGenerator = BatchShaderGenerator.BatchShaderGenerator;
exports.BatchSystem = BatchSystem.BatchSystem;
exports.BatchTextureArray = BatchTextureArray.BatchTextureArray;
exports.ObjectRenderer = ObjectRenderer.ObjectRenderer;
exports.ContextSystem = ContextSystem.ContextSystem;
exports.Filter = Filter.Filter;
exports.FilterState = FilterState.FilterState;
exports.FilterSystem = FilterSystem.FilterSystem;
exports.SpriteMaskFilter = SpriteMaskFilter.SpriteMaskFilter;
exports.defaultFilterVertex = index.defaultFilterVertex;
exports.defaultVertex = index.defaultVertex;
exports.Framebuffer = Framebuffer.Framebuffer;
exports.FramebufferSystem = FramebufferSystem.FramebufferSystem;
exports.GLFramebuffer = GLFramebuffer.GLFramebuffer;
exports.MultisampleSystem = MultisampleSystem.MultisampleSystem;
exports.Attribute = Attribute.Attribute;
exports.Buffer = Buffer.Buffer;
exports.BufferSystem = BufferSystem.BufferSystem;
exports.Geometry = Geometry.Geometry;
exports.GeometrySystem = GeometrySystem.GeometrySystem;
exports.ViewableBuffer = ViewableBuffer.ViewableBuffer;
exports.MaskData = MaskData.MaskData;
exports.MaskSystem = MaskSystem.MaskSystem;
exports.ScissorSystem = ScissorSystem.ScissorSystem;
exports.StencilSystem = StencilSystem.StencilSystem;
exports.PluginSystem = PluginSystem.PluginSystem;
exports.ProjectionSystem = ProjectionSystem.ProjectionSystem;
exports.ObjectRendererSystem = ObjectRendererSystem.ObjectRendererSystem;
exports.Renderer = Renderer.Renderer;
exports.BaseRenderTexture = BaseRenderTexture.BaseRenderTexture;
exports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;
exports.RenderTexture = RenderTexture.RenderTexture;
exports.RenderTexturePool = RenderTexturePool.RenderTexturePool;
exports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;
exports.GLProgram = GLProgram.GLProgram;
exports.IGLUniformData = GLProgram.IGLUniformData;
exports.Program = Program.Program;
exports.Shader = Shader.Shader;
exports.ShaderSystem = ShaderSystem.ShaderSystem;
exports.UniformGroup = UniformGroup.UniformGroup;
exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;
exports.generateProgram = generateProgram.generateProgram;
exports.createUBOElements = generateUniformBufferSync.createUBOElements;
exports.generateUniformBufferSync = generateUniformBufferSync.generateUniformBufferSync;
exports.getUBOData = generateUniformBufferSync.getUBOData;
exports.getTestContext = getTestContext.getTestContext;
exports.uniformParsers = uniformParsers.uniformParsers;
exports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;
exports.StartupSystem = StartupSystem.StartupSystem;
exports.State = State.State;
exports.StateSystem = StateSystem.StateSystem;
exports.BaseTexture = BaseTexture.BaseTexture;
exports.GLTexture = GLTexture.GLTexture;
exports.Texture = Texture.Texture;
exports.TextureGCSystem = TextureGCSystem.TextureGCSystem;
exports.TextureMatrix = TextureMatrix.TextureMatrix;
exports.TextureSystem = TextureSystem.TextureSystem;
exports.TextureUvs = TextureUvs.TextureUvs;
exports.TransformFeedback = TransformFeedback.TransformFeedback;
exports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;
exports.Quad = Quad.Quad;
exports.QuadUv = QuadUv.QuadUv;
exports.ViewSystem = ViewSystem.ViewSystem;
exports.SystemManager = SystemManager.SystemManager;
exports.BaseImageResource = BaseImageResource.BaseImageResource;
exports.Resource = Resource.Resource;
exports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;
exports.ArrayResource = ArrayResource.ArrayResource;
exports.INSTALLED = autoDetectResource.INSTALLED;
exports.autoDetectResource = autoDetectResource.autoDetectResource;
exports.BufferResource = BufferResource.BufferResource;
exports.CanvasResource = CanvasResource.CanvasResource;
exports.CubeResource = CubeResource.CubeResource;
exports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;
exports.ImageResource = ImageResource.ImageResource;
exports.SVGResource = SVGResource.SVGResource;
exports.VideoResource = VideoResource.VideoResource;
exports.VERSION = VERSION;
Object.keys(color).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return color[k]; }
	});
});
Object.keys(constants).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return constants[k]; }
	});
});
Object.keys(extensions).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return extensions[k]; }
	});
});
Object.keys(math).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return math[k]; }
	});
});
Object.keys(runner).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return runner[k]; }
	});
});
Object.keys(settings).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return settings[k]; }
	});
});
Object.keys(ticker).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return ticker[k]; }
	});
});
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 2889:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class AbstractMaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(maskStack) {
    const { gl } = this.renderer;
    const curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  }
  _useCurrent() {
  }
  destroy() {
    this.renderer = null;
    this.maskStack = null;
  }
}

exports.AbstractMaskSystem = AbstractMaskSystem;
//# sourceMappingURL=AbstractMaskSystem.js.map


/***/ }),

/***/ 57938:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var Filter = __webpack_require__(87705);

class MaskData {
  constructor(maskObject = null) {
    this.type = constants.MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = Filter.Filter.defaultMultisample;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    if (value) {
      if (this._filters) {
        this._filters[0] = value;
      } else {
        this._filters = [value];
      }
    } else {
      this._filters = null;
    }
  }
  reset() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = constants.MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  }
  copyCountersOrReset(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  }
}

exports.MaskData = MaskData;
//# sourceMappingURL=MaskData.js.map


/***/ }),

/***/ 90991:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var SpriteMaskFilter = __webpack_require__(36778);
var MaskData = __webpack_require__(57938);

class MaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  setMaskStack(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  }
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d = this.maskDataPool.pop() || new MaskData.MaskData();
      d.pooled = true;
      d.maskObject = maskDataOrTarget;
      maskData = d;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== constants.MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case constants.MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case constants.MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case constants.MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case constants.MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
        default:
          break;
      }
    }
    if (maskData.type === constants.MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  }
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case constants.MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case constants.MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case constants.MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case constants.MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
        default:
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      const maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === constants.MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  }
  detect(maskData) {
    const maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = constants.MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = constants.MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = constants.MASK_TYPES.SCISSOR;
    } else {
      maskData.type = constants.MASK_TYPES.STENCIL;
    }
  }
  pushSpriteMask(maskData) {
    const { maskObject } = maskData;
    const target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter.SpriteMaskFilter()];
      }
    }
    const renderer = this.renderer;
    const renderTextureSystem = renderer.renderTexture;
    let resolution;
    let multisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = maskData.multisample ?? renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = maskData.multisample ?? renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  }
  popSpriteMask(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  }
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "mask"
};
extensions.extensions.add(MaskSystem);

exports.MaskSystem = MaskSystem;
//# sourceMappingURL=MaskSystem.js.map


/***/ }),

/***/ 91551:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);
var settings = __webpack_require__(1405);
var AbstractMaskSystem = __webpack_require__(2889);

const tempMatrix = new math.Matrix();
const rectPool = [];
const _ScissorSystem = class extends AbstractMaskSystem.AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  }
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    const prevData = maskData._scissorRect;
    const { maskObject } = maskData;
    const { renderer } = this;
    const renderTextureSystem = renderer.renderTexture;
    const rect = maskObject.getBounds(true, rectPool.pop() ?? new math.Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix) {
      return false;
    }
    const { a, b, c, d } = matrix;
    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
  }
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (_ScissorSystem.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  }
  push(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    const { gl } = this.renderer;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  }
  pop(maskData) {
    const { gl } = this.renderer;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y;
    if (this.renderer.renderTexture.current) {
      y = rect.y;
    } else {
      y = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
  }
};
let ScissorSystem = _ScissorSystem;
ScissorSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "scissor"
};
extensions.extensions.add(ScissorSystem);

exports.ScissorSystem = ScissorSystem;
//# sourceMappingURL=ScissorSystem.js.map


/***/ }),

/***/ 31173:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var settings = __webpack_require__(1405);
var AbstractMaskSystem = __webpack_require__(2889);

class StencilSystem extends AbstractMaskSystem.AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  }
  push(maskData) {
    const maskObject = maskData.maskObject;
    const { gl } = this.renderer;
    const prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  }
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      const colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  }
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "stencil"
};
extensions.extensions.add(StencilSystem);

exports.StencilSystem = StencilSystem;
//# sourceMappingURL=StencilSystem.js.map


/***/ }),

/***/ 98713:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var utils = __webpack_require__(61973);

class PluginSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.plugins = {};
    Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          utils.deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
          return renderer.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          utils.deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
          return renderer.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          utils.deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
          return renderer.events;
        }
      }
    });
  }
  init() {
    const staticMap = this.rendererPlugins;
    for (const o in staticMap) {
      this.plugins[o] = new staticMap[o](this.renderer);
    }
  }
  destroy() {
    for (const o in this.plugins) {
      this.plugins[o].destroy();
      this.plugins[o] = null;
    }
  }
}
PluginSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions.extensions.add(PluginSystem);

exports.PluginSystem = PluginSystem;
//# sourceMappingURL=PluginSystem.js.map


/***/ }),

/***/ 57477:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);

class ProjectionSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new math.Matrix();
    this.transform = null;
  }
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  }
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix;
    const sign = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign - sourceFrame.y * pm.d;
  }
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "projection"
};
extensions.extensions.add(ProjectionSystem);

exports.ProjectionSystem = ProjectionSystem;
//# sourceMappingURL=ProjectionSystem.js.map


/***/ }),

/***/ 36167:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(61595);
var constants = __webpack_require__(21837);
var Framebuffer = __webpack_require__(71124);
var BaseTexture = __webpack_require__(96728);

class BaseRenderTexture extends BaseTexture.BaseTexture {
  constructor(options = {}) {
    if (typeof options === "number") {
      const width = arguments[0];
      const height = arguments[1];
      const scaleMode = arguments[2];
      const resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample ?? (options.multisample = constants.MSAA_QUALITY.NONE);
    super(null, options);
    this.mipmap = constants.MIPMAP_MODES.OFF;
    this.valid = true;
    this._clear = new color.Color([0, 0, 0, 0]);
    this.framebuffer = new Framebuffer.Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
    this.framebuffer.multisample = options.multisample;
    this.maskStack = [];
    this.filterStack = [{}];
  }
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  dispose() {
    this.framebuffer.dispose();
    super.dispose();
  }
  destroy() {
    super.destroy();
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  }
}

exports.BaseRenderTexture = BaseRenderTexture;
//# sourceMappingURL=BaseRenderTexture.js.map


/***/ }),

/***/ 56064:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);
var RenderTexture = __webpack_require__(76676);

const tempTransform = new math.Transform();
class GenerateTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._tempMatrix = new math.Matrix();
  }
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {};
    const region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0)
      region.width = 1;
    if (region.height === 0)
      region.height = 1;
    const renderTexture = RenderTexture.RenderTexture.create({
      width: region.width,
      height: region.height,
      ...textureOptions
    });
    this._tempMatrix.tx = -region.x;
    this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    displayObject.transform = tempTransform;
    this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    });
    displayObject.transform = transform;
    return renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions.extensions.add(GenerateTextureSystem);

exports.GenerateTextureSystem = GenerateTextureSystem;
//# sourceMappingURL=GenerateTextureSystem.js.map


/***/ }),

/***/ 76676:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Texture = __webpack_require__(48147);
var BaseRenderTexture = __webpack_require__(36167);

class RenderTexture extends Texture.Texture {
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame);
    this.valid = true;
    this.filterFrame = null;
    this.filterPoolKey = null;
    this.updateUvs();
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution;
    const width = Math.round(desiredWidth * resolution) / resolution;
    const height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  }
  setResolution(resolution) {
    const { baseTexture } = this;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  }
  static create(options) {
    return new RenderTexture(new BaseRenderTexture.BaseRenderTexture(options));
  }
}

exports.RenderTexture = RenderTexture;
//# sourceMappingURL=RenderTexture.js.map


/***/ }),

/***/ 56662:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var utils = __webpack_require__(61973);
var BaseRenderTexture = __webpack_require__(36167);
var RenderTexture = __webpack_require__(76676);

class RenderTexturePool {
  constructor(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  createTexture(realWidth, realHeight, multisample = constants.MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture.BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture.RenderTexture(baseRenderTexture);
  }
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = utils.nextPow2(minWidth);
      minHeight = utils.nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    let renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  }
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || constants.MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  }
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i in this.texturePool) {
        const textures = this.texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  }
  setScreenSize(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (const i in this.texturePool) {
      if (!(Number(i) < 0)) {
        continue;
      }
      const textures = this.texturePool[i];
      if (textures) {
        for (let j = 0; j < textures.length; j++) {
          textures[j].destroy(true);
        }
      }
      this.texturePool[i] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  }
}
RenderTexturePool.SCREEN_KEY = -1;

exports.RenderTexturePool = RenderTexturePool;
//# sourceMappingURL=RenderTexturePool.js.map


/***/ }),

/***/ 61625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(61595);
var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);

const tempRect = new math.Rectangle();
const tempRect2 = new math.Rectangle();
class RenderTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new math.Rectangle();
    this.destinationFrame = new math.Rectangle();
    this.viewportFrame = new math.Rectangle();
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture;
    let framebuffer;
    let resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer._view.screen.width;
        tempRect.height = renderer._view.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  }
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;
    const color$1 = color.Color.shared.setValue(clearColor ? clearColor : fallbackColor);
    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {
      color$1.premultiply(color$1.alpha);
    }
    const destinationFrame = this.destinationFrame;
    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x, y, width, height } = this.viewportFrame;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x, y, width, height);
    }
    this.renderer.framebuffer.clear(color$1.red, color$1.green, color$1.blue, color$1.alpha, mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions.extensions.add(RenderTextureSystem);

exports.RenderTextureSystem = RenderTextureSystem;
//# sourceMappingURL=RenderTextureSystem.js.map


/***/ }),

/***/ 80903:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);

class ObjectRendererSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture;
    let clear;
    let transform;
    let skipUpdateTransform;
    if (options) {
      renderTexture = options.renderTexture;
      clear = options.clear;
      transform = options.transform;
      skipUpdateTransform = options.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer.runners.prerender.emit();
    renderer.emit("prerender");
    renderer.projection.transform = transform;
    if (renderer.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    renderer.renderTexture.bind(renderTexture);
    renderer.batch.currentRenderer.start();
    if (clear ?? renderer.background.clearBeforeRender) {
      renderer.renderTexture.clear();
    }
    displayObject.render(renderer);
    renderer.batch.currentRenderer.flush();
    if (renderTexture) {
      if (options.blit) {
        renderer.framebuffer.blit();
      }
      renderTexture.baseTexture.update();
    }
    renderer.runners.postrender.emit();
    renderer.projection.transform = null;
    renderer.emit("postrender");
  }
  destroy() {
    this.renderer = null;
    this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions.extensions.add(ObjectRendererSystem);

exports.ObjectRendererSystem = ObjectRendererSystem;
//# sourceMappingURL=ObjectRendererSystem.js.map


/***/ }),

/***/ 28086:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var constants = __webpack_require__(21837);
var settings = __webpack_require__(1405);
var utils = __webpack_require__(61973);
var BatchRenderer = __webpack_require__(17475);
var Filter = __webpack_require__(87705);
var Program = __webpack_require__(69197);
__webpack_require__(16465);
var BaseTexture = __webpack_require__(96728);
var ContextSystem = __webpack_require__(39305);
var BackgroundSystem = __webpack_require__(37399);
var ViewSystem = __webpack_require__(32741);
var StartupSystem = __webpack_require__(4337);
var TextureGCSystem = __webpack_require__(37012);

settings.settings.PREFER_ENV = constants.ENV.WEBGL2;
settings.settings.STRICT_TEXTURE_CACHE = false;
settings.settings.RENDER_OPTIONS = {
  ...ContextSystem.ContextSystem.defaultOptions,
  ...BackgroundSystem.BackgroundSystem.defaultOptions,
  ...ViewSystem.ViewSystem.defaultOptions,
  ...StartupSystem.StartupSystem.defaultOptions
};
Object.defineProperties(settings.settings, {
  WRAP_MODE: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
      BaseTexture.BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  SCALE_MODE: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
      BaseTexture.BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
      BaseTexture.BaseTexture.defaultOptions.mipmap = value;
    }
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
      BaseTexture.BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  FILTER_RESOLUTION: {
    get() {
      utils.deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
      return Filter.Filter.defaultResolution;
    },
    set(value) {
      Filter.Filter.defaultResolution = value;
    }
  },
  FILTER_MULTISAMPLE: {
    get() {
      utils.deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
      return Filter.Filter.defaultMultisample;
    },
    set(value) {
      Filter.Filter.defaultMultisample = value;
    }
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
      BatchRenderer.BatchRenderer.defaultMaxTextures = value;
    }
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.BatchRenderer.defaultBatchSize;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
      BatchRenderer.BatchRenderer.defaultBatchSize = value;
    }
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
      BatchRenderer.BatchRenderer.canUploadSameBuffer = value;
    }
  },
  GC_MODE: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
      TextureGCSystem.TextureGCSystem.defaultMode = value;
    }
  },
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
      TextureGCSystem.TextureGCSystem.defaultMaxIdle = value;
    }
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
      TextureGCSystem.TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  PRECISION_VERTEX: {
    get() {
      return Program.Program.defaultVertexPrecision;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
      Program.Program.defaultVertexPrecision = value;
    }
  },
  PRECISION_FRAGMENT: {
    get() {
      return Program.Program.defaultFragmentPrecision;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
      Program.Program.defaultFragmentPrecision = value;
    }
  }
});
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ 21444:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class IGLUniformData {
}
class GLProgram {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  }
}

exports.GLProgram = GLProgram;
exports.IGLUniformData = IGLUniformData;
//# sourceMappingURL=GLProgram.js.map


/***/ }),

/***/ 69197:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var utils = __webpack_require__(61973);
var defaultProgram$1 = __webpack_require__(83194);
var defaultProgram = __webpack_require__(79962);
__webpack_require__(68203);
var setPrecision = __webpack_require__(82419);
var getMaxFragmentPrecision = __webpack_require__(44929);

let UID = 0;
const nameCache = {};
const _Program = class {
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {};
    this.id = UID++;
    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    this.extra = extra;
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += `-${nameCache[name]}`;
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
      this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
      this.vertexSrc = setPrecision.setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, constants.PRECISION.HIGH);
      this.fragmentSrc = setPrecision.setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision.getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  static get defaultVertexSrc() {
    return defaultProgram["default"];
  }
  static get defaultFragmentSrc() {
    return defaultProgram$1["default"];
  }
  static from(vertexSrc, fragmentSrc, name) {
    const key = vertexSrc + fragmentSrc;
    let program = utils.ProgramCache[key];
    if (!program) {
      utils.ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);
    }
    return program;
  }
};
let Program = _Program;
Program.defaultVertexPrecision = constants.PRECISION.HIGH;
Program.defaultFragmentPrecision = utils.isMobile.apple.device ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM;

exports.Program = Program;
//# sourceMappingURL=Program.js.map


/***/ }),

/***/ 2520:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(69866);
var Program = __webpack_require__(69197);
var UniformGroup = __webpack_require__(35842);

class Shader {
  constructor(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup.UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup.UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup.UniformGroup({});
    }
    this.disposeRunner = new runner.Runner("disposeShader");
  }
  checkUniformExists(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (const i in group.uniforms) {
      const uniform = group.uniforms[i];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}

exports.Shader = Shader;
//# sourceMappingURL=Shader.js.map


/***/ }),

/***/ 89797:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
__webpack_require__(68203);
var generateProgram = __webpack_require__(7250);
var generateUniformBufferSync = __webpack_require__(50471);
var unsafeEvalSupported = __webpack_require__(13265);
var generateUniformsSync = __webpack_require__(18390);

let UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  constructor(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID++;
  }
  systemCheck() {
    if (!unsafeEvalSupported.unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.reset();
  }
  bind(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program;
    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  }
  setUniforms(uniforms) {
    const shader = this.shader.program;
    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  }
  syncUniforms(group, glProgram, syncData) {
    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync.generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  }
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync.generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  }
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  }
  getGlProgram() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  }
  generateProgram(shader) {
    const gl = this.gl;
    const program = shader.program;
    const glProgram = generateProgram.generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  }
  reset() {
    this.program = null;
    this.shader = null;
  }
  disposeShader(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  }
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "shader"
};
extensions.extensions.add(ShaderSystem);

exports.ShaderSystem = ShaderSystem;
//# sourceMappingURL=ShaderSystem.js.map


/***/ }),

/***/ 35842:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var Buffer = __webpack_require__(27112);

let UID = 0;
class UniformGroup {
  constructor(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer.Buffer) {
      this.buffer = uniforms;
      this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer.Buffer(new Float32Array(1));
        this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  update() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  }
  add(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}

exports.UniformGroup = UniformGroup;
//# sourceMappingURL=UniformGroup.js.map


/***/ }),

/***/ 83194:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";

exports["default"] = defaultFragment;
//# sourceMappingURL=defaultProgram.js.map


/***/ }),

/***/ 79962:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";

exports["default"] = defaultVertex;
//# sourceMappingURL=defaultProgram2.js.map


/***/ }),

/***/ 92970:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += `if(test == ${i}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}

exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader;
//# sourceMappingURL=checkMaxIfStatementsInShader.js.map


/***/ }),

/***/ 20775:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}

exports.compileShader = compileShader;
//# sourceMappingURL=compileShader.js.map


/***/ }),

/***/ 12301:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function booleanArray(size) {
  const array = new Array(size);
  for (let i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}

exports.defaultValue = defaultValue;
//# sourceMappingURL=defaultValue.js.map


/***/ }),

/***/ 7250:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var GLProgram = __webpack_require__(21444);
var compileShader = __webpack_require__(20775);
var defaultValue = __webpack_require__(12301);
var getAttributeData = __webpack_require__(9747);
var getUniformData = __webpack_require__(62251);
var logProgramError = __webpack_require__(77595);

function generateProgram(gl, program) {
  const glVertShader = compileShader.compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  const glFragShader = compileShader.compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError.logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData.getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData.getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a, b) => a > b ? 1 : -1);
    for (let i = 0; i < keys.length; i++) {
      program.attributeData[keys[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program.uniformData) {
    const data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue.defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GLProgram.GLProgram(webGLProgram, uniformData);
  return glProgram;
}

exports.generateProgram = generateProgram;
//# sourceMappingURL=generateProgram.js.map


/***/ }),

/***/ 50471:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(68203);
var uniformParsers = __webpack_require__(60851);
var mapSize = __webpack_require__(89508);

function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
const GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort((a, b) => a.index - b.index);
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  const usedUniformDatas = getUBOData(group.uniforms, uniformData);
  const { uboElements, size } = createUBOElements(usedUniformDatas);
  const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    const uniform = group.uniforms[uboElement.data.name];
    const name = uboElement.data.name;
    let parsed = false;
    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {
      const uniformParser = uniformParsers.uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers.uniformParsers[j].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const size2 = mapSize.mapSize(uboElement.data.type);
        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = size2 / rowSize;
        const remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
    }
  }
  funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}

exports.createUBOElements = createUBOElements;
exports.generateUniformBufferSync = generateUniformBufferSync;
exports.getUBOData = getUBOData;
//# sourceMappingURL=generateUniformBufferSync.js.map


/***/ }),

/***/ 18390:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var uniformParsers = __webpack_require__(60851);

const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
const GLSL_TO_ARRAY_SETTERS = {
  float: `gl.uniform1fv(location, v)`,
  vec2: `gl.uniform2fv(location, v)`,
  vec3: `gl.uniform3fv(location, v)`,
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i in group.uniforms) {
    const data = uniformData[i];
    if (!data) {
      if (group.uniforms[i]?.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `);
        }
      }
      continue;
    }
    const uniform = group.uniforms[i];
    let parsed = false;
    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {
      if (uniformParsers.uniformParsers[j].test(data, uniform)) {
        funcFragments.push(uniformParsers.uniformParsers[j].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}

exports.generateUniformsSync = generateUniformsSync;
//# sourceMappingURL=generateUniformsSync.js.map


/***/ }),

/***/ 9747:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var mapSize = __webpack_require__(89508);
var mapType = __webpack_require__(58697);

function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType.mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize.mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}

exports.getAttributeData = getAttributeData;
//# sourceMappingURL=getAttributeData.js.map


/***/ }),

/***/ 44929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var getTestContext = __webpack_require__(34464);

let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = constants.PRECISION.MEDIUM;
    const gl = getTestContext.getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}

exports.getMaxFragmentPrecision = getMaxFragmentPrecision;
//# sourceMappingURL=getMaxFragmentPrecision.js.map


/***/ }),

/***/ 34464:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var settings = __webpack_require__(1405);

const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas = settings.settings.ADAPTER.createCanvas();
    let gl;
    if (settings.settings.PREFER_ENV >= constants.ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}

exports.getTestContext = getTestContext;
//# sourceMappingURL=getTestContext.js.map


/***/ }),

/***/ 62251:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var defaultValue = __webpack_require__(12301);
var mapType = __webpack_require__(58697);

function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType.mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue.defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}

exports.getUniformData = getUniformData;
//# sourceMappingURL=getUniformData.js.map


/***/ }),

/***/ 68203:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var checkMaxIfStatementsInShader = __webpack_require__(92970);
var compileShader = __webpack_require__(20775);
var defaultValue = __webpack_require__(12301);
var generateUniformsSync = __webpack_require__(18390);
var getMaxFragmentPrecision = __webpack_require__(44929);
var getTestContext = __webpack_require__(34464);
var logProgramError = __webpack_require__(77595);
var mapSize = __webpack_require__(89508);
var mapType = __webpack_require__(58697);
var setPrecision = __webpack_require__(82419);
var uniformParsers = __webpack_require__(60851);
var unsafeEvalSupported = __webpack_require__(13265);



exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;
exports.compileShader = compileShader.compileShader;
exports.defaultValue = defaultValue.defaultValue;
exports.generateUniformsSync = generateUniformsSync.generateUniformsSync;
exports.getMaxFragmentPrecision = getMaxFragmentPrecision.getMaxFragmentPrecision;
exports.getTestContext = getTestContext.getTestContext;
exports.logProgramError = logProgramError.logProgramError;
exports.mapSize = mapSize.mapSize;
exports.mapType = mapType.mapType;
exports.setPrecision = setPrecision.setPrecision;
exports.uniformParsers = uniformParsers.uniformParsers;
exports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 77595:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}

exports.logProgramError = logProgramError;
//# sourceMappingURL=logProgramError.js.map


/***/ }),

/***/ 89508:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}

exports.mapSize = mapSize;
//# sourceMappingURL=mapSize.js.map


/***/ }),

/***/ 58697:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}

exports.mapType = mapType;
//# sourceMappingURL=mapType.js.map


/***/ }),

/***/ 82419:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === constants.PRECISION.HIGH && maxSupportedPrecision !== constants.PRECISION.HIGH) {
      precision = constants.PRECISION.MEDIUM;
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== constants.PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}

exports.setPrecision = setPrecision;
//# sourceMappingURL=setPrecision.js.map


/***/ }),

/***/ 60851:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const uniformParsers = [
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  {
    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];

exports.uniformParsers = uniformParsers;
//# sourceMappingURL=uniformParsers.js.map


/***/ }),

/***/ 13265:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}

exports.unsafeEvalSupported = unsafeEvalSupported;
//# sourceMappingURL=unsafeEvalSupported.js.map


/***/ }),

/***/ 4337:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);

class StartupSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options);
    if (options.hello) {
      console.log(`PixiJS ${"7.2.4"} - ${renderer.rendererLogId} - https://pixijs.com`);
    }
    renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  hello: false
};
StartupSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions.extensions.add(StartupSystem);

exports.StartupSystem = StartupSystem;
//# sourceMappingURL=StartupSystem.js.map


/***/ }),

/***/ 45944:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
class State {
  constructor() {
    this.data = 0;
    this.blendMode = constants.BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND) !== value) {
      this.data ^= 1 << BLEND;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET) !== value) {
      this.data ^= 1 << OFFSET;
    }
  }
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING) !== value) {
      this.data ^= 1 << CULLING;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING) !== value) {
      this.data ^= 1 << WINDING;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== constants.BLEND_MODES.NONE;
    this._blendMode = value;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}

exports.State = State;
//# sourceMappingURL=State.js.map


/***/ }),

/***/ 82949:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var State = __webpack_require__(45944);
var mapWebGLBlendModesToPixi = __webpack_require__(4164);

const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _StateSystem = class {
  constructor() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = constants.BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State.State();
    this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi.mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  }
  set(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff = diff >> 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  }
  forceState(state) {
    state = state || this.defaultState;
    for (let i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value) {
    this.updateCheck(_StateSystem.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value) {
    this.updateCheck(_StateSystem.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  setBlendMode(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModes[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  }
  updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  }
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
  }
};
let StateSystem = _StateSystem;
StateSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "state"
};
extensions.extensions.add(StateSystem);

exports.StateSystem = StateSystem;
//# sourceMappingURL=StateSystem.js.map


/***/ }),

/***/ 4164:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

function mapWebGLBlendModesToPixi(gl, array = []) {
  array[constants.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[constants.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.NONE] = [0, 0];
  array[constants.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[constants.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[constants.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[constants.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[constants.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[constants.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[constants.BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[constants.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}

exports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi;
//# sourceMappingURL=mapWebGLBlendModesToPixi.js.map


/***/ }),

/***/ 86783:
/***/ (() => {

"use strict";


//# sourceMappingURL=ISystem.js.map


/***/ }),

/***/ 80557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(69866);
var utils = __webpack_require__(61973);

class SystemManager extends utils.EventEmitter {
  constructor() {
    super(...arguments);
    this.runners = {};
    this._systemsHash = {};
  }
  setup(config) {
    this.addRunners(...config.runners);
    const priority = (config.priority ?? []).filter((key) => config.systems[key]);
    const orderByPriority = [
      ...priority,
      ...Object.keys(config.systems).filter((key) => !priority.includes(key))
    ];
    for (const i of orderByPriority) {
      this.addSystem(config.systems[i], i);
    }
  }
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new runner.Runner(runnerId);
    });
  }
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  }
  emitWithCustomOptions(runner, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options[systemName]);
    });
  }
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = {};
  }
}

exports.SystemManager = SystemManager;
//# sourceMappingURL=SystemManager.js.map


/***/ }),

/***/ 16465:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BackgroundSystem = __webpack_require__(37399);
var BatchSystem = __webpack_require__(77117);
var ContextSystem = __webpack_require__(39305);
var FilterSystem = __webpack_require__(38132);
var FramebufferSystem = __webpack_require__(39849);
var GeometrySystem = __webpack_require__(96255);
var MaskSystem = __webpack_require__(90991);
var ScissorSystem = __webpack_require__(91551);
var StencilSystem = __webpack_require__(31173);
var PluginSystem = __webpack_require__(98713);
var ProjectionSystem = __webpack_require__(57477);
var GenerateTextureSystem = __webpack_require__(56064);
var RenderTextureSystem = __webpack_require__(61625);
var ShaderSystem = __webpack_require__(89797);
var StartupSystem = __webpack_require__(4337);
var StateSystem = __webpack_require__(82949);
var SystemManager = __webpack_require__(80557);
var TextureGCSystem = __webpack_require__(37012);
var TextureSystem = __webpack_require__(72798);
var TransformFeedbackSystem = __webpack_require__(233);
var ViewSystem = __webpack_require__(32741);



exports.BackgroundSystem = BackgroundSystem.BackgroundSystem;
exports.BatchSystem = BatchSystem.BatchSystem;
exports.ContextSystem = ContextSystem.ContextSystem;
exports.FilterSystem = FilterSystem.FilterSystem;
exports.FramebufferSystem = FramebufferSystem.FramebufferSystem;
exports.GeometrySystem = GeometrySystem.GeometrySystem;
exports.MaskSystem = MaskSystem.MaskSystem;
exports.ScissorSystem = ScissorSystem.ScissorSystem;
exports.StencilSystem = StencilSystem.StencilSystem;
exports.PluginSystem = PluginSystem.PluginSystem;
exports.ProjectionSystem = ProjectionSystem.ProjectionSystem;
exports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;
exports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;
exports.ShaderSystem = ShaderSystem.ShaderSystem;
exports.StartupSystem = StartupSystem.StartupSystem;
exports.StateSystem = StateSystem.StateSystem;
exports.SystemManager = SystemManager.SystemManager;
exports.TextureGCSystem = TextureGCSystem.TextureGCSystem;
exports.TextureSystem = TextureSystem.TextureSystem;
exports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;
exports.ViewSystem = ViewSystem.ViewSystem;
//# sourceMappingURL=systems.js.map


/***/ }),

/***/ 96728:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var settings = __webpack_require__(1405);
var utils = __webpack_require__(61973);
var autoDetectResource = __webpack_require__(92308);
var BufferResource = __webpack_require__(63278);
var Resource = __webpack_require__(80312);

const defaultBufferOptions = {
  scaleMode: constants.SCALE_MODES.NEAREST,
  format: constants.FORMATS.RGBA,
  alphaMode: constants.ALPHA_MODES.NPM
};
const _BaseTexture = class extends utils.EventEmitter {
  constructor(resource = null, options = null) {
    super();
    options = Object.assign({}, _BaseTexture.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format,
      type,
      target,
      resolution,
      resourceOptions
    } = options;
    if (resource && !(resource instanceof Resource.Resource)) {
      resource = autoDetectResource.autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    this.resolution = resolution || settings.settings.RESOLUTION;
    this.width = Math.round((width || 0) * this.resolution) / this.resolution;
    this.height = Math.round((height || 0) * this.resolution) / this.resolution;
    this._mipmap = mipmap;
    this.anisotropicLevel = anisotropicLevel;
    this._wrapMode = wrapMode;
    this._scaleMode = scaleMode;
    this.format = format;
    this.type = type;
    this.target = target;
    this.alphaMode = alphaMode;
    this.uid = utils.uid();
    this.touched = 0;
    this.isPowerOfTwo = false;
    this._refreshPOT();
    this._glTextures = {};
    this.dirtyId = 0;
    this.dirtyStyleId = 0;
    this.cacheId = null;
    this.valid = width > 0 && height > 0;
    this.textureCacheIds = [];
    this.destroyed = false;
    this.resource = null;
    this._batchEnabled = 0;
    this._batchLocation = 0;
    this.parentTextureArray = null;
    this.setResource(resource);
  }
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    if (this._mipmap !== value) {
      this._mipmap = value;
      this.dirtyStyleId++;
    }
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    if (this._scaleMode !== value) {
      this._scaleMode = value;
      this.dirtyStyleId++;
    }
  }
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    if (this._wrapMode !== value) {
      this._wrapMode = value;
      this.dirtyStyleId++;
    }
  }
  setStyle(scaleMode, mipmap) {
    let dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  }
  setSize(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  setRealSize(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  }
  _refreshPOT() {
    this.isPowerOfTwo = utils.isPow2(this.realWidth) && utils.isPow2(this.realHeight);
  }
  setResolution(resolution) {
    const oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  }
  setResource(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  }
  update() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  }
  onError(event) {
    this.emit("error", this, event);
  }
  destroy() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete utils.BaseTextureCache[this.cacheId];
      delete utils.TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    _BaseTexture.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  }
  dispose() {
    this.emit("dispose", this);
  }
  castToBaseTexture() {
    return this;
  }
  static from(source, options, strict = settings.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${utils.uid()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = utils.BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    }
    if (!baseTexture) {
      baseTexture = new _BaseTexture(source, options);
      baseTexture.cacheId = cacheId;
      _BaseTexture.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  }
  static fromBuffer(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    const resource = new BufferResource.BufferResource(buffer, { width, height });
    const type = buffer instanceof Float32Array ? constants.TYPES.FLOAT : constants.TYPES.UNSIGNED_BYTE;
    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options));
  }
  static addToCache(baseTexture, id) {
    if (id) {
      if (!baseTexture.textureCacheIds.includes(id)) {
        baseTexture.textureCacheIds.push(id);
      }
      if (utils.BaseTextureCache[id] && utils.BaseTextureCache[id] !== baseTexture) {
        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
      }
      utils.BaseTextureCache[id] = baseTexture;
    }
  }
  static removeFromCache(baseTexture) {
    if (typeof baseTexture === "string") {
      const baseTextureFromCache = utils.BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index > -1) {
          baseTextureFromCache.textureCacheIds.splice(index, 1);
        }
        delete utils.BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {
        delete utils.BaseTextureCache[baseTexture.textureCacheIds[i]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  }
};
let BaseTexture = _BaseTexture;
BaseTexture.defaultOptions = {
  mipmap: constants.MIPMAP_MODES.POW2,
  anisotropicLevel: 0,
  scaleMode: constants.SCALE_MODES.LINEAR,
  wrapMode: constants.WRAP_MODES.CLAMP,
  alphaMode: constants.ALPHA_MODES.UNPACK,
  target: constants.TARGETS.TEXTURE_2D,
  format: constants.FORMATS.RGBA,
  type: constants.TYPES.UNSIGNED_BYTE
};
BaseTexture._globalBatch = 0;

exports.BaseTexture = BaseTexture;
//# sourceMappingURL=BaseTexture.js.map


/***/ }),

/***/ 59890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

class GLTexture {
  constructor(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = constants.TYPES.UNSIGNED_BYTE;
    this.internalFormat = constants.FORMATS.RGBA;
    this.samplerType = 0;
  }
}

exports.GLTexture = GLTexture;
//# sourceMappingURL=GLTexture.js.map


/***/ }),

/***/ 48147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(23846);
var settings = __webpack_require__(1405);
var utils = __webpack_require__(61973);
var BaseTexture = __webpack_require__(96728);
var ImageResource = __webpack_require__(38703);
var TextureUvs = __webpack_require__(1755);

const DEFAULT_UVS = new TextureUvs.TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
class Texture extends utils.EventEmitter {
  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
    super();
    this.noFrame = false;
    if (!frame) {
      this.noFrame = true;
      frame = new math.Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture) {
      baseTexture = baseTexture.baseTexture;
    }
    this.baseTexture = baseTexture;
    this._frame = frame;
    this.trim = trim;
    this.valid = false;
    this._uvs = DEFAULT_UVS;
    this.uvMatrix = null;
    this.orig = orig || frame;
    this._rotate = Number(rotate || 0);
    if (rotate === true) {
      this._rotate = 2;
    } else if (this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    this.defaultAnchor = anchor ? new math.Point(anchor.x, anchor.y) : new math.Point(0, 0);
    this.defaultBorders = borders;
    this._updateID = 0;
    this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", this.onBaseTextureUpdated, this);
    } else if (this.noFrame) {
      if (baseTexture.valid) {
        this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      this.frame = frame;
    }
    if (this.noFrame) {
      baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
  }
  update() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  }
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  }
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        if (resource?.url && utils.TextureCache[resource.url]) {
          Texture.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture.removeFromCache(this);
    this.textureCacheIds = null;
  }
  clone() {
    const clonedFrame = this._frame.clone();
    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  }
  updateUvs() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs.TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  }
  static from(source, options = {}, strict = settings.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture.BaseTexture) {
      if (!source.cacheId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source.cacheId = `${prefix}-${utils.uid()}`;
        BaseTexture.BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${utils.uid()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = utils.TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    }
    if (!texture && !(source instanceof BaseTexture.BaseTexture)) {
      if (!options.resolution) {
        options.resolution = utils.getResolutionOfUrl(source);
      }
      texture = new Texture(new BaseTexture.BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture.BaseTexture) {
      texture = new Texture(source);
      Texture.addToCache(texture, cacheId);
    }
    return texture;
  }
  static fromURL(url, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);
    const texture = Texture.from(url, Object.assign({ resourceOptions }, options), false);
    const resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(() => Promise.resolve(texture));
  }
  static fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture.BaseTexture.fromBuffer(buffer, width, height, options));
  }
  static fromLoader(source, imageUrl, name, options) {
    const baseTexture = new BaseTexture.BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.BaseTexture.defaultOptions.scaleMode,
      resolution: utils.getResolutionOfUrl(imageUrl)
    }, options));
    const { resource } = baseTexture;
    if (resource instanceof ImageResource.ImageResource) {
      resource.url = imageUrl;
    }
    const texture = new Texture(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    BaseTexture.BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    if (name !== imageUrl) {
      BaseTexture.BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise((resolve) => {
      texture.baseTexture.once("loaded", () => resolve(texture));
    });
  }
  static addToCache(texture, id) {
    if (id) {
      if (!texture.textureCacheIds.includes(id)) {
        texture.textureCacheIds.push(id);
      }
      if (utils.TextureCache[id] && utils.TextureCache[id] !== texture) {
        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
      }
      utils.TextureCache[id] = texture;
    }
  }
  static removeFromCache(texture) {
    if (typeof texture === "string") {
      const textureFromCache = utils.TextureCache[texture];
      if (textureFromCache) {
        const index = textureFromCache.textureCacheIds.indexOf(texture);
        if (index > -1) {
          textureFromCache.textureCacheIds.splice(index, 1);
        }
        delete utils.TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture?.textureCacheIds) {
      for (let i = 0; i < texture.textureCacheIds.length; ++i) {
        if (utils.TextureCache[texture.textureCacheIds[i]] === texture) {
          delete utils.TextureCache[texture.textureCacheIds[i]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame;
    this.noFrame = false;
    const { x, y, width, height } = frame;
    const xNotFit = x + width > this.baseTexture.width;
    const yNotFit = y + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or";
      const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;
      const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid;
    if (!this.trim && !this.rotate) {
      this.orig = frame;
    }
    if (this.valid) {
      this.updateUvs();
    }
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate;
    if (this.valid) {
      this.updateUvs();
    }
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    if (!Texture._EMPTY) {
      Texture._EMPTY = new Texture(new BaseTexture.BaseTexture());
      removeAllHandlers(Texture._EMPTY);
      removeAllHandlers(Texture._EMPTY.baseTexture);
    }
    return Texture._EMPTY;
  }
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.settings.ADAPTER.createCanvas(16, 16);
      const context = canvas.getContext("2d");
      canvas.width = 16;
      canvas.height = 16;
      context.fillStyle = "white";
      context.fillRect(0, 0, 16, 16);
      Texture._WHITE = new Texture(BaseTexture.BaseTexture.from(canvas));
      removeAllHandlers(Texture._WHITE);
      removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}

exports.Texture = Texture;
//# sourceMappingURL=Texture.js.map


/***/ }),

/***/ 37012:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);

const _TextureGCSystem = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = _TextureGCSystem.defaultMaxIdle;
    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
    this.mode = _TextureGCSystem.defaultMode;
  }
  postrender() {
    if (!this.renderer.objectRenderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === constants.GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const tm = this.renderer.texture;
    const managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i = 0; i < managedTextures.length; i++) {
      const texture = managedTextures[i];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      let j = 0;
      for (let i = 0; i < managedTextures.length; i++) {
        if (managedTextures[i] !== null) {
          managedTextures[j++] = managedTextures[i];
        }
      }
      managedTextures.length = j;
    }
  }
  unload(displayObject) {
    const tm = this.renderer.texture;
    const texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (let i = displayObject.children.length - 1; i >= 0; i--) {
      this.unload(displayObject.children[i]);
    }
  }
  destroy() {
    this.renderer = null;
  }
};
let TextureGCSystem = _TextureGCSystem;
TextureGCSystem.defaultMode = constants.GC_MODES.AUTO;
TextureGCSystem.defaultMaxIdle = 60 * 60;
TextureGCSystem.defaultCheckCountMax = 60 * 10;
TextureGCSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "textureGC"
};
extensions.extensions.add(TextureGCSystem);

exports.TextureGCSystem = TextureGCSystem;
//# sourceMappingURL=TextureGCSystem.js.map


/***/ }),

/***/ 32518:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(23846);

const tempMat = new math.Matrix();
class TextureMatrix {
  constructor(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new math.Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    this._textureID = -1;
  }
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i = 0; i < uvs.length; i += 2) {
      const x = uvs[i];
      const y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  }
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.baseTexture;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase.resolution;
    const offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}

exports.TextureMatrix = TextureMatrix;
//# sourceMappingURL=TextureMatrix.js.map


/***/ }),

/***/ 72798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var extensions = __webpack_require__(9498);
var utils = __webpack_require__(61973);
var BaseTexture = __webpack_require__(96728);
var GLTexture = __webpack_require__(59890);
var mapTypeAndFormatToInternalFormat = __webpack_require__(20647);

class TextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture.BaseTexture();
    this.hasIntegerTextures = false;
  }
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat.mapTypeAndFormatToInternalFormat(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i = 0; i < maxTextures; i++) {
      this.boundTextures[i] = null;
    }
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture.GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture.GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i = 0; i < 6; i++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.bind(null, i);
    }
  }
  bind(texture, location = 0) {
    const { gl } = this;
    texture = texture?.castToBaseTexture();
    if (texture?.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  }
  reset() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = this.unknownTexture;
    }
  }
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === this.unknownTexture) {
          this.bind(null, i);
        }
      }
    }
    for (let i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === texture) {
        if (this.currentLocation !== i) {
          gl.activeTexture(gl.TEXTURE0 + i);
          this.currentLocation = i;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i] = null;
      }
    }
  }
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (!hasIntegerTextures) {
      return;
    }
    for (let i = maxTextures - 1; i >= 0; --i) {
      const tex = boundTextures[i];
      if (tex) {
        const glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  }
  initTexture(texture) {
    const glTexture = new GLTexture.GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  }
  initTextureType(texture, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;
    if (this.webGLVersion === 2 && texture.type === constants.TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  }
  updateTexture(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    const renderer = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource?.upload(renderer, texture, glTexture)) {
      if (glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      const width = texture.realWidth;
      const height = texture.realHeight;
      const gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  }
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        const i = this.managedTextures.indexOf(texture);
        if (i !== -1) {
          utils.removeItems(this.managedTextures, i, 1);
        }
      }
    }
  }
  updateTextureStyle(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === constants.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = constants.WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource?.style(this.renderer, texture, glTexture)) {
    } else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  }
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== constants.MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === constants.SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "texture"
};
extensions.extensions.add(TextureSystem);

exports.TextureSystem = TextureSystem;
//# sourceMappingURL=TextureSystem.js.map


/***/ }),

/***/ 1755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var math = __webpack_require__(23846);

class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw;
      const h2 = frame.height / 2 / th;
      const cX = frame.x / tw + w2;
      const cY = frame.y / th + h2;
      rotate = math.groupD8.add(rotate, math.groupD8.NW);
      this.x0 = cX + w2 * math.groupD8.uX(rotate);
      this.y0 = cY + h2 * math.groupD8.uY(rotate);
      rotate = math.groupD8.add(rotate, 2);
      this.x1 = cX + w2 * math.groupD8.uX(rotate);
      this.y1 = cY + h2 * math.groupD8.uY(rotate);
      rotate = math.groupD8.add(rotate, 2);
      this.x2 = cX + w2 * math.groupD8.uX(rotate);
      this.y2 = cY + h2 * math.groupD8.uY(rotate);
      rotate = math.groupD8.add(rotate, 2);
      this.x3 = cX + w2 * math.groupD8.uX(rotate);
      this.y3 = cY + h2 * math.groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}

exports.TextureUvs = TextureUvs;
//# sourceMappingURL=TextureUvs.js.map


/***/ }),

/***/ 48077:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BaseTexture = __webpack_require__(96728);
var autoDetectResource = __webpack_require__(92308);
var Resource = __webpack_require__(80312);

class AbstractMultiResource extends Resource.Resource {
  constructor(length, options) {
    const { width, height } = options || {};
    super(width, height);
    this.items = [];
    this.itemDirtyIds = [];
    for (let i = 0; i < length; i++) {
      const partTexture = new BaseTexture.BaseTexture();
      this.items.push(partTexture);
      this.itemDirtyIds.push(-2);
    }
    this.length = length;
    this._load = null;
    this.baseTexture = null;
  }
  initFromArray(resources, options) {
    for (let i = 0; i < this.length; i++) {
      if (!resources[i]) {
        continue;
      }
      if (resources[i].castToBaseTexture) {
        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
      } else if (resources[i] instanceof Resource.Resource) {
        this.addResourceAt(resources[i], i);
      } else {
        this.addResourceAt(autoDetectResource.autoDetectResource(resources[i], options), i);
      }
    }
  }
  dispose() {
    for (let i = 0, len = this.length; i < len; i++) {
      this.items[i].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  }
  addResourceAt(resource, index) {
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index].setResource(resource);
    return this;
  }
  bind(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    super.bind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = baseTexture;
      this.items[i].on("update", baseTexture.update, baseTexture);
    }
  }
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = null;
      this.items[i].off("update", baseTexture.update, baseTexture);
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const resources = this.items.map((item) => item.resource).filter((item) => item);
    const promises = resources.map((item) => item.load());
    this._load = Promise.all(promises).then(() => {
      const { realWidth, realHeight } = this.items[0];
      this.resize(realWidth, realHeight);
      return Promise.resolve(this);
    });
    return this._load;
  }
}

exports.AbstractMultiResource = AbstractMultiResource;
//# sourceMappingURL=AbstractMultiResource.js.map


/***/ }),

/***/ 46831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var AbstractMultiResource = __webpack_require__(48077);

class ArrayResource extends AbstractMultiResource.AbstractMultiResource {
  constructor(source, options) {
    const { width, height } = options || {};
    let urls;
    let length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    super(length, { width, height });
    if (urls) {
      this.initFromArray(urls, options);
    }
  }
  addBaseTextureAt(baseTexture, index) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = constants.TARGETS.TEXTURE_2D_ARRAY;
  }
  upload(renderer, texture, glTexture) {
    const { length, itemDirtyIds, items } = this;
    const { gl } = renderer;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (let i = 0; i < length; i++) {
      const item = items[i];
      if (itemDirtyIds[i] < item.dirtyId) {
        itemDirtyIds[i] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  }
}

exports.ArrayResource = ArrayResource;
//# sourceMappingURL=ArrayResource.js.map


/***/ }),

/***/ 80856:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var utils = __webpack_require__(61973);
var Resource = __webpack_require__(80312);

class BaseImageResource extends Resource.Resource {
  constructor(source) {
    const sourceAny = source;
    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height);
    this.source = source;
    this.noSubImage = false;
  }
  static crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = utils.determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  upload(renderer, baseTexture, glTexture, source) {
    const gl = renderer.gl;
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    source = source || this.source;
    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
      if (source.readyState <= 1 && source.buffered.length === 0) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  }
  update() {
    if (this.destroyed) {
      return;
    }
    const source = this.source;
    const width = source.naturalWidth || source.videoWidth || source.width;
    const height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    super.update();
  }
  dispose() {
    this.source = null;
  }
}

exports.BaseImageResource = BaseImageResource;
//# sourceMappingURL=BaseImageResource.js.map


/***/ }),

/***/ 63278:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var Resource = __webpack_require__(80312);

class BufferResource extends Resource.Resource {
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    super(width, height);
    this.data = source;
  }
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
  dispose() {
    this.data = null;
  }
  static test(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  }
}

exports.BufferResource = BufferResource;
//# sourceMappingURL=BufferResource.js.map


/***/ }),

/***/ 39276:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BaseImageResource = __webpack_require__(80856);

class CanvasResource extends BaseImageResource.BaseImageResource {
  constructor(source) {
    super(source);
  }
  static test(source) {
    const { OffscreenCanvas } = globalThis;
    if (OffscreenCanvas && source instanceof OffscreenCanvas) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}

exports.CanvasResource = CanvasResource;
//# sourceMappingURL=CanvasResource.js.map


/***/ }),

/***/ 10373:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var AbstractMultiResource = __webpack_require__(48077);

const _CubeResource = class extends AbstractMultiResource.AbstractMultiResource {
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource.SIDES) {
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    }
    super(6, { width, height });
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      this.items[i].target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    }
    this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      this.load();
    }
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index, linkBaseTexture) {
    if (linkBaseTexture === void 0) {
      linkBaseTexture = this.linkBaseTexture;
    }
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error(`CubeResource does not support copying of renderTexture.`);
      }
    } else {
      baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index] = baseTexture;
    return this;
  }
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      const side = this.items[i];
      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i] = side.dirtyId;
        } else if (dirty[i] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i] = -1;
        }
      }
    }
    return true;
  }
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource.SIDES;
  }
};
let CubeResource = _CubeResource;
CubeResource.SIDES = 6;

exports.CubeResource = CubeResource;
//# sourceMappingURL=CubeResource.js.map


/***/ }),

/***/ 92107:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var BufferResource = __webpack_require__(63278);

class DepthResource extends BufferResource.BufferResource {
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
}

exports.DepthResource = DepthResource;
//# sourceMappingURL=DepthResource.js.map


/***/ }),

/***/ 40424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var settings = __webpack_require__(1405);
var BaseImageResource = __webpack_require__(80856);

class ImageBitmapResource extends BaseImageResource.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    let baseSource;
    let url;
    if (typeof source === "string") {
      baseSource = ImageBitmapResource.EMPTY;
      url = source;
    } else {
      baseSource = source;
      url = null;
    }
    super(baseSource);
    this.url = url;
    this.crossOrigin = options.crossOrigin ?? true;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(async (resolve, reject) => {
      if (this.url === null) {
        resolve(this);
        return;
      }
      try {
        const response = await settings.settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed)
          return;
        this.source = imageBitmap;
        this.update();
        resolve(this);
      } catch (e) {
        if (this.destroyed)
          return;
        reject(e);
        this.onError.emit(e);
      }
    });
    return this._load;
  }
  upload(renderer, baseTexture, glTexture) {
    if (!(this.source instanceof ImageBitmap)) {
      this.load();
      return false;
    }
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    return super.upload(renderer, baseTexture, glTexture);
  }
  dispose() {
    if (this.source instanceof ImageBitmap) {
      this.source.close();
    }
    super.dispose();
    this._load = null;
  }
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
  }
  static get EMPTY() {
    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.settings.ADAPTER.createCanvas(0, 0);
    return ImageBitmapResource._EMPTY;
  }
}

exports.ImageBitmapResource = ImageBitmapResource;
//# sourceMappingURL=ImageBitmapResource.js.map


/***/ }),

/***/ 38703:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);
var settings = __webpack_require__(1405);
var BaseImageResource = __webpack_require__(80856);

class ImageResource extends BaseImageResource.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (typeof source === "string") {
      const imageElement = new Image();
      BaseImageResource.BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    super(source);
    if (!source.complete && !!this._width && !!this._height) {
      this._width = 0;
      this._height = 0;
    }
    this.url = source.src;
    this._process = null;
    this.preserveBitmap = false;
    this.createBitmap = (options.createBitmap ?? settings.settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this.bitmap = null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load(createBitmap) {
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise((resolve, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        if (this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        this.resize(source.width, source.height);
        this._load = null;
        if (this.createBitmap) {
          resolve(this.process());
        } else {
          resolve(this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = (event) => {
          reject(event);
          this.onError.emit(event);
        };
      }
    });
    return this._load;
  }
  process() {
    const source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    const createImageBitmap = globalThis.createImageBitmap;
    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then((r) => r.blob()).then((blob) => createImageBitmap(blob, 0, 0, source.width, source.height, {
      premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"
    })).then((bitmap) => {
      if (this.destroyed) {
        return Promise.reject();
      }
      this.bitmap = bitmap;
      this.update();
      this._process = null;
      return Promise.resolve(this);
    });
    return this._process;
  }
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return super.upload(renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    super.upload(renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  }
  dispose() {
    this.source.onload = null;
    this.source.onerror = null;
    super.dispose();
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  }
  static test(source) {
    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
  }
}

exports.ImageResource = ImageResource;
//# sourceMappingURL=ImageResource.js.map


/***/ }),

/***/ 80312:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(69866);

class Resource {
  constructor(width = 0, height = 0) {
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new runner.Runner("setRealSize");
    this.onUpdate = new runner.Runner("update");
    this.onError = new runner.Runner("onError");
  }
  bind(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  }
  unbind(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  }
  resize(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  dispose() {
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  }
  static test(_source, _extension) {
    return false;
  }
}

exports.Resource = Resource;
//# sourceMappingURL=Resource.js.map


/***/ }),

/***/ 19148:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(1405);
var utils = __webpack_require__(61973);
var BaseImageResource = __webpack_require__(80856);

const _SVGResource = class extends BaseImageResource.BaseImageResource {
  constructor(sourceBase64, options) {
    options = options || {};
    super(settings.settings.ADAPTER.createCanvas());
    this._width = 0;
    this._height = 0;
    this.svg = sourceBase64;
    this.scale = options.scale || 1;
    this._overrideWidth = options.width;
    this._overrideHeight = options.height;
    this._resolve = null;
    this._crossorigin = options.crossorigin;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise((resolve) => {
      this._resolve = () => {
        this.resize(this.source.width, this.source.height);
        resolve(this);
      };
      if (_SVGResource.SVG_XML.test(this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    });
    return this._load;
  }
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = (event) => {
      if (!this._resolve) {
        return;
      }
      tempImage.onerror = null;
      this.onError.emit(event);
    };
    tempImage.onload = () => {
      if (!this._resolve) {
        return;
      }
      const svgWidth = tempImage.width;
      const svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      let width = svgWidth * this.scale;
      let height = svgHeight * this.scale;
      if (this._overrideWidth || this._overrideHeight) {
        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      const canvas = this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = `canvas_${utils.uid()}`;
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      this._resolve();
      this._resolve = null;
    };
  }
  static getSize(svgString) {
    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
    const size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  }
  dispose() {
    super.dispose();
    this._resolve = null;
    this._crossorigin = null;
  }
  static test(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
  }
};
let SVGResource = _SVGResource;
SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;

exports.SVGResource = SVGResource;
//# sourceMappingURL=SVGResource.js.map


/***/ }),

/***/ 63997:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ticker = __webpack_require__(47158);
var BaseImageResource = __webpack_require__(80856);

const _VideoResource = class extends BaseImageResource.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      const firstSrc = source[0].src || source[0];
      BaseImageResource.BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i = 0; i < source.length; ++i) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i];
        src = src || source[i];
        const baseSrc = src.split("?").shift().toLowerCase();
        const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source);
    this.noSubImage = true;
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this._load = null;
    this._resolve = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onError = this._onError.bind(this);
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      const elapsedMS = ticker.Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        super.update();
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise((resolve) => {
      if (this.valid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        source.load();
      }
    });
    return this._load;
  }
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  }
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  }
  _isSourceReady() {
    const source = this.source;
    return source.readyState > 2;
  }
  _onPlayStart() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      ticker.Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  }
  _onPlayStop() {
    if (this._isConnectedToTicker) {
      ticker.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  }
  dispose() {
    if (this._isConnectedToTicker) {
      ticker.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    const source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.dispose();
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        ticker.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
        ticker.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
    }
  }
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
  }
};
let VideoResource = _VideoResource;
VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};

exports.VideoResource = VideoResource;
//# sourceMappingURL=VideoResource.js.map


/***/ }),

/***/ 92308:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  let extension = "";
  if (typeof source === "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (let i = INSTALLED.length - 1; i >= 0; --i) {
    const ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}

exports.INSTALLED = INSTALLED;
exports.autoDetectResource = autoDetectResource;
//# sourceMappingURL=autoDetectResource.js.map


/***/ }),

/***/ 37598:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ArrayResource = __webpack_require__(46831);
var autoDetectResource = __webpack_require__(92308);
var BufferResource = __webpack_require__(63278);
var CanvasResource = __webpack_require__(39276);
var CubeResource = __webpack_require__(10373);
var ImageBitmapResource = __webpack_require__(40424);
var ImageResource = __webpack_require__(38703);
var SVGResource = __webpack_require__(19148);
var VideoResource = __webpack_require__(63997);
var BaseImageResource = __webpack_require__(80856);
var Resource = __webpack_require__(80312);
var AbstractMultiResource = __webpack_require__(48077);

autoDetectResource.INSTALLED.push(ImageBitmapResource.ImageBitmapResource, ImageResource.ImageResource, CanvasResource.CanvasResource, VideoResource.VideoResource, SVGResource.SVGResource, BufferResource.BufferResource, CubeResource.CubeResource, ArrayResource.ArrayResource);

exports.ArrayResource = ArrayResource.ArrayResource;
exports.INSTALLED = autoDetectResource.INSTALLED;
exports.autoDetectResource = autoDetectResource.autoDetectResource;
exports.BufferResource = BufferResource.BufferResource;
exports.CanvasResource = CanvasResource.CanvasResource;
exports.CubeResource = CubeResource.CubeResource;
exports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;
exports.ImageResource = ImageResource.ImageResource;
exports.SVGResource = SVGResource.SVGResource;
exports.VideoResource = VideoResource.VideoResource;
exports.BaseImageResource = BaseImageResource.BaseImageResource;
exports.Resource = Resource.Resource;
exports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 20647:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var constants = __webpack_require__(21837);

function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = {
      [constants.TYPES.UNSIGNED_BYTE]: {
        [constants.FORMATS.RGBA]: gl.RGBA8,
        [constants.FORMATS.RGB]: gl.RGB8,
        [constants.FORMATS.RG]: gl.RG8,
        [constants.FORMATS.RED]: gl.R8,
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [constants.FORMATS.RG_INTEGER]: gl.RG8UI,
        [constants.FORMATS.RED_INTEGER]: gl.R8UI,
        [constants.FORMATS.ALPHA]: gl.ALPHA,
        [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,
        [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [constants.TYPES.BYTE]: {
        [constants.FORMATS.RGBA]: gl.RGBA8_SNORM,
        [constants.FORMATS.RGB]: gl.RGB8_SNORM,
        [constants.FORMATS.RG]: gl.RG8_SNORM,
        [constants.FORMATS.RED]: gl.R8_SNORM,
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB8I,
        [constants.FORMATS.RG_INTEGER]: gl.RG8I,
        [constants.FORMATS.RED_INTEGER]: gl.R8I
      },
      [constants.TYPES.UNSIGNED_SHORT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [constants.FORMATS.RG_INTEGER]: gl.RG16UI,
        [constants.FORMATS.RED_INTEGER]: gl.R16UI,
        [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [constants.TYPES.SHORT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB16I,
        [constants.FORMATS.RG_INTEGER]: gl.RG16I,
        [constants.FORMATS.RED_INTEGER]: gl.R16I
      },
      [constants.TYPES.UNSIGNED_INT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [constants.FORMATS.RG_INTEGER]: gl.RG32UI,
        [constants.FORMATS.RED_INTEGER]: gl.R32UI,
        [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [constants.TYPES.INT]: {
        [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [constants.FORMATS.RGB_INTEGER]: gl.RGB32I,
        [constants.FORMATS.RG_INTEGER]: gl.RG32I,
        [constants.FORMATS.RED_INTEGER]: gl.R32I
      },
      [constants.TYPES.FLOAT]: {
        [constants.FORMATS.RGBA]: gl.RGBA32F,
        [constants.FORMATS.RGB]: gl.RGB32F,
        [constants.FORMATS.RG]: gl.RG32F,
        [constants.FORMATS.RED]: gl.R32F,
        [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [constants.TYPES.HALF_FLOAT]: {
        [constants.FORMATS.RGBA]: gl.RGBA16F,
        [constants.FORMATS.RGB]: gl.RGB16F,
        [constants.FORMATS.RG]: gl.RG16F,
        [constants.FORMATS.RED]: gl.R16F
      },
      [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {
        [constants.FORMATS.RGB]: gl.RGB565
      },
      [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [constants.FORMATS.RGBA]: gl.RGBA4
      },
      [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [constants.FORMATS.RGBA]: gl.RGB5_A1
      },
      [constants.TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [constants.FORMATS.RGBA]: gl.RGB10_A2,
        [constants.FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [constants.TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [constants.FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [constants.TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [constants.FORMATS.RGB]: gl.RGB9_E5
      },
      [constants.TYPES.UNSIGNED_INT_24_8]: {
        [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [constants.TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    };
  } else {
    table = {
      [constants.TYPES.UNSIGNED_BYTE]: {
        [constants.FORMATS.RGBA]: gl.RGBA,
        [constants.FORMATS.RGB]: gl.RGB,
        [constants.FORMATS.ALPHA]: gl.ALPHA,
        [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,
        [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {
        [constants.FORMATS.RGB]: gl.RGB
      },
      [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [constants.FORMATS.RGBA]: gl.RGBA
      },
      [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [constants.FORMATS.RGBA]: gl.RGBA
      }
    };
  }
  return table;
}

exports.mapTypeAndFormatToInternalFormat = mapTypeAndFormatToInternalFormat;
//# sourceMappingURL=mapTypeAndFormatToInternalFormat.js.map


/***/ }),

/***/ 13812:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var runner = __webpack_require__(69866);

class TransformFeedback {
  constructor() {
    this._glTransformFeedbacks = {};
    this.buffers = [];
    this.disposeRunner = new runner.Runner("disposeTransformFeedback");
  }
  bindBuffer(index, buffer) {
    this.buffers[index] = buffer;
  }
  destroy() {
    this.disposeRunner.emit(this, false);
  }
}

exports.TransformFeedback = TransformFeedback;
//# sourceMappingURL=TransformFeedback.js.map


/***/ }),

/***/ 233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);

class TransformFeedbackSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange() {
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this;
    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer } = this;
    if (shader) {
      renderer.shader.bind(shader);
    }
    gl.beginTransformFeedback(drawMode);
  }
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  createGLTransformFeedback(tf) {
    const { gl, renderer, CONTEXT_UID } = this;
    const glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i = 0; i < tf.buffers.length; i++) {
      const buffer = tf.buffers[i];
      if (!buffer)
        continue;
      renderer.buffer.update(buffer);
      buffer._glBuffers[CONTEXT_UID].refCount++;
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    tf.disposeRunner.add(this);
    return glTransformFeedback;
  }
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
    const gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem) {
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        if (!buffer)
          continue;
        const buf = buffer._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffer, contextLost);
          }
        }
      }
    }
    if (!glTF) {
      return;
    }
    if (!contextLost) {
      gl.deleteTransformFeedback(glTF);
    }
    delete tf._glTransformFeedbacks[this.CONTEXT_UID];
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions.extensions.add(TransformFeedbackSystem);

exports.TransformFeedbackSystem = TransformFeedbackSystem;
//# sourceMappingURL=TransformFeedbackSystem.js.map


/***/ }),

/***/ 50102:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Geometry = __webpack_require__(26818);

class Quad extends Geometry.Geometry {
  constructor() {
    super();
    this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}

exports.Quad = Quad;
//# sourceMappingURL=Quad.js.map


/***/ }),

/***/ 60357:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Buffer = __webpack_require__(27112);
var Geometry = __webpack_require__(26818);

class QuadUv extends Geometry.Geometry {
  constructor() {
    super();
    this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    this.vertexBuffer = new Buffer.Buffer(this.vertices);
    this.uvBuffer = new Buffer.Buffer(this.uvs);
    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  map(targetTextureFrame, destinationFrame) {
    let x = 0;
    let y = 0;
    this.uvs[0] = x;
    this.uvs[1] = y;
    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;
    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
    x = destinationFrame.x;
    y = destinationFrame.y;
    this.vertices[0] = x;
    this.vertices[1] = y;
    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;
    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;
    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;
    this.invalidate();
    return this;
  }
  invalidate() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  }
}

exports.QuadUv = QuadUv;
//# sourceMappingURL=QuadUv.js.map


/***/ }),

/***/ 32741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var math = __webpack_require__(23846);
var settings = __webpack_require__(1405);

class ViewSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  init(options) {
    this.screen = new math.Rectangle(0, 0, options.width, options.height);
    this.element = options.view || settings.settings.ADAPTER.createCanvas();
    this.resolution = options.resolution || settings.settings.RESOLUTION;
    this.autoDensity = !!options.autoDensity;
  }
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution);
    this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution;
    const screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.element.style.width = `${screenWidth}px`;
      this.element.style.height = `${screenHeight}px`;
    }
    this.renderer.emit("resize", screenWidth, screenHeight);
    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  destroy(removeView) {
    if (removeView) {
      this.element.parentNode?.removeChild(this.element);
    }
    this.renderer = null;
    this.element = null;
    this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  width: 800,
  height: 600,
  resolution: settings.settings.RESOLUTION,
  autoDensity: false
};
ViewSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions.extensions.add(ViewSystem);

exports.ViewSystem = ViewSystem;
//# sourceMappingURL=ViewSystem.js.map


/***/ }),

/***/ 58229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class Bounds {
  constructor() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  }
  getRectangle(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return core.Rectangle.EMPTY;
    }
    rect = rect || new core.Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  }
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  }
  addPointMatrix(matrix, point) {
    const { a, b, c, d, tx, ty } = matrix;
    const x = a * point.x + c * point.y + tx;
    const y = b * point.x + d * point.y + ty;
    this.minX = Math.min(this.minX, x);
    this.maxX = Math.max(this.maxX, x);
    this.minY = Math.min(this.minY, y);
    this.maxY = Math.max(this.maxY, y);
  }
  addQuad(vertices) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = vertices[0];
    let y = vertices[1];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[2];
    y = vertices[3];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[4];
    y = vertices[5];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[6];
    y = vertices[7];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = a * x0 + c * y0 + tx;
    let y = b * x0 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y0 + tx;
    y = b * x1 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x0 + c * y1 + tx;
    y = b * x0 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y1 + tx;
    y = b * x1 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const x = vertexData[i];
      const y = vertexData[i + 1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const rawX = vertices[i];
      const rawY = vertices[i + 1];
      const x = a * rawX + c * rawY + tx;
      const y = d * rawY + b * rawX + ty;
      minX = Math.min(minX, x - padX);
      maxX = Math.max(maxX, x + padX);
      minY = Math.min(minY, y - padY);
      maxY = Math.max(maxY, y + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addBounds(bounds) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  addBoundsArea(bounds, area) {
    const _minX = bounds.minX > area.x ? bounds.minX : area.x;
    const _minY = bounds.minY > area.y ? bounds.minY : area.y;
    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  pad(paddingX = 0, paddingY = paddingX) {
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  }
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}

exports.Bounds = Bounds;
//# sourceMappingURL=Bounds.js.map


/***/ }),

/***/ 50821:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var DisplayObject = __webpack_require__(49219);

const tempMatrix = new core.Matrix();
function sortChildren(a, b) {
  if (a.zIndex === b.zIndex) {
    return a._lastSortedIndex - b._lastSortedIndex;
  }
  return a.zIndex - b.zIndex;
}
const _Container = class extends DisplayObject.DisplayObject {
  constructor() {
    super();
    this.children = [];
    this.sortableChildren = _Container.defaultSortableChildren;
    this.sortDirty = false;
  }
  onChildrenChange(_length) {
  }
  addChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    } else {
      const child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  }
  addChildAt(child, index) {
    if (index < 0 || index > this.children.length) {
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index, 0, child);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("added", this);
    this.emit("childAdded", child, this, index);
    return child;
  }
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index;
  }
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    const currentIndex = this.getChildIndex(child);
    core.utils.removeItems(this.children, currentIndex, 1);
    this.children.splice(index, 0, child);
    this.onChildrenChange(index);
  }
  getChildAt(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  }
  removeChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    } else {
      const child = children[0];
      const index = this.children.indexOf(child);
      if (index === -1)
        return null;
      child.parent = null;
      child.transform._parentID = -1;
      core.utils.removeItems(this.children, index, 1);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index);
    }
    return children[0];
  }
  removeChildAt(index) {
    const child = this.getChildAt(index);
    child.parent = null;
    child.transform._parentID = -1;
    core.utils.removeItems(this.children, index, 1);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index);
    return child;
  }
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex;
    const end = endIndex;
    const range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].parent = null;
        if (removed[i].transform) {
          removed[i].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].emit("removed", this);
        this.emit("childRemoved", removed[i], this, i);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  sortChildren() {
    let sortRequired = false;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      child._lastSortedIndex = i;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  }
  updateTransform() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      if (child.visible) {
        child.updateTransform();
      }
    }
  }
  calculateBounds() {
    this._bounds.clear();
    this._calculateBounds();
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate) {
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  }
  _calculateBounds() {
  }
  _renderWithCulling(renderer) {
    const sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    let bounds;
    let transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== _Container.prototype._render) {
      bounds = this.getBounds(true);
    }
    const projectionTransform = renderer.projection.transform;
    if (projectionTransform) {
      if (transform) {
        transform = tempMatrix.copyFrom(transform);
        transform.prepend(projectionTransform);
      } else {
        transform = projectionTransform;
      }
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer);
    } else if (this.cullArea) {
      return;
    }
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      const childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer);
      child.cullable = childCullable;
    }
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters?.length) {
      this.renderAdvanced(renderer);
    } else if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
  }
  renderAdvanced(renderer) {
    const filters = this.filters;
    const mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (let i = 0; i < filters.length; i++) {
        if (filters[i].enabled) {
          this._enabledFilters.push(filters[i]);
        }
      }
    }
    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== core.MASK_TYPES.NONE));
    if (flush) {
      renderer.batch.flush();
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
    if (flush) {
      renderer.batch.flush();
    }
    if (mask) {
      renderer.mask.pop(this);
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.pop();
    }
  }
  _render(_renderer) {
  }
  destroy(options) {
    super.destroy();
    this.sortDirty = false;
    const destroyChildren = typeof options === "boolean" ? options : options?.children;
    const oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (let i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    if (width !== 0) {
      this.scale.x = value / width;
    } else {
      this.scale.x = 1;
    }
    this._width = value;
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    if (height !== 0) {
      this.scale.y = value / height;
    } else {
      this.scale.y = 1;
    }
    this._height = value;
  }
};
let Container = _Container;
Container.defaultSortableChildren = false;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

exports.Container = Container;
//# sourceMappingURL=Container.js.map


/***/ }),

/***/ 49219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var Bounds = __webpack_require__(58229);

class DisplayObject extends core.utils.EventEmitter {
  constructor() {
    super();
    this.tempDisplayObjectParent = null;
    this.transform = new core.Transform();
    this.alpha = 1;
    this.visible = true;
    this.renderable = true;
    this.cullable = false;
    this.cullArea = null;
    this.parent = null;
    this.worldAlpha = 1;
    this._lastSortedIndex = 0;
    this._zIndex = 0;
    this.filterArea = null;
    this.filters = null;
    this._enabledFilters = null;
    this._bounds = new Bounds.Bounds();
    this._localBounds = null;
    this._boundsID = 0;
    this._boundsRect = null;
    this._localBoundsRect = null;
    this._mask = null;
    this._maskRefCount = 0;
    this._destroyed = false;
    this.isSprite = false;
    this.isMask = false;
  }
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  }
  updateTransform() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  getBounds(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new core.Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  }
  getLocalBounds(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new core.Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds.Bounds();
    }
    const transformRef = this.transform;
    const parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds;
    const worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  }
  toGlobal(position, point, skipUpdate = false) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  }
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  }
  setParent(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  }
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    this.position.x = x;
    this.position.y = y;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  }
  destroy(_options) {
    this.removeFromParent();
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.eventMode = "auto";
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  }
  get _tempDisplayObjectParent() {
    if (this.tempDisplayObjectParent === null) {
      this.tempDisplayObjectParent = new TemporaryDisplayObject();
    }
    return this.tempDisplayObjectParent;
  }
  enableTempParent() {
    const myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  }
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  get angle() {
    return this.transform.rotation * core.RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * core.DEG_TO_RAD;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    if (this.parent) {
      this.parent.sortDirty = true;
    }
  }
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible) {
        return false;
      }
      item = item.parent;
    } while (item);
    return true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
    }
    this._mask = value;
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments);
    this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

exports.DisplayObject = DisplayObject;
exports.TemporaryDisplayObject = TemporaryDisplayObject;
//# sourceMappingURL=DisplayObject.js.map


/***/ }),

/***/ 31230:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(52005);
var Bounds = __webpack_require__(58229);
var Container = __webpack_require__(50821);
var DisplayObject = __webpack_require__(49219);



exports.Bounds = Bounds.Bounds;
exports.Container = Container.Container;
exports.DisplayObject = DisplayObject.DisplayObject;
exports.TemporaryDisplayObject = DisplayObject.TemporaryDisplayObject;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 52005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var Container = __webpack_require__(50821);

Object.defineProperties(core.settings, {
  SORTABLE_CHILDREN: {
    get() {
      return Container.Container.defaultSortableChildren;
    },
    set(value) {
      core.utils.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
      Container.Container.defaultSortableChildren = value;
    }
  }
});

Object.defineProperty(exports, "settings", ({
    enumerable: true,
    get: function () { return core.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ 92819:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var EventTicker = __webpack_require__(78367);
var FederatedMouseEvent = __webpack_require__(61560);
var FederatedPointerEvent = __webpack_require__(23138);
var FederatedWheelEvent = __webpack_require__(50928);

const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new core.Point();
const tempLocalMapping = new core.Point();
class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new core.utils.EventEmitter();
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = false;
    e.propagationImmediatelyStopped = false;
    this.propagate(e, type);
    this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e.type];
    if (mappers) {
      for (let i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
    }
  }
  hitTest(x, y) {
    EventTicker.EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e, type) {
    if (!e.target) {
      return;
    }
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    for (let i = composedPath.length - 2; i >= 0; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
  }
  all(e, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i = targets.length - 1; i >= 0; i--) {
      events.forEach((event) => {
        e.currentTarget = targets[i];
        this.notifyTarget(e, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventTicker.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventTicker.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {
      return true;
    }
    if (displayObject.eventMode === "none") {
      return true;
    }
    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {
      return true;
    }
    if (displayObject.isMask) {
      return true;
    }
    return false;
  }
  hitPruneFn(displayObject, location) {
    if (displayObject.hitArea) {
      displayObject.worldTransform.applyInverse(location, tempLocalMapping);
      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !maskObject.containsPoint?.(location)) {
        return true;
      }
    }
    return false;
  }
  hitTestFn(displayObject, location) {
    if (displayObject.eventMode === "passive") {
      return false;
    }
    if (displayObject.hitArea) {
      return true;
    }
    if (displayObject.containsPoint) {
      return displayObject.containsPoint(location);
    }
    return false;
  }
  notifyTarget(e, type) {
    type = type ?? e.type;
    const handlerKey = `on${type}`;
    e.currentTarget[handlerKey]?.(e);
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key);
    if (e.eventPhase === e.AT_TARGET) {
      this.notifyListeners(e, type);
    }
  }
  mapPointerDown(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerdown");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchstart");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerMove(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerOver(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e = this.createPointerEvent(from);
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    this.dispatchEvent(e, "pointerover");
    if (isMouse)
      this.dispatchEvent(e, "mouseover");
    if (e.pointerType === "mouse")
      this.cursor = e.target?.cursor;
    const enterEvent = this.clonePointerEvent(e, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerup");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchend");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e.composedPath().includes(currentTarget)) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e);
  }
  mapPointerUpOutside(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e);
  }
  mapWheel(from) {
    if (!(from instanceof FederatedWheelEvent.FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length; i++) {
      if (propagationPath[i].parent === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from) {
    const event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent))
      return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  copyMouseData(from, to) {
    if (!(from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent))
      return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (!listeners)
      return;
    if (!e.currentTarget.isInteractive())
      return;
    if ("fn" in listeners) {
      if (listeners.once)
        e.currentTarget.removeListener(type, listeners.fn, void 0, true);
      listeners.fn.call(listeners.context, e);
    } else {
      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once)
          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
        listeners[i].fn.call(listeners[i].context, e);
      }
    }
  }
}

exports.EventBoundary = EventBoundary;
//# sourceMappingURL=EventBoundary.js.map


/***/ }),

/***/ 19516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var EventBoundary = __webpack_require__(92819);
var EventTicker = __webpack_require__(78367);
var FederatedPointerEvent = __webpack_require__(23138);
var FederatedWheelEvent = __webpack_require__(50928);

const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class {
  constructor(renderer) {
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new EventBoundary.EventBoundary(null);
    EventTicker.EventsTicker.init(this);
    this.autoPreventDefault = true;
    this.eventsAdded = false;
    this.rootPointerEvent = new FederatedPointerEvent.FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent.FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "auto";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
  }
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursor === mode) {
      return;
    }
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this.rootPointerEvent;
  }
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const events = this.normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i = 0, j = events.length; i < j; i++) {
      const nativeEvent2 = events[i];
      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    EventTicker.EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this.removeEvents();
    this.domElement = element;
    EventTicker.EventsTicker.domElement = element;
    this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) {
      return;
    }
    EventTicker.EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
      this.domElement.addEventListener("mousedown", this.onPointerDown, true);
      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.addEventListener("touchstart", this.onPointerDown, true);
      this.domElement.addEventListener("touchend", this.onPointerUp, true);
      this.domElement.addEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) {
      return;
    }
    EventTicker.EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
      this.domElement.removeEventListener("touchend", this.onPointerUp, true);
      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this.eventsAdded = false;
  }
  mapPositionToPoint(point, x, y) {
    let rect;
    if (!this.domElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.domElement.getBoundingClientRect();
    }
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
let EventSystem = _EventSystem;
EventSystem.extension = {
  name: "events",
  type: [
    core.ExtensionType.RendererSystem,
    core.ExtensionType.CanvasRendererSystem
  ]
};
EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
core.extensions.add(EventSystem);

exports.EventSystem = EventSystem;
//# sourceMappingURL=EventSystem.js.map


/***/ }),

/***/ 78367:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this.tickerAdded || !this.domElement) {
      return;
    }
    core.Ticker.system.add(this.tickerUpdate, this, core.UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  }
  removeTickerListener() {
    if (!this.tickerAdded) {
      return;
    }
    core.Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  }
}
const EventsTicker = new EventsTickerClass();

exports.EventsTicker = EventsTicker;
//# sourceMappingURL=EventTicker.js.map


/***/ }),

/***/ 56905:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new core.Point();
    this.page = new core.Point();
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}

exports.FederatedEvent = FederatedEvent;
//# sourceMappingURL=FederatedEvent.js.map


/***/ }),

/***/ 70167:
/***/ (() => {

"use strict";


//# sourceMappingURL=FederatedEventMap.js.map


/***/ }),

/***/ 68668:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var EventSystem = __webpack_require__(19516);
var FederatedEvent = __webpack_require__(56905);

function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: void 0,
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.EventSystem.defaultEventMode);
  },
  set interactive(value) {
    core.utils.deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.`);
    this._internalInteractive = value;
    this.eventMode = value ? "static" : "auto";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? EventSystem.EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value);
    this._internalEventMode = value;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.on(type, listener, context);
  },
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context);
  },
  dispatchEvent(e) {
    if (!(e instanceof FederatedEvent.FederatedEvent)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    e.defaultPrevented = false;
    e.path = null;
    e.target = this;
    e.manager.dispatchEvent(e);
    return !e.defaultPrevented;
  }
};
display.DisplayObject.mixin(FederatedDisplayObject);

exports.FederatedDisplayObject = FederatedDisplayObject;
//# sourceMappingURL=FederatedEventTarget.js.map


/***/ }),

/***/ 61560:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var FederatedEvent = __webpack_require__(56905);

class FederatedMouseEvent extends FederatedEvent.FederatedEvent {
  constructor() {
    super(...arguments);
    this.client = new core.Point();
    this.movement = new core.Point();
    this.offset = new core.Point();
    this.global = new core.Point();
    this.screen = new core.Point();
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}

exports.FederatedMouseEvent = FederatedMouseEvent;
//# sourceMappingURL=FederatedMouseEvent.js.map


/***/ }),

/***/ 23138:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var FederatedMouseEvent = __webpack_require__(61560);

class FederatedPointerEvent extends FederatedMouseEvent.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.height = 0;
    this.isPrimary = false;
  }
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}

exports.FederatedPointerEvent = FederatedPointerEvent;
//# sourceMappingURL=FederatedPointerEvent.js.map


/***/ }),

/***/ 50928:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var FederatedMouseEvent = __webpack_require__(61560);

class FederatedWheelEvent extends FederatedMouseEvent.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.DOM_DELTA_PIXEL = 0;
    this.DOM_DELTA_LINE = 1;
    this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;

exports.FederatedWheelEvent = FederatedWheelEvent;
//# sourceMappingURL=FederatedWheelEvent.js.map


/***/ }),

/***/ 7065:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var EventBoundary = __webpack_require__(92819);
var EventSystem = __webpack_require__(19516);
var FederatedEvent = __webpack_require__(56905);
__webpack_require__(70167);
var FederatedEventTarget = __webpack_require__(68668);
var FederatedMouseEvent = __webpack_require__(61560);
var FederatedPointerEvent = __webpack_require__(23138);
var FederatedWheelEvent = __webpack_require__(50928);



exports.EventBoundary = EventBoundary.EventBoundary;
exports.EventSystem = EventSystem.EventSystem;
exports.FederatedEvent = FederatedEvent.FederatedEvent;
exports.FederatedDisplayObject = FederatedEventTarget.FederatedDisplayObject;
exports.FederatedMouseEvent = FederatedMouseEvent.FederatedMouseEvent;
exports.FederatedPointerEvent = FederatedPointerEvent.FederatedPointerEvent;
exports.FederatedWheelEvent = FederatedWheelEvent.FederatedWheelEvent;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 9498:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Renderer"] = "renderer";
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererSystem"] = "renderer-webgl-system";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
const normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
  _addHandlers: {},
  _removeHandlers: {},
  _queue: {},
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    });
    return this;
  },
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type]) {
          queue[type] = queue[type] || [];
          queue[type].push(ext);
        } else {
          handlers[type](ext);
        }
      });
    });
    return this;
  },
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue = this._queue;
    if (queue[type]) {
      queue[type].forEach((ext) => onAdd(ext));
      delete queue[type];
    }
    return this;
  },
  handleByMap(type, map) {
    return this.handle(type, (extension) => {
      map[extension.name] = extension.ref;
    }, (extension) => {
      delete map[extension.name];
    });
  },
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, (extension) => {
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority));
    }, (extension) => {
      const index = list.indexOf(extension.ref);
      if (index !== -1) {
        list.splice(index, 1);
      }
    });
  }
};

exports.ExtensionType = ExtensionType;
exports.extensions = extensions;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 80868:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const TEMP_RECT = new core.Rectangle();
const BYTES_PER_PIXEL = 4;
const _Extract = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  async image(target, format, quality) {
    const image = new Image();
    image.src = await this.base64(target, format, quality);
    return image;
  }
  async base64(target, format, quality) {
    const canvas = this.canvas(target);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, format, quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(format, quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    const canvasBuffer = new core.utils.CanvasRenderTarget(width, height, 1);
    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    canvasBuffer.context.putImageData(imageData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    return pixels;
  }
  _rawPixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("The Extract has already been destroyed");
    }
    let resolution;
    let flipY = false;
    let renderTexture;
    let generated = false;
    if (target) {
      if (target instanceof core.RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer.generateTexture(target, {
          resolution: renderer.resolution,
          multisample: renderer.multisample
        });
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame ?? renderTexture.frame;
      flipY = false;
      if (!generated) {
        renderer.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
        if (fbo.blitFramebuffer) {
          renderer.framebuffer.bind(fbo.blitFramebuffer);
        }
      }
    } else {
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width / resolution;
        frame.height = renderer.height / resolution;
      }
      flipY = true;
      renderer.renderTexture.bind();
    }
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const gl = renderer.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture?.destroy(true);
    }
    return { pixels, width, height, flipY };
  }
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w = width << 2;
    const h = height >> 1;
    const temp = new Uint8Array(w);
    for (let y = 0; y < h; y++) {
      const t = y * w;
      const b = (height - y - 1) * w;
      temp.set(pixels.subarray(t, t + w));
      pixels.copyWithin(t, b, b + w);
      pixels.set(temp, b);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n = pixels.length;
    for (let i = 0; i < n; i += 4) {
      const alpha = pixels[i + 3];
      if (alpha !== 0) {
        const a = 255.001 / alpha;
        pixels[i] = pixels[i] * a + 0.5;
        pixels[i + 1] = pixels[i + 1] * a + 0.5;
        pixels[i + 2] = pixels[i + 2] * a + 0.5;
      }
    }
  }
};
let Extract = _Extract;
Extract.extension = {
  name: "extract",
  type: core.ExtensionType.RendererSystem
};
core.extensions.add(Extract);

exports.Extract = Extract;
//# sourceMappingURL=Extract.js.map


/***/ }),

/***/ 24993:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Extract = __webpack_require__(80868);



exports.Extract = Extract.Extract;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 59501:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var alpha = __webpack_require__(28775);

class AlphaFilter extends core.Filter {
  constructor(alpha$1 = 1) {
    super(core.defaultVertex, alpha["default"], { uAlpha: 1 });
    this.alpha = alpha$1;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}

exports.AlphaFilter = AlphaFilter;
//# sourceMappingURL=AlphaFilter.js.map


/***/ }),

/***/ 28775:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=alpha.js.map


/***/ }),

/***/ 61743:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var AlphaFilter = __webpack_require__(59501);



exports.AlphaFilter = AlphaFilter.AlphaFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 52801:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var BlurFilterPass = __webpack_require__(59300);

class BlurFilter extends core.Filter {
  constructor(strength = 8, quality = 4, resolution = core.Filter.defaultResolution, kernelSize = 5) {
    super();
    this._repeatEdgePixels = false;
    this.blurXFilter = new BlurFilterPass.BlurFilterPass(true, strength, quality, resolution, kernelSize);
    this.blurYFilter = new BlurFilterPass.BlurFilterPass(false, strength, quality, resolution, kernelSize);
    this.resolution = resolution;
    this.quality = quality;
    this.blur = strength;
    this.repeatEdgePixels = false;
  }
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, core.CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value;
    this.updatePadding();
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value;
    this.updatePadding();
  }
}

exports.BlurFilter = BlurFilter;
//# sourceMappingURL=BlurFilter.js.map


/***/ }),

/***/ 59300:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var generateBlurFragSource = __webpack_require__(1953);
var generateBlurVertSource = __webpack_require__(14522);

class BlurFilterPass extends core.Filter {
  constructor(horizontal, strength = 8, quality = 4, resolution = core.Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource.generateBlurVertSource(kernelSize, horizontal);
    const fragSrc = generateBlurFragSource.generateBlurFragSource(kernelSize);
    super(vertSrc, fragSrc);
    this.horizontal = horizontal;
    this.resolution = resolution;
    this._quality = 0;
    this.quality = quality;
    this.blur = strength;
  }
  apply(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = filterManager.getFilterTexture();
      const renderer = filterManager.renderer;
      let flip = input;
      let flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, core.CLEAR_MODES.CLEAR);
      for (let i = 1; i < this.passes - 1; i++) {
        filterManager.bindAndClear(flip, core.CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip;
        flip = temp;
        renderer.shader.bind(this);
        renderer.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2;
    this.strength = value;
  }
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.passes = value;
  }
}

exports.BlurFilterPass = BlurFilterPass;
//# sourceMappingURL=BlurFilterPass.js.map


/***/ }),

/***/ 1953:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
const fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate;
  let blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}

exports.generateBlurFragSource = generateBlurFragSource;
//# sourceMappingURL=generateBlurFragSource.js.map


/***/ }),

/***/ 14522:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}

exports.generateBlurVertSource = generateBlurVertSource;
//# sourceMappingURL=generateBlurVertSource.js.map


/***/ }),

/***/ 6564:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BlurFilter = __webpack_require__(52801);
var BlurFilterPass = __webpack_require__(59300);



exports.BlurFilter = BlurFilter.BlurFilter;
exports.BlurFilterPass = BlurFilterPass.BlurFilterPass;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 67306:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var colorMatrix = __webpack_require__(34484);

class ColorMatrixFilter extends core.Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(core.defaultFilterVertex, colorMatrix["default"], uniforms);
    this.alpha = 1;
  }
  _loadMatrix(matrix, multiply = false) {
    let newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  }
  _multiply(out, a, b) {
    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
    return out;
  }
  _colorMatrix(matrix) {
    const m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;
    return m;
  }
  brightness(b, multiply) {
    const matrix = [
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  tint(color, multiply) {
    const [r, g, b] = core.Color.shared.setValue(color).toArray();
    const matrix = [
      r,
      0,
      0,
      0,
      0,
      0,
      g,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w = 1 / 3;
    const sqrW = sqrt(w);
    const a00 = cosR + (1 - cosR) * w;
    const a01 = w * (1 - cosR) - sqrW * sinR;
    const a02 = w * (1 - cosR) + sqrW * sinR;
    const a10 = w * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w * (1 - cosR);
    const a12 = w * (1 - cosR) - sqrW * sinR;
    const a20 = w * (1 - cosR) - sqrW * sinR;
    const a21 = w * (1 - cosR) + sqrW * sinR;
    const a22 = cosR + w * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  contrast(amount, multiply) {
    const v = (amount || 0) + 1;
    const o = -0.5 * (v - 1);
    const matrix = [
      v,
      0,
      0,
      0,
      o,
      0,
      v,
      0,
      0,
      o,
      0,
      0,
      v,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  saturate(amount = 0, multiply) {
    const x = amount * 2 / 3 + 1;
    const y = (x - 1) * -0.5;
    const matrix = [
      x,
      y,
      y,
      0,
      0,
      y,
      x,
      y,
      0,
      0,
      y,
      y,
      x,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    const temp = core.Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  night(intensity, multiply) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  predator(amount, multiply) {
    const matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;

exports.ColorMatrixFilter = ColorMatrixFilter;
//# sourceMappingURL=ColorMatrixFilter.js.map


/***/ }),

/***/ 34484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=colorMatrix.js.map


/***/ }),

/***/ 82746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ColorMatrixFilter = __webpack_require__(67306);



exports.ColorMatrixFilter = ColorMatrixFilter.ColorMatrixFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 95361:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var displacement$1 = __webpack_require__(70587);
var displacement = __webpack_require__(12749);

class DisplacementFilter extends core.Filter {
  constructor(sprite, scale) {
    const maskMatrix = new core.Matrix();
    sprite.renderable = false;
    super(displacement["default"], displacement$1["default"], {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    });
    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    this.scale = new core.Point(scale, scale);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}

exports.DisplacementFilter = DisplacementFilter;
//# sourceMappingURL=DisplacementFilter.js.map


/***/ }),

/***/ 70587:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=displacement.js.map


/***/ }),

/***/ 12749:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=displacement2.js.map


/***/ }),

/***/ 34734:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var DisplacementFilter = __webpack_require__(95361);



exports.DisplacementFilter = DisplacementFilter.DisplacementFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 28527:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var fxaa$1 = __webpack_require__(81361);
var fxaa = __webpack_require__(87275);

class FXAAFilter extends core.Filter {
  constructor() {
    super(fxaa["default"], fxaa$1["default"]);
  }
}

exports.FXAAFilter = FXAAFilter;
//# sourceMappingURL=FXAAFilter.js.map


/***/ }),

/***/ 81361:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=fxaa.js.map


/***/ }),

/***/ 87275:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=fxaa2.js.map


/***/ }),

/***/ 2013:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var FXAAFilter = __webpack_require__(28527);



exports.FXAAFilter = FXAAFilter.FXAAFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 16849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var noise = __webpack_require__(59851);

class NoiseFilter extends core.Filter {
  constructor(noise$1 = 0.5, seed = Math.random()) {
    super(core.defaultFilterVertex, noise["default"], {
      uNoise: 0,
      uSeed: 0
    });
    this.noise = noise$1;
    this.seed = seed;
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}

exports.NoiseFilter = NoiseFilter;
//# sourceMappingURL=NoiseFilter.js.map


/***/ }),

/***/ 937:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var NoiseFilter = __webpack_require__(16849);



exports.NoiseFilter = NoiseFilter.NoiseFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 59851:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=noise.js.map


/***/ }),

/***/ 47920:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var _const = __webpack_require__(75902);
var GraphicsGeometry = __webpack_require__(83960);
var FillStyle = __webpack_require__(24814);
var LineStyle = __webpack_require__(85543);
__webpack_require__(81439);
var QuadraticUtils = __webpack_require__(13932);
var BezierUtils = __webpack_require__(55867);
var ArcUtils = __webpack_require__(84234);

const DEFAULT_SHADERS = {};
const _Graphics = class extends display.Container {
  constructor(geometry = null) {
    super();
    this.shader = null;
    this.pluginName = "batch";
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this._fillStyle = new FillStyle.FillStyle();
    this._lineStyle = new LineStyle.LineStyle();
    this._matrix = null;
    this._holeMode = false;
    this.state = core.State.for2d();
    this._geometry = geometry || new GraphicsGeometry.GraphicsGeometry();
    this._geometry.refCount++;
    this._transformID = -1;
    this._tintColor = new core.Color(16777215);
    this.blendMode = core.BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _Graphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: core.Texture.WHITE,
      color: options?.texture ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: _const.LINE_CAP.BUTT,
      join: _const.LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new core.Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new core.Polygon();
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x, y) {
    this.startPoly();
    this.currentPath.points[0] = x;
    this.currentPath.points[1] = y;
    return this;
  }
  lineTo(x, y) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points = this.currentPath.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  }
  _initCurve(x = 0, y = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x, y];
      }
    } else {
      this.moveTo(x, y);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points;
    const result = ArcUtils.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += core.PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += core.PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX);
      const yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps) {
      } else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  }
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: core.Texture.WHITE, color, alpha });
  }
  normalizeColor(options) {
    const temp = core.Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber();
    options.alpha ?? (options.alpha = temp.alpha);
  }
  beginTextureFill(options) {
    const defaultOptions = {
      texture: core.Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x, y, width, height) {
    return this.drawShape(new core.Rectangle(x, y, width, height));
  }
  drawRoundedRect(x, y, width, height, radius) {
    return this.drawShape(new core.RoundedRectangle(x, y, width, height, radius));
  }
  drawCircle(x, y, radius) {
    return this.drawShape(new core.Circle(x, y, radius));
  }
  drawEllipse(x, y, width, height) {
    return this.drawShape(new core.Ellipse(x, y, width, height));
  }
  drawPolygon(...path) {
    let points;
    let closeStroke = true;
    const poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    const shape = new core.Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === core.SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i = 0; i < len; i++) {
      const gI = geometry.batches[i];
      const color = gI.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      const batch = {
        vertexData,
        blendMode,
        indices,
        uvs,
        _batchRGB: core.Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  }
  _renderBatched(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i = 0, l = this.batches.length; i < l; i++) {
      const batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer) {
    const shader = this._resolveDirectShader(renderer);
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    core.Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (let i = 0, l = drawCalls.length; i < l; i++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
    }
  }
  _renderDrawCallDirect(renderer, drawCall) {
    const { texArray, type, size, start } = drawCall;
    const groupTextureCount = texArray.count;
    for (let j = 0; j < groupTextureCount; j++) {
      renderer.texture.bind(texArray.elements[j], j);
    }
    renderer.geometry.draw(type, size, start);
  }
  _resolveDirectShader(renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer.plugins[pluginName];
        const sampleValues = new Int32Array(maxTextures);
        for (let i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new core.Matrix(),
          default: core.UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        const program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new core.Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
    return this._geometry.containsPoint(_Graphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i = 0; i < this.batches.length; i++) {
        const batch = this.batches[i];
        batch._tintRGB = core.Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i = 0; i < data.length; i += 2) {
      const x = data[i];
      const y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx;
      vertexData[count++] = d * y + b * x + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
};
let Graphics = _Graphics;
Graphics.curves = _const.curves;
Graphics._TEMP_POINT = new core.Point();

exports.Graphics = Graphics;
//# sourceMappingURL=Graphics.js.map


/***/ }),

/***/ 39736:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class GraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  clone() {
    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  }
}

exports.GraphicsData = GraphicsData;
//# sourceMappingURL=GraphicsData.js.map


/***/ }),

/***/ 83960:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var GraphicsData = __webpack_require__(39736);
var index = __webpack_require__(81439);
var BatchPart = __webpack_require__(14666);
var buildPoly = __webpack_require__(6533);
var buildLine = __webpack_require__(37849);

const tmpPoint = new core.Point();
const _GraphicsGeometry = class extends core.BatchGeometry {
  constructor() {
    super();
    this.closePointEps = 1e-4;
    this.boundsPadding = 0;
    this.uvsFloat32 = null;
    this.indicesUint16 = null;
    this.batchable = false;
    this.points = [];
    this.colors = [];
    this.uvs = [];
    this.indices = [];
    this.textureIds = [];
    this.graphicsData = [];
    this.drawCalls = [];
    this.batchDirty = -1;
    this.batches = [];
    this.dirty = 0;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.shapeIndex = 0;
    this._bounds = new display.Bounds();
    this.boundsDirty = -1;
  }
  get bounds() {
    this.updateBatches();
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      index.DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (let i = 0; i < this.batches.length; i++) {
      const batchPart = this.batches[i];
      batchPart.reset();
      index.BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData.GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new GraphicsData.GraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i = 0; i < graphicsData.length; ++i) {
      const data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i2 = 0; i2 < data.holes.length; i2++) {
              const hole = data.holes[i2];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    const uvs = this.uvs;
    const graphicsData = this.graphicsData;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      const data = graphicsData[i];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      const command = index.FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (let j = 0; j < 2; j++) {
        const style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const index2 = this.indices.length;
        const attribIndex = this.points.length / 2;
        nextTexture.wrapMode = core.WRAP_MODES.REPEAT;
        if (j === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        const size = this.points.length / 2 - attribIndex;
        if (size === 0)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index2, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = index.BATCH_POOL.pop() || new BatchPart.BatchPart();
          batchPart.begin(style, index2, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    const index$1 = this.indices.length;
    const attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index$1, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i = 0, l = this.graphicsData.length; i < l; i++) {
      const data = this.graphicsData[i];
      const fill = data.fillStyle;
      const line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i = 0, l = batches.length; i < l; i++) {
      const batch = batches[i];
      for (let j = 0; j < batch.size; j++) {
        const index = batch.start + j;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    const batches = this.batches;
    for (let i = 0; i < batches.length; i++) {
      if (batches[i].style.native) {
        return false;
      }
    }
    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
  }
  buildDrawCalls() {
    let TICK = ++core.BaseTexture._globalBatch;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      index.DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    const colors = this.colors;
    const textureIds = this.textureIds;
    let currentGroup = index.DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new core.BatchDrawCall();
      currentGroup.texArray = new core.BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = core.DRAW_MODES.TRIANGLES;
    let textureCount = 0;
    let currentTexture = null;
    let textureId = 0;
    let native = false;
    let drawMode = core.DRAW_MODES.TRIANGLES;
    let index$1 = 0;
    this.drawCalls.push(currentGroup);
    for (let i = 0; i < this.batches.length; i++) {
      const data = this.batches[i];
      const maxTextures = 8;
      const style = data.style;
      const nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? core.DRAW_MODES.LINES : core.DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = maxTextures;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === maxTextures) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = index.DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new core.BatchDrawCall();
                currentGroup.texArray = new core.BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index$1;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = core.WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index$1 += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    core.BaseTexture._globalBatch = TICK;
    this.packAttributes();
  }
  packAttributes() {
    const verts = this.points;
    const uvs = this.uvs;
    const colors = this.colors;
    const textureIds = this.textureIds;
    const glPoints = new ArrayBuffer(verts.length * 3 * 4);
    const f32 = new Float32Array(glPoints);
    const u32 = new Uint32Array(glPoints);
    let p = 0;
    for (let i = 0; i < verts.length / 2; i++) {
      f32[p++] = verts[i * 2];
      f32[p++] = verts[i * 2 + 1];
      f32[p++] = uvs[i * 2];
      f32[p++] = uvs[i * 2 + 1];
      u32[p++] = colors[i];
      f32[p++] = textureIds[i];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  }
  processFill(data) {
    if (data.holes.length) {
      buildPoly.buildPoly.triangulate(data, this);
    } else {
      const command = index.FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  }
  processLine(data) {
    buildLine.buildLine(data, this);
    for (let i = 0; i < data.holes.length; i++) {
      buildLine.buildLine(data.holes[i], this);
    }
  }
  processHoles(holes) {
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      const command = index.FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points, matrix) {
    for (let i = 0; i < points.length / 2; i++) {
      const x = points[i * 2];
      const y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  }
  addColors(colors, color, alpha, size, offset = 0) {
    const bgr = core.Color.shared.setValue(color).toLittleEndianNumber();
    const result = core.Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (let i = 0; i < size; i++) {
      colors[offset + i] = result;
    }
  }
  addTextureIds(textureIds, id, size, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (let i = 0; i < size; i++) {
      textureIds[offset + i] = id;
    }
  }
  addUvs(verts, uvs, texture, start, size, matrix = null) {
    let index = 0;
    const uvsStart = uvs.length;
    const frame = texture.frame;
    while (index < size) {
      let x = verts[(start + index) * 2];
      let y = verts[(start + index) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x + matrix.c * y + matrix.tx;
        y = matrix.b * x + matrix.d * y + matrix.ty;
        x = nx;
      }
      index++;
      uvs.push(x / frame.width, y / frame.height);
    }
    const baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  }
  adjustUvs(uvs, texture, start, size) {
    const baseTexture = texture.baseTexture;
    const eps = 1e-6;
    const finish = start + size * 2;
    const frame = texture.frame;
    const scaleX = frame.width / baseTexture.width;
    const scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width;
    let offsetY = frame.y / frame.height;
    let minX = Math.floor(uvs[start] + eps);
    let minY = Math.floor(uvs[start + 1] + eps);
    for (let i = start + 2; i < finish; i += 2) {
      minX = Math.min(minX, Math.floor(uvs[i] + eps));
      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (let i = start; i < finish; i += 2) {
      uvs[i] = (uvs[i] + offsetX) * scaleX;
      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
    }
  }
};
let GraphicsGeometry = _GraphicsGeometry;
GraphicsGeometry.BATCHABLE_SIZE = 100;

exports.GraphicsGeometry = GraphicsGeometry;
//# sourceMappingURL=GraphicsGeometry.js.map


/***/ }),

/***/ 75902:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
  return LINE_JOIN2;
})(LINE_JOIN || {});
var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
  return LINE_CAP2;
})(LINE_CAP || {});
const curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length, defaultSegments = 20) {
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    let result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
const GRAPHICS_CURVES = curves;

exports.GRAPHICS_CURVES = GRAPHICS_CURVES;
exports.LINE_CAP = LINE_CAP;
exports.LINE_JOIN = LINE_JOIN;
exports.curves = curves;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ 47997:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var index = __webpack_require__(81439);
var _const = __webpack_require__(75902);
var Graphics = __webpack_require__(47920);
var GraphicsData = __webpack_require__(39736);
var GraphicsGeometry = __webpack_require__(83960);
var FillStyle = __webpack_require__(24814);
var LineStyle = __webpack_require__(85543);
var buildPoly = __webpack_require__(6533);
var buildCircle = __webpack_require__(44935);
var buildRectangle = __webpack_require__(18978);
var buildRoundedRectangle = __webpack_require__(21417);
var buildLine = __webpack_require__(37849);
var ArcUtils = __webpack_require__(84234);
var BezierUtils = __webpack_require__(55867);
var QuadraticUtils = __webpack_require__(13932);
var BatchPart = __webpack_require__(14666);

const graphicsUtils = {
  buildPoly: buildPoly.buildPoly,
  buildCircle: buildCircle.buildCircle,
  buildRectangle: buildRectangle.buildRectangle,
  buildRoundedRectangle: buildRoundedRectangle.buildRoundedRectangle,
  buildLine: buildLine.buildLine,
  ArcUtils: ArcUtils.ArcUtils,
  BezierUtils: BezierUtils.BezierUtils,
  QuadraticUtils: QuadraticUtils.QuadraticUtils,
  BatchPart: BatchPart.BatchPart,
  FILL_COMMANDS: index.FILL_COMMANDS,
  BATCH_POOL: index.BATCH_POOL,
  DRAW_CALL_POOL: index.DRAW_CALL_POOL
};

exports.GRAPHICS_CURVES = _const.GRAPHICS_CURVES;
exports.LINE_CAP = _const.LINE_CAP;
exports.LINE_JOIN = _const.LINE_JOIN;
exports.curves = _const.curves;
exports.Graphics = Graphics.Graphics;
exports.GraphicsData = GraphicsData.GraphicsData;
exports.GraphicsGeometry = GraphicsGeometry.GraphicsGeometry;
exports.FillStyle = FillStyle.FillStyle;
exports.LineStyle = LineStyle.LineStyle;
exports.graphicsUtils = graphicsUtils;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 24814:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class FillStyle {
  constructor() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = core.Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  clone() {
    const obj = new FillStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = core.Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
  }
}

exports.FillStyle = FillStyle;
//# sourceMappingURL=FillStyle.js.map


/***/ }),

/***/ 85543:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(75902);
var FillStyle = __webpack_require__(24814);

class LineStyle extends FillStyle.FillStyle {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.alignment = 0.5;
    this.native = false;
    this.cap = _const.LINE_CAP.BUTT;
    this.join = _const.LINE_JOIN.MITER;
    this.miterLimit = 10;
  }
  clone() {
    const obj = new LineStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  }
  reset() {
    super.reset();
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  }
}

exports.LineStyle = LineStyle;
//# sourceMappingURL=LineStyle.js.map


/***/ }),

/***/ 84234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var _const = __webpack_require__(75902);

class ArcUtils {
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  }
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle;
    const n = _const.curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / core.PI_2) * 40);
    const theta = sweep / (n * 2);
    const theta2 = theta * 2;
    const cTheta = Math.cos(theta);
    const sTheta = Math.sin(theta);
    const segMinus = n - 1;
    const remainder = segMinus % 1 / segMinus;
    for (let i = 0; i <= segMinus; ++i) {
      const real = i + remainder * i;
      const angle = theta + startAngle + theta2 * real;
      const c = Math.cos(angle);
      const s = -Math.sin(angle);
      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
    }
  }
}

exports.ArcUtils = ArcUtils;
//# sourceMappingURL=ArcUtils.js.map


/***/ }),

/***/ 14666:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BatchPart {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  }
}

exports.BatchPart = BatchPart;
//# sourceMappingURL=BatchPart.js.map


/***/ }),

/***/ 55867:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(75902);

class BezierUtils {
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    const n = 10;
    let result = 0;
    let t = 0;
    let t2 = 0;
    let t3 = 0;
    let nt = 0;
    let nt2 = 0;
    let nt3 = 0;
    let x = 0;
    let y = 0;
    let dx = 0;
    let dy = 0;
    let prevX = fromX;
    let prevY = fromY;
    for (let i = 1; i <= n; ++i) {
      t = i / n;
      t2 = t * t;
      t3 = t2 * t;
      nt = 1 - t;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
      dx = prevX - x;
      dy = prevY - y;
      prevX = x;
      prevY = y;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  }
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    points.length -= 2;
    const n = _const.curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    let dt = 0;
    let dt2 = 0;
    let dt3 = 0;
    let t2 = 0;
    let t3 = 0;
    points.push(fromX, fromY);
    for (let i = 1, j = 0; i <= n; ++i) {
      j = i / n;
      dt = 1 - j;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j * j;
      t3 = t2 * j;
      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  }
}

exports.BezierUtils = BezierUtils;
//# sourceMappingURL=BezierUtils.js.map


/***/ }),

/***/ 13932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(75902);

class QuadraticUtils {
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX;
    const ay = fromY - 2 * cpY + toY;
    const bx = 2 * cpX - 2 * fromX;
    const by = 2 * cpY - 2 * fromY;
    const a = 4 * (ax * ax + ay * ay);
    const b = 4 * (ax * bx + ay * by);
    const c = bx * bx + by * by;
    const s = 2 * Math.sqrt(a + b + c);
    const a2 = Math.sqrt(a);
    const a32 = 2 * a * a2;
    const c2 = 2 * Math.sqrt(c);
    const ba = b / a2;
    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
  }
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const n = _const.curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    let xa = 0;
    let ya = 0;
    for (let i = 1; i <= n; ++i) {
      const j = i / n;
      xa = fromX + (cpX - fromX) * j;
      ya = fromY + (cpY - fromY) * j;
      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
    }
  }
}

exports.QuadraticUtils = QuadraticUtils;
//# sourceMappingURL=QuadraticUtils.js.map


/***/ }),

/***/ 44935:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x;
    let y;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === core.SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === core.SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x = ellipse.x;
      y = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m;
    if (m === 0) {
      return;
    }
    if (n === 0) {
      points.length = 8;
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y - dy;
      return;
    }
    let j1 = 0;
    let j2 = n * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      if (dy) {
        const y2 = y - y0;
        points[j3++] = x2;
        points[j3++] = y2;
        points[--j4] = y2;
        points[--j4] = x1;
      }
    }
    for (let i = 1; i < n; i++) {
      const a = Math.PI / 2 * (i / n);
      const x0 = dx + Math.cos(a) * rx;
      const y0 = dy + Math.sin(a) * ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      points[j3++] = x2;
      points[j3++] = y2;
      points[--j4] = y2;
      points[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x2;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x2;
      }
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x;
    let y;
    if (graphicsData.type !== core.SHAPES.RREC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x = roundedRect.x + roundedRect.width / 2;
      y = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
    vertPos++;
    verts.push(points[0], points[1]);
    for (let i = 2; i < points.length; i += 2) {
      verts.push(points[i], points[i + 1]);
      indices.push(vertPos++, center, vertPos);
    }
    indices.push(center + 1, center, vertPos);
  }
};

exports.buildCircle = buildCircle;
//# sourceMappingURL=buildCircle.js.map


/***/ }),

/***/ 37849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var _const = __webpack_require__(75902);

function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new core.Point(points[0], points[1]);
  const lastPoint = new core.Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === _const.LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === _const.LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === _const.LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === _const.LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join = _const.LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join) {
        case _const.LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case _const.LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case _const.LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join) {
        case _const.LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case _const.LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === _const.LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === _const.LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices = graphicsGeometry.indices;
  const eps2 = _const.curves.epsilon * _const.curves.epsilon;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i = 0;
  const shape = graphicsData.shape;
  const points = graphicsData.points || shape.points;
  const closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices = graphicsGeometry.indices;
  const length = points.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}

exports.buildLine = buildLine;
//# sourceMappingURL=buildLine.js.map


/***/ }),

/***/ 6533:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

function fixOrientation(points, hole = false) {
  const m = points.length;
  if (m < 6) {
    return;
  }
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n = m / 2;
    for (let i = n + n % 2; i < m; i += 2) {
      const i1 = m - i - 2;
      const i2 = m - i - 1;
      const i3 = i;
      const i4 = i + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]];
      [points[i2], points[i4]] = [points[i4], points[i2]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      const holeArray = [];
      for (let i = 0; i < holes.length; i++) {
        const hole = holes[i];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      const triangles = core.utils.earcut(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      const vertPos = verts.length / 2;
      for (let i = 0; i < triangles.length; i += 3) {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i + 1] + vertPos);
        indices.push(triangles[i + 2] + vertPos);
      }
      for (let i = 0; i < points.length; i++) {
        verts.push(points[i]);
      }
    }
  }
};

exports.buildPoly = buildPoly;
//# sourceMappingURL=buildPoly.js.map


/***/ }),

/***/ 18978:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape;
    const x = rectData.x;
    const y = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points = graphicsData.points;
    points.length = 0;
    if (!(width >= 0 && height >= 0)) {
      return;
    }
    points.push(x, y, x + width, y, x + width, y + height, x, y + height);
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    if (points.length === 0) {
      return;
    }
    const vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};

exports.buildRectangle = buildRectangle;
//# sourceMappingURL=buildRectangle.js.map


/***/ }),

/***/ 21417:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var buildCircle = __webpack_require__(44935);

const buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};

exports.buildRoundedRectangle = buildRoundedRectangle;
//# sourceMappingURL=buildRoundedRectangle.js.map


/***/ }),

/***/ 81439:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var buildCircle = __webpack_require__(44935);
var buildPoly = __webpack_require__(6533);
var buildRectangle = __webpack_require__(18978);
var buildRoundedRectangle = __webpack_require__(21417);
var ArcUtils = __webpack_require__(84234);
var BatchPart = __webpack_require__(14666);
var BezierUtils = __webpack_require__(55867);
var buildLine = __webpack_require__(37849);
var QuadraticUtils = __webpack_require__(13932);

const FILL_COMMANDS = {
  [core.SHAPES.POLY]: buildPoly.buildPoly,
  [core.SHAPES.CIRC]: buildCircle.buildCircle,
  [core.SHAPES.ELIP]: buildCircle.buildCircle,
  [core.SHAPES.RECT]: buildRectangle.buildRectangle,
  [core.SHAPES.RREC]: buildRoundedRectangle.buildRoundedRectangle
};
const BATCH_POOL = [];
const DRAW_CALL_POOL = [];

exports.buildCircle = buildCircle.buildCircle;
exports.buildPoly = buildPoly.buildPoly;
exports.buildRectangle = buildRectangle.buildRectangle;
exports.buildRoundedRectangle = buildRoundedRectangle.buildRoundedRectangle;
exports.ArcUtils = ArcUtils.ArcUtils;
exports.BatchPart = BatchPart.BatchPart;
exports.BezierUtils = BezierUtils.BezierUtils;
exports.buildLine = buildLine.buildLine;
exports.QuadraticUtils = QuadraticUtils.QuadraticUtils;
exports.BATCH_POOL = BATCH_POOL;
exports.DRAW_CALL_POOL = DRAW_CALL_POOL;
exports.FILL_COMMANDS = FILL_COMMANDS;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 10739:
/***/ (() => {

"use strict";


//# sourceMappingURL=IPoint.js.map


/***/ }),

/***/ 80667:
/***/ (() => {

"use strict";


//# sourceMappingURL=IPointData.js.map


/***/ }),

/***/ 74709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(76317);
var Point = __webpack_require__(38164);

class Matrix {
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  set(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  apply(pos, newPos) {
    newPos = newPos || new Point.Point();
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new Point.Point();
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  translate(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  }
  scale(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  }
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(_const.PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
    return transform;
  }
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  toString() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return new Matrix();
  }
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}

exports.Matrix = Matrix;
//# sourceMappingURL=Matrix.js.map


/***/ }),

/***/ 85339:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class ObservablePoint {
  constructor(cb, scope, x = 0, y = 0) {
    this._x = x;
    this._y = y;
    this.cb = cb;
    this.scope = scope;
  }
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  set(x = 0, y = x) {
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyFrom(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyTo(p) {
    p.set(this._x, this._y);
    return p;
  }
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
  toString() {
    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.cb.call(this.scope);
    }
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.cb.call(this.scope);
    }
  }
}

exports.ObservablePoint = ObservablePoint;
//# sourceMappingURL=ObservablePoint.js.map


/***/ }),

/***/ 38164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class Point {
  constructor(x = 0, y = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p) {
    this.set(p.x, p.y);
    return this;
  }
  copyTo(p) {
    p.set(this.x, this.y);
    return p;
  }
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  set(x = 0, y = x) {
    this.x = x;
    this.y = y;
    return this;
  }
  toString() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  }
}

exports.Point = Point;
//# sourceMappingURL=Point.js.map


/***/ }),

/***/ 9418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Matrix = __webpack_require__(74709);
var ObservablePoint = __webpack_require__(85339);

const _Transform = class {
  constructor() {
    this.worldTransform = new Matrix.Matrix();
    this.localTransform = new Matrix.Matrix();
    this.position = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint.ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint.ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};
let Transform = _Transform;
Transform.IDENTITY = new _Transform();

exports.Transform = Transform;
//# sourceMappingURL=Transform.js.map


/***/ }),

/***/ 76317:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});

exports.DEG_TO_RAD = DEG_TO_RAD;
exports.PI_2 = PI_2;
exports.RAD_TO_DEG = RAD_TO_DEG;
exports.SHAPES = SHAPES;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ 65813:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Matrix = __webpack_require__(74709);

const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j = 0; j < 16; j++) {
      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (let k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new Matrix.Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (ind) => ux[ind],
  uY: (ind) => uy[ind],
  vX: (ind) => vx[ind],
  vY: (ind) => vy[ind],
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  rotate180: (rotation) => rotation ^ 4,
  isVertical: (rotation) => (rotation & 3) === 2,
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};

exports.groupD8 = groupD8;
//# sourceMappingURL=groupD8.js.map


/***/ }),

/***/ 23846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Circle = __webpack_require__(78781);
var Ellipse = __webpack_require__(88079);
var Polygon = __webpack_require__(42427);
var Rectangle = __webpack_require__(75456);
var RoundedRectangle = __webpack_require__(81943);
var groupD8 = __webpack_require__(65813);
__webpack_require__(10739);
__webpack_require__(80667);
var Matrix = __webpack_require__(74709);
var ObservablePoint = __webpack_require__(85339);
var Point = __webpack_require__(38164);
var Transform = __webpack_require__(9418);
var _const = __webpack_require__(76317);



exports.Circle = Circle.Circle;
exports.Ellipse = Ellipse.Ellipse;
exports.Polygon = Polygon.Polygon;
exports.Rectangle = Rectangle.Rectangle;
exports.RoundedRectangle = RoundedRectangle.RoundedRectangle;
exports.groupD8 = groupD8.groupD8;
exports.Matrix = Matrix.Matrix;
exports.ObservablePoint = ObservablePoint.ObservablePoint;
exports.Point = Point.Point;
exports.Transform = Transform.Transform;
exports.DEG_TO_RAD = _const.DEG_TO_RAD;
exports.PI_2 = _const.PI_2;
exports.RAD_TO_DEG = _const.RAD_TO_DEG;
exports.SHAPES = _const.SHAPES;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 78781:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(76317);
var Rectangle = __webpack_require__(75456);

class Circle {
  constructor(x = 0, y = 0, radius = 0) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.type = _const.SHAPES.CIRC;
  }
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  contains(x, y) {
    if (this.radius <= 0) {
      return false;
    }
    const r2 = this.radius * this.radius;
    let dx = this.x - x;
    let dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  getBounds() {
    return new Rectangle.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
  toString() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}

exports.Circle = Circle;
//# sourceMappingURL=Circle.js.map


/***/ }),

/***/ 88079:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(76317);
var Rectangle = __webpack_require__(75456);

class Ellipse {
  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x;
    this.y = y;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = _const.SHAPES.ELIP;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    let normx = (x - this.x) / this.width;
    let normy = (y - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  getBounds() {
    return new Rectangle.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
  toString() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}

exports.Ellipse = Ellipse;
//# sourceMappingURL=Ellipse.js.map


/***/ }),

/***/ 42427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(76317);

class Polygon {
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p = [];
      for (let i = 0, il = flat.length; i < il; i++) {
        p.push(flat[i].x, flat[i].y);
      }
      flat = p;
    }
    this.points = flat;
    this.type = _const.SHAPES.POLY;
    this.closeStroke = true;
  }
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  }
  contains(x, y) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i = 0, j = length - 1; i < length; j = i++) {
      const xi = this.points[i * 2];
      const yi = this.points[i * 2 + 1];
      const xj = this.points[j * 2];
      const yj = this.points[j * 2 + 1];
      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  toString() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
}

exports.Polygon = Polygon;
//# sourceMappingURL=Polygon.js.map


/***/ }),

/***/ 75456:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(76317);
var Point = __webpack_require__(38164);

const tempPoints = [new Point.Point(), new Point.Point(), new Point.Point(), new Point.Point()];
class Rectangle {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = Number(x);
    this.y = Number(y);
    this.width = Number(width);
    this.height = Number(height);
    this.type = _const.SHAPES.RECT;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s * (lb.y - lt.y);
    const ny = s * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s * (lt.y - rt.y);
    const my = s * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  toString() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}

exports.Rectangle = Rectangle;
//# sourceMappingURL=Rectangle.js.map


/***/ }),

/***/ 81943:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(76317);

class RoundedRectangle {
  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = _const.SHAPES.RREC;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.x + this.width) {
      if (y >= this.y && y <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return true;
        }
        let dx = x - (this.x + radius);
        let dy = y - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  toString() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}

exports.RoundedRectangle = RoundedRectangle;
//# sourceMappingURL=RoundedRectangle.js.map


/***/ }),

/***/ 75523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var SimplePlane = __webpack_require__(67123);

const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends SimplePlane.SimplePlane {
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    super(core.Texture.WHITE, 4, 4);
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    this._width = this._origWidth;
    this._height = this._origHeight;
    this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;
    this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;
    this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;
    this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;
    this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  updateHorizontalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  updateVerticalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  _getMinScale() {
    const w = this._leftWidth + this._rightWidth;
    const scaleW = this._width > w ? 1 : this._width / w;
    const h = this._topHeight + this._bottomHeight;
    const scaleH = this._height > h ? 1 : this._height / h;
    const scale = Math.min(scaleW, scaleH);
    return scale;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._refresh();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._refresh();
  }
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value;
    this._refresh();
  }
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value;
    this._refresh();
  }
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value;
    this._refresh();
  }
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value;
    this._refresh();
  }
  _refresh() {
    const texture = this.texture;
    const uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth;
    const _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  }
}

exports.NineSlicePlane = NineSlicePlane;
//# sourceMappingURL=NineSlicePlane.js.map


/***/ }),

/***/ 14168:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var mesh = __webpack_require__(57309);

class SimpleMesh extends mesh.Mesh {
  constructor(texture = core.Texture.EMPTY, vertices, uvs, indices, drawMode) {
    const geometry = new mesh.MeshGeometry(vertices, uvs, indices);
    geometry.getBuffer("aVertexPosition").static = false;
    const meshMaterial = new mesh.MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode);
    this.autoUpdate = true;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer);
  }
}

exports.SimpleMesh = SimpleMesh;
//# sourceMappingURL=SimpleMesh.js.map


/***/ }),

/***/ 67123:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var mesh = __webpack_require__(57309);
var PlaneGeometry = __webpack_require__(72938);

class SimplePlane extends mesh.Mesh {
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new PlaneGeometry.PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    const meshMaterial = new mesh.MeshMaterial(core.Texture.WHITE);
    super(planeGeometry, meshMaterial);
    this.texture = texture;
    this.autoResize = true;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry;
    const { width, height } = this.shader.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  }
  set texture(value) {
    if (this.shader.texture === value) {
      return;
    }
    this.shader.texture = value;
    this._textureID = -1;
    if (value.baseTexture.valid) {
      this.textureUpdated();
    } else {
      value.once("update", this.textureUpdated, this);
    }
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    super._render(renderer);
  }
  destroy(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    super.destroy(options);
  }
}

exports.SimplePlane = SimplePlane;
//# sourceMappingURL=SimplePlane.js.map


/***/ }),

/***/ 68841:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var mesh = __webpack_require__(57309);
var RopeGeometry = __webpack_require__(30818);

class SimpleRope extends mesh.Mesh {
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new RopeGeometry.RopeGeometry(texture.height, points, textureScale);
    const meshMaterial = new mesh.MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = core.WRAP_MODES.REPEAT;
    }
    super(ropeGeometry, meshMaterial);
    this.autoUpdate = true;
  }
  _render(renderer) {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    super._render(renderer);
  }
}

exports.SimpleRope = SimpleRope;
//# sourceMappingURL=SimpleRope.js.map


/***/ }),

/***/ 72938:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var mesh = __webpack_require__(57309);

class PlaneGeometry extends mesh.MeshGeometry {
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super();
    this.segWidth = segWidth;
    this.segHeight = segHeight;
    this.width = width;
    this.height = height;
    this.build();
  }
  build() {
    const total = this.segWidth * this.segHeight;
    const verts = [];
    const uvs = [];
    const indices = [];
    const segmentsX = this.segWidth - 1;
    const segmentsY = this.segHeight - 1;
    const sizeX = this.width / segmentsX;
    const sizeY = this.height / segmentsY;
    for (let i = 0; i < total; i++) {
      const x = i % this.segWidth;
      const y = i / this.segWidth | 0;
      verts.push(x * sizeX, y * sizeY);
      uvs.push(x / segmentsX, y / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % segmentsX;
      const ypos = i / segmentsX | 0;
      const value = ypos * this.segWidth + xpos;
      const value2 = ypos * this.segWidth + xpos + 1;
      const value3 = (ypos + 1) * this.segWidth + xpos;
      const value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
}

exports.PlaneGeometry = PlaneGeometry;
//# sourceMappingURL=PlaneGeometry.js.map


/***/ }),

/***/ 30818:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var mesh = __webpack_require__(57309);

class RopeGeometry extends mesh.MeshGeometry {
  constructor(width = 200, points, textureScale = 0) {
    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this.build();
  }
  get width() {
    return this._width;
  }
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition");
    const uvBuffer = this.getBuffer("aTextureCoord");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i = 0; i < total; i++) {
      const index = i * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i].x;
        const dy = prev.y - points[i].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    let indexCount = 0;
    for (let i = 0; i < total - 1; i++) {
      const index = i * 2;
      indices[indexCount++] = index;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i = 0; i < total; i++) {
      const point = points[i];
      const index = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      let ratio = (1 - i / (total - 1)) * 10;
      if (ratio > 1) {
        ratio = 1;
      }
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  }
}

exports.RopeGeometry = RopeGeometry;
//# sourceMappingURL=RopeGeometry.js.map


/***/ }),

/***/ 42683:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var PlaneGeometry = __webpack_require__(72938);
var RopeGeometry = __webpack_require__(30818);
var NineSlicePlane = __webpack_require__(75523);
var SimpleMesh = __webpack_require__(14168);
var SimplePlane = __webpack_require__(67123);
var SimpleRope = __webpack_require__(68841);



exports.PlaneGeometry = PlaneGeometry.PlaneGeometry;
exports.RopeGeometry = RopeGeometry.RopeGeometry;
exports.NineSlicePlane = NineSlicePlane.NineSlicePlane;
exports.SimpleMesh = SimpleMesh.SimpleMesh;
exports.SimplePlane = SimplePlane.SimplePlane;
exports.SimpleRope = SimpleRope.SimpleRope;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 59644:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var MeshBatchUvs = __webpack_require__(42124);

const tempPoint = new core.Point();
const tempPolygon = new core.Polygon();
const _Mesh = class extends display.Container {
  constructor(geometry, shader, state, drawMode = core.DRAW_MODES.TRIANGLES) {
    super();
    this.geometry = geometry;
    this.shader = shader;
    this.state = state || core.State.for2d();
    this.drawMode = drawMode;
    this.start = 0;
    this.size = 0;
    this.uvs = null;
    this.indices = null;
    this.vertexData = new Float32Array(1);
    this.vertexDirty = -1;
    this._transformID = -1;
    this._roundPixels = core.settings.ROUND_PIXELS;
    this.batchUvs = null;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    if (this._geometry === value) {
      return;
    }
    if (this._geometry) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
    }
    this._geometry = value;
    if (this._geometry) {
      this._geometry.refCount++;
    }
    this.vertexDirty = -1;
  }
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  get tintValue() {
    return this.shader.tintValue;
  }
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  _render(renderer) {
    const vertices = this.geometry.buffers[0].data;
    const shader = this.shader;
    if (shader.batchable && this.drawMode === core.DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  }
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  _renderToBatch(renderer) {
    const geometry = this.geometry;
    const shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  }
  calculateVertices() {
    const geometry = this.geometry;
    const verticesBuffer = geometry.buffers[0];
    const vertices = verticesBuffer.data;
    const vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    for (let i = 0; i < vertexData.length / 2; i++) {
      const x = vertices[i * 2];
      const y = vertices[i * 2 + 1];
      vertexData[i * 2] = a * x + c * y + tx;
      vertexData[i * 2 + 1] = b * x + d * y + ty;
    }
    if (this._roundPixels) {
      const resolution = core.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
    this.vertexDirty = vertexDirtyId;
  }
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1];
    const shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs.MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    const vertices = this.geometry.getBuffer("aVertexPosition").data;
    const points = tempPolygon.points;
    const indices = this.geometry.getIndex().data;
    const len = indices.length;
    const step = this.drawMode === 4 ? 3 : 1;
    for (let i = 0; i + 2 < len; i += step) {
      const ind0 = indices[i] * 2;
      const ind1 = indices[i + 1] * 2;
      const ind2 = indices[i + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  }
};
let Mesh = _Mesh;
Mesh.BATCHABLE_SIZE = 100;

exports.Mesh = Mesh;
//# sourceMappingURL=Mesh.js.map


/***/ }),

/***/ 42124:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class MeshBatchUvs {
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  }
}

exports.MeshBatchUvs = MeshBatchUvs;
//# sourceMappingURL=MeshBatchUvs.js.map


/***/ }),

/***/ 81300:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class MeshGeometry extends core.Geometry {
  constructor(vertices, uvs, index) {
    super();
    const verticesBuffer = new core.Buffer(vertices);
    const uvsBuffer = new core.Buffer(uvs, true);
    const indexBuffer = new core.Buffer(index, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, core.TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, core.TYPES.FLOAT).addIndex(indexBuffer);
    this._updateId = -1;
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}

exports.MeshGeometry = MeshGeometry;
//# sourceMappingURL=MeshGeometry.js.map


/***/ }),

/***/ 85233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var mesh$1 = __webpack_require__(56486);
var mesh = __webpack_require__(66222);

class MeshMaterial extends core.Shader {
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: core.Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    super(options.program || core.Program.from(mesh["default"], mesh$1["default"]), uniforms);
    this._colorDirty = false;
    this.uvMatrix = new core.TextureMatrix(uSampler);
    this.batchable = options.program === void 0;
    this.pluginName = options.pluginName;
    this._tintColor = new core.Color(options.tint);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
    this.alpha = options.alpha;
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    if (this.uniforms.uSampler !== value) {
      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
        this._colorDirty = true;
      }
      this.uniforms.uSampler = value;
      this.uvMatrix.texture = value;
    }
  }
  set alpha(value) {
    if (value === this._alpha)
      return;
    this._alpha = value;
    this._colorDirty = true;
  }
  get alpha() {
    return this._alpha;
  }
  set tint(value) {
    if (value === this.tint)
      return;
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const baseTexture = this.texture.baseTexture;
      const applyToChannels = baseTexture.alphaMode;
      core.Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  }
}

exports.MeshMaterial = MeshMaterial;
//# sourceMappingURL=MeshMaterial.js.map


/***/ }),

/***/ 57309:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Mesh = __webpack_require__(59644);
var MeshBatchUvs = __webpack_require__(42124);
var MeshGeometry = __webpack_require__(81300);
var MeshMaterial = __webpack_require__(85233);



exports.Mesh = Mesh.Mesh;
exports.MeshBatchUvs = MeshBatchUvs.MeshBatchUvs;
exports.MeshGeometry = MeshGeometry.MeshGeometry;
exports.MeshMaterial = MeshMaterial.MeshMaterial;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 56486:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";

exports["default"] = fragment;
//# sourceMappingURL=mesh.js.map


/***/ }),

/***/ 66222:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=mesh2.js.map


/***/ }),

/***/ 13283:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var sprite = __webpack_require__(64441);

const _tempMatrix = new core.Matrix();
display.DisplayObject.prototype._cacheAsBitmap = false;
display.DisplayObject.prototype._cacheData = null;
display.DisplayObject.prototype._cacheAsBitmapResolution = null;
display.DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
}
Object.defineProperties(display.DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      let data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
display.DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
display.DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  const bounds = this.getLocalBounds(null, true).clone();
  if (this.filters?.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(core.settings.RESOLUTION);
  const cachedRenderTexture = renderer.renderTexture.current;
  const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  const cachedProjectionTransform = renderer.projection.transform;
  const renderTexture = core.RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
  });
  const textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  core.Texture.addToCache(renderTexture, textureCacheId);
  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new sprite.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
display.DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
display.DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const bounds = this.getLocalBounds(null, true);
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer.canvasContext.activeContext;
  const cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(core.settings.RESOLUTION);
  const renderTexture = core.RenderTexture.create({ width: bounds.width, height: bounds.height });
  const textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  core.Texture.addToCache(renderTexture, textureCacheId);
  const m = _tempMatrix;
  this.transform.localTransform.copyTo(m);
  m.invert();
  m.tx -= bounds.x;
  m.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.canvasContext.activeContext = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new sprite.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
display.DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
display.DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
display.DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  core.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  core.Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
display.DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};

exports.CacheData = CacheData;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 42885:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);

display.DisplayObject.prototype.name = null;
display.Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (let i = 0, j = this.children.length; i < j; i++) {
    if (this.children[i].name === name) {
      return this.children[i];
    }
  }
  if (deep) {
    for (let i = 0, j = this.children.length; i < j; i++) {
      const child = this.children[i];
      if (!child.getChildByName) {
        continue;
      }
      const target = child.getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 93204:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var display = __webpack_require__(31230);

display.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new core.Point(), skipUpdate = false) {
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 63930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

class ParticleBuffer {
  constructor(properties, dynamicPropertyFlags, size) {
    this.geometry = new core.Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (let i = 0; i < properties.length; ++i) {
      let property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || core.TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new core.Buffer(core.utils.createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new core.Buffer(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new core.Buffer(this.staticData, true, false);
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === core.TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === core.TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  }
  uploadDynamic(children, startIndex, amount) {
    for (let i = 0; i < this.dynamicProperties.length; i++) {
      const property = this.dynamicProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(children, startIndex, amount) {
    for (let i = 0; i < this.staticProperties.length; i++) {
      const property = this.staticProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  }
}

exports.ParticleBuffer = ParticleBuffer;
//# sourceMappingURL=ParticleBuffer.js.map


/***/ }),

/***/ 16945:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);

class ParticleContainer extends display.Container {
  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
    super();
    const maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    this._properties = [false, true, false, false, false];
    this._maxSize = maxSize;
    this._batchSize = batchSize;
    this._buffers = null;
    this._bufferUpdateIDs = [];
    this._updateID = 0;
    this.interactiveChildren = false;
    this.blendMode = core.BLEND_MODES.NORMAL;
    this.autoResize = autoResize;
    this.roundPixels = true;
    this.baseTexture = null;
    this.setProperties(properties);
    this._tintColor = new core.Color(0);
    this.tintRgb = new Float32Array(3);
    this.tint = 16777215;
  }
  setProperties(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  }
  updateTransform() {
    this.displayObjectUpdateTransform();
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintColor.toRgbArray(this.tintRgb);
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", () => this.onChildrenChange(0));
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  }
  onChildrenChange(smallestChildIndex) {
    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  }
  dispose() {
    if (this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  }
  destroy(options) {
    super.destroy(options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  }
}

exports.ParticleContainer = ParticleContainer;
//# sourceMappingURL=ParticleContainer.js.map


/***/ }),

/***/ 36851:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var ParticleBuffer = __webpack_require__(63930);
var particles$1 = __webpack_require__(20383);
var particles = __webpack_require__(67337);

class ParticleRenderer extends core.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.shader = null;
    this.properties = null;
    this.tempMatrix = new core.Matrix();
    this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: core.TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ];
    this.shader = core.Shader.from(particles["default"], particles$1["default"], {});
    this.state = core.State.for2d();
  }
  render(container) {
    const children = container.children;
    const maxSize = container._maxSize;
    const batchSize = container._batchSize;
    const renderer = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    let buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    const baseTexture = children[0]._texture.baseTexture;
    const premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = core.utils.correctBlendMode(container.blendMode, premultiplied);
    renderer.state.set(this.state);
    const gl = renderer.gl;
    const m = container.worldTransform.copyTo(this.tempMatrix);
    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m.toArray(true);
    this.shader.uniforms.uColor = core.Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
      let amount = totalChildren - i;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      const buffer = buffers[j];
      buffer.uploadDynamic(children, i, amount);
      const bid = container._bufferUpdateIDs[j] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i, amount);
      }
      renderer.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  generateBuffers(container) {
    const buffers = [];
    const size = container._maxSize;
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    for (let i = 0; i < size; i += batchSize) {
      buffers.push(new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  }
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    return new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  uploadVertices(children, startIndex, amount, array, stride, offset) {
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const texture = sprite._texture;
      const sx = sprite.scale.x;
      const sy = sprite.scale.y;
      const trim = texture.trim;
      const orig = texture.orig;
      if (trim) {
        w1 = trim.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  }
  uploadPosition(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  }
  uploadRotation(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  }
  uploadUvs(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const textureUvs = children[startIndex + i]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  }
  uploadTint(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const result = core.Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
      array[offset] = result;
      array[offset + stride] = result;
      array[offset + stride * 2] = result;
      array[offset + stride * 3] = result;
      offset += stride * 4;
    }
  }
  destroy() {
    super.destroy();
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: core.ExtensionType.RendererPlugin
};
core.extensions.add(ParticleRenderer);

exports.ParticleRenderer = ParticleRenderer;
//# sourceMappingURL=ParticleRenderer.js.map


/***/ }),

/***/ 868:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var ParticleContainer = __webpack_require__(16945);
var ParticleRenderer = __webpack_require__(36851);



exports.ParticleContainer = ParticleContainer.ParticleContainer;
exports.ParticleRenderer = ParticleRenderer.ParticleRenderer;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 20383:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";

exports["default"] = fragment;
//# sourceMappingURL=particles.js.map


/***/ }),

/***/ 67337:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";

exports["default"] = vertex;
//# sourceMappingURL=particles2.js.map


/***/ }),

/***/ 39655:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var text = __webpack_require__(74083);
var CountLimiter = __webpack_require__(95970);

function findMultipleBaseTextures(item, queue) {
  let result = false;
  if (item?._textures?.length) {
    for (let i = 0; i < item._textures.length; i++) {
      if (item._textures[i] instanceof core.Texture) {
        const baseTexture = item._textures[i].baseTexture;
        if (!queue.includes(baseTexture)) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof core.BaseTexture) {
    const texture = item.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof core.Texture) {
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof text.Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof text.TextStyle) {
    const font = item.toFontString();
    text.TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof text.Text) {
    if (!queue.includes(item.style)) {
      queue.push(item.style);
    }
    if (!queue.includes(item)) {
      queue.push(item);
    }
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof text.TextStyle) {
    if (!queue.includes(item)) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
const _BasePrepare = class {
  constructor(renderer) {
    this.limiter = new CountLimiter.CountLimiter(_BasePrepare.uploadsPerFrame);
    this.renderer = renderer;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = () => {
      if (!this.queue) {
        return;
      }
      this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  upload(item) {
    return new Promise((resolve) => {
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        this.completes.push(resolve);
        if (!this.ticking) {
          this.ticking = true;
          core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
        }
      } else {
        resolve();
      }
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
          if (this.uploadHooks[i](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i = 0, len = completes.length; i < len; i++) {
        completes[i]();
      }
    } else {
      core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
    }
  }
  registerFindHook(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  }
  registerUploadHook(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  }
  add(item) {
    for (let i = 0, len = this.addHooks.length; i < len; i++) {
      if (this.addHooks[i](item, this.queue)) {
        break;
      }
    }
    if (item instanceof display.Container) {
      for (let i = item.children.length - 1; i >= 0; i--) {
        this.add(item.children[i]);
      }
    }
    return this;
  }
  destroy() {
    if (this.ticking) {
      core.Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  }
};
let BasePrepare = _BasePrepare;
BasePrepare.uploadsPerFrame = 4;

exports.BasePrepare = BasePrepare;
//# sourceMappingURL=BasePrepare.js.map


/***/ }),

/***/ 95970:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class CountLimiter {
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}

exports.CountLimiter = CountLimiter;
//# sourceMappingURL=CountLimiter.js.map


/***/ }),

/***/ 97228:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var graphics = __webpack_require__(47997);
var BasePrepare = __webpack_require__(39655);

function uploadBaseTextures(renderer, item) {
  if (item instanceof core.BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof graphics.Graphics)) {
    return false;
  }
  const { geometry } = item;
  item.finishPoly();
  geometry.updateBatches();
  const { batches } = geometry;
  for (let i = 0; i < batches.length; i++) {
    const { texture } = batches[i].style;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof graphics.Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
class Prepare extends BasePrepare.BasePrepare {
  constructor(renderer) {
    super(renderer);
    this.uploadHookHelper = this.renderer;
    this.registerFindHook(findGraphics);
    this.registerUploadHook(uploadBaseTextures);
    this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: core.ExtensionType.RendererSystem
};
core.extensions.add(Prepare);

exports.Prepare = Prepare;
//# sourceMappingURL=Prepare.js.map


/***/ }),

/***/ 41696:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class TimeLimiter {
  constructor(maxMilliseconds) {
    this.maxMilliseconds = maxMilliseconds;
    this.frameStart = 0;
  }
  beginFrame() {
    this.frameStart = Date.now();
  }
  allowedToUpload() {
    return Date.now() - this.frameStart < this.maxMilliseconds;
  }
}

exports.TimeLimiter = TimeLimiter;
//# sourceMappingURL=TimeLimiter.js.map


/***/ }),

/***/ 29911:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(40738);
var BasePrepare = __webpack_require__(39655);
var CountLimiter = __webpack_require__(95970);
var Prepare = __webpack_require__(97228);
var TimeLimiter = __webpack_require__(41696);



exports.BasePrepare = BasePrepare.BasePrepare;
exports.CountLimiter = CountLimiter.CountLimiter;
exports.Prepare = Prepare.Prepare;
exports.TimeLimiter = TimeLimiter.TimeLimiter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 40738:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var BasePrepare = __webpack_require__(39655);

Object.defineProperties(core.settings, {
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.BasePrepare.uploadsPerFrame;
    },
    set(value) {
      core.utils.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
      BasePrepare.BasePrepare.uploadsPerFrame = value;
    }
  }
});

Object.defineProperty(exports, "settings", ({
    enumerable: true,
    get: function () { return core.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ 80122:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class Runner {
  constructor(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    const { name, items } = this;
    this._aliasCount++;
    for (let i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  }
  ensureNonAliasedItems() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  }
  add(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.includes(item);
  }
  removeAll() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});

exports.Runner = Runner;
//# sourceMappingURL=Runner.js.map


/***/ }),

/***/ 69866:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Runner = __webpack_require__(80122);



exports.Runner = Runner.Runner;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 74330:
/***/ (() => {

"use strict";


//# sourceMappingURL=ICanvas.js.map


/***/ }),

/***/ 93423:
/***/ (() => {

"use strict";


//# sourceMappingURL=ICanvasRenderingContext2D.js.map


/***/ }),

/***/ 71542:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};

exports.BrowserAdapter = BrowserAdapter;
//# sourceMappingURL=adapter.js.map


/***/ }),

/***/ 1405:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var adapter = __webpack_require__(71542);
__webpack_require__(74330);
__webpack_require__(93423);
var settings = __webpack_require__(59040);
var isMobile = __webpack_require__(10977);



exports.BrowserAdapter = adapter.BrowserAdapter;
exports.settings = settings.settings;
exports.isMobile = isMobile.isMobile;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 59040:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var adapter = __webpack_require__(71542);

const settings = {
  ADAPTER: adapter.BrowserAdapter,
  RESOLUTION: 1,
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};

exports.settings = settings;
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ 10977:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var isMobileJs = __webpack_require__(22437);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isMobileJs__default = /*#__PURE__*/_interopDefaultLegacy(isMobileJs);

const isMobileCall = isMobileJs__default["default"].default ?? isMobileJs__default["default"];
const isMobile = isMobileCall(globalThis.navigator);

exports.isMobile = isMobile;
//# sourceMappingURL=isMobile.js.map


/***/ }),

/***/ 59773:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var sprite = __webpack_require__(64441);

class AnimatedSprite extends sprite.Sprite {
  constructor(textures, autoUpdate = true) {
    super(textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = 1;
    this.loop = true;
    this.updateAnchor = false;
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      core.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      core.Ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  update(deltaTime) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign;
        this._currentTime += sign;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  }
  updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  destroy(options) {
    this.stop();
    super.destroy(options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  static fromFrames(frames) {
    const textures = [];
    for (let i = 0; i < frames.length; ++i) {
      textures.push(core.Texture.from(frames[i]));
    }
    return new AnimatedSprite(textures);
  }
  static fromImages(images) {
    const textures = [];
    for (let i = 0; i < images.length; ++i) {
      textures.push(core.Texture.from(images[i]));
    }
    return new AnimatedSprite(textures);
  }
  get totalFrames() {
    return this._textures.length;
  }
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof core.Texture) {
      this._textures = value;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i = 0; i < value.length; i++) {
        this._textures.push(value[i].texture);
        this._durations.push(value[i].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this.updateTexture();
  }
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  }
  get playing() {
    return this._playing;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        core.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        core.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}

exports.AnimatedSprite = AnimatedSprite;
//# sourceMappingURL=AnimatedSprite.js.map


/***/ }),

/***/ 78509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var AnimatedSprite = __webpack_require__(59773);



exports.AnimatedSprite = AnimatedSprite.AnimatedSprite;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 15237:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var sprite = __webpack_require__(64441);

const tempPoint = new core.Point();
class TilingSprite extends sprite.Sprite {
  constructor(texture, width = 100, height = 100) {
    super(texture);
    this.tileTransform = new core.Transform();
    this._width = width;
    this._height = height;
    this.uvMatrix = this.texture.uvMatrix || new core.TextureMatrix(texture);
    this.pluginName = "tilingSprite";
    this.uvRespectAnchor = false;
  }
  get clampMargin() {
    return this.uvMatrix.clampMargin;
  }
  set clampMargin(value) {
    this.uvMatrix.clampMargin = value;
    this.uvMatrix.update(true);
  }
  get tileScale() {
    return this.tileTransform.scale;
  }
  set tileScale(value) {
    this.tileTransform.scale.copyFrom(value);
  }
  get tilePosition() {
    return this.tileTransform.position;
  }
  set tilePosition(value) {
    this.tileTransform.position.copyFrom(value);
  }
  _onTextureUpdate() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  }
  _render(renderer) {
    const texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const minX = this._width * -this._anchor._x;
    const minY = this._height * -this._anchor._y;
    const maxX = this._width * (1 - this._anchor._x);
    const maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new core.Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._width;
    const height = this._height;
    const x1 = -width * this.anchor._x;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      const y1 = -height * this.anchor._y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this.tileTransform = null;
    this.uvMatrix = null;
  }
  static from(source, options) {
    const texture = source instanceof core.Texture ? source : core.Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
}

exports.TilingSprite = TilingSprite;
//# sourceMappingURL=TilingSprite.js.map


/***/ }),

/***/ 87170:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var spriteTiling$1 = __webpack_require__(27540);
var spriteTiling = __webpack_require__(88692);
var spriteTilingFallback$1 = __webpack_require__(83395);
var spriteTilingFallback = __webpack_require__(18693);
var spriteTilingSimple = __webpack_require__(4947);

const tempMat = new core.Matrix();
class TilingSpriteRenderer extends core.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    renderer.runners.contextChange.add(this);
    this.quad = new core.QuadUv();
    this.state = core.State.for2d();
  }
  contextChange() {
    const renderer = this.renderer;
    const uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = core.Shader.from(spriteTilingFallback["default"], spriteTilingSimple["default"], uniforms);
    this.shader = renderer.context.webGLVersion > 1 ? core.Shader.from(spriteTiling["default"], spriteTiling$1["default"], uniforms) : core.Shader.from(spriteTilingFallback["default"], spriteTilingFallback$1["default"], uniforms);
  }
  render(ts) {
    const renderer = this.renderer;
    const quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    const tex = ts._texture;
    const baseTex = tex.baseTexture;
    const premultiplied = baseTex.alphaMode > 0;
    const lt = ts.tileTransform.localTransform;
    const uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
        if (baseTex.wrapMode === core.WRAP_MODES.CLAMP) {
          baseTex.wrapMode = core.WRAP_MODES.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== core.WRAP_MODES.CLAMP;
      }
    }
    const shader = isSimple ? this.simpleShader : this.shader;
    const w = tex.width;
    const h = tex.height;
    const W = ts._width;
    const H = ts._height;
    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = core.Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer.shader.bind(shader);
    renderer.geometry.bind(quad);
    this.state.blendMode = core.utils.correctBlendMode(ts.blendMode, premultiplied);
    renderer.state.set(this.state);
    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: core.ExtensionType.RendererPlugin
};
core.extensions.add(TilingSpriteRenderer);

exports.TilingSpriteRenderer = TilingSpriteRenderer;
//# sourceMappingURL=TilingSpriteRenderer.js.map


/***/ }),

/***/ 13903:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var TilingSprite = __webpack_require__(15237);
var TilingSpriteRenderer = __webpack_require__(87170);



exports.TilingSprite = TilingSprite.TilingSprite;
exports.TilingSpriteRenderer = TilingSpriteRenderer.TilingSpriteRenderer;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 83395:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";

exports["default"] = gl1FragmentSrc;
//# sourceMappingURL=sprite-tiling-fallback.js.map


/***/ }),

/***/ 18693:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

exports["default"] = gl1VertexSrc;
//# sourceMappingURL=sprite-tiling-fallback2.js.map


/***/ }),

/***/ 4947:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";

exports["default"] = fragmentSimpleSrc;
//# sourceMappingURL=sprite-tiling-simple.js.map


/***/ }),

/***/ 27540:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";

exports["default"] = gl2FragmentSrc;
//# sourceMappingURL=sprite-tiling.js.map


/***/ }),

/***/ 88692:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";

exports["default"] = gl2VertexSrc;
//# sourceMappingURL=sprite-tiling2.js.map


/***/ }),

/***/ 28224:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);

const tempPoint = new core.Point();
const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends display.Container {
  constructor(texture) {
    super();
    this._anchor = new core.ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    this._texture = null;
    this._width = 0;
    this._height = 0;
    this._tintColor = new core.Color(16777215);
    this._tintRGB = null;
    this.tint = 16777215;
    this.blendMode = core.BLEND_MODES.NORMAL;
    this._cachedTint = 16777215;
    this.uvs = null;
    this.texture = texture || core.Texture.EMPTY;
    this.vertexData = new Float32Array(8);
    this.vertexTrimmedData = null;
    this._transformID = -1;
    this._textureID = -1;
    this._transformTrimmedID = -1;
    this._textureTrimmedID = -1;
    this.indices = indices;
    this.pluginName = "batch";
    this.isSprite = true;
    this._roundPixels = core.settings.ROUND_PIXELS;
  }
  _onTextureUpdate() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = core.utils.sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = core.utils.sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  }
  _onAnchorUpdate() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  }
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    const trim = texture.trim;
    const orig = texture.orig;
    const anchor = this._anchor;
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    if (trim) {
      w1 = trim.x - anchor._x * orig.width;
      w0 = w1 + trim.width;
      h1 = trim.y - anchor._y * orig.height;
      h0 = h1 + trim.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
    if (this._roundPixels) {
      const resolution = core.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture;
    const vertexData = this.vertexTrimmedData;
    const orig = texture.orig;
    const anchor = this._anchor;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const w1 = -anchor._x * orig.width;
    const w0 = w1 + orig.width;
    const h1 = -anchor._y * orig.height;
    const h0 = h1 + orig.height;
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
  }
  _render(renderer) {
    this.calculateVertices();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const trim = this._texture.trim;
    const orig = this._texture.orig;
    if (!trim || trim.width === orig.width && trim.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new display.Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new core.Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._texture.orig.width;
    const height = this._texture.orig.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  static from(source, options) {
    const texture = source instanceof core.Texture ? source : core.Texture.from(source, options);
    return new Sprite(texture);
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate, this);
    }
    this._texture = value || core.Texture.EMPTY;
    this._cachedTint = 16777215;
    this._textureID = -1;
    this._textureTrimmedID = -1;
    if (value) {
      if (value.baseTexture.valid) {
        this._onTextureUpdate();
      } else {
        value.once("update", this._onTextureUpdate, this);
      }
    }
  }
}

exports.Sprite = Sprite;
//# sourceMappingURL=Sprite.js.map


/***/ }),

/***/ 64441:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Sprite = __webpack_require__(28224);



exports.Sprite = Sprite.Sprite;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 93108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const _Spritesheet = class {
  constructor(texture, data, resolutionFilename = null) {
    this.linkedSheets = [];
    this._texture = texture instanceof core.Texture ? texture : null;
    this.baseTexture = texture instanceof core.BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = core.utils.getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = parseFloat(scale ?? "1");
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  }
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i = this._frameKeys[frameIndex];
      const data = this._frames[i];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new core.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new core.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i] = new core.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);
        core.Texture.addToCache(this.textures[i], i);
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i = 0; i < animations[animName].length; i++) {
        const frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    for (const i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  }
};
let Spritesheet = _Spritesheet;
Spritesheet.BATCH_SIZE = 1e3;

exports.Spritesheet = Spritesheet;
//# sourceMappingURL=Spritesheet.js.map


/***/ }),

/***/ 34216:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Spritesheet = __webpack_require__(93108);
var spritesheetAsset = __webpack_require__(84146);



exports.Spritesheet = Spritesheet.Spritesheet;
exports.spritesheetAsset = spritesheetAsset.spritesheetAsset;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 84146:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(13369);
var core = __webpack_require__(11491);
var Spritesheet = __webpack_require__(93108);

const validImages = ["jpg", "png", "jpeg", "avif", "webp"];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = core.utils.path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: core.ExtensionType.Asset,
  cache: {
    test: (asset) => asset instanceof Spritesheet.Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  resolver: {
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: core.ExtensionType.LoadParser,
      priority: assets.LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return core.utils.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      let basePath = core.utils.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let imagePath = basePath + asset.meta.image;
      imagePath = assets.copySearchParams(imagePath, options.src);
      const assets$1 = await loader.load([imagePath]);
      const texture = assets$1[imagePath];
      const spritesheet = new Spritesheet.Spritesheet(texture.baseTexture, asset, options.src);
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if (options.data?.ignoreMultiPack) {
            continue;
          }
          itemUrl = assets.copySearchParams(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
core.extensions.add(spritesheetAsset);

exports.spritesheetAsset = spritesheetAsset;
//# sourceMappingURL=spritesheetAsset.js.map


/***/ }),

/***/ 45039:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var text = __webpack_require__(74083);
var BitmapFontData = __webpack_require__(35799);
var index = __webpack_require__(58590);
__webpack_require__(8119);
var resolveCharacters = __webpack_require__(26787);
var drawGlyph = __webpack_require__(4571);
var extractCharCode = __webpack_require__(16227);

const _BitmapFont = class {
  constructor(data, textures, ownsTextures) {
    const [info] = data.info;
    const [common] = data.common;
    const [page] = data.page;
    const [distanceField] = data.distanceField;
    const res = core.utils.getResolutionOfUrl(page.file);
    const pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (let i = 0; i < data.page.length; i++) {
      const { id, file } = data.page[i];
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
      if (distanceField?.fieldType && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = core.MIPMAP_MODES.OFF;
      }
    }
    for (let i = 0; i < data.char.length; i++) {
      const { id, page: page2 } = data.char[i];
      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];
      x /= res;
      y /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      const rect = new core.Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new core.Texture(pageTextures[page2].baseTexture, rect),
        page: page2
      };
    }
    for (let i = 0; i < data.kerning.length; i++) {
      let { first, second, amount } = data.kerning[i];
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField?.distanceRange;
    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
  }
  destroy() {
    for (const id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (const id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  }
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData.BitmapFontData) {
      fontData = data;
    } else {
      const format = index.autoDetectFormat(data);
      if (!format) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format.parse(data);
    }
    if (textures instanceof core.Texture) {
      textures = [textures];
    }
    const font = new _BitmapFont(fontData, textures, ownsTextures);
    _BitmapFont.available[font.font] = font;
    return font;
  }
  static uninstall(name) {
    const font = _BitmapFont.available[name];
    if (!font) {
      throw new Error(`No font found named '${name}'`);
    }
    font.destroy();
    delete _BitmapFont.available[name];
  }
  static from(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont.defaultOptions, options);
    const charsList = resolveCharacters.resolveCharacters(chars);
    const style = textStyle instanceof text.TextStyle ? textStyle : new text.TextStyle(textStyle);
    const lineWidth = textureWidth;
    const fontData = new BitmapFontData.BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0;
    let positionY = 0;
    let canvas;
    let context;
    let baseTexture;
    let maxCharHeight = 0;
    const baseTextures = [];
    const textures = [];
    for (let i = 0; i < charsList.length; i++) {
      if (!canvas) {
        canvas = core.settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context = canvas.getContext("2d");
        baseTexture = new core.BaseTexture(canvas, { resolution, ...baseOptions });
        baseTextures.push(baseTexture);
        textures.push(new core.Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      const character = charsList[i];
      const metrics = text.TextMetrics.measureText(character, style, false, canvas);
      const width = metrics.width;
      const height = Math.ceil(metrics.height);
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        canvas = null;
        context = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph.drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);
      const id = extractCharCode.extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (let i = 0, len = charsList.length; i < len; i++) {
      const first = charsList[i];
      for (let j = 0; j < len; j++) {
        const second = charsList[j];
        const c1 = context.measureText(first).width;
        const c2 = context.measureText(second).width;
        const total = context.measureText(first + second).width;
        const amount = total - (c1 + c2);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode.extractCharCode(first),
            second: extractCharCode.extractCharCode(second),
            amount
          });
        }
      }
    }
    const font = new _BitmapFont(fontData, textures, true);
    if (_BitmapFont.available[name] !== void 0) {
      _BitmapFont.uninstall(name);
    }
    _BitmapFont.available[name] = font;
    return font;
  }
};
let BitmapFont = _BitmapFont;
BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
BitmapFont.NUMERIC = [["0", "9"]];
BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
BitmapFont.ASCII = [[" ", "~"]];
BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
};
BitmapFont.available = {};

exports.BitmapFont = BitmapFont;
//# sourceMappingURL=BitmapFont.js.map


/***/ }),

/***/ 35799:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class BitmapFontData {
  constructor() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
}

exports.BitmapFontData = BitmapFontData;
//# sourceMappingURL=BitmapFontData.js.map


/***/ }),

/***/ 99409:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var mesh = __webpack_require__(57309);
var BitmapFont = __webpack_require__(45039);
var msdf$1 = __webpack_require__(33741);
var msdf = __webpack_require__(97503);
__webpack_require__(8119);
var splitTextToCharacters = __webpack_require__(95465);
var extractCharCode = __webpack_require__(16227);

const pageMeshDataDefaultPageMeshData = [];
const pageMeshDataMSDFPageMeshData = [];
const charRenderDataPool = [];
const _BitmapText = class extends display.Container {
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
    if (!BitmapFont.BitmapFont.available[fontName]) {
      throw new Error(`Missing BitmapFont "${fontName}"`);
    }
    this._activePagesMeshData = [];
    this._textWidth = 0;
    this._textHeight = 0;
    this._align = align;
    this._tintColor = new core.Color(tint);
    this._font = void 0;
    this._fontName = fontName;
    this._fontSize = fontSize;
    this.text = text;
    this._maxWidth = maxWidth;
    this._maxLineHeight = 0;
    this._letterSpacing = letterSpacing;
    this._anchor = new core.ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0);
    this._roundPixels = core.settings.ROUND_PIXELS;
    this.dirty = true;
    this._resolution = core.settings.RESOLUTION;
    this._autoResolution = true;
    this._textureCache = {};
  }
  updateText() {
    const data = BitmapFont.BitmapFont.available[this._fontName];
    const fontSize = this.fontSize;
    const scale = fontSize / data.size;
    const pos = new core.Point();
    const chars = [];
    const lineWidths = [];
    const lineSpaces = [];
    const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    const charsInput = splitTextToCharacters.splitTextToCharacters(text);
    const maxWidth = this._maxWidth * data.size / fontSize;
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    let line = 0;
    let lastBreakPos = -1;
    let lastBreakWidth = 0;
    let spacesRemoved = 0;
    let maxLineHeight = 0;
    let spaceCount = 0;
    for (let i = 0; i < charsInput.length; i++) {
      const char = charsInput[i];
      const charCode = extractCharCode.extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      const charRenderData = charRenderDataPool.pop() || {
        texture: core.Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new core.Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
      charRenderData.position.y = Math.round(pos.y + charData.yOffset);
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    const lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    const lineAlignOffsets = [];
    for (let i = 0; i <= line; i++) {
      let alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length;
    const pagesMeshData = {};
    const newPagesMeshData = [];
    const activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i = 0; i < lenChars; i++) {
      const texture = chars[i].texture;
      const baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new mesh.MeshGeometry();
          let material;
          let meshBlendMode;
          if (data.distanceFieldType === "none") {
            material = new mesh.MeshMaterial(core.Texture.EMPTY);
            meshBlendMode = core.BLEND_MODES.NORMAL;
          } else {
            material = new mesh.MeshMaterial(core.Texture.EMPTY, { program: core.Program.from(msdf["default"], msdf$1["default"]), uniforms: { uFWidth: 0 } });
            meshBlendMode = core.BLEND_MODES.NORMAL_NPM;
          }
          const mesh$1 = new mesh.Mesh(geometry, material);
          mesh$1.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: mesh$1,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new core.Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tintColor.value;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i = 0; i < activePagesMeshData.length; i++) {
      if (!newPagesMeshData.includes(activePagesMeshData[i])) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (let i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      const total = pageMeshData.total;
      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < mesh.Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        const total2 = pageMeshData.total;
        const vertices = pageMeshData.vertices;
        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {
          vertices[i2] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i = 0; i < lenChars; i++) {
      const char = chars[i];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      const xPos = offset * scale;
      const yPos = char.position.y * scale;
      const texture = char.texture;
      const pageMesh = pagesMeshData[texture.baseTexture.uid];
      const textureFrame = texture.frame;
      const textureUvs = texture._uvs;
      const index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x;
        const anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i2 = 0; i2 < pageMeshData.total; i2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      const indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (let i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
    this._font = data;
    this.dirty = false;
  }
  updateTransform() {
    this.validate();
    this.containerUpdateTransform();
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a, b, c, d } = this.worldTransform;
      const dx = Math.sqrt(a * a + b * b);
      const dy = Math.sqrt(c * c + d * d);
      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      const fontScale = this.fontSize / size;
      const resolution = renderer._view.resolution;
      for (const mesh of this._activePagesMeshData) {
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
      }
    }
    super._render(renderer);
  }
  getLocalBounds() {
    this.validate();
    return super.getLocalBounds();
  }
  validate() {
    const font = BitmapFont.BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint === value)
      return;
    this._tintColor.setValue(value);
    for (let i = 0; i < this._activePagesMeshData.length; i++) {
      this._activePagesMeshData[i].mesh.tint = value;
    }
  }
  get align() {
    return this._align;
  }
  set align(value) {
    if (this._align !== value) {
      this._align = value;
      this.dirty = true;
    }
  }
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!BitmapFont.BitmapFont.available[value]) {
      throw new Error(`Missing BitmapFont "${value}"`);
    }
    if (this._fontName !== value) {
      this._fontName = value;
      this.dirty = true;
    }
  }
  get fontSize() {
    return this._fontSize ?? BitmapFont.BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    if (this._fontSize !== value) {
      this._fontSize = value;
      this.dirty = true;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    if (typeof value === "number") {
      this._anchor.set(value);
    } else {
      this._anchor.copyFrom(value);
    }
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    if (this._maxWidth === value) {
      return;
    }
    this._maxWidth = value;
    this.dirty = true;
  }
  get maxLineHeight() {
    this.validate();
    return this._maxLineHeight;
  }
  get textWidth() {
    this.validate();
    return this._textWidth;
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    if (this._letterSpacing !== value) {
      this._letterSpacing = value;
      this.dirty = true;
    }
  }
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    if (value !== this._roundPixels) {
      this._roundPixels = value;
      this.dirty = true;
    }
  }
  get textHeight() {
    this.validate();
    return this._textHeight;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  destroy(options) {
    const { _textureCache } = this;
    const data = BitmapFont.BitmapFont.available[this._fontName];
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData) {
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = core.Texture.EMPTY;
    });
    for (const id in _textureCache) {
      const texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._tintColor = null;
    this._textureCache = null;
    super.destroy(options);
  }
};
let BitmapText = _BitmapText;
BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};

exports.BitmapText = BitmapText;
//# sourceMappingURL=BitmapText.js.map


/***/ }),

/***/ 94448:
/***/ (() => {

"use strict";


//# sourceMappingURL=BitmapTextStyle.js.map


/***/ }),

/***/ 22816:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BitmapFontData = __webpack_require__(35799);

class TextFormat {
  static test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  }
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i in items) {
      const name = items[i].match(/^[a-z]+/gm)[0];
      const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i2 in attributeList) {
        const split = attributeList[i2].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    const font = new BitmapFontData.BitmapFontData();
    rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    }));
    rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    }));
    rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    }));
    rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    }));
    rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    }));
    rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    }));
    return font;
  }
}

exports.TextFormat = TextFormat;
//# sourceMappingURL=TextFormat.js.map


/***/ }),

/***/ 27516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BitmapFontData = __webpack_require__(35799);

class XMLFormat {
  static test(data) {
    const xml = data;
    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  static parse(xml) {
    const data = new BitmapFontData.BitmapFontData();
    const info = xml.getElementsByTagName("info");
    const common = xml.getElementsByTagName("common");
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    const distanceField = xml.getElementsByTagName("distanceField");
    for (let i = 0; i < info.length; i++) {
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    }
    for (let i = 0; i < common.length; i++) {
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    }
    for (let i = 0; i < page.length; i++) {
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    for (let i = 0; i < char.length; i++) {
      const letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i = 0; i < kerning.length; i++) {
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    }
    for (let i = 0; i < distanceField.length; i++) {
      data.distanceField.push({
        fieldType: distanceField[i].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  }
}

exports.XMLFormat = XMLFormat;
//# sourceMappingURL=XMLFormat.js.map


/***/ }),

/***/ 61077:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var XMLFormat = __webpack_require__(27516);

class XMLStringFormat {
  static test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return XMLFormat.XMLFormat.test(core.settings.ADAPTER.parseXML(data));
    }
    return false;
  }
  static parse(xmlTxt) {
    return XMLFormat.XMLFormat.parse(core.settings.ADAPTER.parseXML(xmlTxt));
  }
}

exports.XMLStringFormat = XMLStringFormat;
//# sourceMappingURL=XMLStringFormat.js.map


/***/ }),

/***/ 58590:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var TextFormat = __webpack_require__(22816);
var XMLFormat = __webpack_require__(27516);
var XMLStringFormat = __webpack_require__(61077);

const formats = [
  TextFormat.TextFormat,
  XMLFormat.XMLFormat,
  XMLStringFormat.XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}

exports.TextFormat = TextFormat.TextFormat;
exports.XMLFormat = XMLFormat.XMLFormat;
exports.XMLStringFormat = XMLStringFormat.XMLStringFormat;
exports.autoDetectFormat = autoDetectFormat;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 93637:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BitmapFont = __webpack_require__(45039);
var BitmapFontData = __webpack_require__(35799);
var BitmapText = __webpack_require__(99409);
__webpack_require__(94448);
var index = __webpack_require__(58590);
var loadBitmapFont = __webpack_require__(11143);
var TextFormat = __webpack_require__(22816);
var XMLFormat = __webpack_require__(27516);
var XMLStringFormat = __webpack_require__(61077);



exports.BitmapFont = BitmapFont.BitmapFont;
exports.BitmapFontData = BitmapFontData.BitmapFontData;
exports.BitmapText = BitmapText.BitmapText;
exports.autoDetectFormat = index.autoDetectFormat;
exports.loadBitmapFont = loadBitmapFont.loadBitmapFont;
exports.TextFormat = TextFormat.TextFormat;
exports.XMLFormat = XMLFormat.XMLFormat;
exports.XMLStringFormat = XMLStringFormat.XMLStringFormat;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 11143:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var assets = __webpack_require__(13369);
var core = __webpack_require__(11491);
var BitmapFont = __webpack_require__(45039);
__webpack_require__(58590);
var TextFormat = __webpack_require__(22816);
var XMLStringFormat = __webpack_require__(61077);

const validExtensions = [".xml", ".fnt"];
const loadBitmapFont = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url) {
    return validExtensions.includes(core.utils.path.extname(url).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.TextFormat.test(data) || XMLStringFormat.XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = TextFormat.TextFormat.test(asset) ? TextFormat.TextFormat.parse(asset) : XMLStringFormat.XMLStringFormat.parse(asset);
    const { src } = data;
    const { page: pages } = fontData;
    const textureUrls = [];
    for (let i = 0; i < pages.length; ++i) {
      const pageFile = pages[i].file;
      let imagePath = core.utils.path.join(core.utils.path.dirname(src), pageFile);
      imagePath = assets.copySearchParams(imagePath, src);
      textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url) => loadedTextures[url]);
    return BitmapFont.BitmapFont.install(fontData, textures, true);
  },
  async load(url, _options) {
    const response = await core.settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
core.extensions.add(loadBitmapFont);

exports.loadBitmapFont = loadBitmapFont;
//# sourceMappingURL=loadBitmapFont.js.map


/***/ }),

/***/ 33741:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";

exports["default"] = msdfFrag;
//# sourceMappingURL=msdf.js.map


/***/ }),

/***/ 97503:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";

exports["default"] = msdfVert;
//# sourceMappingURL=msdf2.js.map


/***/ }),

/***/ 4571:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var generateFillStyle = __webpack_require__(12452);

function drawGlyph(canvas, context, metrics, x, y, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context.translate(x, y);
  context.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context.font = style.toFontString();
  context.lineWidth = style.strokeThickness;
  context.textBaseline = style.textBaseline;
  context.lineJoin = style.lineJoin;
  context.miterLimit = style.miterLimit;
  context.fillStyle = generateFillStyle.generateFillStyle(canvas, context, style, resolution, [char], metrics);
  context.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context.shadowColor = core.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context.shadowBlur = dropShadowBlur;
    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context.shadowColor = "black";
    context.shadowBlur = 0;
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "rgba(0, 0, 0, 0)";
}

exports.drawGlyph = drawGlyph;
//# sourceMappingURL=drawGlyph.js.map


/***/ }),

/***/ 16227:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}

exports.extractCharCode = extractCharCode;
//# sourceMappingURL=extractCharCode.js.map


/***/ }),

/***/ 12452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var text = __webpack_require__(74083);

function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === text.TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i = 0; i < lines.length; i++) {
      const thisLineTop = metrics.lineHeight * i;
      for (let j = 0; j < fill.length; j++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i = 0; i < fill.length; i++) {
      let stop;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}

exports.generateFillStyle = generateFillStyle;
//# sourceMappingURL=generateFillStyle.js.map


/***/ }),

/***/ 8119:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var drawGlyph = __webpack_require__(4571);
var extractCharCode = __webpack_require__(16227);
var generateFillStyle = __webpack_require__(12452);
var resolveCharacters = __webpack_require__(26787);
var splitTextToCharacters = __webpack_require__(95465);



exports.drawGlyph = drawGlyph.drawGlyph;
exports.extractCharCode = extractCharCode.extractCharCode;
exports.generateFillStyle = generateFillStyle.generateFillStyle;
exports.resolveCharacters = resolveCharacters.resolveCharacters;
exports.splitTextToCharacters = splitTextToCharacters.splitTextToCharacters;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 26787:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var splitTextToCharacters = __webpack_require__(95465);

function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i = 0, j = chars.length; i < j; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
        result.push(String.fromCharCode(i2));
      }
    } else {
      result.push(...splitTextToCharacters.splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}

exports.resolveCharacters = resolveCharacters;
//# sourceMappingURL=resolveCharacters.js.map


/***/ }),

/***/ 95465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}

exports.splitTextToCharacters = splitTextToCharacters;
//# sourceMappingURL=splitTextToCharacters.js.map


/***/ }),

/***/ 65493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var sprite = __webpack_require__(64441);
var text = __webpack_require__(74083);
var HTMLTextStyle = __webpack_require__(32116);

const _HTMLText = class extends sprite.Sprite {
  constructor(text = "", style = {}) {
    super(core.Texture.EMPTY);
    this._text = null;
    this._style = null;
    this._autoResolution = true;
    this._loading = false;
    this.localStyleID = -1;
    this.dirty = false;
    this.ownsStyle = false;
    const image = new Image();
    const texture = core.Texture.from(image, {
      scaleMode: core.settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture.orig = new core.Rectangle();
    texture.trim = new core.Rectangle();
    this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg";
    const nsxhtml = "http://www.w3.org/1999/xhtml";
    const svgRoot = document.createElementNS(nssvg, "svg");
    const foreignObject = document.createElementNS(nssvg, "foreignObject");
    const domElement = document.createElementNS(nsxhtml, "div");
    const styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    this.maxWidth = _HTMLText.defaultMaxWidth;
    this.maxHeight = _HTMLText.defaultMaxHeight;
    this._domElement = domElement;
    this._styleElement = styleElement;
    this._svgRoot = svgRoot;
    this._foreignObject = foreignObject;
    this._foreignObject.appendChild(styleElement);
    this._foreignObject.appendChild(domElement);
    this._image = image;
    this._loadImage = new Image();
    this._autoResolution = _HTMLText.defaultAutoResolution;
    this._resolution = _HTMLText.defaultResolution ?? core.settings.RESOLUTION;
    this.text = text;
    this.style = style;
  }
  measureText(overrides) {
    const { text, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text,
      style: style.toCSS(resolution)
    });
    this._styleElement.textContent = style.toGlobalCSS();
    document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));
    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));
    this._svgRoot.setAttribute("width", contentWidth.toString());
    this._svgRoot.setAttribute("height", contentHeight.toString());
    if (text !== this._text) {
      this._domElement.innerHTML = this._text;
    }
    if (style !== this._style) {
      Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });
      this._styleElement.textContent = this._style?.toGlobalCSS();
    }
    return {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width));
    image.height = loadImage.height = Math.ceil(Math.max(1, height));
    if (!this._loading) {
      this._loading = true;
      await new Promise((resolve) => {
        loadImage.onload = async () => {
          await style.onBeforeDraw();
          this._loading = false;
          image.src = loadImage.src;
          loadImage.onload = null;
          loadImage.src = "";
          this.updateTexture();
          resolve();
        };
        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
      });
    }
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style, texture, _image: image, resolution } = this;
    const { padding } = style;
    const { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution;
    texture.trim.height = texture._frame.height = image.height / resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(image.width, image.height, resolution);
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  _renderCanvas(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._renderCanvas(renderer);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _onStyleChange() {
    this.dirty = true;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);
    super.destroy(options);
    const forceClear = null;
    if (this.ownsStyle) {
      this._style?.cleanFonts();
    }
    this._style = forceClear;
    this._svgRoot?.remove();
    this._svgRoot = forceClear;
    this._domElement?.remove();
    this._domElement = forceClear;
    this._foreignObject?.remove();
    this._foreignObject = forceClear;
    this._styleElement?.remove();
    this._styleElement = forceClear;
    this._loadImage.src = "";
    this._loadImage.onload = null;
    this._loadImage = forceClear;
    this._image.src = "";
    this._image = forceClear;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._image.width / this.resolution;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._image.height / this.resolution;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    if (this._style === style) {
      return;
    }
    style = style || {};
    if (style instanceof HTMLTextStyle.HTMLTextStyle) {
      this.ownsStyle = false;
      this._style = style;
    } else if (style instanceof text.TextStyle) {
      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");
      this.ownsStyle = true;
      this._style = HTMLTextStyle.HTMLTextStyle.from(style);
    } else {
      this.ownsStyle = true;
      this._style = new HTMLTextStyle.HTMLTextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === "" || text === null || text === void 0 ? " " : text);
    text = this.sanitiseText(text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  sanitiseText(text) {
    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
let HTMLText = _HTMLText;
HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
HTMLText.defaultMaxWidth = 2024;
HTMLText.defaultMaxHeight = 2024;
HTMLText.defaultAutoResolution = true;

exports.HTMLText = HTMLText;
//# sourceMappingURL=HTMLText.js.map


/***/ }),

/***/ 32116:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var text = __webpack_require__(74083);

const _HTMLTextStyle = class extends text.TextStyle {
  constructor() {
    super(...arguments);
    this._fonts = [];
    this._overrides = [];
    this._stylesheet = "";
    this.fontsDirty = false;
  }
  static from(originalStyle) {
    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));
  }
  cleanFonts() {
    if (this._fonts.length > 0) {
      this._fonts.forEach((font) => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        if (font.refs === 0) {
          if (font.fontFace) {
            document.fonts.delete(font.fontFace);
          }
          delete _HTMLTextStyle.availableFonts[font.originalUrl];
        }
      });
      this.fontFamily = "Arial";
      this._fonts.length = 0;
      this.styleID++;
      this.fontsDirty = true;
    }
  }
  loadFont(url, options = {}) {
    const { availableFonts } = _HTMLTextStyle;
    if (availableFonts[url]) {
      const font = availableFonts[url];
      this._fonts.push(font);
      font.refs++;
      this.styleID++;
      this.fontsDirty = true;
      return Promise.resolve();
    }
    return core.settings.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {
      const src = URL.createObjectURL(blob);
      const reader = new FileReader();
      reader.onload = () => resolve([src, reader.result]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: core.utils.path.basename(url, core.utils.path.extname(url)),
        weight: "normal",
        style: "normal",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url,
        fontFace: null
      }, options);
      availableFonts[url] = font;
      this._fonts.push(font);
      this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style
      });
      font.fontFace = fontFace;
      await fontFace.load();
      document.fonts.add(fontFace);
      await document.fonts.ready;
      this.styleID++;
      this.fontsDirty = true;
    });
  }
  addOverride(...value) {
    const toAdd = value.filter((v) => !this._overrides.includes(v));
    if (toAdd.length > 0) {
      this._overrides.push(...toAdd);
      this.styleID++;
    }
  }
  removeOverride(...value) {
    const toRemove = value.filter((v) => this._overrides.includes(v));
    if (toRemove.length > 0) {
      this._overrides = this._overrides.filter((v) => !toRemove.includes(v));
      this.styleID++;
    }
  }
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style}; 
            }`, this._stylesheet);
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    if (this._stylesheet !== value) {
      this._stylesheet = value;
      this.styleID++;
    }
  }
  normalizeColor(color) {
    if (Array.isArray(color)) {
      color = core.utils.rgb2hex(color);
    }
    if (typeof color === "number") {
      return core.utils.hex2string(color);
    }
    return color;
  }
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha;
    const x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);
    const y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    if (color.startsWith("#") && alpha < 1) {
      color += (alpha * 255 | 0).toString(16).padStart(2, "0");
    }
    const position = `${x}px ${y}px`;
    if (this.dropShadowBlur > 0) {
      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  reset() {
    Object.assign(this, _HTMLTextStyle.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    this.fontsDirty = false;
    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {
      return new Promise((resolve) => setTimeout(resolve, 100));
    }
    return Promise.resolve();
  }
  get isSafari() {
    const { userAgent } = core.settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
let HTMLTextStyle = _HTMLTextStyle;
HTMLTextStyle.availableFonts = {};
HTMLTextStyle.defaultOptions = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  whiteSpace: "normal",
  wordWrap: false,
  wordWrapWidth: 100
};

exports.HTMLTextStyle = HTMLTextStyle;
//# sourceMappingURL=HTMLTextStyle.js.map


/***/ }),

/***/ 26191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var HTMLText = __webpack_require__(65493);
var HTMLTextStyle = __webpack_require__(32116);



exports.HTMLText = HTMLText.HTMLText;
exports.HTMLTextStyle = HTMLTextStyle.HTMLTextStyle;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 1804:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var sprite = __webpack_require__(64441);
var _const = __webpack_require__(97752);
var TextMetrics = __webpack_require__(91103);
var TextStyle = __webpack_require__(38335);

const defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
const _Text = class extends sprite.Sprite {
  constructor(text, style, canvas) {
    let ownCanvas = false;
    if (!canvas) {
      canvas = core.settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    const texture = core.Texture.from(canvas);
    texture.orig = new core.Rectangle();
    texture.trim = new core.Rectangle();
    super(texture);
    this._ownCanvas = ownCanvas;
    this.canvas = canvas;
    this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    this._resolution = _Text.defaultResolution ?? core.settings.RESOLUTION;
    this._autoResolution = _Text.defaultAutoResolution;
    this._text = null;
    this._style = null;
    this._styleListener = null;
    this._font = "";
    this.text = text;
    this.style = style;
    this.localStyleID = -1;
  }
  static get experimentalLetterSpacing() {
    return TextMetrics.TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    core.utils.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
    TextMetrics.TextMetrics.experimentalLetterSpacing = value;
  }
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    const context = this.context;
    const measured = TextMetrics.TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    const width = measured.width;
    const height = measured.height;
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context.scale(this._resolution, this._resolution);
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context.font = this._font;
    context.lineWidth = style.strokeThickness;
    context.textBaseline = style.textBaseline;
    context.lineJoin = style.lineJoin;
    context.miterLimit = style.miterLimit;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i = 0; i < passesCount; ++i) {
      const isShadowPass = style.dropShadow && i === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context.fillStyle = "black";
        context.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor;
        const dropShadowBlur = style.dropShadowBlur * this._resolution;
        const dropShadowDistance = style.dropShadowDistance * this._resolution;
        context.shadowColor = core.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
        context.shadowBlur = dropShadowBlur;
        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context.fillStyle = this._generateFillStyle(style, lines, measured);
        context.strokeStyle = style.stroke;
        context.shadowColor = "black";
        context.shadowBlur = 0;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (let i2 = 0; i2 < lines.length; i2++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i2];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  }
  drawLetterSpacing(text, x, y, isStroke = false) {
    const style = this._style;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (TextMetrics.TextMetrics.experimentalLetterSpacingSupported) {
      if (TextMetrics.TextMetrics.experimentalLetterSpacing) {
        this.context.letterSpacing = `${letterSpacing}px`;
        this.context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        this.context.letterSpacing = "0px";
        this.context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        this.context.strokeText(text, x, y);
      } else {
        this.context.fillText(text, x, y);
      }
      return;
    }
    let currentPosition = x;
    const stringArray = TextMetrics.TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width;
    let currentWidth = 0;
    for (let i = 0; i < stringArray.length; ++i) {
      const currentChar = stringArray[i];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y);
      } else {
        this.context.fillText(currentChar, currentPosition, y);
      }
      let textStr = "";
      for (let j = i + 1; j < stringArray.length; ++j) {
        textStr += stringArray[j];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = core.utils.trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    const texture = this._texture;
    const style = this._style;
    const padding = style.trim ? 0 : style.padding;
    const baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  updateTransform() {
    this.updateText(true);
    super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return super.getBounds(skipUpdate, rect);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds.call(this, rect);
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    const fill = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i = 0; i < lines.length; i++) {
        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
        const thisLineTop = metrics.lineHeight * i;
        let thisLineGradientStart = thisLineTop;
        if (i > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        const thisLineBottom = thisLineTop + textHeight;
        const nextLineTop = metrics.lineHeight * (i + 1);
        let thisLineGradientEnd = thisLineBottom;
        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j = 0; j < fill.length; j++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i = 0; i < fill.length; i++) {
        let stop;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    super.destroy(options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(true);
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    if (style instanceof TextStyle.TextStyle) {
      this._style = style;
    } else {
      this._style = new TextStyle.TextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
};
let Text = _Text;
Text.defaultAutoResolution = true;

exports.Text = Text;
//# sourceMappingURL=Text.js.map


/***/ }),

/***/ 91103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);

const contextSettings = {
  willReadFrequently: true
};
const _TextMetrics = class {
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = core.settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    const font = style.toFontString();
    const fontProperties = _TextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context = canvas.getContext("2d", contextSettings);
    context.font = font;
    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context);
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  }
  static _measureText(text, letterSpacing, context) {
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics.experimentalLetterSpacing) {
        context.letterSpacing = `${letterSpacing}px`;
        context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context.letterSpacing = "0px";
        context.textLetterSpacing = "0px";
      }
    }
    let width = context.measureText(text).width;
    if (width > 0) {
      if (useExperimentalLetterSpacing) {
        width -= letterSpacing;
      } else {
        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
      }
    }
    return width;
  }
  static wordWrap(text, style, canvas = _TextMetrics._canvas) {
    const context = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _TextMetrics.tokenize(text);
    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i];
      if (_TextMetrics.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (_TextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics.wordWrapSplit(token);
          for (let j = 0; j < characters.length; j++) {
            let char = characters[j];
            let lastChar = char;
            let k = 1;
            while (characters[j + k]) {
              const nextChar = characters[j + k];
              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k++;
            }
            j += k - 1;
            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context);
            if (characterWidth + width > wordWrapWidth) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i === tokens.length - 1;
          lines += _TextMetrics.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _TextMetrics.addLine(line, false);
    return lines;
  }
  static addLine(line, newLine = true) {
    line = _TextMetrics.trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static getFromCache(key, letterSpacing, cache, context) {
    let width = cache[key];
    if (typeof width !== "number") {
      width = _TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
      cache[key] = width;
    }
    return width;
  }
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i = text.length - 1; i >= 0; i--) {
      const char = text[i];
      if (!_TextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const nextChar = text[i + 1];
      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _TextMetrics.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_TextMetrics._fonts[font]) {
      return _TextMetrics._fonts[font];
    }
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    const canvas = _TextMetrics._canvas;
    const context = _TextMetrics._context;
    context.font = font;
    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
    const width = Math.ceil(context.measureText(metricsString).width);
    let baseline = Math.ceil(context.measureText(_TextMetrics.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
    if (width === 0 || height === 0) {
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(metricsString, 0, baseline);
    const imagedata = context.getImageData(0, 0, width, height).data;
    const pixels = imagedata.length;
    const line = width * 4;
    let i = 0;
    let idx = 0;
    let stop = false;
    for (i = 0; i < baseline; ++i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    _TextMetrics._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _TextMetrics._fonts[font];
    } else {
      _TextMetrics._fonts = {};
    }
  }
  static get _canvas() {
    if (!_TextMetrics.__canvas) {
      let canvas;
      try {
        const c = new OffscreenCanvas(0, 0);
        const context = c.getContext("2d", contextSettings);
        if (context?.measureText) {
          _TextMetrics.__canvas = c;
          return c;
        }
        canvas = core.settings.ADAPTER.createCanvas();
      } catch (ex) {
        canvas = core.settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10;
      _TextMetrics.__canvas = canvas;
    }
    return _TextMetrics.__canvas;
  }
  static get _context() {
    if (!_TextMetrics.__context) {
      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _TextMetrics.__context;
  }
};
let TextMetrics = _TextMetrics;
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter === "function") {
    const segmenter = new Intl.Segmenter();
    return (s) => [...segmenter.segment(s)].map((x) => x.segment);
  }
  return (s) => [...s];
})();
TextMetrics.experimentalLetterSpacing = false;
TextMetrics._fonts = {};
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];

exports.TextMetrics = TextMetrics;
//# sourceMappingURL=TextMetrics.js.map


/***/ }),

/***/ 38335:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(97752);
var core = __webpack_require__(11491);

const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
const _TextStyle = class {
  constructor(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  clone() {
    const clonedProperties = {};
    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
    return new _TextStyle(clonedProperties);
  }
  reset() {
    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
  }
  get align() {
    return this._align;
  }
  set align(align) {
    if (this._align !== align) {
      this._align = align;
      this.styleID++;
    }
  }
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    if (this._breakWords !== breakWords) {
      this._breakWords = breakWords;
      this.styleID++;
    }
  }
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    if (this._dropShadow !== dropShadow) {
      this._dropShadow = dropShadow;
      this.styleID++;
    }
  }
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    if (this._dropShadowAlpha !== dropShadowAlpha) {
      this._dropShadowAlpha = dropShadowAlpha;
      this.styleID++;
    }
  }
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    if (this._dropShadowAngle !== dropShadowAngle) {
      this._dropShadowAngle = dropShadowAngle;
      this.styleID++;
    }
  }
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    if (this._dropShadowBlur !== dropShadowBlur) {
      this._dropShadowBlur = dropShadowBlur;
      this.styleID++;
    }
  }
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    if (this._dropShadowColor !== outputColor) {
      this._dropShadowColor = outputColor;
      this.styleID++;
    }
  }
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    if (this._dropShadowDistance !== dropShadowDistance) {
      this._dropShadowDistance = dropShadowDistance;
      this.styleID++;
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(fill) {
    const outputColor = getColor(fill);
    if (this._fill !== outputColor) {
      this._fill = outputColor;
      this.styleID++;
    }
  }
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    if (this._fillGradientType !== fillGradientType) {
      this._fillGradientType = fillGradientType;
      this.styleID++;
    }
  }
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
      this._fillGradientStops = fillGradientStops;
      this.styleID++;
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    if (this.fontFamily !== fontFamily) {
      this._fontFamily = fontFamily;
      this.styleID++;
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    if (this._fontSize !== fontSize) {
      this._fontSize = fontSize;
      this.styleID++;
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    if (this._fontStyle !== fontStyle) {
      this._fontStyle = fontStyle;
      this.styleID++;
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    if (this._fontVariant !== fontVariant) {
      this._fontVariant = fontVariant;
      this.styleID++;
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    if (this._fontWeight !== fontWeight) {
      this._fontWeight = fontWeight;
      this.styleID++;
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    if (this._letterSpacing !== letterSpacing) {
      this._letterSpacing = letterSpacing;
      this.styleID++;
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    if (this._lineHeight !== lineHeight) {
      this._lineHeight = lineHeight;
      this.styleID++;
    }
  }
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    if (this._leading !== leading) {
      this._leading = leading;
      this.styleID++;
    }
  }
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    if (this._lineJoin !== lineJoin) {
      this._lineJoin = lineJoin;
      this.styleID++;
    }
  }
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    if (this._miterLimit !== miterLimit) {
      this._miterLimit = miterLimit;
      this.styleID++;
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    if (this._padding !== padding) {
      this._padding = padding;
      this.styleID++;
    }
  }
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    if (this._stroke !== outputColor) {
      this._stroke = outputColor;
      this.styleID++;
    }
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    if (this._strokeThickness !== strokeThickness) {
      this._strokeThickness = strokeThickness;
      this.styleID++;
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    if (this._textBaseline !== textBaseline) {
      this._textBaseline = textBaseline;
      this.styleID++;
    }
  }
  get trim() {
    return this._trim;
  }
  set trim(trim) {
    if (this._trim !== trim) {
      this._trim = trim;
      this.styleID++;
    }
  }
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    if (this._whiteSpace !== whiteSpace) {
      this._whiteSpace = whiteSpace;
      this.styleID++;
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    if (this._wordWrap !== wordWrap) {
      this._wordWrap = wordWrap;
      this.styleID++;
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    if (this._wordWrapWidth !== wordWrapWidth) {
      this._wordWrapWidth = wordWrapWidth;
      this.styleID++;
    }
  }
  toFontString() {
    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (let i = fontFamilies.length - 1; i >= 0; i--) {
      let fontFamily = fontFamilies[i].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
let TextStyle = _TextStyle;
TextStyle.defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};
function getColor(color) {
  const temp = core.Color.shared;
  if (!Array.isArray(color)) {
    return temp.setValue(color).toHex();
  } else {
    return color.map((c) => temp.setValue(c).toHex());
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}

exports.TextStyle = TextStyle;
//# sourceMappingURL=TextStyle.js.map


/***/ }),

/***/ 97752:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  return TEXT_GRADIENT2;
})(TEXT_GRADIENT || {});

exports.TEXT_GRADIENT = TEXT_GRADIENT;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ 74083:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(97752);
var Text = __webpack_require__(1804);
var TextMetrics = __webpack_require__(91103);
var TextStyle = __webpack_require__(38335);



exports.TEXT_GRADIENT = _const.TEXT_GRADIENT;
exports.Text = Text.Text;
exports.TextMetrics = TextMetrics.TextMetrics;
exports.TextStyle = TextStyle.TextStyle;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 56242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(65837);
var TickerListener = __webpack_require__(79830);

const _Ticker = class {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener.TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener.TickerListener(fn, context, priority));
  }
  addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener.TickerListener(fn, context, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
let Ticker = _Ticker;
Ticker.targetFPMS = 0.06;

exports.Ticker = Ticker;
//# sourceMappingURL=Ticker.js.map


/***/ }),

/***/ 79830:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class TickerListener {
  constructor(fn, context = null, priority = 0, once = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context;
    this.priority = priority;
    this.once = once;
  }
  match(fn, context = null) {
    return this.fn === fn && this.context === context;
  }
  emit(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    const redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}

exports.TickerListener = TickerListener;
//# sourceMappingURL=TickerListener.js.map


/***/ }),

/***/ 40905:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var extensions = __webpack_require__(9498);
var _const = __webpack_require__(65837);
var Ticker = __webpack_require__(56242);

class TickerPlugin {
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.Ticker.shared : new Ticker.Ticker();
    if (options.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = extensions.ExtensionType.Application;
extensions.extensions.add(TickerPlugin);

exports.TickerPlugin = TickerPlugin;
//# sourceMappingURL=TickerPlugin.js.map


/***/ }),

/***/ 65837:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});

exports.UPDATE_PRIORITY = UPDATE_PRIORITY;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ 47158:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(26621);
var _const = __webpack_require__(65837);
var Ticker = __webpack_require__(56242);
var TickerPlugin = __webpack_require__(40905);



exports.UPDATE_PRIORITY = _const.UPDATE_PRIORITY;
exports.Ticker = Ticker.Ticker;
exports.TickerPlugin = TickerPlugin.TickerPlugin;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 26621:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(1405);
var utils = __webpack_require__(61973);
var Ticker = __webpack_require__(56242);

Object.defineProperties(settings.settings, {
  TARGET_FPMS: {
    get() {
      return Ticker.Ticker.targetFPMS;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
      Ticker.Ticker.targetFPMS = value;
    }
  }
});

Object.defineProperty(exports, "settings", ({
    enumerable: true,
    get: function () { return settings.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ 25296:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);
var ButtonEvents = __webpack_require__(18993);
var tsMixer = __webpack_require__(6993);

class Button extends ButtonEvents.ButtonEvents {
  /**
   * Turns a given container-based view into a button by adding all button events.
   * @param {Container} view - instance of container, to be turned into button.
   */
  constructor(view) {
    super();
    if (view)
      this.init(view);
  }
  /**
   * Creates and connect interaction events.
   * @param {Container} view - instance of container, to be turned into button
   */
  init(view) {
    this.view = view;
    this.enabled = true;
  }
  /** Set button view, thar all the interaction events are applied to. */
  set view(view) {
    const wasItInitiated = !!this._view;
    if (wasItInitiated)
      this.disconnectEvents(view);
    this._view = view;
    this.connectEvents(view);
    if (!wasItInitiated)
      this.enabled = true;
  }
  /** Get button view, thar all the interaction events are applied to. */
  get view() {
    return this._view;
  }
  /**
   * Switcher, which prevents all button events from firing if off.
   * @param {boolean} enabled
   */
  set enabled(enabled) {
    if (!this.view) {
      console.error("Button view is not set. Please set it before enabling the button.");
      return;
    }
    this.view.eventMode = enabled ? "static" : "auto";
    this.view.cursor = enabled ? "pointer" : "default";
    if (!enabled && this.isDown) {
      this.processUp();
    }
  }
  /** Getter that returns button state. */
  get enabled() {
    return this.view.eventMode === "static";
  }
}
class ButtonContainer extends tsMixer.Mixin(display.Container, Button) {
  constructor(view) {
    super();
    if (view) {
      this.init(view);
    }
  }
  /**
   * Initialize button.
   * @param {Container} view
   */
  init(view) {
    this.addChild(view);
    this.view = view;
    this.enabled = true;
  }
}

exports.Button = Button;
exports.ButtonContainer = ButtonContainer;
//# sourceMappingURL=Button.js.map


/***/ }),

/***/ 18993:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var typedSignals = __webpack_require__(31852);

class ButtonEvents {
  constructor() {
    this.onPress = new typedSignals.Signal();
    this.onDown = new typedSignals.Signal();
    this.onUp = new typedSignals.Signal();
    this.onHover = new typedSignals.Signal();
    this.onOut = new typedSignals.Signal();
    this.onUpOut = new typedSignals.Signal();
  }
  connectEvents(view) {
    if (core.utils.isMobile.any) {
      view.on("pointerdown", this.processDown, this);
      view.on("pointerup", this.processUp, this);
      view.on("pointerupoutside", this.processUpOut, this);
      view.on("pointerout", this.processOut, this);
      view.on("pointertap", this.processPress, this);
      view.on("pointerover", this.processOver, this);
    } else {
      view.on("mousedown", this.processDown, this);
      view.on("mouseup", this.processUp, this);
      view.on("mouseupoutside", this.processUpOut, this);
      view.on("mouseout", this.processOut, this);
      view.on("click", this.processPress, this);
      view.on("mouseover", this.processOver, this);
    }
  }
  disconnectEvents(view) {
    if (core.utils.isMobile.any) {
      view.off("pointerdown", this.processDown, this);
      view.off("pointerup", this.processUp, this);
      view.off("pointerupoutside", this.processUpOut, this);
      view.off("pointerout", this.processOut, this);
      view.off("pointertap", this.processPress, this);
      view.off("pointerover", this.processOver, this);
    } else {
      view.off("mousedown", this.processDown, this);
      view.off("mouseup", this.processUp, this);
      view.off("mouseupoutside", this.processUpOut, this);
      view.off("mouseout", this.processOut, this);
      view.off("click", this.processPress, this);
      view.off("mouseover", this.processOver, this);
    }
  }
  processDown(e) {
    this._isDown = true;
    this.onDown.emit(this, e);
    this.down(e);
  }
  processUp(e) {
    if (this._isDown) {
      this.onUp.emit(this, e);
      this.up(e);
    }
    this._isDown = false;
  }
  processUpOut(e) {
    if (this._isDown) {
      this.onUp.emit(this, e);
      this.onUpOut.emit(this, e);
      this.up(e);
      this.upOut(e);
    }
    this._isDown = false;
  }
  processOut(e) {
    if (this._isMouseIn) {
      this._isMouseIn = false;
      this.onOut.emit(this, e);
      this.out(e);
    }
  }
  processPress(e) {
    this._isDown = false;
    this.onPress.emit(this, e);
    this.press(e);
  }
  processOver(e) {
    if (core.isMobile.any)
      return;
    this._isMouseIn = true;
    this.onHover.emit(this, e);
    this.hover(e);
  }
  /**
   * Method called when the button pressed.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  down(_e) {
  }
  /**
   * Method called when the button is up.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  up(_e) {
  }
  /**
   * Method called when the up event happens outside of the button,
   * after the down event happened inside the button boundaries.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  upOut(_e) {
  }
  /**
   * Method called when the mouse leaves the button.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  out(_e) {
  }
  /**
   * Method called when the mouse press down the button.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  press(_e) {
  }
  /**
   * Method called when the mouse hovers the button.
   * To be overridden.
   * Fired only if device is not mobile.
   * @param {FederatedPointerEvent} _e - event data
   */
  hover(_e) {
  }
  /** Getter that returns if the button is down. */
  get isDown() {
    return this._isDown;
  }
}

exports.ButtonEvents = ButtonEvents;
//# sourceMappingURL=ButtonEvents.js.map


/***/ }),

/***/ 61037:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var text = __webpack_require__(74083);
var typedSignals = __webpack_require__(31852);
var Switcher = __webpack_require__(55807);
var cleanup = __webpack_require__(99798);

class CheckBox extends Switcher.Switcher {
  constructor(options) {
    super();
    this.text = options.text;
    this.style = options.style;
    this.checked = options.checked;
    this.triggerEvents = ["onPress"];
    this.innerView.cursor = "pointer";
    this.onCheck = new typedSignals.Signal();
    this.onChange.connect(() => this.onCheck.emit(this.checked));
  }
  addLabel(text$1, style) {
    if (!text$1)
      return;
    this.label = new text.Text(text$1 ?? "", style ?? this._style?.text);
    this.addChild(this.label);
    this.label.cursor = "pointer";
    this.label.eventMode = "static";
    this.label.on("pointertap", () => this.checked = !this.checked);
  }
  /** Setter, which sets a checkbox text. */
  set text(text) {
    if (!text) {
      cleanup.cleanup(this.label);
      return;
    }
    this.label ? this.label.text = text : this.addLabel(text);
  }
  /** Getter, which returns a checkbox text. */
  get text() {
    return this.label?.text ?? "";
  }
  /** Setter, which sets a checkbox style settings. */
  set style(style) {
    this._style = style;
    const { unchecked, checked } = style;
    this.views = [unchecked, checked];
    const uncheckedView = this.views[0];
    if (this.label) {
      if (style.text)
        this.label.style = style.text;
      this.label.x = uncheckedView.width + 10 + (style.textOffset?.x ?? 0);
      this.label.y = (uncheckedView.height - this.label.height) / 2 + (style.textOffset?.y ?? 0);
    }
  }
  /** Getter, which returns a checkbox style settings. */
  get style() {
    return this._style;
  }
  /** Getter, which returns a checkbox state. */
  get checked() {
    return this.active === 1;
  }
  /** Setter, which sets a checkbox state. */
  set checked(checked) {
    this.switch(checked ? 1 : 0);
  }
  /**
   * Setter, that sets a checkbox state without emitting a signal.
   * @param checked
   */
  forceCheck(checked) {
    this.forceSwitch(checked ? 1 : 0);
  }
}

exports.CheckBox = CheckBox;
//# sourceMappingURL=CheckBox.js.map


/***/ }),

/***/ 23696:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var SliderBase = __webpack_require__(30452);
var typedSignals = __webpack_require__(31852);

class DoubleSlider extends SliderBase.SliderBase {
  constructor(options) {
    super(options);
    /** Signal that fires when value have changed. */
    this.onChange = new typedSignals.Signal();
    /** Signal that fires when value is changing. */
    this.onUpdate = new typedSignals.Signal();
    this.options = options;
    this.setInitialState();
  }
  setInitialState() {
    this.validateValues();
    const { value1, value2 } = this.options;
    this.updateProgress(value1, value2);
    this.value2 = value2;
    this.value1 = value1;
  }
  updateProgress(value1 = this.value1, value2 = this.value2) {
    this.progressStart = (value1 - this.min) / (this.max - this.min) * 100;
    this.progress = (value2 - this.min) / (this.max - this.min) * 100;
  }
  validateValues() {
    if (!this.options.value1) {
      this.options.value1 = this.min;
    }
    if (!this.options.value2) {
      this.options.value2 = this.options.max;
    }
    if (this.options.value2 < this.options.value1) {
      this.options.value2 = this.options.value1;
    }
    if (this.options.value1 < this.options.min) {
      this.options.value1 = this.options.min;
    }
    if (this.options.value1 > this.options.max) {
      this.options.value1 = this.options.max;
    }
    if (this.options.value2 > this.options.max) {
      this.options.value2 = this.options.max;
    }
  }
  /** Returns left value. */
  get value1() {
    return this._value1;
  }
  /** Sets left value. */
  set value1(value1) {
    if (value1 === this._value1)
      return;
    if (value1 < this.min)
      value1 = this.min;
    if (value1 > this._value2)
      value1 = this._value2;
    this._value1 = value1;
    this.updateSlider1();
    this.onUpdate?.emit(this.value1, this.value2);
  }
  /** Returns right value. */
  get value2() {
    return this._value2;
  }
  /** Sets right value. */
  set value2(value2) {
    if (value2 === this._value2)
      return;
    if (value2 < this._value1)
      value2 = this._value1;
    if (value2 > this.max)
      value2 = this.max;
    this._value2 = value2;
    this.updateSlider2();
    this.onUpdate?.emit(this.value1, this.value2);
  }
  update(event) {
    if (!this.dragging)
      return;
    const obj = event.currentTarget;
    const { x } = obj.parent.worldTransform.applyInverse(event.global);
    const slider1Dist = Math.abs(x - this._slider1.x - this._slider1.width);
    const slider2Dist = Math.abs(x - this._slider2.x);
    if (!this.activeValue) {
      if (this.slider1 && x < this.slider1.x) {
        this.activeValue = "value1";
      } else if (this.slider2 && x > this.slider2.x) {
        this.activeValue = "value2";
      } else {
        this.activeValue = slider1Dist < slider2Dist ? "value1" : "value2";
      }
    }
    const progress = this.validate(x / this.bg.width * 100);
    if (this.activeValue === "value1") {
      this.progressStart = progress;
      this.value1 = this.min + (this.max - this.min) / 100 * progress;
      this.updateProgress(this.value1, this.value2);
    } else {
      this.progress = progress;
      this.value2 = this.min + (this.max - this.min) / 100 * progress;
    }
  }
  endUpdate() {
    super.endUpdate();
    this.activeValue = null;
  }
  change() {
    this.onChange?.emit(this.value1, this.value2);
  }
  /**
   * Set Slider1 instance.
   * @param value - Container or string with texture name.
   */
  set slider1(value) {
    super.slider1 = value;
    this.updateSlider1();
  }
  /** Get Slider1 instance. */
  get slider1() {
    return this._slider1;
  }
  /**
   * Sets Slider instance.
   * @param value - Container or string with texture name.
   */
  set slider2(value) {
    super.slider2 = value;
    this.updateSlider2();
  }
  /** Get Slider2 instance. */
  get slider2() {
    return this._slider2;
  }
  updateSlider1() {
    this._slider1.x = (this.bg.width - this._slider1.width) / 100 * this.progressStart;
    if (this._slider2 && this._slider1.x > this._slider2.x) {
      this._slider1.x = this._slider2.x;
    }
    if (this.options?.showValue) {
      this.value1Text.text = `${Math.round(this.value1)}`;
      const sliderPosX = this._slider1.x + this._slider1.width / 2;
      const sliderPosY = this._slider1.y;
      this.value1Text.x = sliderPosX + (this.options.valueTextOffset?.x ?? 0);
      this.value1Text.y = sliderPosY + (this.options.valueTextOffset?.y ?? 0);
    }
  }
  updateSlider2() {
    this._slider2.x = (this.bg.width - this._slider2.width) / 100 * this.progress;
    if (this._slider2.x < this._slider1.x) {
      this._slider2.x = this._slider1.x;
    }
    if (this.options?.showValue) {
      this.value2Text.text = `${Math.round(this.value2)}`;
      const sliderPosX = this._slider2.x + this._slider2.width / 2;
      const sliderPosY = this._slider2.y;
      this.value2Text.x = sliderPosX + (this.options.valueTextOffset?.x ?? 0);
      this.value2Text.y = sliderPosY + (this.options.valueTextOffset?.y ?? 0);
    }
  }
}

exports.DoubleSlider = DoubleSlider;
//# sourceMappingURL=DoubleSlider.js.map


/***/ }),

/***/ 43055:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var view = __webpack_require__(52705);
var text = __webpack_require__(48363);
var Button = __webpack_require__(25296);
var typedSignals = __webpack_require__(31852);
var fit = __webpack_require__(29813);
var tweedle_js = __webpack_require__(19451);

class FancyButton extends display.Container {
  /**
   * Turns a given container-based view into a button by adding all button events.
   * @param {object} options - Button options.
   * @param {Container} options.defaultView - Container-based view that is shown when non of the button events are active.
   * @param {Container} options.hoverView - Container-based view that is shown when the mouse hovers over the button.
   * @param {Container} options.pressedView - Container-based view, shown when the mouse press on the component.
   * @param {Container} options.disabledView - Container-based view shown when the button is disabled.
   * @param {Container} options.icon - Container-based view for the button icon.
   * @param {Text} options.text - Text-based view for the button text.
   * @param {number} options.padding - Padding of the button text and icon views.
   * If button text or icon does not fit active view + padding it will scale down to fit.
   * @param {Point} options.offset - Offset of the button state views.
   * @param {Point} options.textOffset - Offset of the text view.
   * @param {Point} options.iconOffset - Offset of the icon view.
   * @param {number} options.scale - Scale of the button. Scale will be applied to a main container,
   * when all animations scales will be applied to the inner view.
   * @param {number} options.anchor - Anchor point of the button.
   * @param {number} options.anchorX - Horizontal anchor point of the button.
   * @param {number} options.anchorY - Vertical anchor point of the button.
   * @param options.animations - Animations that will be played when the button state changes.
   */
  constructor({
    defaultView,
    hoverView,
    pressedView,
    disabledView,
    text,
    padding,
    offset,
    textOffset,
    iconOffset,
    scale,
    anchor,
    anchorX,
    anchorY,
    icon,
    animations
  }) {
    super();
    this.defaultDuration = 100;
    this._views = {};
    this.innerView = new display.Container();
    this.addChild(this.innerView);
    this.anchor = new core.ObservablePoint(this.updateAnchor, this);
    this.anchor.set(anchorX ?? anchor ?? 0, anchorY ?? anchor ?? 0);
    this.padding = padding ?? 0;
    this.offset = offset;
    this.textOffset = textOffset;
    this.iconOffset = iconOffset;
    this.scale.set(scale ?? 1);
    if (animations) {
      this.animations = animations;
      core.Ticker.shared.add(() => tweedle_js.Group.shared.update());
    }
    this.views = {
      defaultView,
      hoverView,
      pressedView,
      disabledView,
      text,
      icon
    };
    this.setState("default");
    this.addEvents();
  }
  /**
   * Updates the text of the button and updates its scaling basing on the new size.
   * @param {string | number} text
   */
  set text(text) {
    if (!text || text === 0) {
      this.innerView.removeChild(this._views.text);
      this._views.text = null;
      return;
    }
    if (!this._views.text) {
      this.createTextView(text);
      return;
    }
    this._views.text.text = text.toString();
  }
  /** Returns the text string of the button text element. */
  get text() {
    return this._views.text?.text;
  }
  /**
   * Setter, that prevents all button events from firing.
   * @param {boolean} enabled
   */
  set enabled(enabled) {
    this.events.enabled = enabled;
    this.setState(enabled ? "default" : "disabled");
  }
  /** Getter that returns button state, that controls if button events are firing. */
  get enabled() {
    return this.events.enabled;
  }
  /**
   * Updates button state and shows the according views.
   *
   * Updates positions and offsets of the views.
   *
   * Plays animations if they are set.
   * @param {State} newState
   */
  setState(newState) {
    if (this.state === newState) {
      return;
    }
    const currentView = this.getStateView(this.state);
    const activeView = this.getStateView(newState);
    if (currentView)
      currentView.visible = false;
    this.state = newState;
    if (activeView) {
      this.setOffset(activeView, newState, this.offset);
      activeView.visible = true;
    }
    this.updateAnchor();
    this.playAnimations(newState);
  }
  /**
   *
   * Manage button text view.
   * @param {string | Text} text - can be a string, Text, BitmapText ot HTMLText (Container-based element).
   */
  createTextView(text$1) {
    if (!this._views.text) {
      this._views.text = text.getTextView(text$1);
      this._views.text.anchor.set(0);
      this.innerView.addChild(this._views.text);
    }
    this.adjustTextView(this.state);
  }
  /**
   * Manages views offsets if it's set.
   * @param view
   * @param state
   * @param offset
   */
  setOffset(view, state, offset) {
    const stateOffset = offset ? offset[state] : {
      x: 0,
      y: 0
    };
    const defaultStateOffset = offset?.default;
    if (stateOffset) {
      view.x += stateOffset.x ?? 0;
      view.y += stateOffset.y ?? 0;
    } else if (defaultStateOffset) {
      view.x += defaultStateOffset.x ?? 0;
      view.y += defaultStateOffset.y ?? 0;
    } else if (offset.x || offset.y) {
      view.x += offset.x ?? 0;
      view.y += offset.y ?? 0;
    }
  }
  /**
   * Returns active view for the state.
   * @param state
   */
  getStateView(state) {
    const { default: defaultView, hover, pressed, disabled } = this._views;
    switch (state) {
      case "hover":
        return hover ?? defaultView;
      case "pressed":
        return pressed ?? hover ?? defaultView;
      case "disabled":
        return disabled ?? defaultView;
      case "default":
        return defaultView;
      default:
        return void 0;
    }
  }
  /**
   * Adjusts text view position and scale.
   * @param {State} state
   */
  adjustTextView(state) {
    if (!this.text)
      return;
    const activeView = this.getStateView(this.state);
    if (activeView) {
      fit.fitToView(activeView, this._views.text, this.padding);
      this._views.text.x = activeView.x + activeView.width / 2;
      this._views.text.y = activeView.y + activeView.height / 2;
    }
    this._views.text.anchor.set(0.5);
    this.setOffset(this._views.text, state, this.textOffset);
  }
  /**
   * Adjusts icon view position and scale.
   * @param {State} state
   */
  adjustIconView(state) {
    if (!this._views.icon) {
      return;
    }
    const activeView = this.getStateView(state);
    fit.fitToView(activeView, this._views.icon, this.padding);
    this._views.icon.anchor?.set(0);
    this._views.icon.x = activeView.x + activeView.width / 2 - this._views.icon.width / 2;
    this._views.icon.y = activeView.y + activeView.height / 2 - this._views.icon.height / 2;
    this.setOffset(this._views.icon, state, this.iconOffset);
  }
  /**
   * Reset views positions according to the button anchor setting.
   * We have to set the anchor position for each view individually, as each of them
   * can be a different type of view (container without anchor, sprite with anchor, etc)
   * we have to reset all anchors to 0,0 and then set the positions manually.
   */
  updateAnchor() {
    const anchorX = this.anchor.x ?? 0;
    const anchorY = this.anchor.y ?? 0;
    const views = [this._views.default, this._views.hover, this._views.pressed, this._views.disabled];
    views.forEach((view) => {
      if (!view)
        return;
      view.anchor?.set(0);
      view.x = -view.width * anchorX;
      view.y = -view.height * anchorY;
    });
    if (this._views.default) {
      const { x, y, width, height } = this._views.default;
      this.hitArea = new core.Rectangle(x, y, width, height);
    }
    this.adjustIconView(this.state);
    this.adjustTextView(this.state);
  }
  /**
   * Set button views according to the config.
   * If state view is not set (undefined), it will not be changed,
   * so if it was set before, it will remain the same.
   * If state view is set to null, it will be removed from the button.
   * If state view is set it will be updated or added to a button.
   * @param {Views} views
   */
  // eslint-disable-next-line accessor-pairs
  set views(views) {
    const { defaultView, hoverView, pressedView, disabledView, text, icon } = views;
    if (defaultView) {
      this._views.default = view.getView(defaultView);
      this.setOffset(this._views.default, "default", this.offset);
      if (!this._views.default.parent) {
        this.innerView.addChild(this._views.default);
      }
    } else if (defaultView === null && this._views.default) {
      this.innerView.removeChild(this._views.default);
      this._views.default = null;
    }
    if (hoverView) {
      this._views.hover = view.getView(hoverView);
      if (!this._views.hover.parent) {
        this.innerView.addChild(this._views.hover);
      }
      this._views.hover.visible = false;
    } else if (hoverView === null && this._views.hover) {
      this.innerView.removeChild(this._views.hover);
      this._views.hover = null;
    }
    if (pressedView) {
      this._views.pressed = view.getView(pressedView);
      if (!this._views.pressed.parent) {
        this.innerView.addChild(this._views.pressed);
      }
      this._views.pressed.visible = false;
    } else if (pressedView === null && this._views.pressed) {
      this.innerView.removeChild(this._views.pressed);
      this._views.pressed = null;
    }
    if (disabledView) {
      this._views.disabled = view.getView(disabledView);
      if (!this._views.disabled.parent) {
        this.innerView.addChild(this._views.disabled);
      }
      this._views.disabled.visible = false;
    } else if (disabledView === null && this._views.disabled) {
      this.innerView.removeChild(this._views.disabled);
      this._views.disabled = null;
    }
    if (icon) {
      this._views.icon = view.getView(icon);
      if (!this._views.icon.parent) {
        this.innerView.addChild(this._views.icon);
      }
    } else if (icon === null && this._views.icon) {
      this.innerView.removeChild(this._views.icon);
      this._views.icon = null;
    }
    if (text) {
      this.createTextView(text);
    } else if (text === null && this._views.text) {
      this.innerView.removeChild(this._views.text);
      this._views.text = null;
    }
  }
  /** Creates all button events */
  addEvents() {
    this.events = new Button.Button(this);
    this.onDown = new typedSignals.Signal();
    this.onUp = new typedSignals.Signal();
    this.onUpOut = new typedSignals.Signal();
    this.onOut = new typedSignals.Signal();
    this.onPress = new typedSignals.Signal();
    this.onHover = new typedSignals.Signal();
    this.events.onDown.connect((_bth, e) => {
      this.onDown.emit(this, e);
      this.down();
      this.setState("pressed");
    });
    this.events.onUp.connect((_bth, e) => {
      this.onUp.emit(this, e);
      this.up();
      core.utils.isMobile.any ? this.setState("default") : this.setState("hover");
    });
    this.events.onUpOut.connect((_bth, e) => {
      this.onUpOut.emit(this, e);
      this.upOut();
      this.setState("default");
    });
    this.events.onOut.connect((_bth, e) => {
      this.onOut.emit(this, e);
      this.out();
      if (!this.events.isDown) {
        this.setState("default");
      }
    });
    this.events.onPress.connect((_bth, e) => {
      this.onPress.emit(this, e);
      this.press();
      core.utils.isMobile.any ? this.setState("default") : this.setState("hover");
    });
    this.events.onHover.connect((_bth, e) => {
      this.onHover.emit(this, e);
      this.hover();
      if (!this.events.isDown) {
        core.utils.isMobile.any ? this.setState("default") : this.setState("hover");
      }
    });
  }
  /**
   * Starts animation for the current button state if configured.
   * @param {State} state
   */
  playAnimations(state) {
    if (!this.animations)
      return;
    if (state === "default" && !this.originalInnerViewState) {
      this.originalInnerViewState = {
        x: this.innerView.x,
        y: this.innerView.y,
        width: this.innerView.width,
        height: this.innerView.height,
        scale: {
          x: this.innerView.scale.x,
          y: this.innerView.scale.y
        }
      };
      const defaultStateAnimation = this.animations?.default;
      if (defaultStateAnimation) {
        this.innerView.x = defaultStateAnimation.props.x ?? this.originalInnerViewState.x;
        this.innerView.y = defaultStateAnimation.props.y ?? this.originalInnerViewState.y;
        this.innerView.width = defaultStateAnimation.props.width ?? this.originalInnerViewState.width;
        this.innerView.height = defaultStateAnimation.props.height ?? this.originalInnerViewState.height;
        this.innerView.scale.x = defaultStateAnimation.props.scale.x ?? this.originalInnerViewState.scale.x;
        this.innerView.scale.y = defaultStateAnimation.props.scale.y ?? this.originalInnerViewState.scale.y;
        return;
      }
    }
    const stateAnimation = this.animations[state] ?? this.animations.default;
    if (stateAnimation) {
      const data = stateAnimation;
      this.defaultDuration = data.duration;
      new tweedle_js.Tween(this.innerView).to(data.props, data.duration).start();
      return;
    }
    new tweedle_js.Tween(this.innerView).to(this.originalInnerViewState, this.defaultDuration).start();
  }
  /**
   * Method called when the button pressed.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  down(_e) {
  }
  /**
   * Method called when the button is up.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  up(_e) {
  }
  /**
   * Method called when the up event happens outside of the button,
   * after the down event happened inside the button boundaries.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  upOut(_e) {
  }
  /**
   * Method called when the mouse leaves the button.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  out(_e) {
  }
  /**
   * Method called when the mouse press down the button.
   * To be overridden.
   * @param {FederatedPointerEvent} _e - event data
   */
  press(_e) {
  }
  /**
   * Method called when the mouse hovers the button.
   * To be overridden.
   * Fired only if device is not mobile.
   * @param {FederatedPointerEvent} _e - event data
   */
  hover(_e) {
  }
}

exports.FancyButton = FancyButton;
//# sourceMappingURL=FancyButton.js.map


/***/ }),

/***/ 90626:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var graphics = __webpack_require__(47997);
var sprite = __webpack_require__(64441);
var text = __webpack_require__(74083);
var typedSignals = __webpack_require__(31852);
var view = __webpack_require__(52705);

class Input extends display.Container {
  constructor(options) {
    super();
    this.editing = false;
    this.tick = 0;
    this.activation = false;
    /** Top side padding */
    this.paddingTop = 0;
    /** Right side padding */
    this.paddingRight = 0;
    /** Bottom side padding */
    this.paddingBottom = 0;
    /** Left side padding */
    this.paddingLeft = 0;
    this.options = options;
    this.padding = options.padding;
    this.cursor = "text";
    this.interactive = true;
    this.on("pointertap", () => {
      this.activation = true;
      core.utils.isMobile.any && this.handleActivation();
    });
    if (core.utils.isMobile.any) {
      window.addEventListener("touchstart", () => this.handleActivation());
    } else if (!core.utils.isMobile.any) {
      window.addEventListener("click", () => this.handleActivation());
      window.addEventListener("keydown", (e) => {
        const key = e.key;
        if (key === "Backspace") {
          this._delete();
        } else if (key === "Escape" || key === "Enter") {
          this.stopEditing();
        } else if (key.length === 1)
          this._add(key);
      });
    }
    this.onEnter = new typedSignals.Signal();
    this.onChange = new typedSignals.Signal();
    core.Ticker.shared.add((delta) => this.update(delta));
    if (options.bg) {
      this.bg = options.bg;
    } else {
      console.error("Input: bg is not defined, please define it.");
    }
  }
  init() {
    const options = this.options;
    const defaultTextStyle = {
      fill: 0,
      align: "center"
    };
    this.options.textStyle = options.textStyle ?? defaultTextStyle;
    const textStyle = new text.TextStyle(options.textStyle ?? defaultTextStyle);
    this.inputField = new text.Text("", textStyle);
    this._cursor = new sprite.Sprite(core.Texture.WHITE);
    this._cursor.tint = Number(options.textStyle.fill) || 0;
    this._cursor.anchor.set(0.5);
    this._cursor.width = 2;
    this._cursor.height = this.inputField.height * 0.8;
    this._cursor.alpha = 0;
    this.placeholder = new text.Text(options.placeholder, textStyle ?? defaultTextStyle);
    this.placeholder.visible = !!options.placeholder;
    this.addChild(this.inputField, this.placeholder, this._cursor);
    this.value = options.value ?? "";
    this.align();
  }
  set bg(bg) {
    this._bg = view.getView(bg);
    this._bg.cursor = "text";
    this._bg.interactive = true;
    if (!this._bg.parent) {
      this.addChild(this._bg);
    }
    if (!this.inputField) {
      this.init();
    }
    this.inputMask = new graphics.Graphics().beginFill(16777215).drawRect(
      this.paddingLeft,
      this.paddingTop,
      this._bg.width - this.paddingRight - this.paddingLeft,
      this._bg.height - this.paddingBottom - this.paddingTop
    );
    this.inputField.mask = this.inputMask;
    this._cursor.mask = this.inputMask;
    if (!this.inputMask.parent) {
      this.addChild(this.inputMask);
    }
  }
  get bg() {
    return this._bg;
  }
  _add(key) {
    if (!this.editing) {
      return;
    }
    if (this.options.maxLength && this.value.length >= this.options.maxLength) {
      return;
    }
    this.value = this.value + key;
    this.onChange.emit(this.value);
  }
  _delete() {
    if (!this.editing || this.value.length === 0)
      return;
    const array = this.value.split("");
    array.pop();
    this.value = array.join("");
    this.onChange.emit(this.value);
  }
  _startEditing() {
    this.tick = 0;
    this.editing = true;
    this.placeholder.visible = false;
    this._cursor.alpha = 1;
    if (core.utils.isMobile.any) {
      this._keyboard = document.createElement("input");
      document.body.appendChild(this._keyboard);
      this._keyboard.style.position = "fixed";
      this._keyboard.style.left = "-1000px";
      this._keyboard.oninput = () => {
        let value = this._keyboard.value;
        const maxLength = this.options.maxLength;
        if (maxLength && value.length > this.options.maxLength) {
          value = value.substring(0, maxLength);
          this._keyboard.value = value;
        }
        this.value = value;
        this.onChange.emit(this.value);
      };
      this._keyboard.focus();
      this._keyboard.click();
      this._keyboard.value = this.value;
    }
    this.align();
  }
  handleActivation() {
    this.stopEditing();
    if (this.activation) {
      this._startEditing();
      this.activation = false;
    }
  }
  stopEditing() {
    if (!this.editing)
      return;
    this._cursor.alpha = 0;
    this.editing = false;
    if (this.inputField.text === "") {
      this.placeholder.visible = true;
    }
    if (this.value.length === 0)
      this.placeholder.visible = true;
    if (core.utils.isMobile.any) {
      this._keyboard?.blur();
      this._keyboard?.remove();
      this._keyboard = null;
    }
    this.align();
    this.onEnter.emit(this.value);
  }
  update(dt) {
    if (!this.editing)
      return;
    this.tick += dt * 0.1;
    this._cursor.alpha = Math.round(Math.sin(this.tick) * 0.5 + 0.5);
  }
  align() {
    if (!this._bg)
      return;
    const align = this.getAlign();
    this.inputField.anchor.set(align, 0.5);
    this.inputField.x = this._bg.width * align + (align === 1 ? -this.paddingRight : this.paddingLeft);
    this.inputField.y = this._bg.height / 2 + this.paddingTop - this.paddingBottom;
    this.placeholder.anchor.set(align, 0.5);
    this.placeholder.x = this._bg.width * align + (align === 1 ? -this.paddingRight : this.paddingLeft);
    this.placeholder.y = this._bg.height / 2;
    this._cursor.x = this.getCursorPosX();
    this._cursor.y = this.inputField.y;
  }
  getAlign() {
    const maxWidth = this._bg.width * 0.95;
    const paddings = this.paddingLeft + this.paddingRight - 10;
    const isOverflowed = this.inputField.width + paddings > maxWidth;
    if (isOverflowed) {
      return this.editing ? 1 : 0;
    }
    switch (this.options.align) {
      case "left":
        return 0;
      case "center":
        return 0.5;
      case "right":
        return 1;
      default:
        return 0;
    }
  }
  getCursorPosX() {
    const align = this.getAlign();
    switch (align) {
      case 0:
        return this.inputField.x + this.inputField.width;
      case 0.5:
        return this.inputField.x + this.inputField.width * 0.5;
      case 1:
        return this.inputField.x;
      default:
        return 0;
    }
  }
  /** Sets the input text. */
  set value(text) {
    this.inputField.text = text;
    if (text.length !== 0) {
      this.placeholder.visible = false;
    } else {
      this.placeholder.visible = !this.editing;
    }
    this.align();
  }
  /** Return text of the input. */
  get value() {
    return this.inputField.text;
  }
  /**
   * Set paddings
   * @param value - number, array of 4 numbers or object with keys: top, right, bottom, left
   * or: [top, right, bottom, left]
   * or: [top&bottom, right&left]
   * or: {
   *  left: 10,
   *  right: 10,
   *  top: 10,
   *  bottom: 10,
   * }
   */
  set padding(value) {
    if (typeof value === "number") {
      this.paddingTop = value;
      this.paddingRight = value;
      this.paddingBottom = value;
      this.paddingLeft = value;
    }
    if (Array.isArray(value)) {
      this.paddingTop = value[0] ?? 0;
      this.paddingRight = value[1] ?? value[0] ?? 0;
      this.paddingBottom = value[2] ?? value[0] ?? 0;
      this.paddingLeft = value[3] ?? value[1] ?? value[0] ?? 0;
    } else if (typeof value === "object") {
      this.paddingTop = value.top ?? 0;
      this.paddingRight = value.right ?? 0;
      this.paddingBottom = value.bottom ?? 0;
      this.paddingLeft = value.left ?? 0;
    }
  }
  // Return array of paddings [top, right, bottom, left]
  get padding() {
    return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
  }
}

exports.Input = Input;
//# sourceMappingURL=Input.js.map


/***/ }),

/***/ 66280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);

class List extends display.Container {
  constructor(options) {
    super();
    /** Returns all arranged elements. */
    this.children = [];
    if (options) {
      this.init(options);
    }
    options?.items?.forEach((item) => this.addChild(item));
    this.on("added", () => this.arrangeChildren());
    this.on("childAdded", () => this.arrangeChildren());
  }
  /**
   * Initiates list component.
   * @param options
   */
  init(options) {
    this.options = options;
    if (options?.type) {
      this.type = options.type;
    }
    if (options?.children) {
      options.children.forEach((child) => this.addChild(child));
    }
  }
  /**
   * Set items arrange direction.
   * @param type - Arrange direction.
   */
  set type(type) {
    this._type = type;
    this.arrangeChildren();
  }
  /**
   * Get items arrange direction.
   * @returns Arrange direction.
   */
  get type() {
    return this._type;
  }
  /**
   * Set element margin.
   * @param margin - Margin between elements.
   */
  set elementsMargin(margin) {
    this.options.elementsMargin = margin;
    this.arrangeChildren();
  }
  /**
   * Get element margin.
   * @returns Margin between elements.
   */
  get elementsMargin() {
    return this.options.elementsMargin;
  }
  /**
   * Set vertical padding.
   * @param padding - Vertical padding between list border and its elements.
   */
  set vertPadding(padding) {
    this.options.vertPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get vertical padding.
   * @returns Vertical padding between list border and its elements.
   */
  get vertPadding() {
    return this.options.vertPadding;
  }
  /**
   * Set horizontal padding.
   * @param padding - Horizontal padding between list border and its elements.
   */
  set horPadding(padding) {
    this.options.horPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get horizontal padding.
   * @returns Horizontal padding between list border and its elements.
   */
  get horPadding() {
    return this.options.horPadding;
  }
  /**
   * Arrange all elements basing in their sizes and component options.
   * Can be arranged vertically, horizontally or bidirectional.
   */
  arrangeChildren() {
    let x = this.options?.horPadding ?? 0;
    let y = this.options?.vertPadding ?? 0;
    const elementsMargin = this.options?.elementsMargin ?? 0;
    let maxWidth = this.parent?.width;
    if (this.options?.horPadding) {
      maxWidth -= this.options.horPadding;
    }
    this.children.forEach((child, id) => {
      switch (this.type) {
        case "vertical":
          child.y = y;
          child.x = x;
          y += elementsMargin + child.height;
          break;
        case "horizontal":
          child.x = x;
          child.y = y;
          x += elementsMargin + child.width;
          break;
        default:
          child.x = x;
          child.y = y;
          if (child.x + child.width >= maxWidth && id > 0) {
            y += elementsMargin + child.height;
            x = this.options?.horPadding ?? 0;
            child.x = x;
            child.y = y;
          }
          x += elementsMargin + child.width;
          break;
      }
    });
  }
}

exports.List = List;
//# sourceMappingURL=List.js.map


/***/ }),

/***/ 62564:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var graphics = __webpack_require__(47997);
var sprite = __webpack_require__(64441);
var view = __webpack_require__(52705);

class MaskedFrame extends graphics.Graphics {
  constructor(options) {
    super();
    if (options?.target) {
      this.init(options);
    }
  }
  /**
   * Initializes a component.
   * @param root0
   * @param root0.target - Container to apply a mask or a border.
   * @param root0.mask - Mask.
   * @param root0.borderWidth - Border width.
   * @param root0.borderColor - Border color.
   */
  init({ target, mask, borderWidth, borderColor }) {
    if (this.target) {
      this.removeChild(this.target);
    }
    this.target = view.getView(target);
    this.addChild(this.target);
    if (mask)
      this.setMask(mask);
    if (borderWidth)
      this.setBorder(borderWidth, borderColor);
  }
  /**
   * Applies a mask to a target container.
   * @param mask
   */
  setMask(mask) {
    this.maskData = mask;
    this._targetMask = view.getView(mask);
    this.target.addChild(this._targetMask);
    this.target.mask = this._targetMask;
  }
  /**
   * Shows a border around the target Container, same shape as the mask.
   * @param borderWidth
   * @param borderColor
   */
  setBorder(borderWidth, borderColor) {
    this.borderWidth = borderWidth;
    this.borderColor = borderColor;
    this.showBorder();
    const borderMask = typeof this.maskData === "string" ? sprite.Sprite.from(this.maskData) : this.maskData.clone();
    borderMask.width += borderWidth * 2;
    borderMask.height += borderWidth * 2;
    this.mask = borderMask;
    this.addChild(borderMask);
  }
  /** Hides a border. */
  showBorder() {
    const width = this.borderWidth * 2;
    this.clear().beginFill(this.borderColor).drawRect(0, 0, this.target.width + width, this.target.height + width);
    this.target.x = this.borderWidth;
    this.target.y = this.borderWidth;
  }
  /** Hides a border. */
  hideBorder() {
    this.clear();
  }
}

exports.MaskedFrame = MaskedFrame;
//# sourceMappingURL=MaskedFrame.js.map


/***/ }),

/***/ 76186:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);
var graphics = __webpack_require__(47997);
var sprite = __webpack_require__(64441);
var view = __webpack_require__(52705);

class ProgressBar extends display.Container {
  constructor(params) {
    super();
    this.progressStart = 0;
    this._progress = 0;
    this.innerView = new display.Container();
    this.addChild(this.innerView);
    if (params?.bg && params?.fill) {
      this.init(params);
    }
  }
  /**
   * Initialize ProgressBar.
   * @param root0
   * @param root0.bg - Background texture.
   * @param root0.fill - Fill texture.
   * @param root0.fillOffset - Fill offset.
   * @param root0.progress - Initial progress value.
   */
  init({ bg, fill, fillOffset, progress }) {
    this.setBackground(bg);
    this.setFill(fill, fillOffset);
    this.progress = progress;
  }
  /**
   * Set bg.
   * @param bg
   */
  setBackground(bg) {
    if (this.bg) {
      this.innerView.removeChild(this.bg);
    }
    this.bg = view.getView(bg);
    this.innerView.addChildAt(this.bg, 0);
  }
  /**
   * Set fill.
   * @param fill
   * @param fillOffset
   */
  setFill(fill, fillOffset) {
    if (this.fill) {
      this.innerView.removeChild(this.fill);
      this.fill.destroy();
    }
    if (this.bg instanceof sprite.Sprite && fill === this.bg) {
      fill = sprite.Sprite.from(this.bg.texture);
    }
    this.fill = view.getView(fill);
    this.innerView.addChildAt(this.fill, 1);
    const offsetX = fillOffset?.x ?? 0;
    const offsetY = fillOffset?.y ?? 0;
    this.fill.x = (this.bg.width - this.fill.width) / 2 + offsetX;
    this.fill.y = (this.bg.height - this.fill.height) / 2 + offsetY;
    if (!this.fillMask) {
      this.fillMask = new graphics.Graphics();
    }
    this.fill.addChild(this.fillMask);
    this.fill.mask = this.fillMask;
  }
  validate(progress) {
    progress = Math.round(progress);
    if (progress < 0) {
      return 0;
    }
    if (progress > 100) {
      return 100;
    }
    return progress;
  }
  /** Set current progress percentage value. */
  set progress(progress) {
    this._progress = this.validate(progress);
    if (!this.fill)
      return;
    const startPoint = this.fill.width / 100 * this.progressStart;
    const endPoint = this.fill.width / 100 * this._progress - startPoint;
    if (this.fillMask) {
      this.fillMask.clear().lineStyle(0).beginFill(16777215).drawRect(startPoint, 0, endPoint, this.fill.height);
    }
  }
  /** Return current progress percentage value. */
  get progress() {
    return this._progress;
  }
}

exports.ProgressBar = ProgressBar;
//# sourceMappingURL=ProgressBar.js.map


/***/ }),

/***/ 44754:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);
var typedSignals = __webpack_require__(31852);
var List = __webpack_require__(66280);

class RadioGroup extends display.Container {
  constructor(options) {
    super();
    this.items = [];
    if (options) {
      this.init(options);
    }
    this.onChange = new typedSignals.Signal();
  }
  /**
   * Initiates a group.
   * @param options
   */
  init(options) {
    this.options = options;
    this.value = options.items[options.selectedItem || 0].label.text;
    this.selected = options.selectedItem ?? 0;
    if (this.innerView) {
      this.innerView.type = options.type;
      this.innerView.elementsMargin = options.elementsMargin;
    } else {
      this.innerView = new List.List({
        type: options.type,
        elementsMargin: options.elementsMargin
      });
    }
    this.addItems(options.items);
    this.addChild(this.innerView);
    this.selectItem(this.selected);
  }
  /**
   * Add items to a group.
   * @param {CheckBox[]} items - array of {@link CheckBox} instances.
   */
  addItems(items) {
    items.forEach((checkBox, id) => {
      checkBox.onChange.connect(() => this.selectItem(id));
      this.items.push(checkBox);
      this.innerView.addChild(checkBox);
    });
  }
  /**
   * Remove items from a group.
   * @param ids
   */
  removeItems(ids) {
    ids.forEach((id) => {
      const item = this.items[id];
      if (!item)
        return;
      item.onChange.disconnectAll();
      this.innerView.removeChild(item);
      this.items.splice(id, 1);
    });
  }
  /**
   * Select item by ID.
   * @param id
   */
  selectItem(id) {
    this.items.forEach((item, key) => {
      item.forceCheck(key === id);
    });
    if (this.selected !== id) {
      this.onChange.emit(id, this.items[id].label.text);
    }
    this.value = this.options.items[id].label.text;
    this.selected = id;
  }
}

exports.RadioGroup = RadioGroup;
//# sourceMappingURL=RadioGroup.js.map


/***/ }),

/***/ 81460:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var graphics = __webpack_require__(47997);
var sprite = __webpack_require__(64441);
var List = __webpack_require__(66280);
var Trackpad = __webpack_require__(17117);

class ScrollBox extends display.Container {
  /**
   * @param options
   * @param {number} options.background - background color of the ScrollBox.
   * @param {number} options.width - width of the ScrollBox.
   * @param {number} options.height - height of the ScrollBox.
   * @param {number} options.radius - radius of the ScrollBox and its masks corners.
   * @param {number} options.elementsMargin - margin between elements.
   * @param {number} options.vertPadding - vertical padding of the ScrollBox.
   * @param {number} options.horPadding - horizontal padding of the ScrollBox.
   * @param {number} options.padding - padding of the ScrollBox (same horizontal and vertical).
   * @param {boolean} options.disableDynamicRendering - disables dynamic rendering of the ScrollBox,
   * so even elements the are not visible will be rendered. Be careful with this options as it can impact performance.
   */
  constructor(options) {
    super();
    this.__width = 0;
    this.__height = 0;
    this.isDragging = 0;
    this.interactiveStorage = [];
    this.visibleItems = [];
    this.ticker = core.Ticker.shared;
    if (options) {
      this.init(options);
    }
    this.ticker.add(this.update, this);
    this.onMouseScrollBinded = this.onMouseScroll.bind(this);
  }
  /**
   * Initiates ScrollBox.
   * @param options
   * @param {number} options.background - background color of the ScrollBox.
   * @param {number} options.width - width of the ScrollBox.
   * @param {number} options.height - height of the ScrollBox.
   * @param {number} options.radius - radius of the ScrollBox and its masks corners.
   * @param {number} options.elementsMargin - margin between elements.
   * @param {number} options.vertPadding - vertical padding of the ScrollBox.
   * @param {number} options.horPadding - horizontal padding of the ScrollBox.
   * @param {number} options.padding - padding of the ScrollBox (same horizontal and vertical).
   * @param {boolean} options.disableDynamicRendering - disables dynamic rendering of the ScrollBox,
   * so even elements the are not visible will be rendered. Be careful with this options as it can impact performance.
   */
  init(options) {
    this.options = options;
    this.setBackground(options.background);
    this.__width = options.width | this.background.width;
    this.__height = options.height | this.background.height;
    options.vertPadding = options.vertPadding ?? options.padding ?? 0;
    options.horPadding = options.horPadding ?? options.padding ?? 0;
    if (!this.list) {
      this.list = new List.List();
      super.addChild(this.list);
    }
    this.list.init({
      type: options.type,
      elementsMargin: options.elementsMargin,
      vertPadding: options.vertPadding,
      horPadding: options.horPadding
    });
    this.addItems(options.items);
    if (this.hasBounds) {
      this.addMask();
      this.makeScrollable();
    }
    this._trackpad.xAxis.value = 0;
    this._trackpad.yAxis.value = 0;
    this.resize();
  }
  get hasBounds() {
    return !!this.__width || !!this.__height;
  }
  onChildrenChange() {
  }
  /**
   *  Adds array of items to a scrollable list.
   * @param {Container[]} items - items to add.
   */
  addItems(items) {
    if (!items?.length)
      return;
    items.forEach((item) => this.addItem(item));
  }
  /** Remove all items from a scrollable list. */
  removeItems() {
    this.list.removeChildren();
  }
  /**
   * Adds one or more items to a scrollable list.
   * @param {Container} items - one or more items to add.
   */
  addItem(...items) {
    if (items.length > 1) {
      items.forEach((item) => this.addItem(item));
    } else {
      const child = items[0];
      if (!child.width || !child.height) {
        console.error("ScrollBox item should have size");
      }
      child.eventMode = "static";
      this.list.addChild(child);
      if (!this.options.disableDynamicRendering) {
        child.renderable = this.isItemVisible(child);
      }
    }
    this.resize();
    return items[0];
  }
  /**
   * Removes an item from a scrollable list.
   * @param {number} itemID - id of the item to remove.
   */
  removeItem(itemID) {
    const child = this.list.children[itemID];
    if (!child) {
      return;
    }
    this.list.removeChild(child);
    this.resize();
  }
  /**
   * Checks if the item is visible or scrolled out of the visible part of the view.* Adds an item to a scrollable list.
   * @param {Container} item - item to check.
   */
  isItemVisible(item) {
    const isVertical = this.options.type === "vertical" || !this.options.type;
    let isVisible = false;
    const list = this.list;
    if (isVertical) {
      const posY = item.y + list.y;
      if (posY + item.height + this.options.vertPadding >= 0 && posY - this.options.vertPadding - this.options.elementsMargin <= this.options.height) {
        isVisible = true;
      }
    } else {
      const posX = item.x + list.x;
      if (posX + item.width >= 0 && posX <= this.options.width) {
        isVisible = true;
      }
    }
    return isVisible;
  }
  /**
   * Returns all inner items in a list.
   * @returns {Array<Container> | Array} - list of items.
   */
  get items() {
    return this.list?.children ?? [];
  }
  /**
   * Set ScrollBox background.
   * @param {number | string} background - background color or texture.
   */
  setBackground(background) {
    if (this.background) {
      this.removeChild(this.background);
      if (this.background instanceof sprite.Sprite) {
        this.background.destroy();
      }
    }
    this.options.background = background;
    this.background = background !== void 0 && typeof background === "string" ? sprite.Sprite.from(background) : new graphics.Graphics();
    this.addChildAt(this.background, 0);
    this.resize();
  }
  addMask() {
    if (!this.borderMask) {
      this.borderMask = new graphics.Graphics();
      super.addChild(this.borderMask);
      this.mask = this.borderMask;
    }
    this.resize();
  }
  makeScrollable() {
    if (!this._trackpad) {
      this._trackpad = new Trackpad.Trackpad({
        disableEasing: this.options.disableEasing
      });
    }
    this.on("pointerdown", (e) => {
      this.isDragging = 1;
      const touchPoint = this.worldTransform.applyInverse(e.global);
      this._trackpad.pointerDown(touchPoint);
      const listTouchPoint = this.list.worldTransform.applyInverse(e.global);
      this.visibleItems.forEach((item) => {
        if (item.x < listTouchPoint.x && item.x + item.width > listTouchPoint.x && item.y < listTouchPoint.y && item.y + item.height > listTouchPoint.y) {
          this.pressedChild = item;
        }
      });
    });
    this.on("pointerup", () => {
      this.isDragging = 0;
      this._trackpad.pointerUp();
      this.restoreItemsInteractivity();
      this.pressedChild = null;
    });
    this.on("pointerupoutside", () => {
      this.isDragging = 0;
      this._trackpad.pointerUp();
      this.restoreItemsInteractivity();
      this.pressedChild = null;
    });
    this.on("globalpointermove", (e) => {
      const touchPoint = this.worldTransform.applyInverse(e.global);
      this._trackpad.pointerMove(touchPoint);
      if (!this.isDragging)
        return;
      if (this.pressedChild) {
        this.revertClick(this.pressedChild);
        this.pressedChild = null;
      }
    });
    const { onMouseHover, onMouseOut } = this;
    this.on("mouseover", onMouseHover, this).on("mouseout", onMouseOut, this);
  }
  setInteractive(interactive) {
    this.eventMode = interactive ? "static" : "auto";
  }
  get listHeight() {
    return this.list.height + this.options.vertPadding * 2;
  }
  get listWidth() {
    return this.list.width + this.options.horPadding * 2;
  }
  /** Controls item positions and visibility. */
  resize() {
    if (!this.hasBounds)
      return;
    this.renderAllItems();
    if (this.borderMask && (this.lastWidth !== this.listWidth || this.lastHeight !== this.listHeight)) {
      const verPadding = this.options.vertPadding;
      const horPadding = this.options.horPadding;
      if (!this.options.width) {
        this.__width += this.listWidth;
      }
      if (!this.options.height) {
        this.__height += this.listHeight;
      }
      this.borderMask.clear().lineStyle(0).beginFill(16777215).drawRoundedRect(
        0,
        0,
        this.__width,
        this.__height,
        this.options.radius | 0
      );
      this.borderMask.eventMode = "none";
      if (this.background instanceof graphics.Graphics) {
        this.background.clear().lineStyle(0);
        const color = this.options.background;
        this.background.beginFill(
          color ?? 0,
          color ? 1 : 1e-7
          // if color is not set, set alpha to 0 to be able to drag by click on bg
        );
        this.background.drawRect(
          0,
          0,
          this.__width + horPadding,
          this.__height + verPadding
        );
      }
      if (this.options.type === "horizontal") {
        this.setInteractive(this.listWidth > this.__width);
      } else {
        this.setInteractive(this.listHeight > this.__height);
      }
      this.lastWidth = this.listWidth;
      this.lastHeight = this.listHeight;
    }
    if (this._trackpad) {
      const maxWidth = this.borderMask.width - this.list.width - this.options.horPadding * 2;
      const maxHeight = this.borderMask.height - this.list.height - this.options.vertPadding * 2;
      if (this.options.type === "vertical") {
        this._trackpad.yAxis.max = -Math.abs(maxHeight);
      } else if (this.options.type === "horizontal") {
        this._trackpad.xAxis.max = -Math.abs(maxWidth);
      } else {
        this._trackpad.yAxis.max = -Math.abs(maxHeight);
        this._trackpad.xAxis.max = -Math.abs(maxWidth);
      }
    }
    this.stopRenderHiddenItems();
  }
  onMouseHover() {
    this.renderAllItems();
    document.addEventListener("mousewheel", this.onMouseScrollBinded);
    document.addEventListener("DOMMouseScroll", this.onMouseScrollBinded);
  }
  onMouseOut() {
    this.stopRenderHiddenItems();
    document.removeEventListener("mousewheel", this.onMouseScrollBinded);
    document.removeEventListener(
      "DOMMouseScroll",
      this.onMouseScrollBinded
    );
  }
  onMouseScroll(event) {
    this.renderAllItems();
    if (this.options.type === "horizontal" && (typeof event.deltaX !== "undefined" || typeof event.deltaY !== "undefined")) {
      const targetPos = event.deltaY ? this.list.x - event.deltaY : this.list.x - event.deltaX;
      if (targetPos < 0 && targetPos + this.listWidth + this.options.horPadding < this.__width) {
        this._trackpad.xAxis.value = this.__width - this.listWidth;
      } else if (targetPos > this.options.horPadding) {
        this._trackpad.xAxis.value = 0;
      } else {
        this._trackpad.xAxis.value = targetPos;
      }
    } else if (typeof event.deltaY !== "undefined") {
      const targetPos = this.list.y - event.deltaY;
      if (targetPos < 0 && targetPos + this.listHeight + this.options.vertPadding < this.__height) {
        this._trackpad.yAxis.value = this.__height - this.listHeight;
      } else if (targetPos > this.options.vertPadding) {
        this._trackpad.yAxis.value = 0;
      } else {
        this._trackpad.yAxis.value = targetPos;
      }
    }
    this.stopRenderHiddenItems();
  }
  /** Makes it scroll down to the last element. */
  scrollBottom() {
    if (!this.interactive) {
      this.scrollTop();
    } else {
      this.scrollTo(this.list.children.length - 1);
    }
  }
  /** Makes it scroll up to the first element. */
  scrollTop() {
    this._trackpad.xAxis.value = 0;
    this._trackpad.yAxis.value = 0;
  }
  renderAllItems() {
    if (this.options.disableDynamicRendering) {
      return;
    }
    this.items.forEach((child) => {
      child.renderable = true;
    });
  }
  stopRenderHiddenItems() {
    if (this.options.disableDynamicRendering) {
      return;
    }
    this.visibleItems.length = 0;
    this.items.forEach((child) => {
      child.renderable = this.isItemVisible(child);
      this.visibleItems.push(child);
    });
  }
  /**
   * Scrolls to the element with the given ID.
   * @param elementID
   */
  scrollTo(elementID) {
    if (!this.interactive) {
      return;
    }
    const target = this.list.children[elementID];
    if (!target) {
      return;
    }
    this._trackpad.xAxis.value = this.options.type === "horizontal" ? this.__width - target.x - target.width - this.options.horPadding : 0;
    this._trackpad.yAxis.value = !this.options.type || this.options.type === "vertical" ? this.__height - target.y - target.height - this.options.vertPadding : 0;
  }
  /** Gets component height. */
  get height() {
    return this.__height;
  }
  /** Gets component width. */
  get width() {
    return this.__width;
  }
  update() {
    if (!this.list)
      return;
    this._trackpad.update();
    const type = this.options.type === "horizontal" ? "x" : "y";
    if (this.list[type] !== this._trackpad[type]) {
      this.list[type] = this._trackpad[type];
    }
  }
  /** Destroys the component. */
  destroy() {
    this.ticker.remove(this.update, this);
    this.background.destroy();
    this.list.destroy();
    super.destroy();
  }
  restoreItemsInteractivity() {
    this.interactiveStorage.forEach((element) => {
      element.item.eventMode = element.eventMode;
    });
    this.interactiveStorage.length = 0;
  }
  revertClick(item) {
    if (item.eventMode !== "auto") {
      core.utils.isMobile.any ? item.emit("pointerupoutside", null) : item.emit("mouseupoutside", null);
      this.interactiveStorage.push({
        item,
        eventMode: item.eventMode
      });
      item.eventMode = "auto";
    }
    if (item instanceof display.Container && item.children) {
      item.children.forEach((child) => this.revertClick(child));
    }
  }
}

exports.ScrollBox = ScrollBox;
//# sourceMappingURL=ScrollBox.js.map


/***/ }),

/***/ 85664:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);
var graphics = __webpack_require__(47997);
var text = __webpack_require__(74083);
var typedSignals = __webpack_require__(31852);
var FancyButton = __webpack_require__(43055);
var ScrollBox = __webpack_require__(81460);
var view = __webpack_require__(52705);

const defaultVisibleItems = 5;
class Select extends display.Container {
  constructor(options) {
    super();
    this.onSelect = new typedSignals.Signal();
    if (options) {
      this.init(options);
    }
  }
  /**
   * Initiates Select.
   * @param root0
   * @param root0.closedBG
   * @param root0.textStyle
   * @param root0.items
   * @param root0.openBG
   * @param root0.selected
   * @param root0.selectedTextOffset
   * @param root0.scrollBox
   * @param root0.visibleItems
   */
  init({ closedBG, textStyle, items, openBG, selected, selectedTextOffset, scrollBox, visibleItems }) {
    if (this.openView && this.openView !== openBG) {
      this.removeChild(this.openView);
    }
    if (!this.openButton) {
      this.openButton = new FancyButton.FancyButton({
        defaultView: view.getView(closedBG),
        text: new text.Text(items?.items ? items.items[0] : "", textStyle),
        textOffset: selectedTextOffset
      });
      this.openButton.onPress.connect(() => this.toggle());
      this.addChild(this.openButton);
    } else {
      this.openButton.views = {
        defaultView: view.getView(closedBG),
        text: new text.Text(items?.items ? items.items[0] : "", textStyle)
      };
      this.openButton.textOffset = selectedTextOffset;
    }
    if (this.openView !== openBG) {
      this.openView = view.getView(openBG);
      this.openView.visible = false;
      this.addChild(this.openView);
    }
    if (!this.closeButton) {
      this.closeButton = new FancyButton.FancyButton({
        defaultView: new graphics.Graphics().beginFill(0, 1e-5).drawRect(0, 0, this.openButton.width, this.openButton.height),
        text: new text.Text(items?.items ? items.items[0] : "", textStyle),
        textOffset: selectedTextOffset
      });
      this.closeButton.onPress.connect(() => this.toggle());
      this.openView.addChild(this.closeButton);
    } else {
      this.closeButton.views = {
        defaultView: new graphics.Graphics().beginFill(0, 1e-5).drawRect(0, 0, this.openButton.width, this.openButton.height),
        text: new text.Text(items?.items ? items.items[0] : "", textStyle)
      };
      this.openButton.textOffset = selectedTextOffset;
    }
    if (!this.scrollBox) {
      this.scrollBox = new ScrollBox.ScrollBox();
      this.openView.addChild(this.scrollBox);
    } else {
      this.scrollBox.removeItems();
    }
    this.scrollBox.init({
      type: "vertical",
      elementsMargin: 0,
      width: this.openButton.width,
      height: this.openButton.height * (visibleItems ?? defaultVisibleItems),
      radius: 0,
      padding: 0,
      ...scrollBox
    });
    this.scrollBox.y = this.openButton.height;
    if (scrollBox?.offset) {
      this.scrollBox.x = scrollBox.offset.x ?? 0;
      this.scrollBox.y += scrollBox.offset.y ?? 0;
    }
    this.convertItemsToButtons(items).forEach((button, id) => {
      const text = button.text;
      if (id === selected) {
        this.openButton.text = text;
        this.closeButton.text = text;
      }
      button.onPress.connect(() => {
        this.value = id;
        this.onSelect.emit(id, text);
        this.openButton.text = text;
        this.closeButton.text = text;
        this.close();
      });
      this.scrollBox.addItem(button);
    });
  }
  /** Toggle the select state (open if closed, closes - id open). */
  toggle() {
    this.openView.visible = !this.openView.visible;
    this.openButton.visible = !this.openButton.visible;
  }
  /** Show dropdown. */
  open() {
    this.openView.visible = true;
    this.openButton.visible = false;
  }
  /** Hide dropdown. */
  close() {
    this.openView.visible = false;
    this.openButton.visible = true;
  }
  convertItemsToButtons({
    items,
    backgroundColor,
    hoverColor,
    width,
    height,
    textStyle,
    radius
  }) {
    const buttons = [];
    items.forEach((item) => {
      const defaultView = new graphics.Graphics().beginFill(backgroundColor).drawRoundedRect(0, 0, width, height, radius);
      const color = hoverColor ?? backgroundColor;
      const hoverView = new graphics.Graphics().beginFill(color).drawRoundedRect(0, 0, width, height, radius);
      const text$1 = new text.Text(item, textStyle);
      const button = new FancyButton.FancyButton({ defaultView, hoverView, text: text$1 });
      buttons.push(button);
    });
    return buttons;
  }
}

exports.Select = Select;
//# sourceMappingURL=Select.js.map


/***/ }),

/***/ 33893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var typedSignals = __webpack_require__(31852);
var SliderBase = __webpack_require__(30452);

class Slider extends SliderBase.SliderBase {
  constructor(options) {
    super({
      bg: options.bg,
      slider1: options.slider,
      fill: options.fill ?? "",
      min: options.min,
      max: options.max,
      value1: options.value,
      valueTextStyle: options.valueTextStyle,
      showValue: options.showValue,
      valueTextOffset: options.valueTextOffset,
      fillOffset: options.fillOffset
    });
    /** Fires when value is changing, on every move of slider. */
    this.onUpdate = new typedSignals.Signal();
    /** Fires when value changed, only when slider is released. */
    this.onChange = new typedSignals.Signal();
    this.options = options;
    this.progress = ((options.value ?? this.min) - this.min) / (this.max - this.min) * 100;
    this.value = options.value ?? this.min;
  }
  /** Return selected value. */
  get value() {
    return this._value1;
  }
  /** Set selected value. */
  set value(value) {
    if (value === this._value1)
      return;
    if (value < this.min)
      value = this.min;
    if (value > this.max)
      value = this.max;
    this._value1 = value;
    this.updateSlider();
    this.onUpdate?.emit(this.value);
  }
  /** Set slider instance ot texture. */
  // eslint-disable-next-line accessor-pairs
  set slider(value) {
    this.slider1 = value;
    this.updateSlider();
  }
  update(event) {
    if (!this.dragging)
      return;
    const obj = event.currentTarget;
    const { x } = obj.parent.worldTransform.applyInverse(event.global);
    this.progress = this.validate(x / this.bg.width * 100);
    this.value = this.min + (this.max - this.min) / 100 * this.progress;
  }
  change() {
    this.onChange?.emit(this.value);
  }
  updateSlider() {
    this._slider1.x = (this.bg.width - this._slider1.width) / 100 * this.progress;
    if (this.options.showValue) {
      this.value1Text.text = `${Math.round(this.value)}`;
      const sliderPosX = this._slider1.x + this._slider1.width / 2;
      const sliderPosY = this._slider1.y;
      this.value1Text.x = sliderPosX + (this.options.valueTextOffset?.x ?? 0);
      this.value1Text.y = sliderPosY + (this.options.valueTextOffset?.y ?? 0);
    }
  }
}

exports.Slider = Slider;
//# sourceMappingURL=Slider.js.map


/***/ }),

/***/ 30452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);
var sprite = __webpack_require__(64441);
var text = __webpack_require__(74083);
var ProgressBar = __webpack_require__(76186);
var view = __webpack_require__(52705);

class SliderBase extends ProgressBar.ProgressBar {
  constructor(options) {
    super();
    this.dragging = 0;
    /** Minimal value. */
    this.min = 0;
    /** Maximal value. */
    this.max = 100;
    this.setBackground(options.bg);
    if (options.fill) {
      this.setFill(options.fill, options.fillOffset);
    }
    this.settings = options;
    this.slider1 = options.slider1;
    this.slider2 = options.slider2;
    this.min = options.min ?? 0;
    this.max = options.max ?? 100;
    this.activate();
  }
  /**
   * Sets Slider1 instance.
   * @param value - Container or string with texture name.
   */
  set slider1(value) {
    if (!value)
      return;
    if (this._slider1) {
      this.slider1.removeAllListeners();
      this.removeChild(this._slider1);
      this.slider1.destroy();
    }
    this._slider1 = this.createSlider(value);
    this._slider1.eventMode = "static";
    this._slider1.on("pointerdown", this.startUpdate, this).on("globalpointermove", this.update, this).on("pointerup", this.endUpdate, this).on("pointerupoutside", this.endUpdate, this);
    if (this.settings.showValue && !this.value1Text) {
      this.value1Text = new text.Text("", this.settings.valueTextStyle || { fill: 16777215 });
      this.value1Text.anchor.set(0.5);
      this.addChild(this.value1Text);
    }
  }
  /** Get Slider1 instance. */
  get slider1() {
    return this._slider1;
  }
  /**
   * Sets Slider2 instance.
   * @param value - Container or string with texture name.
   */
  set slider2(value) {
    if (!value)
      return;
    if (this._slider2) {
      this.slider2.removeAllListeners();
      this.removeChild(this._slider2);
      this.slider2.destroy();
    }
    this._slider2 = this.createSlider(value);
    this._slider2.eventMode = "static";
    this._slider2.on("pointerdown", this.startUpdate, this).on("globalpointermove", this.update, this).on("pointerup", this.endUpdate, this).on("pointerupoutside", this.endUpdate, this);
    if (this.settings.showValue && !this.value2Text) {
      this.value2Text = new text.Text("", this.settings.valueTextStyle || { fill: 16777215 });
      this.value2Text.anchor.set(0.5);
      this.addChild(this.value2Text);
    }
  }
  /** Get Slider2 instance. */
  get slider2() {
    return this._slider2;
  }
  /**
   * Set bg.
   * @param bg
   */
  setBackground(bg) {
    if (this.bg) {
      this.bg.removeAllListeners();
    }
    super.setBackground(bg);
    this.activate();
  }
  activate() {
    this.bg.eventMode = "static";
    this.bg.on("pointerdown", this.startUpdate, this).on("globalpointermove", this.update, this).on("pointerup", this.endUpdate, this).on("pointerupoutside", this.endUpdate, this);
    if (this.fill) {
      this.fill.eventMode = "none";
    }
    if (this.value1Text) {
      this.value1Text.eventMode = "none";
    }
    if (this.value2Text) {
      this.value2Text.eventMode = "none";
    }
  }
  createSlider(sliderData) {
    const slider = view.getView(sliderData);
    slider.x = slider.width / 2;
    const container = new display.Container();
    container.addChild(slider);
    if (slider instanceof sprite.Sprite) {
      slider.anchor.set(0.5);
    }
    container.y = this.bg.height / 2;
    this.addChild(container);
    return container;
  }
  startUpdate(event) {
    this.dragging = 1;
    this.startUpdateValue1 = this._value1;
    this.startUpdateValue2 = this._value2;
    this.update(event);
  }
  endUpdate() {
    if (!this.dragging)
      return;
    this.dragging = 0;
    if (this.startUpdateValue1 !== this._value1 || this.startUpdateValue2 !== this._value2) {
      this.change();
    }
    this.startUpdateValue1 = null;
    this.startUpdateValue2 = null;
  }
  /* Called when dragging started and on every move. */
  update(_event) {
  }
  /** Called when dragging stopped. */
  change() {
  }
}

exports.SliderBase = SliderBase;
//# sourceMappingURL=SliderBase.js.map


/***/ }),

/***/ 55807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var display = __webpack_require__(31230);
var typedSignals = __webpack_require__(31852);
var view = __webpack_require__(52705);

class Switcher extends display.Container {
  /**
   * @param {Array<Container | string>} views - Array of views or textures that will be switching.
   * @param triggerEvents - Button events, to switch views (can be one event or an array of events).
   * @param activeViewID - The id of the view, visible by default.
   */
  constructor(views, triggerEvents, activeViewID) {
    super();
    this._triggerEvents = /* @__PURE__ */ new Set(["onPress"]);
    this.innerView = new display.Container();
    this.addChild(this.innerView);
    this.onChange = new typedSignals.Signal();
    if (views)
      this.views = views;
    if (triggerEvents)
      this.triggerEvents = triggerEvents;
    if (activeViewID && this.views.length > 0)
      this.active = activeViewID;
    this.setInteractionEvents();
  }
  setInteractionEvents() {
    this.innerView.eventMode = "static";
    this.innerView.on("pointerdown", () => this.handleEvents("onDown"));
    this.innerView.on("pointerup", () => this.handleEvents("onUp"));
    this.innerView.on("pointerupoutside", () => this.handleEvents("onUpOut"));
    this.innerView.on("pointerout", () => this.handleEvents("onOut"));
    this.innerView.on("pointertap", () => this.handleEvents("onPress"));
    this.innerView.on("pointerover", () => this.handleEvents("onHover"));
  }
  handleEvents(event) {
    if (this._triggerEvents.has(event)) {
      this.switch();
    }
  }
  /** Returns the active view. */
  get activeView() {
    if (this.views && this.views[this.active]) {
      return this.views[this.active];
    }
    return void 0;
  }
  /** Sets the list of instances for switching. */
  set views(views) {
    this.innerView.removeChildren();
    views.forEach((stateView) => this.add(stateView));
  }
  /** Returns all the switchable views */
  get views() {
    return this.innerView.children;
  }
  /**
   * Adds view instance to a switching list.
   * @param view
   */
  add(view$1) {
    const viewInstance = view.getView(view$1);
    this.innerView.addChild(viewInstance);
    viewInstance.visible = false;
    if (this.views.length === 1) {
      this.active = 0;
    }
  }
  /**
   * Removes view instance from a switching list by id.
   * @param id - id of the view to remove.
   */
  remove(id) {
    if (this.views[id]) {
      this.innerView.removeChild(this.views[id]);
    }
  }
  /**
   * Sets a list of events that will make a switcher switch to the next view.
   * @param {ButtonEvent | ButtonEvent[]} triggerEvents - Button events,
   * to switch views (can be one event or an array of events).
   */
  set triggerEvents(triggerEvents) {
    this._triggerEvents = new Set(Array.isArray(triggerEvents) ? triggerEvents : [triggerEvents]);
  }
  /** Returns a list of events that will make a switcher switch to the next view. */
  get triggerEvents() {
    return Array.from(this._triggerEvents);
  }
  /**
   * Show a view by id, or to next one by order, if no ID provided.
   * @param {number} id - optional id of the view to show. If not set, will switch to the next view.
   */
  switch(id) {
    if (id !== void 0 && id === this.active)
      return;
    const exID = this.active;
    this.forceSwitch(id);
    if (exID !== this.active) {
      const res = this.views.length > 2 ? this.active : this.active === 1;
      this.onChange.emit(res);
    }
  }
  /**
   * Switches a view to a given one without triggering the onChange event.
   * @param {number} id - optional id of the view to show. If not set, will switch to the next view.
   */
  forceSwitch(id) {
    if (id !== void 0 && id === this.active)
      return;
    if (this.activeView) {
      this.activeView.visible = false;
    }
    if (id !== void 0 && !this.views[id]) {
      throw new Error(`View with id ${id} does not exist.`);
    }
    this._active = id !== void 0 ? id : this.nextActive;
    if (this._active === void 0) {
      return;
    }
    this.views[this.active].visible = true;
  }
  /** Returns the id of the next view in order. Or undefined, if order is empty. */
  get nextActive() {
    if (this.views.length === 0)
      return void 0;
    return this.active < this.views.length - 1 ? this.active + 1 : 0;
  }
  /** Sets the id of the visible(active) view and shows to it. */
  set active(id) {
    this.switch(id);
  }
  /** Gets the id of the visible(active) view. */
  get active() {
    return this._active;
  }
}

exports.Switcher = Switcher;
//# sourceMappingURL=Switcher.js.map


/***/ }),

/***/ 85930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Button = __webpack_require__(25296);
var CheckBox = __webpack_require__(61037);
var DoubleSlider = __webpack_require__(23696);
var FancyButton = __webpack_require__(43055);
var Input = __webpack_require__(90626);
var List = __webpack_require__(66280);
var MaskedFrame = __webpack_require__(62564);
var ProgressBar = __webpack_require__(76186);
var RadioGroup = __webpack_require__(44754);
var ScrollBox = __webpack_require__(81460);
var Select = __webpack_require__(85664);
var Slider = __webpack_require__(33893);
var Switcher = __webpack_require__(55807);



exports.Button = Button.Button;
exports.ButtonContainer = Button.ButtonContainer;
exports.CheckBox = CheckBox.CheckBox;
exports.DoubleSlider = DoubleSlider.DoubleSlider;
exports.FancyButton = FancyButton.FancyButton;
exports.Input = Input.Input;
exports.List = List.List;
exports.MaskedFrame = MaskedFrame.MaskedFrame;
exports.ProgressBar = ProgressBar.ProgressBar;
exports.RadioGroup = RadioGroup.RadioGroup;
exports.ScrollBox = ScrollBox.ScrollBox;
exports.Select = Select.Select;
exports.Slider = Slider.Slider;
exports.Switcher = Switcher.Switcher;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 99798:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function cleanup(element) {
  if (!element)
    return;
  if (element.parent) {
    element.parent.removeChild(element);
  }
  element.destroy();
  element = null;
}

exports.cleanup = cleanup;
//# sourceMappingURL=cleanup.js.map


/***/ }),

/***/ 29813:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function fitToView(parent, child, padding = 0) {
  let scaleX = child.scale.x;
  let scaleY = child.scale.y;
  const maxWidth = parent.width - padding * 2;
  const maxHeight = parent.height - padding * 2;
  const widthOverflow = maxWidth - Math.round(child.width);
  const heightOverflow = maxHeight - Math.round(child.height);
  if (widthOverflow < 0) {
    scaleX = maxWidth / (child.width * scaleX);
  }
  if (heightOverflow < 0) {
    scaleY = maxHeight / (child.height * scaleY);
  }
  if (scaleX <= 0 || scaleY <= 0) {
    child.visible = false;
  }
  child.scale.set(Math.min(scaleX, scaleY));
}

exports.fitToView = fitToView;
//# sourceMappingURL=fit.js.map


/***/ }),

/***/ 48363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var text = __webpack_require__(74083);

function getTextView(text$1) {
  if (typeof text$1 === "string" || typeof text$1 === "number") {
    return new text.Text(String(text$1));
  }
  return text$1;
}

exports.getTextView = getTextView;
//# sourceMappingURL=text.js.map


/***/ }),

/***/ 52705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var sprite = __webpack_require__(64441);

function getView(view) {
  if (typeof view === "string") {
    return sprite.Sprite.from(view);
  }
  return view;
}

exports.getView = getView;
//# sourceMappingURL=view.js.map


/***/ }),

/***/ 98705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var Spring = __webpack_require__(32440);

class ScrollSpring {
  constructor() {
    this._spring = new Spring.Spring();
    this._pos = 0;
    this.to = 0;
  }
  start(speed, pos, to) {
    this._speed = speed;
    this._pos = pos;
    this.to = to;
    this.done = false;
    this._spring.x = this._pos;
    this._spring.tx = this.to;
    const diff = this.to - this._pos;
    const toDirection = Math.abs(diff) / diff;
    const currentDirection = Math.abs(this._speed) / this._speed;
    if (toDirection !== currentDirection) {
      this._correctSpeed = true;
    } else {
      this._correctSpeed = false;
    }
  }
  update() {
    if (this._correctSpeed) {
      this._speed *= 0.6;
      if (Math.abs(this._speed) < 2) {
        this._correctSpeed = false;
      }
      this._pos += this._speed;
      this._spring.x = this._pos;
    } else {
      const diff = this.to - this._pos;
      if (Math.abs(diff) < 0.05) {
        this._pos = this.to;
        this.done = true;
      } else {
        this._spring.tx = this.to;
        this._spring.update();
        this._pos = this._spring.x;
      }
    }
    return this._pos;
  }
  cancel() {
  }
}

exports["default"] = ScrollSpring;
//# sourceMappingURL=ScrollSpring.js.map


/***/ }),

/***/ 18886:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var ScrollSpring = __webpack_require__(98705);

class SlidingNumber {
  constructor(options = {}) {
    this.position = 0;
    this.constrain = true;
    this.min = 0;
    // the window width of the drag
    this.max = 0;
    // the window width of the drag
    this.maxSpeed = 400;
    this._offset = 0;
    this._prev = 0;
    this._speed = 0;
    this._targetSpeed = 0;
    this._speedChecker = 0;
    this._grab = 0;
    this.constrain = options.constrain ?? true;
    this.maxSpeed = options.maxSpeed ?? 400;
    this._ease = options.ease ?? new ScrollSpring.default();
  }
  set value(n) {
    this._speed = 0;
    this.position = n;
  }
  get value() {
    return this.position;
  }
  grab(offset) {
    this._grab = offset;
    this._offset = this.position - offset;
    this._speedChecker = 0;
    this._targetSpeed = this._speed = 0;
    this._hasStopped = false;
  }
  hold(newPosition) {
    this._speedChecker++;
    this.position = newPosition + this._offset;
    if (this._speedChecker > 1) {
      this._targetSpeed = this.position - this._prev;
    }
    this._speed += (this._targetSpeed - this._speed) / 2;
    if (this._speed > this.maxSpeed)
      this._speed = this.maxSpeed;
    else if (this._speed < -this.maxSpeed)
      this._speed = -this.maxSpeed;
    this._prev = this.position;
    if (this.constrain) {
      this._activeEase = null;
      if (this.position > this.min) {
        this.position -= (this.position - this.min) / 1.5;
      } else if (this.position < this.max) {
        this.position += (this.max - this.position) / 1.5;
      }
    }
  }
  slide(instant = false) {
    if (this._hasStopped)
      return;
    if (this.constrain) {
      this._updateConstrain(instant);
    } else {
      this._updateDefault();
    }
  }
  get moveAmount() {
    return -(this.position - this._offset - this._grab);
  }
  _updateDefault() {
    this._speed *= 0.9;
    this.position += this._speed;
    if ((this._speed < 0 ? this._speed * -1 : this._speed) < 0.01) {
      this._hasStopped = true;
    }
  }
  _updateConstrain(instant = false) {
    const max = this.max;
    if (instant) {
      if (this.value > 0) {
        this.value = 0;
      }
      if (this.value > 0) {
        this.value = 0;
      }
      if (this.value < this.max) {
        this.value = this.max;
      }
      if (this.value < this.max) {
        this.value = this.max;
      }
    } else if (this.position > this.min || this.position < max || this._activeEase) {
      if (!this._activeEase) {
        this._activeEase = this._ease;
        if (this.position > this.min) {
          this._activeEase.start(this._speed, this.position, this.min);
        } else {
          this._activeEase.start(this._speed, this.position, max);
        }
      }
      this.position = this._activeEase.update();
      if (this._activeEase.done) {
        this.position = this._activeEase.to;
        this._speed = 0;
        this._activeEase = null;
      }
    } else {
      this._updateDefault();
    }
  }
}

exports.SlidingNumber = SlidingNumber;
//# sourceMappingURL=SlidingNumber.js.map


/***/ }),

/***/ 32440:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class Spring {
  constructor(options = {}) {
    this.x = 0;
    this.ax = 0;
    this.dx = 0;
    this.tx = 0;
    this._options = options;
    this._options.max = options.max || 160;
    this._options.damp = options.damp || 0.8;
    this._options.springiness = options.springiness || 0.1;
  }
  update() {
    this.ax = (this.tx - this.x) * this._options.springiness;
    this.dx += this.ax;
    this.dx *= this._options.damp;
    if (this.dx < -this._options.max)
      this.dx = -this._options.max;
    else if (this.dx > this._options.max)
      this.dx = this._options.max;
    this.x += this.dx;
  }
  reset() {
    this.x = 0;
    this.ax = 0;
    this.dx = 0;
    this.tx = 0;
  }
  get max() {
    return this._options.max;
  }
  set max(value) {
    this._options.max = value;
  }
  get damp() {
    return this._options.damp;
  }
  set damp(value) {
    this._options.damp = value;
  }
  get springiness() {
    return this._options.springiness;
  }
  set springiness(value) {
    this._options.springiness = value;
  }
}

exports.Spring = Spring;
//# sourceMappingURL=Spring.js.map


/***/ }),

/***/ 17117:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(11491);
var SlidingNumber = __webpack_require__(18886);

class Trackpad {
  constructor(options) {
    this.disableEasing = false;
    this.xAxis = new SlidingNumber.SlidingNumber({
      ease: options.xEase,
      maxSpeed: options.maxSpeed,
      constrain: options.constrain
    });
    this.yAxis = new SlidingNumber.SlidingNumber({
      ease: options.yEase,
      maxSpeed: options.maxSpeed,
      constrain: options.constrain
    });
    this.disableEasing = options.disableEasing ?? false;
    this._frame = new core.Rectangle();
    this._bounds = new core.Rectangle();
    this._globalPosition = new core.Point();
  }
  pointerDown(pos) {
    this._globalPosition = pos;
    this.xAxis.grab(pos.x);
    this.yAxis.grab(pos.y);
    this._isDown = true;
  }
  pointerUp() {
    this._isDown = false;
  }
  pointerMove(pos) {
    this._globalPosition = pos;
  }
  update() {
    if (this._dirty) {
      this._dirty = false;
      this.xAxis.min = this._bounds.left;
      this.xAxis.min = this._bounds.right - this._frame.width;
      this.xAxis.min = this._bounds.top;
      this.xAxis.min = this._bounds.bottom - this._frame.height;
    }
    if (this._isDown) {
      this.xAxis.hold(this._globalPosition.x);
      this.yAxis.hold(this._globalPosition.y);
    } else {
      this.xAxis.slide(this.disableEasing);
      this.yAxis.slide(this.disableEasing);
    }
  }
  resize(w, h) {
    this._frame.x = 0;
    this._frame.width = w;
    this._frame.y = 0;
    this._frame.height = h;
    this._dirty = true;
  }
  setBounds(minX, maxX, minY, maxY) {
    this._bounds.x = minX;
    this._bounds.width = maxX - minX;
    this._bounds.y = minY;
    this._bounds.height = maxY - minY;
    this._dirty = true;
  }
  get x() {
    return this.xAxis.value;
  }
  get y() {
    return this.yAxis.value;
  }
}

exports.Trackpad = Trackpad;
//# sourceMappingURL=Trackpad.js.map


/***/ }),

/***/ 47894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var deprecation = __webpack_require__(70849);

function skipHello() {
  deprecation.deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello() {
  deprecation.deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}

exports.sayHello = sayHello;
exports.skipHello = skipHello;
//# sourceMappingURL=hello.js.map


/***/ }),

/***/ 34249:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(84728);
var settings = __webpack_require__(1405);

let supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas = settings.settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}

exports.isWebGLSupported = isWebGLSupported;
//# sourceMappingURL=isWebGLSupported.js.map


/***/ }),

/***/ 81880:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(61595);
var deprecation = __webpack_require__(70849);

function hex2rgb(hex, out = []) {
  deprecation.deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");
  return color.Color.shared.setValue(hex).toRgbArray(out);
}
function hex2string(hex) {
  deprecation.deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");
  return color.Color.shared.setValue(hex).toHex();
}
function string2hex(string) {
  deprecation.deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");
  return color.Color.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  deprecation.deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");
  return color.Color.shared.setValue(rgb).toNumber();
}

exports.hex2rgb = hex2rgb;
exports.hex2string = hex2string;
exports.rgb2hex = rgb2hex;
exports.string2hex = string2hex;
//# sourceMappingURL=hex.js.map


/***/ }),

/***/ 52232:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var color = __webpack_require__(61595);
var constants = __webpack_require__(21837);
var deprecation = __webpack_require__(70849);

function mapPremultipliedBlendModes() {
  const pm = [];
  const npm = [];
  for (let i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[constants.BLEND_MODES.NORMAL_NPM] = constants.BLEND_MODES.NORMAL;
  pm[constants.BLEND_MODES.ADD_NPM] = constants.BLEND_MODES.ADD;
  pm[constants.BLEND_MODES.SCREEN_NPM] = constants.BLEND_MODES.SCREEN;
  npm[constants.BLEND_MODES.NORMAL] = constants.BLEND_MODES.NORMAL_NPM;
  npm[constants.BLEND_MODES.ADD] = constants.BLEND_MODES.ADD_NPM;
  npm[constants.BLEND_MODES.SCREEN] = constants.BLEND_MODES.SCREEN_NPM;
  const array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply = true) {
  deprecation.deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);
  return color.Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  deprecation.deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);
  return color.Color.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out, premultiply = true) {
  deprecation.deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);
  return color.Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}

exports.correctBlendMode = correctBlendMode;
exports.premultiplyBlendMode = premultiplyBlendMode;
exports.premultiplyRgba = premultiplyRgba;
exports.premultiplyTint = premultiplyTint;
exports.premultiplyTintToRgba = premultiplyTintToRgba;
//# sourceMappingURL=premultiply.js.map


/***/ }),

/***/ 48230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

exports.DATA_URI = DATA_URI;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ 67258:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
    outBuffer[i + 0] = j + 0;
    outBuffer[i + 1] = j + 1;
    outBuffer[i + 2] = j + 2;
    outBuffer[i + 3] = j + 0;
    outBuffer[i + 4] = j + 2;
    outBuffer[i + 5] = j + 3;
  }
  return outBuffer;
}

exports.createIndicesForQuads = createIndicesForQuads;
//# sourceMappingURL=createIndicesForQuads.js.map


/***/ }),

/***/ 19056:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}

exports.getBufferType = getBufferType;
//# sourceMappingURL=getBufferType.js.map


/***/ }),

/***/ 72171:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var getBufferType = __webpack_require__(19056);

const map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = getBufferType.getBufferType(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}

exports.interleaveTypedArrays = interleaveTypedArrays;
//# sourceMappingURL=interleaveTypedArrays.js.map


/***/ }),

/***/ 18660:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function nextPow2(v) {
  v += v === 0 ? 1 : 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  let r = (v > 65535 ? 1 : 0) << 4;
  v >>>= r;
  let shift = (v > 255 ? 1 : 0) << 3;
  v >>>= shift;
  r |= shift;
  shift = (v > 15 ? 1 : 0) << 2;
  v >>>= shift;
  r |= shift;
  shift = (v > 3 ? 1 : 0) << 1;
  v >>>= shift;
  r |= shift;
  return r | v >> 1;
}

exports.isPow2 = isPow2;
exports.log2 = log2;
exports.nextPow2 = nextPow2;
//# sourceMappingURL=pow2.js.map


/***/ }),

/***/ 12242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}

exports.removeItems = removeItems;
//# sourceMappingURL=removeItems.js.map


/***/ }),

/***/ 30489:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function sign(n) {
  if (n === 0)
    return 0;
  return n < 0 ? -1 : 1;
}

exports.sign = sign;
//# sourceMappingURL=sign.js.map


/***/ }),

/***/ 88564:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

let nextUid = 0;
function uid() {
  return ++nextUid;
}

exports.uid = uid;
//# sourceMappingURL=uid.js.map


/***/ }),

/***/ 61973:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(84728);
var settings = __webpack_require__(1405);
var eventemitter3 = __webpack_require__(30228);
var earcut = __webpack_require__(66570);
var url = __webpack_require__(36468);
var path = __webpack_require__(22526);
var hello = __webpack_require__(47894);
var isWebGLSupported = __webpack_require__(34249);
var hex = __webpack_require__(81880);
var premultiply = __webpack_require__(52232);
var _const = __webpack_require__(48230);
var createIndicesForQuads = __webpack_require__(67258);
var getBufferType = __webpack_require__(19056);
var interleaveTypedArrays = __webpack_require__(72171);
var pow2 = __webpack_require__(18660);
var removeItems = __webpack_require__(12242);
var sign = __webpack_require__(30489);
var uid = __webpack_require__(88564);
var deprecation = __webpack_require__(70849);
var BoundingBox = __webpack_require__(19191);
var caches = __webpack_require__(62507);
var CanvasRenderTarget = __webpack_require__(74113);
var getCanvasBoundingBox = __webpack_require__(37081);
var trimCanvas = __webpack_require__(13460);
var decomposeDataUri = __webpack_require__(88719);
var determineCrossOrigin = __webpack_require__(8059);
var getResolutionOfUrl = __webpack_require__(78606);
__webpack_require__(64083);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var eventemitter3__default = /*#__PURE__*/_interopDefaultLegacy(eventemitter3);
var earcut__default = /*#__PURE__*/_interopDefaultLegacy(earcut);



Object.defineProperty(exports, "isMobile", ({
	enumerable: true,
	get: function () { return settings.isMobile; }
}));
Object.defineProperty(exports, "EventEmitter", ({
	enumerable: true,
	get: function () { return eventemitter3__default["default"]; }
}));
Object.defineProperty(exports, "earcut", ({
	enumerable: true,
	get: function () { return earcut__default["default"]; }
}));
exports.url = url.url;
exports.path = path.path;
exports.sayHello = hello.sayHello;
exports.skipHello = hello.skipHello;
exports.isWebGLSupported = isWebGLSupported.isWebGLSupported;
exports.hex2rgb = hex.hex2rgb;
exports.hex2string = hex.hex2string;
exports.rgb2hex = hex.rgb2hex;
exports.string2hex = hex.string2hex;
exports.correctBlendMode = premultiply.correctBlendMode;
exports.premultiplyBlendMode = premultiply.premultiplyBlendMode;
exports.premultiplyRgba = premultiply.premultiplyRgba;
exports.premultiplyTint = premultiply.premultiplyTint;
exports.premultiplyTintToRgba = premultiply.premultiplyTintToRgba;
exports.DATA_URI = _const.DATA_URI;
exports.createIndicesForQuads = createIndicesForQuads.createIndicesForQuads;
exports.getBufferType = getBufferType.getBufferType;
exports.interleaveTypedArrays = interleaveTypedArrays.interleaveTypedArrays;
exports.isPow2 = pow2.isPow2;
exports.log2 = pow2.log2;
exports.nextPow2 = pow2.nextPow2;
exports.removeItems = removeItems.removeItems;
exports.sign = sign.sign;
exports.uid = uid.uid;
exports.deprecation = deprecation.deprecation;
exports.BoundingBox = BoundingBox.BoundingBox;
exports.BaseTextureCache = caches.BaseTextureCache;
exports.ProgramCache = caches.ProgramCache;
exports.TextureCache = caches.TextureCache;
exports.clearTextureCache = caches.clearTextureCache;
exports.destroyTextureCache = caches.destroyTextureCache;
exports.CanvasRenderTarget = CanvasRenderTarget.CanvasRenderTarget;
exports.getCanvasBoundingBox = getCanvasBoundingBox.getCanvasBoundingBox;
exports.trimCanvas = trimCanvas.trimCanvas;
exports.decomposeDataUri = decomposeDataUri.decomposeDataUri;
exports.determineCrossOrigin = determineCrossOrigin.determineCrossOrigin;
exports.getResolutionOfUrl = getResolutionOfUrl.getResolutionOfUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 70849:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const warnings = {};
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}

exports.deprecation = deprecation;
//# sourceMappingURL=deprecation.js.map


/***/ }),

/***/ 19191:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const _BoundingBox = class {
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
let BoundingBox = _BoundingBox;
BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);

exports.BoundingBox = BoundingBox;
//# sourceMappingURL=BoundingBox.js.map


/***/ }),

/***/ 74113:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(1405);

class CanvasRenderTarget {
  constructor(width, height, resolution) {
    this._canvas = settings.settings.ADAPTER.createCanvas();
    this._context = this._canvas.getContext("2d");
    this.resolution = resolution || settings.settings.RESOLUTION;
    this.resize(width, height);
  }
  clear() {
    this._checkDestroyed();
    this._context.setTransform(1, 0, 0, 1, 0, 0);
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed();
    this._canvas.width = Math.round(desiredWidth * this.resolution);
    this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  destroy() {
    this._context = null;
    this._canvas = null;
  }
  get width() {
    this._checkDestroyed();
    return this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed();
    this._canvas.width = Math.round(val);
  }
  get height() {
    this._checkDestroyed();
    return this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed();
    this._canvas.height = Math.round(val);
  }
  get canvas() {
    this._checkDestroyed();
    return this._canvas;
  }
  get context() {
    this._checkDestroyed();
    return this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null) {
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
    }
  }
}

exports.CanvasRenderTarget = CanvasRenderTarget;
//# sourceMappingURL=CanvasRenderTarget.js.map


/***/ }),

/***/ 62507:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const ProgramCache = {};
const TextureCache = /* @__PURE__ */ Object.create(null);
const BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
}
function clearTextureCache() {
  let key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}

exports.BaseTextureCache = BaseTextureCache;
exports.ProgramCache = ProgramCache;
exports.TextureCache = TextureCache;
exports.clearTextureCache = clearTextureCache;
exports.destroyTextureCache = destroyTextureCache;
//# sourceMappingURL=caches.js.map


/***/ }),

/***/ 37081:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var BoundingBox = __webpack_require__(19191);

function checkRow(data, width, y) {
  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x, top, bottom) {
  const stride = 4 * width;
  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas;
  const context = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return BoundingBox.BoundingBox.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new BoundingBox.BoundingBox(left, top, right, bottom);
}

exports.getCanvasBoundingBox = getCanvasBoundingBox;
//# sourceMappingURL=getCanvasBoundingBox.js.map


/***/ }),

/***/ 13460:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var getCanvasBoundingBox = __webpack_require__(37081);

function trimCanvas(canvas) {
  const boundingBox = getCanvasBoundingBox.getCanvasBoundingBox(canvas);
  const { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context = canvas.getContext("2d");
    if (context === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    data = context.getImageData(boundingBox.left, boundingBox.top, width, height);
  }
  return { width, height, data };
}

exports.trimCanvas = trimCanvas;
//# sourceMappingURL=trimCanvas.js.map


/***/ }),

/***/ 88719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _const = __webpack_require__(48230);

function decomposeDataUri(dataUri) {
  const dataUriMatch = _const.DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
  }
  return void 0;
}

exports.decomposeDataUri = decomposeDataUri;
//# sourceMappingURL=decomposeDataUri.js.map


/***/ }),

/***/ 8059:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var url = __webpack_require__(36468);

let tempAnchor;
function determineCrossOrigin(url$1, loc = globalThis.location) {
  if (url$1.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor) {
    tempAnchor = document.createElement("a");
  }
  tempAnchor.href = url$1;
  const parsedUrl = url.url.parse(tempAnchor.href);
  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}

exports.determineCrossOrigin = determineCrossOrigin;
//# sourceMappingURL=determineCrossOrigin.js.map


/***/ }),

/***/ 78606:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(84728);
var settings = __webpack_require__(1405);

function getResolutionOfUrl(url, defaultValue = 1) {
  const resolution = settings.settings.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue;
}

exports.getResolutionOfUrl = getResolutionOfUrl;
//# sourceMappingURL=getResolutionOfUrl.js.map


/***/ }),

/***/ 22526:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(1405);

function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code = path2.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i)}`;
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  hasProtocol(path2) {
    return /^[^/:]+:\//.test(this.toPosix(path2));
  },
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let protocol = "";
    const isFile = /^file:\/\/\//.exec(path2);
    const isHttp = /^[^/:]+:\/\//.exec(path2);
    const isWindows = /^[^/:]+:\//.exec(path2);
    if (isFile || isHttp || isWindows) {
      const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];
      protocol = arr;
      path2 = path2.slice(arr.length);
    }
    return protocol;
  },
  toAbsolute(url, customBaseUrl, customRootUrl) {
    if (this.isDataUrl(url))
      return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.settings.ADAPTER.getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    assertPath(url);
    url = this.toPosix(url);
    if (url.startsWith("/")) {
      return path.join(rootUrl, url.slice(1));
    }
    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
    return absolutePath;
  },
  normalize(path2) {
    path2 = this.toPosix(path2);
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol + path2;
  },
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i - 1] ?? "";
          if (this.extname(prevArg)) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; i >= 1; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/"))
      root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      if (index !== -1) {
        root = path2.slice(0, index);
      } else
        root = path2;
      if (!root.endsWith("/"))
        root += "/";
    }
    return root;
  },
  basename(path2, ext) {
    assertPath(path2);
    if (ext)
      assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i = path2.length - 1; i >= 0; --i) {
      if (path2.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    const protocol = "";
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    if (protocol)
      ret.dir = protocol + ret.dir;
    return ret;
  },
  sep: "/",
  delimiter: ":"
};

exports.path = path;
//# sourceMappingURL=path.js.map


/***/ }),

/***/ 84728:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var settings = __webpack_require__(1405);

settings.settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;

Object.defineProperty(exports, "settings", ({
	enumerable: true,
	get: function () { return settings.settings; }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ 64083:
/***/ (() => {

"use strict";


//# sourceMappingURL=index.js.map


/***/ }),

/***/ 36468:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var url$1 = __webpack_require__(88835);

const url = {
  parse: url$1.parse,
  format: url$1.format,
  resolve: url$1.resolve
};

exports.url = url;
//# sourceMappingURL=url.js.map


/***/ }),

/***/ 13144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(66743);

var $apply = __webpack_require__(11002);
var $call = __webpack_require__(10076);
var $reflectApply = __webpack_require__(47119);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ 11002:
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ 10076:
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ 73126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(66743);
var $TypeError = __webpack_require__(69675);

var $call = __webpack_require__(10076);
var $actualApply = __webpack_require__(13144);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ 47119:
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ 36556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(70453);

var callBindBasic = __webpack_require__(73126);

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


/***/ }),

/***/ 56284:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:!0}));var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},o=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},a=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},s=/^#([0-9a-f]{3,8})$/i,i=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,o=Math.max(t,n,e),a=o-Math.min(t,n,e),s=a?o===t?(n-e)/a:o===n?2+(e-t)/a:4+(t-n)/a:0;return{h:60*(s<0?s+6:s),s:o?a/o*100:0,v:o/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var o=Math.floor(t),a=e*(1-n),s=e*(1-(t-o)*n),i=e*(1-(1-t+o)*n),h=o%6;return{r:255*[e,s,a,a,i,e][h],g:255*[i,e,e,s,a,a][h],b:255*[a,a,i,e,e,s][h],a:u}},d=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},g=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},p=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,c=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=s.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:o({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||c.exec(t);if(!n)return null;var e,u,o=d({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(o)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,a=r.a,s=void 0===a?1:a;return t(n)&&t(e)&&t(u)?o({r:Number(n),g:Number(e),b:Number(u),a:Number(s)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,o=r.a,a=void 0===o?1:o;if(!t(n)||!t(e)||!t(u))return null;var s=d({h:Number(n),s:Number(e),l:Number(u),a:Number(a)});return f(s)},"hsl"],[function(r){var n=r.h,o=r.s,a=r.v,s=r.a,i=void 0===s?1:s;if(!t(n)||!t(o)||!t(a))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(o),v:Number(a),a:Number(i)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=p(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},I=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},H=function(r,t){var n=p(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},$=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(I(this.rgba),2)},r.prototype.isDark=function(){return I(this.rgba)<.5},r.prototype.isLight=function(){return I(this.rgba)>=.5},r.prototype.toHex=function(){return r=a(this.rgba),t=r.r,e=r.g,u=r.b,s=(o=r.a)<1?i(n(255*o)):"","#"+i(t)+i(e)+i(u)+s;var r,t,e,u,o,s},r.prototype.toRgb=function(){return a(this.rgba)},r.prototype.toRgbString=function(){return r=a(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return g(p(this.rgba))},r.prototype.toHslString=function(){return r=g(p(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return j({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,-r))},r.prototype.grayscale=function(){return j(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),j(H(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),j(H(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?j({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=p(this.rgba);return"number"==typeof r?j({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===j(r).toHex()},r}(),j=function(r){return r instanceof $?r:new $(r)},w=[];exports.Colord=$,exports.colord=j,exports.extend=function(r){r.forEach(function(r){w.indexOf(r)<0&&(r($,y),w.push(r))})},exports.getFormat=function(r){return x(r)[1]},exports.random=function(){return new $({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};


/***/ }),

/***/ 9439:
/***/ ((module) => {

module.exports=function(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,o=r[this.toHex()];if(o)return o;if(null==f?void 0:f.closest){var n=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=n,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])};


/***/ }),

/***/ 7176:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(73126);
var gOPD = __webpack_require__(75795);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ 66570:
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ 30655:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 41237:
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 69383:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 79290:
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 79538:
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 58068:
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 69675:
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 35345:
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 79612:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ 30228:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 89353:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 66743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(89353);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 70453:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(79612);

var $Error = __webpack_require__(69383);
var $EvalError = __webpack_require__(41237);
var $RangeError = __webpack_require__(79290);
var $ReferenceError = __webpack_require__(79538);
var $SyntaxError = __webpack_require__(58068);
var $TypeError = __webpack_require__(69675);
var $URIError = __webpack_require__(35345);

var abs = __webpack_require__(71514);
var floor = __webpack_require__(58968);
var max = __webpack_require__(6188);
var min = __webpack_require__(68002);
var pow = __webpack_require__(75880);
var round = __webpack_require__(70414);
var sign = __webpack_require__(73093);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(75795);
var $defineProperty = __webpack_require__(30655);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(64039)();

var getProto = __webpack_require__(93628);
var $ObjectGPO = __webpack_require__(71064);
var $ReflectGPO = __webpack_require__(48648);

var $apply = __webpack_require__(11002);
var $call = __webpack_require__(10076);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(66743);
var hasOwn = __webpack_require__(9957);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 71064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(79612);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ 48648:
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ 93628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(48648);
var originalGetProto = __webpack_require__(71064);

var getDunderProto = __webpack_require__(7176);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ 6549:
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ 75795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(6549);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 64039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(41333);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 41333:
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 9957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(66743);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ 94196:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Handle stopping all sounds globally.
     */
    stop: function() {
      var self = this || Howler;

      // Loop through all Howls and stop them.
      for (var i=0; i<self._howls.length; i++) {
        self._howls[i].stop();
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var ua = self._navigator ? self._navigator.userAgent : '';
      var checkOpera = ua.match(/OPR\/(\d+)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
      var safariVersion = ua.match(/Version\/(.*?) /);
      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        while (self._html5AudioPool.length < self.html5PoolSize) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
            break;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);
          document.removeEventListener('keydown', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);
      document.addEventListener('keydown', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';

        // Handle updating the state of the audio context after suspending.
        var handleSuspension = function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        };

        // Either the state gets suspended or it is interrupted.
        // Either way, we need to update the state to suspended.
        self.ctx.suspend().then(handleSuspension, handleSuspension);
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhr = {
        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
      };

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload && self._preload !== 'none') {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                  } else {
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;
          self._state = 'loading';

          var listener = function() {
            self._state = 'loaded';
            
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = Math.min(Math.max(0, parseFloat(from)), 1);
      to = Math.min(Math.max(0, parseFloat(to)), 1);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Make sure the volume is in the right bounds.
        if (diff < 0) {
          vol = Math.max(to, vol);
        } else {
          vol = Math.min(to, vol);
        }

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;

              // If playing, restart playback to ensure looping updates.
              if (self.playing(ids[i])) {
                self.pause(ids[i], true);
                self.play(ids[i], true);
              }
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        if (self._sounds.length) {
          id = self._sounds[0]._id;
        }
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return 0;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }

            self._emit('seek', id);
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (!node.bufferSource) {
        return self;
      }

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Listen for the 'ended' event on the sound to account for edge-case where
        // a finite sound has a duration of Infinity.
        self._endFn = self._endListener.bind(self);
        self._node.addEventListener('ended', self._endFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    },

    /**
     * HTML5 Audio ended listener callback.
     */
    _endListener: function() {
      var self = this;
      var parent = self._parent;

      // Only handle the `ended`` event if the duration is Infinity.
      if (parent._duration === Infinity) {
        // Update the parent duration to match the real audio duration.
        // Round up the duration to account for the lower precision in HTML5 Audio.
        parent._duration = Math.ceil(self._node.duration * 10) / 10;

        // Update the sprite that corresponds to the real duration.
        if (parent._sprite.__default[1] === Infinity) {
          parent._sprite.__default[1] = parent._duration * 1000;
        }

        // Run the regular ended method.
        parent._ended(self);
      }

      // Clear the event listener since the duration is now correct.
      self._node.removeEventListener('ended', self._endFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open(self._xhr.method, url, true);
      xhr.withCredentials = self._xhr.withCredentials;
      xhr.responseType = 'arraybuffer';

      // Apply any custom headers to the request.
      if (self._xhr.headers) {
        Object.keys(self._xhr.headers).forEach(function(key) {
          xhr.setRequestHeader(key, self._xhr.headers[key]);
        });
      }

      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  // Add support for CommonJS libraries such as browserify.
  if (true) {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Add to global in Node.js (for testing, etc).
  if (typeof __webpack_require__.g !== 'undefined') {
    __webpack_require__.g.HowlerGlobal = HowlerGlobal;
    __webpack_require__.g.Howler = Howler;
    __webpack_require__.g.Howl = Howl;
    __webpack_require__.g.Sound = Sound;
  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Create a new panner node if one doesn't already exist.
        var panner = sound._panner;
        if (!panner) {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
          panner = sound._panner
        }

        // Update the panner values or create a new panner if none exists.
        panner.coneInnerAngle = pa.coneInnerAngle;
        panner.coneOuterAngle = pa.coneOuterAngle;
        panner.coneOuterGain = pa.coneOuterGain;
        panner.distanceModel = pa.distanceModel;
        panner.maxDistance = pa.maxDistance;
        panner.refDistance = pa.refDistance;
        panner.rolloffFactor = pa.rolloffFactor;
        panner.panningModel = pa.panningModel;
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();


/***/ }),

/***/ 22437:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* reexport */ isMobile)
});

;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/isMobile.js
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
        navigator.platform === 'MacIntel' &&
        typeof navigator.maxTouchPoints === 'number' &&
        navigator.maxTouchPoints > 1 &&
        typeof MSStream === 'undefined');
};
function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
}
function isMobile(param) {
    var nav = {
        userAgent: '',
        platform: '',
        maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
        nav = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
    }
    else if (typeof param === 'string') {
        nav.userAgent = param;
    }
    else if (param && param.userAgent) {
        nav = {
            userAgent: param.userAgent,
            platform: param.platform,
            maxTouchPoints: param.maxTouchPoints || 0
        };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
        apple: {
            phone: match(appleIphone) && !match(windowsPhone),
            ipod: match(appleIpod),
            tablet: !match(appleIphone) &&
                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone),
            universal: match(appleUniversal),
            device: (match(appleIphone) ||
                match(appleIpod) ||
                match(appleTablet) ||
                match(appleUniversal) ||
                isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone)
        },
        amazon: {
            phone: match(amazonPhone),
            tablet: !match(amazonPhone) && match(amazonTablet),
            device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
            phone: (!match(windowsPhone) && match(amazonPhone)) ||
                (!match(windowsPhone) && match(androidPhone)),
            tablet: !match(windowsPhone) &&
                !match(amazonPhone) &&
                !match(androidPhone) &&
                (match(amazonTablet) || match(androidTablet)),
            device: (!match(windowsPhone) &&
                (match(amazonPhone) ||
                    match(amazonTablet) ||
                    match(androidPhone) ||
                    match(androidTablet))) ||
                match(/\bokhttp\b/i)
        },
        windows: {
            phone: match(windowsPhone),
            tablet: match(windowsTablet),
            device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
            blackberry: match(otherBlackBerry),
            blackberry10: match(otherBlackBerry10),
            opera: match(otherOpera),
            firefox: match(otherFirefox),
            chrome: match(otherChrome),
            device: match(otherBlackBerry) ||
                match(otherBlackBerry10) ||
                match(otherOpera) ||
                match(otherFirefox) ||
                match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
    };
    result.any =
        result.apple.device ||
            result.android.device ||
            result.windows.device ||
            result.other.device;
    result.phone =
        result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
        result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
}
//# sourceMappingURL=isMobile.js.map
;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/index.js


//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6765:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InvalidTokenError: () => (/* binding */ n),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function e(e){this.message=e}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,"");if(t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,o,a=0,i=0,c="";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);return c};function t(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw"Illegal base64url string!"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t="0"+t),"%"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if("string"!=typeof e)throw new n("Invalid token specified");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(".")[o]))}catch(e){throw new n("Invalid token specified: "+e.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (o);
//# sourceMappingURL=jwt-decode.esm.js.map


/***/ }),

/***/ 71514:
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ 58968:
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ 94459:
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ 6188:
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ 68002:
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ 75880:
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ 70414:
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ 73093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(94459);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ 58859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(42634);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
function isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
function isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 15091:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var loaderUni = __webpack_require__(23494);
var base = __webpack_require__(55075);
var runtime4_1 = __webpack_require__(77954);



Object.defineProperty(exports, "Spine", ({
	enumerable: true,
	get: function () { return loaderUni.Spine; }
}));
Object.defineProperty(exports, "SkeletonBounds", ({
	enumerable: true,
	get: function () { return runtime4_1.SkeletonBounds; }
}));
Object.keys(base).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return base[k]; }
	});
});
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 59340:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(99231), exports);
__exportStar(__webpack_require__(37660), exports);
__exportStar(__webpack_require__(18495), exports);
__exportStar(__webpack_require__(44459), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 99231:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GRAPH_HEIGHT = exports.GRAPH_WIDTH = exports.GRAPH_Y = exports.FONT_SIZE = exports.GRAPH_X = exports.TEXT_Y = exports.TEXT_X = exports.HEIGHT = exports.WIDTH = exports.PR = void 0;
exports.PR = 4;
exports.WIDTH = 50 * exports.PR;
exports.HEIGHT = 30 * exports.PR;
exports.TEXT_X = 7;
exports.TEXT_Y = 7;
exports.GRAPH_X = exports.TEXT_X;
exports.FONT_SIZE = 20; // tested @ 120.0 FPS (120~120)
exports.GRAPH_Y = exports.FONT_SIZE + exports.TEXT_Y;
exports.GRAPH_WIDTH = exports.WIDTH - exports.GRAPH_X * 2;
exports.GRAPH_HEIGHT = exports.HEIGHT - exports.GRAPH_X - exports.GRAPH_Y;
//# sourceMappingURL=stats-constants.js.map

/***/ }),

/***/ 44459:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PIXIHooks = exports.StatsJSAdapter = void 0;
const BaseHooks_1 = __importDefault(__webpack_require__(7480));
const stats_panel_1 = __webpack_require__(37660);
class StatsJSAdapter {
    constructor(hook, stats) {
        this.hook = hook;
        if (stats) {
            this.stats = stats;
        }
        else if (window.Stats) {
            this.stats = new window.Stats();
        }
        if (this.stats) {
            this.dcPanel = this.stats.addPanel(new stats_panel_1.Panel('DC', '#f60', '#300'));
            this.tcPanel = this.stats.addPanel(new stats_panel_1.Panel('TC', '#0c6', '#033'));
            this.stats.showPanel(0);
        }
        else {
            throw new Error("Stats can't found in window, pass instance of Stats.js as second param");
        }
    }
    update() {
        if (this.stats) {
            if (this.hook) {
                this.dcPanel.update(this.hook.deltaDrawCalls, Math.max(50, this.hook.maxDeltaDrawCalls));
                this.tcPanel.update(this.hook.texturesCount, Math.max(20, this.hook.maxTextureCount));
            }
            this.stats.update();
        }
    }
    reset() {
        if (this.hook)
            this.hook.reset();
    }
}
exports.StatsJSAdapter = StatsJSAdapter;
class PIXIHooks extends BaseHooks_1.default {
    constructor(app) {
        super();
        if (!app) {
            console.error('[PIXI Hooks] missing PIXI.Application');
            return;
        }
        const renderer = app.renderer;
        if (renderer.gl) {
            this.attach(renderer.gl);
            // const startTextures = renderer.texture.managedTextures;
            const glTextures = renderer.texture._glTextures;
            if (!glTextures || !this.texturehook) {
                console.error('[PIXI Hooks] !glTextures || !this.texturehook');
            }
            else {
                console.log('[PIXI Hooks] Collect used textures:', glTextures.length);
                // for (let i = 0; i < startTextures.length; i++) {
                //   const txr = startTextures[i];
                Object.values(glTextures).forEach((glTexture) => {
                    if (glTexture.gl === renderer.gl) {
                        this.texturehook.registerTexture(glTexture.texture);
                    }
                });
                // }
            }
        }
        else {
            console.error('[PIXI Hook] Canvas renderer is not allowed');
        }
    }
}
exports.PIXIHooks = PIXIHooks;
//# sourceMappingURL=stats-gl.js.map

/***/ }),

/***/ 37660:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Panel = void 0;
const stats_constants_1 = __webpack_require__(99231);
class Panel {
    constructor(name, fg, bg) {
        this.values = [];
        this.snapshotSize = 30; // min~max of X frames total
        const canvas = document.createElement('canvas');
        canvas.width = stats_constants_1.WIDTH;
        canvas.height = stats_constants_1.HEIGHT;
        const context = canvas.getContext('2d');
        if (!context) {
            throw new Error('Cant get context on canvas');
        }
        context.font = `bold ${stats_constants_1.FONT_SIZE}px ${getComputedStyle(document.body).fontFamily}`;
        context.textBaseline = 'top';
        context.fillStyle = bg;
        context.fillRect(0, 0, stats_constants_1.WIDTH, stats_constants_1.HEIGHT);
        context.fillStyle = fg;
        context.fillText(name, stats_constants_1.TEXT_X, stats_constants_1.TEXT_Y);
        context.fillRect(stats_constants_1.GRAPH_X, stats_constants_1.GRAPH_Y, stats_constants_1.GRAPH_WIDTH, stats_constants_1.GRAPH_HEIGHT);
        context.fillStyle = bg;
        context.globalAlpha = 0.8;
        context.fillRect(stats_constants_1.GRAPH_X, stats_constants_1.GRAPH_Y, stats_constants_1.GRAPH_WIDTH, stats_constants_1.GRAPH_HEIGHT);
        this.name = name;
        this.dom = canvas;
        this.context = context;
        this.fg = fg;
        this.bg = bg;
    }
    get min() {
        return this.values
            .reduce((min, value) => Math.min(min, value), Infinity)
            .toFixed();
    }
    get max() {
        return this.values.reduce((max, value) => Math.max(max, value), 0).toFixed();
    }
    get averageValue() {
        return (this.values.reduce((sum, value) => sum + value, 0) / this.values.length).toFixed(1);
    }
    pushValue(value) {
        this.values.push(value);
        if (this.values.length > this.snapshotSize) {
            this.values = this.values.slice(-this.snapshotSize);
        }
    }
    update(value, maxValue) {
        const context = this.context;
        this.pushValue(value);
        context.fillStyle = this.bg;
        context.globalAlpha = 1;
        context.fillRect(0, 0, stats_constants_1.WIDTH, stats_constants_1.GRAPH_Y);
        context.fillStyle = this.fg;
        context.font = `bold ${stats_constants_1.FONT_SIZE}px ${getComputedStyle(document.body).fontFamily}`;
        context.fillText(`${this.averageValue} ${this.name} (${this.min}-${this.max})`, stats_constants_1.TEXT_X, stats_constants_1.TEXT_Y);
        context.drawImage(this.dom, stats_constants_1.GRAPH_X + stats_constants_1.PR, stats_constants_1.GRAPH_Y, stats_constants_1.GRAPH_WIDTH - stats_constants_1.PR, stats_constants_1.GRAPH_HEIGHT, stats_constants_1.GRAPH_X, stats_constants_1.GRAPH_Y, stats_constants_1.GRAPH_WIDTH - stats_constants_1.PR, stats_constants_1.GRAPH_HEIGHT);
        context.fillRect(stats_constants_1.GRAPH_X + stats_constants_1.GRAPH_WIDTH - stats_constants_1.PR, stats_constants_1.GRAPH_Y, stats_constants_1.PR, stats_constants_1.GRAPH_HEIGHT);
        context.fillStyle = this.bg;
        context.globalAlpha = 0.8;
        context.fillRect(stats_constants_1.GRAPH_X + stats_constants_1.GRAPH_WIDTH - stats_constants_1.PR, stats_constants_1.GRAPH_Y, 2 * stats_constants_1.PR, Math.round((1 - value / maxValue) * stats_constants_1.GRAPH_HEIGHT));
    }
}
exports.Panel = Panel;
//# sourceMappingURL=stats-panel.js.map

/***/ }),

/***/ 18495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stats = void 0;
exports.addStats = addStats;
const stats_gl_1 = __webpack_require__(44459);
const stats_panel_1 = __webpack_require__(37660);
class Stats {
    constructor() {
        this.setMode = this.showPanel;
        this.mode = 0;
        this.domElement = document.createElement('div');
        this.domElement.id = 'stats';
        this.domElement.addEventListener('click', (event) => {
            event.preventDefault();
            this.showPanel(++this.mode % this.domElement.children.length);
        }, false);
        this.beginTime = (performance || Date).now();
        this.prevTime = this.beginTime;
        this.frames = 0;
        this.fpsPanel = this.addPanel(new Stats.Panel('FPS', '#3ff', '#002'));
        this.msPanel = this.addPanel(new Stats.Panel('MS', '#0f0', '#020'));
        if (performance && performance.memory) {
            this.memPanel = this.addPanel(new Stats.Panel('MB', '#f08', '#200'));
        }
    }
    addPanel(panel) {
        this.domElement.appendChild(panel.dom);
        return panel;
    }
    showPanel(id) {
        for (let index = 0; index < this.domElement.children.length; index++) {
            const element = this.domElement.children[index];
            element.style.display = index === id ? 'block' : 'none';
        }
        this.mode = id;
    }
    begin() {
        this.beginTime = (performance || Date).now();
    }
    end() {
        this.frames++;
        const time = (performance || Date).now();
        this.msPanel.update(time - this.beginTime, 200);
        if (time > this.prevTime + 1000) {
            this.fpsPanel.update((this.frames * 1000) / (time - this.prevTime), 100);
            this.prevTime = time;
            this.frames = 0;
            if (this.memPanel) {
                const memory = performance.memory;
                this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
            }
        }
        return time;
    }
    update() {
        this.beginTime = this.end();
    }
}
exports.Stats = Stats;
Stats.Panel = stats_panel_1.Panel;
function addStats(document, app) {
    const stats = new Stats();
    const pixiHooks = new stats_gl_1.PIXIHooks(app);
    const adapter = new stats_gl_1.StatsJSAdapter(pixiHooks, stats);
    document.body.appendChild(adapter.stats.domElement);
    return adapter;
}
//# sourceMappingURL=stats.js.map

/***/ }),

/***/ 39761:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(11491);
var filterAlpha = __webpack_require__(61743);
var filterBlur = __webpack_require__(6564);
var filterColorMatrix = __webpack_require__(82746);
var filterDisplacement = __webpack_require__(34734);
var filterFxaa = __webpack_require__(2013);
var filterNoise = __webpack_require__(937);

const filters = {
  AlphaFilter: filterAlpha.AlphaFilter,
  BlurFilter: filterBlur.BlurFilter,
  BlurFilterPass: filterBlur.BlurFilterPass,
  ColorMatrixFilter: filterColorMatrix.ColorMatrixFilter,
  DisplacementFilter: filterDisplacement.DisplacementFilter,
  FXAAFilter: filterFxaa.FXAAFilter,
  NoiseFilter: filterNoise.NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      core.utils.deprecation("7.1.0", `filters.${key} has moved to ${key}`);
      return FilterClass;
    }
  });
});

exports.filters = filters;
//# sourceMappingURL=filters.js.map


/***/ }),

/***/ 95894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(13283);
__webpack_require__(42885);
__webpack_require__(93204);
var filters = __webpack_require__(39761);
var accessibility = __webpack_require__(29252);
var app = __webpack_require__(50415);
var assets = __webpack_require__(13369);
var compressedTextures = __webpack_require__(39260);
var core = __webpack_require__(11491);
var display = __webpack_require__(31230);
var events = __webpack_require__(7065);
var extract = __webpack_require__(24993);
var filterAlpha = __webpack_require__(61743);
var filterBlur = __webpack_require__(6564);
var filterColorMatrix = __webpack_require__(82746);
var filterDisplacement = __webpack_require__(34734);
var filterFxaa = __webpack_require__(2013);
var filterNoise = __webpack_require__(937);
var graphics = __webpack_require__(47997);
var mesh = __webpack_require__(57309);
var meshExtras = __webpack_require__(42683);
var particleContainer = __webpack_require__(868);
var prepare = __webpack_require__(29911);
var sprite = __webpack_require__(64441);
var spriteAnimated = __webpack_require__(78509);
var spriteTiling = __webpack_require__(13903);
var spritesheet = __webpack_require__(34216);
var text = __webpack_require__(74083);
var textBitmap = __webpack_require__(93637);
var textHtml = __webpack_require__(26191);



exports.filters = filters.filters;
Object.keys(accessibility).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return accessibility[k]; }
	});
});
Object.keys(app).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return app[k]; }
	});
});
Object.keys(assets).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return assets[k]; }
	});
});
Object.keys(compressedTextures).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return compressedTextures[k]; }
	});
});
Object.keys(core).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return core[k]; }
	});
});
Object.keys(display).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return display[k]; }
	});
});
Object.keys(events).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return events[k]; }
	});
});
Object.keys(extract).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return extract[k]; }
	});
});
Object.keys(filterAlpha).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterAlpha[k]; }
	});
});
Object.keys(filterBlur).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterBlur[k]; }
	});
});
Object.keys(filterColorMatrix).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterColorMatrix[k]; }
	});
});
Object.keys(filterDisplacement).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterDisplacement[k]; }
	});
});
Object.keys(filterFxaa).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterFxaa[k]; }
	});
});
Object.keys(filterNoise).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return filterNoise[k]; }
	});
});
Object.keys(graphics).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return graphics[k]; }
	});
});
Object.keys(mesh).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return mesh[k]; }
	});
});
Object.keys(meshExtras).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return meshExtras[k]; }
	});
});
Object.keys(particleContainer).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return particleContainer[k]; }
	});
});
Object.keys(prepare).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prepare[k]; }
	});
});
Object.keys(sprite).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return sprite[k]; }
	});
});
Object.keys(spriteAnimated).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return spriteAnimated[k]; }
	});
});
Object.keys(spriteTiling).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return spriteTiling[k]; }
	});
});
Object.keys(spritesheet).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return spritesheet[k]; }
	});
});
Object.keys(text).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return text[k]; }
	});
});
Object.keys(textBitmap).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return textBitmap[k]; }
	});
});
Object.keys(textHtml).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return textHtml[k]; }
	});
});
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 44741:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof __webpack_require__.g === "object" ? __webpack_require__.g :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ 14803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var inspect = __webpack_require__(58859);

var $TypeError = __webpack_require__(69675);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode} */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	// eslint-disable-next-line eqeqeq
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
			}
			return curr;
		}
	}
};

/** @type {import('./list.d.ts').listGet} */
var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	}
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('./list.d.ts').listHas} */
var listHas = function (objects, key) {
	if (!objects) {
		return false;
	}
	return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	}
};

/** @type {import('.')} */
module.exports = function getSideChannelList() {
	/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			}
			return !!deletedNode;
		},
		get: function (key) {
			return listGet($o, key);
		},
		has: function (key) {
			return listHas($o, key);
		},
		set: function (key, value) {
			if (!$o) {
				// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
				$o = {
					next: void undefined
				};
			}
			// eslint-disable-next-line no-extra-parens
			listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),

/***/ 80507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(70453);
var callBound = __webpack_require__(36556);
var inspect = __webpack_require__(58859);

var $TypeError = __webpack_require__(69675);
var $Map = GetIntrinsic('%Map%', true);

/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */
var $mapSize = callBound('Map.prototype.size', true);

/** @type {import('.')} */
module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
	/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {Map<K, V> | undefined} */ var $m;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			if ($m) {
				var result = $mapDelete($m, key);
				if ($mapSize($m) === 0) {
					$m = void undefined;
				}
				return result;
			}
			return false;
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($m) {
				return $mapGet($m, key);
			}
		},
		has: function (key) {
			if ($m) {
				return $mapHas($m, key);
			}
			return false;
		},
		set: function (key, value) {
			if (!$m) {
				// @ts-expect-error TS can't handle narrowing a variable inside a closure
				$m = new $Map();
			}
			$mapSet($m, key, value);
		}
	};

	// @ts-expect-error TODO: figure out why TS is erroring here
	return channel;
};


/***/ }),

/***/ 72271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(70453);
var callBound = __webpack_require__(36556);
var inspect = __webpack_require__(58859);
var getSideChannelMap = __webpack_require__(80507);

var $TypeError = __webpack_require__(69675);
var $WeakMap = GetIntrinsic('%WeakMap%', true);

/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

/** @type {import('.')} */
module.exports = $WeakMap
	? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapDelete($wm, key);
					}
				} else if (getSideChannelMap) {
					if ($m) {
						return $m['delete'](key);
					}
				}
				return false;
			},
			get: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				}
				return $m && $m.get(key);
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				}
				return !!$m && $m.has(key);
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) {
						$m = getSideChannelMap();
					}
					// eslint-disable-next-line no-extra-parens
					/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
				}
			}
		};

		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	}
	: getSideChannelMap;


/***/ }),

/***/ 920:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $TypeError = __webpack_require__(69675);
var inspect = __webpack_require__(58859);
var getSideChannelList = __webpack_require__(14803);
var getSideChannelMap = __webpack_require__(80507);
var getSideChannelWeakMap = __webpack_require__(72271);

var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @typedef {ReturnType<typeof getSideChannel>} Channel */

	/** @type {Channel | undefined} */ var $channelData;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			return !!$channelData && $channelData['delete'](key);
		},
		get: function (key) {
			return $channelData && $channelData.get(key);
		},
		has: function (key) {
			return !!$channelData && $channelData.has(key);
		},
		set: function (key, value) {
			if (!$channelData) {
				$channelData = makeChannel();
			}

			$channelData.set(key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),

/***/ 59920:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const tsyringe_1 = __webpack_require__(659);
const UIState_1 = __importDefault(__webpack_require__(54572));
const UIPanelEvent_1 = __webpack_require__(566);
class ChangeUISettingsStateCommand extends ControlCommand_1.default {
    execute(event) {
        const uiState = tsyringe_1.container.resolve(UIState_1.default);
        uiState.settingsOpen = event.type == UIPanelEvent_1.UIPanelEvent.OPEN_SETTINGS;
    }
}
exports["default"] = ChangeUISettingsStateCommand;


/***/ }),

/***/ 76090:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const tsyringe_1 = __webpack_require__(659);
const UIState_1 = __importDefault(__webpack_require__(54572));
class ClosePanelCommand extends ControlCommand_1.default {
    execute(event) {
        const uiState = tsyringe_1.container.resolve(UIState_1.default);
        uiState.activePanel = null;
    }
}
exports["default"] = ClosePanelCommand;


/***/ }),

/***/ 7770:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const tsyringe_1 = __webpack_require__(659);
const PopupState_1 = __importDefault(__webpack_require__(57388));
class HidePopupCommand extends ControlCommand_1.default {
    execute(event) {
        const popupState = tsyringe_1.container.resolve(PopupState_1.default);
        popupState.activePopup = null;
    }
}
exports["default"] = HidePopupCommand;


/***/ }),

/***/ 10558:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const tsyringe_1 = __webpack_require__(659);
const UIState_1 = __importDefault(__webpack_require__(54572));
class OpenPanelCommand extends ControlCommand_1.default {
    execute(event) {
        const uiState = tsyringe_1.container.resolve(UIState_1.default);
        const panelData = event.data;
        uiState.activePanel = panelData;
    }
}
exports["default"] = OpenPanelCommand;


/***/ }),

/***/ 58575:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const tsyringe_1 = __webpack_require__(659);
const PopupState_1 = __importDefault(__webpack_require__(57388));
class ShowPopupCommand extends ControlCommand_1.default {
    execute(event) {
        const popupState = tsyringe_1.container.resolve(PopupState_1.default);
        popupState.activePopup = event.data;
    }
}
exports["default"] = ShowPopupCommand;


/***/ }),

/***/ 566:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIPanelEvent = void 0;
var UIPanelEvent;
(function (UIPanelEvent) {
    UIPanelEvent["SET_TYPE"] = "uiSetType";
    UIPanelEvent["OPEN_SETTINGS"] = "uiSettingsOpen";
    UIPanelEvent["CLOSE_SETTINGS"] = "uiSettingsClose";
    UIPanelEvent["OPEN_PANEL"] = "uiPanelOpen";
    UIPanelEvent["CLOSE_PANEL"] = "uiPanelClose";
    UIPanelEvent["SHOW_POPUP"] = "uiPopupShow";
    UIPanelEvent["HIDE_POPUP"] = "uiPopupHide";
})(UIPanelEvent || (exports.UIPanelEvent = UIPanelEvent = {}));


/***/ }),

/***/ 11703:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class History {
    constructor() {
        this.entries = [];
    }
}
exports["default"] = History;


/***/ }),

/***/ 52431:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiFunctionalButtonEvent = void 0;
var MultiFunctionalButtonEvent;
(function (MultiFunctionalButtonEvent) {
    MultiFunctionalButtonEvent["STATE_CHANGED"] = "onMultiFunctionalButtonStateChanged";
})(MultiFunctionalButtonEvent || (exports.MultiFunctionalButtonEvent = MultiFunctionalButtonEvent = {}));


/***/ }),

/***/ 93590:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiFunctionalButtonState = void 0;
var MultiFunctionalButtonState;
(function (MultiFunctionalButtonState) {
    MultiFunctionalButtonState["FEATURE_BUY"] = "FeatureBuy";
    MultiFunctionalButtonState["FREESPINS_LEFT"] = "FreespinsLeft";
    MultiFunctionalButtonState["INVISIBLE"] = "Invisible";
})(MultiFunctionalButtonState || (exports.MultiFunctionalButtonState = MultiFunctionalButtonState = {}));


/***/ }),

/***/ 57388:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupData = exports.PopupType = void 0;
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const UIStateEvent_1 = __webpack_require__(17939);
var PopupType;
(function (PopupType) {
    PopupType["NOT_ENOUGH_BALANCE"] = "notEnoughBalance";
    PopupType["CONNECTION_LOST"] = "connectionLost";
    PopupType["FEATURE_BUY"] = "featureBuy";
    PopupType["WARNING_POPUP"] = "warningPopup";
})(PopupType || (exports.PopupType = PopupType = {}));
class PopupData {
    constructor() {
        this.hideOnClick = false;
        this.duration = -1;
        this.callbacks = null;
    }
}
exports.PopupData = PopupData;
class PopupState extends eventemitter3_1.default {
    constructor() {
        super(...arguments);
        this._activePopup = null;
    }
    get activePopup() {
        return this._activePopup;
    }
    set activePopup(popup) {
        this._activePopup = popup;
        this.emit(UIStateEvent_1.UIStateEvent.ACTIVE_POPUP_CHANGED, popup);
    }
    get activeType() {
        return this._activePopup.type;
    }
}
exports["default"] = PopupState;


/***/ }),

/***/ 54572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIPanelType = exports.UIType = void 0;
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const UIStateEvent_1 = __webpack_require__(17939);
var UIType;
(function (UIType) {
    UIType["MAIN"] = "main";
    UIType["SETTINGS"] = "settings";
})(UIType || (exports.UIType = UIType = {}));
var UIPanelType;
(function (UIPanelType) {
    UIPanelType["RULES"] = "rules";
    UIPanelType["HISTORY"] = "history";
    UIPanelType["AUTOSPIN_SETTINGS"] = "autospinSettings";
    UIPanelType["BET_SETTINGS"] = "betSettings";
    UIPanelType["PAYTABLE"] = "paytable";
    UIPanelType["MENU_SETTING"] = "menuSettings";
    UIPanelType["SYSTEM_SETTINGS"] = "systemSettings";
})(UIPanelType || (exports.UIPanelType = UIPanelType = {}));
class UIState extends eventemitter3_1.default {
    constructor() {
        super(...arguments);
        this._settingsOpen = false;
        this._activePanel = null;
    }
    get settingsOpen() {
        return this._settingsOpen;
    }
    set settingsOpen(value) {
        if (this._settingsOpen == value) {
            return;
        }
        this._settingsOpen = value;
        this.emit(UIStateEvent_1.UIStateEvent.SETTINGS_OPEN_CHANGED, value);
    }
    get activePanel() {
        return this._activePanel;
    }
    set activePanel(type) {
        if (this._activePanel == type) {
            return;
        }
        this._activePanel = type;
        this.emit(UIStateEvent_1.UIStateEvent.ACTIVE_PANEL_CHANGED, type);
    }
}
exports["default"] = UIState;


/***/ }),

/***/ 55314:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ButtonVolumeState = exports.ButtonVolumeEvent = void 0;
var ButtonVolumeEvent;
(function (ButtonVolumeEvent) {
    ButtonVolumeEvent["STATE_CHANGED"] = "onStateChanged";
})(ButtonVolumeEvent || (exports.ButtonVolumeEvent = ButtonVolumeEvent = {}));
var ButtonVolumeState;
(function (ButtonVolumeState) {
    ButtonVolumeState["ON"] = "on";
    ButtonVolumeState["OFF"] = "off";
})(ButtonVolumeState || (exports.ButtonVolumeState = ButtonVolumeState = {}));


/***/ }),

/***/ 17939:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIStateEvent = void 0;
var UIStateEvent;
(function (UIStateEvent) {
    UIStateEvent["SETTINGS_OPEN_CHANGED"] = "uiSettingsOpenChanged";
    UIStateEvent["ACTIVE_PANEL_CHANGED"] = "uiPanelChanged";
    UIStateEvent["ACTIVE_POPUP_CHANGED"] = "uiPopupChanged";
})(UIStateEvent || (exports.UIStateEvent = UIStateEvent = {}));


/***/ }),

/***/ 27310:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class SoundList {
}
SoundList.GOOD_WIN = 'big_win';
SoundList.HUGE_WIN = 'super_win';
SoundList.GREAT_WIN = 'mega_win';
SoundList.INSANE_WIN = 'ultra_win';
SoundList.UI_BUTTON_CLICK = 'button_click';
SoundList.TURBO_BUTTON_CLICK = 'bet_panel_turbo_icon_click';
SoundList.INTRO_SPIN_START_BUTTON_CLICK = 'intro_spin_start_button_click';
SoundList.BET_DECREASE_BUTTON_CLICK = 'bet_panel_inside_amount_decrease';
SoundList.BET_INCREASE_BUTTON_CLICK = 'bet_panel_inside_amount_increase';
SoundList.UI_BUTTON_SPIN_START = 'button_spin_start';
SoundList.UI_REEL_STOP = 'reel_stop';
SoundList.BET_AMOUNT_INCREASE = 'bet_panel_inside_amount_increase';
SoundList.BET_AMOUNT_DECREASE = 'bet_panel_inside_amount_decrease';
SoundList.UI_POPUP_COMMON_WINDOW = 'common_popup_window';
SoundList.TRANSITION = 'transition';
SoundList.FREESPIN_AWARD = 'freespin_trigger';
SoundList.FREESPIN_CONG = 'freespin_cong';
SoundList.UI_ERROR_APPEARANCE = 'error_appearance';
SoundList.COUNTER_LOOP = 'counter_loop';
SoundList.HERO_ANIMATION = 'hero_animation';
exports["default"] = SoundList;


/***/ }),

/***/ 75400:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const ButtonAutoSpinStopAnimation_1 = __importDefault(__webpack_require__(20608));
const Button_1 = __importDefault(__webpack_require__(78386));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
class ButtonAutoSpinStop extends Button_1.default {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        this.buttonAnimator = this.normal;
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ButtonAutoSpinStopAnimation':
                instance = new ButtonAutoSpinStopAnimation_1.default(new pixi_js_1.Text('', {
                    fontFamily: AssetsManager_1.default.webFonts.get('Alexandria').family,
                    fill: [0xffffff],
                    fontSize: 57,
                    lineJoin: 'round',
                    align: 'center',
                }));
                break;
            default:
                instance = super.customClassElementCreate(le);
                break;
        }
        return instance;
    }
    setAnimation(name) {
        this.buttonAnimator.setAnimation(name);
    }
    setAutoPlayLeftValue(value) {
        this.text.text = value;
    }
}
exports["default"] = ButtonAutoSpinStop;


/***/ }),

/***/ 20608:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_spine_1 = __webpack_require__(15091);
class ButtonAutoSpinStopAnimation extends pixi_spine_1.Spine {
    constructor(text) {
        super(AssetsManager_1.default.spine.get('button-spin'));
        this.text = text;
        this.text.x = 0;
        this.text.y = 36;
        this.text.scale.y = -1;
        this.text.pivot.x = this.text.width / 2;
        const counterContainer = this.slotContainers[this.skeleton.findSlotIndex('auto_spin_Placeholder')];
        counterContainer.removeChildren();
        counterContainer.addChild(this.text);
    }
    setAnimation(name) {
        this.state.setAnimation(0, name, name === ButtonAutoSpinStopAnimation.LOOP ||
            name === ButtonAutoSpinStopAnimation.INFINITE_LOOP);
    }
    setAutoPlayLeftValue(value) {
        this.text.text = value;
        this.text.pivot.x = this.text.width / 2;
    }
}
ButtonAutoSpinStopAnimation.SPIN = 'auto_spin_click';
ButtonAutoSpinStopAnimation.LOOP = 'auto_spin_Idle';
ButtonAutoSpinStopAnimation.INFINITE_SPIN = 'infinity_stop_click';
ButtonAutoSpinStopAnimation.INFINITE_LOOP = 'infinity_stop_idle';
exports["default"] = ButtonAutoSpinStopAnimation;


/***/ }),

/***/ 9352:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Button_1 = __importDefault(__webpack_require__(78386));
class ButtonAutospin extends Button_1.default {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
    }
    autospinChange(value) {
        this.normal['stop'].alpha = (value <= 0) ? 0 : 1;
        this.normal['play'].alpha = (value <= 0) ? 1 : 0;
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            default:
                instance = super.customClassElementCreate(le);
                break;
        }
        return instance;
    }
    updateView() {
        super.updateView();
    }
}
exports["default"] = ButtonAutospin;


/***/ }),

/***/ 79619:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Button_1 = __importDefault(__webpack_require__(78386));
const Utils_1 = __webpack_require__(63948);
const ButtonSpinAnimation_1 = __importDefault(__webpack_require__(58553));
const engineTween_1 = __webpack_require__(50381);
class ButtonSpin extends Button_1.default {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        this.buttonAnimator = this.normal;
        this.on('pointerover', () => {
            // this.buttonAnimator.setAnimation(ButtonSpinAnimation.HOVER);
        });
        this.on('pointerout', () => {
            this.buttonAnimator.setAnimation(ButtonSpinAnimation_1.default.WAIT_DELAY);
        });
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ButtonSpinAnimation':
                instance = new ButtonSpinAnimation_1.default();
                break;
            default:
                instance = super.customClassElementCreate(le);
                break;
        }
        return instance;
    }
    removeTweens() {
        this.buttonAnimator.visible = false;
        this.buttonAnimator.state.setEmptyAnimations(0);
    }
    waitAnimation(waitAnimation) {
        this.buttonAnimator.setAnimation(waitAnimation);
    }
    spinAnimation(inAnim, outAnim, showPattern = false, addRotation = false, isSpinning = true, minScale = 0.83, maxScale = 1) {
        if (this.currentAnim === outAnim) {
            return;
        }
        this.buttonAnimator.setAnimation(inAnim);
        this.buttonAnimation(outAnim, this.buttonAnimator.getAnimationDuration(inAnim, isSpinning), addRotation, minScale, maxScale);
        this.currentAnim = inAnim;
    }
    buttonAnimation(startAnim, delay = 0, addRotation = false, minScale, maxScale) {
        engineTween_1.Tweener.removeTweens(this.scale);
        engineTween_1.Tweener.removeTweens(this.normal);
        this.normal.rotation = 0;
        if (startAnim.length > 0) {
            (delay > 0) ? this.buttonAnimator.addAnimation(startAnim, delay) : this.buttonAnimator.setAnimation(startAnim);
        }
        // Tweener.addTween(this.scale, {
        //     x: minScale,
        //     y: minScale,
        //     time: 0.1,
        //     transition: 'easeOutSine'
        // });
        // Tweener.addTween(this.scale, {
        //     x: maxScale,
        //     y: maxScale,
        //     time: 0.65,
        //     delay: 0.1,
        //     transition: 'easeOutBounce'
        // });
        if (addRotation) {
            engineTween_1.Tweener.addTween(this.normal, {
                rotation: (0, Utils_1.degToRad)(360),
                time: 0.35,
                transition: 'easeOutQuad',
                onComplete: () => {
                    this.normal.rotation = 0;
                }
            });
        }
    }
}
exports["default"] = ButtonSpin;


/***/ }),

/***/ 58553:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const ScreenOrientation_1 = __webpack_require__(81827);
const BrowserApplication_1 = __webpack_require__(32139);
const pixi_spine_1 = __webpack_require__(15091);
class ButtonSpinAnimation extends pixi_spine_1.Spine {
    constructor() {
        super(AssetsManager_1.default.spine.get('button-spin'));
        this.configureAnimationMixes();
        this.updateSpineAnims(); // Ensure animations are set based on orientation
        BrowserApplication_1.BrowserApplication.mainScreenStage.on("change-orientation", this.updateSpineAnims, this);
    }
    configureAnimationMixes() {
        this.state.data.setMix(this.getAnimationName(ButtonSpinAnimation.SPIN), this.getAnimationName(ButtonSpinAnimation.LOOP), 0.15);
        this.state.data.setMix(this.getAnimationName(ButtonSpinAnimation.LOOP), this.getAnimationName(ButtonSpinAnimation.STOP), 0.15);
        this.state.data.setMix(this.getAnimationName(ButtonSpinAnimation.LOOP), this.getAnimationName(ButtonSpinAnimation.SPIN), 0.15);
        this.state.data.setMix(this.getAnimationName(ButtonSpinAnimation.WAIT_DELAY), this.getAnimationName(ButtonSpinAnimation.SPIN), 0.15);
        this.state.data.setMix(this.getAnimationName(ButtonSpinAnimation.WAIT_DELAY_INTRO), this.getAnimationName(ButtonSpinAnimation.SPIN), 0.15);
    }
    /**
     * Utility to dynamically apply 'm-' prefix for mobile animations
     */
    getAnimationName(baseName) {
        const isMobile = BrowserApplication_1.BrowserApplication.mainScreenStage.orientation === ScreenOrientation_1.ScreenOrientation.VERTICAL;
        const mobileName = `m-${baseName}`;
        // Ensure the animation exists before assigning
        const animationExists = this.spineData.animations.some((animation) => animation.name === (isMobile ? mobileName : baseName));
        return animationExists ? (isMobile ? mobileName : baseName) : baseName;
    }
    /**
     * Dynamically updates animations based on orientation
     */
    updateSpineAnims() {
        ButtonSpinAnimation.SPIN = this.getAnimationName('spin_click');
        ButtonSpinAnimation.WAIT_DELAY = this.getAnimationName('spin_idle');
        ButtonSpinAnimation.WAIT_DELAY_INTRO = this.getAnimationName('spin_idle');
        this.setAnimation(ButtonSpinAnimation.WAIT_DELAY);
    }
    /**
     * Now correctly applies `m-` prefix for mobile animations
     */
    setAnimation(name) {
        const animationName = this.getAnimationName(name);
        this.state.setAnimation(0, animationName, [
            ButtonSpinAnimation.LOOP,
            ButtonSpinAnimation.WAIT,
            ButtonSpinAnimation.WAIT_DELAY,
            ButtonSpinAnimation.WAIT_DELAY_INTRO
        ].includes(name));
    }
    /**
     * Now correctly applies `m-` prefix for mobile animations
     */
    addAnimation(name, delay) {
        const animationName = this.getAnimationName(name);
        this.state.addAnimation(0, animationName, animationName === this.getAnimationName(ButtonSpinAnimation.LOOP), delay);
    }
    getAnimationDuration(name, isSpinning) {
        const animationName = this.getAnimationName(name);
        if (animationName === this.getAnimationName(ButtonSpinAnimation.LOOP) && isSpinning) {
            return 0;
        }
        const animation = this.spineData.animations.find((animation) => animation.name === animationName);
        return animation ? animation.duration : 0;
    }
    onRemoved() {
        BrowserApplication_1.BrowserApplication.mainScreenStage.off("change-orientation", this.updateSpineAnims, this);
    }
}
ButtonSpinAnimation.SPIN = 'spin_click';
ButtonSpinAnimation.LOOP = 'stop_idle';
ButtonSpinAnimation.STOP = 'stop_idle';
ButtonSpinAnimation.WAIT = 'wait';
ButtonSpinAnimation.WAIT_DELAY = 'spin_idle';
ButtonSpinAnimation.WAIT_DELAY_INTRO = 'spin_idle';
exports["default"] = ButtonSpinAnimation;


/***/ }),

/***/ 57861:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Button_1 = __importDefault(__webpack_require__(78386));
const ButtonVolumeEvent_1 = __webpack_require__(55314);
class ButtonVolume extends Button_1.default {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        this.on('pointerup', this.onClick, this);
        this.btn_on = this.normal['btn_on'];
        this.btn_off = this.normal['btn_off'];
    }
    set state(state) {
        if (this._state == state)
            return;
        this._state = state;
        this.changeState();
        this.emit(ButtonVolumeEvent_1.ButtonVolumeEvent.STATE_CHANGED, this._state);
    }
    changeState() {
        [this.btn_off, this.btn_on].forEach((view) => {
            view.visible = false;
        });
        switch (this._state) {
            case ButtonVolumeEvent_1.ButtonVolumeState.ON:
                this.btn_on.visible = true;
                break;
            case ButtonVolumeEvent_1.ButtonVolumeState.OFF:
                this.btn_off.visible = true;
                break;
        }
    }
    onClick() {
        this.state = this._state == ButtonVolumeEvent_1.ButtonVolumeState.ON ? ButtonVolumeEvent_1.ButtonVolumeState.OFF : ButtonVolumeEvent_1.ButtonVolumeState.ON;
    }
    setInitialState(music, fx) {
        if (!music && !fx) {
            this._state = ButtonVolumeEvent_1.ButtonVolumeState.OFF;
        }
        else {
            this._state = ButtonVolumeEvent_1.ButtonVolumeState.ON;
        }
        this.changeState();
    }
}
exports["default"] = ButtonVolume;


/***/ }),

/***/ 64823:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
class LoadingProgressBar extends pixi_js_1.Container {
    constructor(layoutElement) {
        super();
        this.currentProgress = 0;
        this.targetProgress = 0;
        this.animationSpeed = 0.02;
        this.createProgressBar();
        this.setupAnimation();
    }
    createProgressBar() {
        // Layer 1: Base Frame (GoldenStrokeMain.png)
        const baseTexture = AssetsManager_1.default.textures.get('gold-panel');
        if (baseTexture) {
            this.baseFrame = new pixi_js_1.Sprite(baseTexture);
            this.baseFrame.anchor.set(0.5, 0.5);
            this.addChild(this.baseFrame);
        }
        // Layer 2: Progress Track Background (BaseStrokepanel.png)
        const trackTexture = AssetsManager_1.default.textures.get('base-panel');
        if (trackTexture) {
            this.trackBackground = new pixi_js_1.Sprite(trackTexture);
            this.trackBackground.anchor.set(0.5, 0.5);
            this.addChild(this.trackBackground);
        }
        // Layer 3: Progress Fill (BaseColored.png) - this will be masked
        const fillTexture = AssetsManager_1.default.textures.get('loading-bar');
        let fillSprite;
        if (fillTexture) {
            fillSprite = new pixi_js_1.Sprite(fillTexture);
            fillSprite.anchor.set(0.5, 0.5);
            this.addChild(fillSprite);
        }
        // Layer 4: Progress Fill Mask (will be clipped)
        this.fillMask = new pixi_js_1.Graphics();
        this.fillMask.beginFill(0x000000);
        this.fillMask.drawRect(12, 0, 100, 20); // Initial size, will be updated
        this.fillMask.endFill();
        this.addChild(this.fillMask);
        // Apply mask to fill sprite
        if (fillSprite) {
            fillSprite.mask = this.fillMask;
        }
        // Layer 5: Animated Stripes Overlay (Stripe.png) - slightly taller than BaseColored
        const stripeTexture = AssetsManager_1.default.textures.get('loading-stripe');
        if (stripeTexture && fillTexture) {
            this.stripeOverlay = new pixi_js_1.TilingSprite(stripeTexture, fillTexture.width * 0.97, fillTexture.height * 0.8);
            this.stripeOverlay.anchor.set(0.5, 0.5);
            this.stripeOverlay.mask = this.fillMask;
            this.addChild(this.stripeOverlay);
        }
        // Layer 6: Highlights (on top of stripes, aligned with BaseColored and masked with progress)
        const highlightTopTexture = AssetsManager_1.default.textures.get('highlightTop');
        if (highlightTopTexture && fillTexture) {
            this.highlightTop = new pixi_js_1.Sprite(highlightTopTexture);
            this.highlightTop.anchor.set(0.5, 1); // Bottom anchor for top highlight
            this.highlightTop.y = -fillTexture.height / 10; // Move very close to BaseColored center
            this.highlightTop.mask = this.fillMask; // Apply same mask as progress
            this.addChild(this.highlightTop);
        }
        const highlightBottomTexture = AssetsManager_1.default.textures.get('highlightBottom');
        if (highlightBottomTexture && fillTexture) {
            this.highlightBottom = new pixi_js_1.Sprite(highlightBottomTexture);
            this.highlightBottom.anchor.set(0.5, 0); // Top anchor for bottom highlight
            this.highlightBottom.y = fillTexture.height / 10; // Move very close to BaseColored center
            this.highlightBottom.mask = this.fillMask; // Apply same mask as progress
            this.addChild(this.highlightBottom);
        }
        // Set initial progress
        this.updateProgressMask();
    }
    setupAnimation() {
        // Animate the stripe overlay continuously
        const animate = () => {
            if (this.stripeOverlay) {
                // Move the tiling position continuously for seamless looping
                if (this.stripeOverlay.tilePosition == null)
                    return;
                this.stripeOverlay.tilePosition.x -= 2; // Move stripes left continuously
            }
            // Smoothly animate progress
            if (this.currentProgress < this.targetProgress) {
                this.currentProgress = Math.min(this.currentProgress + this.animationSpeed, this.targetProgress);
                this.updateProgressMask();
            }
            else if (this.currentProgress > this.targetProgress) {
                this.currentProgress = Math.max(this.currentProgress - this.animationSpeed, this.targetProgress);
                this.updateProgressMask();
            }
            requestAnimationFrame(animate);
        };
        animate();
    }
    updateProgressMask() {
        if (this.fillMask && this.baseFrame) {
            const fillTexture = AssetsManager_1.default.textures.get('loading-bar');
            if (fillTexture) {
                const progressWidth = fillTexture.width * this.currentProgress;
                const borderRadius = 12; // Rounded corners
                this.fillMask.clear();
                this.fillMask.beginFill(0x000000);
                this.fillMask.drawRoundedRect(-fillTexture.width / 2, -fillTexture.height / 2, progressWidth, fillTexture.height, borderRadius);
                this.fillMask.endFill();
            }
        }
    }
    // PUBLIC API
    setProgress(progress) {
        this.targetProgress = Math.max(0, Math.min(1, progress));
    }
    getProgress() {
        return this.currentProgress;
    }
    setAnimationSpeed(speed) {
        this.animationSpeed = speed;
    }
}
exports["default"] = LoadingProgressBar;


/***/ }),

/***/ 20523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadingScreen = void 0;
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_js_1 = __webpack_require__(95894);
const AdjustableLayoutContainer_1 = __importDefault(__webpack_require__(66961));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const BrowserApplication_1 = __webpack_require__(32139);
const ScreenOrientation_1 = __webpack_require__(81827);
const Translation_1 = __importDefault(__webpack_require__(62231));
const engineTween_1 = __webpack_require__(50381);
const LoadingProgressBar_1 = __importDefault(__webpack_require__(64823));
class LoadingScreen extends AdjustableLayoutContainer_1.default {
    constructor(onCompleteCallback) {
        super(null);
        this.isClickable = false;
        this.background = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('loading-bg-desktop'));
        this.backgroundMobile = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('loading-bg-mobile'));
        this.background.anchor.set(0.5, 0.5);
        this.backgroundMobile.anchor.set(0.5, 0.5);
        this.addChild(this.background);
        this.addChild(this.backgroundMobile);
        this.coinDesktop = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('coins-desktop'));
        this.coinDesktop.anchor.set(0.5, 0.5);
        this.background.addChild(this.coinDesktop);
        this.character = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('loading-character'));
        this.character.anchor.set(0.5, 0.5);
        this.addChild(this.character);
        this.characterLogo = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('loading-logo'));
        this.characterLogo.anchor.set(0.5, 0.5);
        this.characterLogo.position.y = 50;
        this.character.addChild(this.characterLogo);
        this.createGradientBottom();
        this.footerText = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('loading-text'));
        this.footerText.anchor.set(0.5, 0.5);
        this.addChild(this.footerText);
        this.startButton = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('startbutton'));
        this.startButton.anchor.set(0.5, 0.5);
        this.startButton.scale.set(0);
        this.startButton.position.y = -190;
        const startText = Translation_1.default.t('tfStart');
        const bitmapText = new pixi_js_1.Text(startText, {
            fontFamily: AssetsManager_1.default.webFonts.get('LongdonDecorative').family,
            fill: ['#FFFFFF'],
            stroke: '#000000',
            strokeThickness: 4,
            fontSize: 80,
            lineJoin: 'round',
            align: 'center',
        });
        bitmapText.anchor.set(0.5, 0.5);
        this.startButton.addChild(bitmapText);
        this.footerText.addChild(this.startButton);
        this.progressBar = new LoadingProgressBar_1.default();
        this.addChild(this.progressBar);
        this.callback = onCompleteCallback;
        this.once('added', () => {
            this.handleWindowResize();
            this.interactive = true;
            this.once('pointerup', this.onPopupClick, this);
        });
    }
    onPopupClick() {
        if (!this.isClickable) {
            Howler.ctx.resume();
            this.isClickable = true;
        }
        if (LoadingScreen.finished) {
            this.interactive = false;
            setTimeout(() => {
                if (this.callback) {
                    this.callback();
                    this.callback = null;
                }
                this.isClickable = false;
            }, 100);
            SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
            this.removeAllListeners();
        }
    }
    updateLayout(desc) {
        this.handleWindowResize();
    }
    createGradientBottom() {
        this.gradientBottom = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('footer-desktop'));
        this.gradientBottomMobile = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('footer-mobile'));
        this.gradientBottom.anchor.set(0.5, 1);
        this.gradientBottom.position.set(0, 540);
        this.gradientBottomMobile.anchor.set(0.5, 1);
        this.background.addChild(this.gradientBottom);
        this.addChild(this.gradientBottomMobile);
    }
    // PUBLIC API
    start() {
    }
    stop() {
        if (!LoadingScreen.finished) {
            LoadingScreen.finished = true;
            if (this.isClickable) {
                if (this.callback) {
                    this.callback();
                    this.callback = null;
                    this.interactive = false;
                }
            }
            else {
                engineTween_1.Tweener.addTween(this.progressBar, {
                    alpha: 0,
                    time: 0.1,
                    transition: 'linear',
                    onComplete: () => {
                        // Style the button
                        engineTween_1.Tweener.addTween(this.startButton.scale, {
                            x: 1,
                            y: 1,
                            time: 0.6,
                            transition: 'easeOutBounce'
                        });
                        const targetY = this.characterLogo.position.y - 100;
                        engineTween_1.Tweener.addTween(this.characterLogo.position, {
                            y: targetY,
                            time: 0.6,
                            transition: 'easeOutBounce',
                        });
                    }
                });
            }
        }
    }
    handleWindowResize() {
        if (!this.parent) {
            return;
        }
        const parentScale = this.parent ? this.parent.scale.x : 1;
        const parentOffset = this.parent ? this.parent.position : { x: 0, y: 0 };
        const inverseParentScale = 1 / parentScale;
        this.scale.set(inverseParentScale);
        this.position.set(-parentOffset.x * inverseParentScale, -parentOffset.y * inverseParentScale);
        const baseWidth = 1920; // Base game width
        const baseHeight = 1080; // Base game height
        const width = window.innerWidth;
        const height = window.innerHeight;
        const yScale = height / baseHeight;
        const xScale = width / baseWidth;
        const scale = Math.min(xScale * 2, yScale);
        // Background: Scale on Y-axis to be full screen
        this.character.position.set(width / 2, height / 2);
        // Character: Always keep centered
        if (ScreenOrientation_1.ScreenOrientation.HORIZONTAL == BrowserApplication_1.BrowserApplication.mainScreenStage.orientation) {
            this.character.scale.set(scale);
            this.backgroundMobile.visible = false;
            this.gradientBottomMobile.visible = false;
            this.background.visible = true;
            this.gradientBottom.visible = true;
            this.characterLogo.position.y = this.progressBar.alpha == 0 ? -50 : 50;
            // this.startButton.position.y = -150;
            if (width > height * (baseWidth / baseHeight)) {
                this.background.scale.set(xScale);
            }
            else {
                this.background.scale.set(yScale);
            }
            this.background.x = width / 2;
            this.background.y = height / 2;
            // Footer text: Center horizontally at bottom, positioned within gradient area
            this.footerText.x = width / 2;
            this.footerText.y = height * 0.89; // Position in lower part of gradient
            this.footerText.scale.set(scale);
            // Progress bar: Center horizontally and position at bottom
            if (this.progressBar) {
                this.progressBar.x = width / 2;
                this.progressBar.y = height * 0.77; // Position above footer text
                this.progressBar.scale.set(scale);
            }
        }
        else {
            this.character.scale.set(scale * 1.2);
            this.backgroundMobile.visible = true;
            this.background.visible = false;
            this.gradientBottomMobile.visible = true;
            this.gradientBottom.visible = false;
            const mobileWidth = 430;
            const mobileHeight = 744;
            const yScaleMobile = height / mobileHeight;
            const xScaleMobile = width / mobileWidth;
            const scaleMobile = Math.max(xScaleMobile, yScaleMobile);
            this.characterLogo.position.y = this.progressBar.alpha == 0 ? 50 : 150;
            this.backgroundMobile.scale.set(scaleMobile, scaleMobile);
            this.backgroundMobile.x = width / 2;
            this.backgroundMobile.y = height / 2;
            this.gradientBottomMobile.scale.set(scale * 2.5);
            this.gradientBottomMobile.position.set(width / 2, height);
            // Footer text: Center horizontally at bottom, positioned within gradient area
            this.footerText.x = width / 2;
            this.footerText.y = height - (this.gradientBottom.height * 0.15); // Position in lower part of gradient
            this.footerText.scale.set(scale);
            // Progress bar: Center horizontally and position at bottom
            if (this.progressBar) {
                this.progressBar.x = width / 2;
                this.progressBar.y = height - (this.gradientBottom.height * 0.3); // Position above footer text
                this.progressBar.scale.set(scale);
            }
        }
    }
    setProgress(progress) {
        if (this.progressBar) {
            this.progressBar.setProgress(progress);
        }
    }
    simulateLoading() {
        // Removed simulated loading - now using real asset loading progress
        // Progress is updated via setProgress() calls from SugarDaddy.ts
    }
    destroy() {
        this.background.destroy();
        this.character.destroy();
        this.characterLogo.destroy();
        this.footerText.destroy();
        this.gradientBottom.destroy();
        this.progressBar.destroy();
        super.destroy();
    }
}
exports.LoadingScreen = LoadingScreen;
LoadingScreen.finished = false;
var LoadingState;
(function (LoadingState) {
    LoadingState["START"] = "start";
    LoadingState["PROGRESS"] = "progress";
    LoadingState["END"] = "end";
})(LoadingState || (LoadingState = {}));


/***/ }),

/***/ 22452:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_spine_1 = __webpack_require__(15091);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const engineTween_1 = __webpack_require__(50381);
class Logo extends pixi_spine_1.Spine {
    constructor(isLoop = false, delayBetweenAnimations = 3) {
        super(AssetsManager_1.default.spine.get('logo'));
        this.visible = false;
        this.state.addListener({
            complete: (entry) => {
                engineTween_1.Tweener.addCaller(this, {
                    count: 1,
                    time: delayBetweenAnimations,
                    onComplete: () => {
                        this.onAdded(isLoop);
                    }
                });
            }
        });
        this.on('added', this.onAdded, this);
    }
    onAdded(isLoop) {
        this.state.setEmptyAnimations(0);
        this.state.setAnimation(0, 'idle', isLoop);
    }
    playWinAnimation(animationName) {
        this.state.data.setMix('idle', animationName, 0.15);
        this.state.data.setMix(animationName, 'idle', 0.15);
        this.state.setAnimation(0, animationName, false);
    }
}
exports["default"] = Logo;


/***/ }),

/***/ 81887:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Button_1 = __importDefault(__webpack_require__(78386));
const MultiFunctionalButtonState_1 = __webpack_require__(93590);
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIPanelEvent_1 = __webpack_require__(566);
const PopupState_1 = __webpack_require__(57388);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const MultiFunctionalButtonEvent_1 = __webpack_require__(52431);
const SoundList_1 = __importDefault(__webpack_require__(27310));
const engineTween_1 = __webpack_require__(50381);
class MultiFunctionalButton extends Button_1.default {
    constructor(le, customClassResolver = null, hitArea = null) {
        super(le, customClassResolver, hitArea);
        this.background = this['normal']['background'];
        this.tfText = this['normal']['tfText'];
        this._isVisible = this.visible;
        this.state = MultiFunctionalButtonState_1.MultiFunctionalButtonState.INVISIBLE;
        // this.setText('FREESPINS LEFT: 0',true);
        // this.state = MultiFunctionalButtonState.FREESPINS_LEFT;
        //
        // //TODO: test purposes timeout
        // setTimeout(()=>{
        //     this.state = MultiFunctionalButtonState.UNVISIBLE;
        // }, 1500);
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            default:
                instance = super.customClassElementCreate(le);
                break;
        }
        return instance;
    }
    set state(state) {
        if (state === this._currentState)
            return;
        this._currentState = state;
        switch (this._currentState) {
            case MultiFunctionalButtonState_1.MultiFunctionalButtonState.FEATURE_BUY:
                this.changeVisibility(true);
                this.changeButton(381, () => {
                    this.onBtnFeatureBuy();
                });
                this.setText('FEATURE BUY', true);
                break;
            case MultiFunctionalButtonState_1.MultiFunctionalButtonState.FREESPINS_LEFT:
                this.changeVisibility(true);
                this.changeButton(424);
                break;
            case MultiFunctionalButtonState_1.MultiFunctionalButtonState.INVISIBLE:
                this.changeVisibility(false);
                break;
        }
        this.emit(MultiFunctionalButtonEvent_1.MultiFunctionalButtonEvent.STATE_CHANGED);
    }
    setText(text, swapWithAnimation = false) {
        if (!swapWithAnimation) {
            this.tfText.text = text;
            return;
        }
        const transitionTime = 0.35;
        engineTween_1.Tweener.addTween(this.tfText, {
            alpha: 0,
            time: transitionTime / 2,
            transition: 'easeOutSine',
            onComplete: () => {
                this.tfText.text = text;
                engineTween_1.Tweener.addTween(this.tfText, {
                    alpha: 1,
                    time: transitionTime / 2,
                    transition: 'easeOutSine'
                });
            }
        });
    }
    isVisible() {
        return this._isVisible;
    }
    changeVisibility(visible) {
        //Main value that changes instantly  -> this.visible is only visual aspect of visibility
        this._isVisible = visible;
        if (visible)
            this.visible = visible;
        engineTween_1.Tweener.addTween(this, {
            alpha: visible ? 1 : 0,
            time: 0.35,
            transition: 'easeOutSine',
            onComplete: () => {
                this.visible = visible;
            }
        });
    }
    changeButton(width, onClick = null) {
        if (!this.visible)
            this.visible = true;
        this.enabled = onClick != null;
        if (onClick)
            this.onclick = onClick;
        const transitionTime = 0.7;
        engineTween_1.Tweener.addTween(this.background, {
            width: width,
            time: transitionTime,
            transition: 'easeOutQuint'
        });
        engineTween_1.Tweener.addTween(this.background.pivot, {
            x: width / 2,
            time: transitionTime,
            transition: 'easeOutQuint'
        });
    }
    onBtnFeatureBuy() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        const data = {
            type: PopupState_1.PopupType.FEATURE_BUY,
            hideOnClick: false,
            duration: -1,
            callbacks: null
        };
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.SHOW_POPUP, data).dispatch();
    }
}
exports["default"] = MultiFunctionalButton;


/***/ }),

/***/ 47010:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const pixi_spine_1 = __webpack_require__(15091);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const ValueText_1 = __importDefault(__webpack_require__(68223));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const tsyringe_1 = __webpack_require__(659);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const engineTween_1 = __webpack_require__(50381);
class TotalWinFrame extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        // this.tfTotalWin.text = 'TOTAL WIN'
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.totalWinValue.renderValueFunction = (tf, value) => {
            tf.text = `${wallet.getCurrencyValue(value)}`;
        };
        // this.totalWinIso = this.getChildByName('isoText');
        // this.totalWinIso.text= Wallet.currency.isoCode; 
        this.setValue(0);
        this.on('added', this.onAdded, this);
    }
    onAdded() {
        this._defaultPos = this.position.y;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'TotalWinGlow':
                instance = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('total-win-glow'));
                break;
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
        }
        return instance;
    }
    setValue(value, animated = false) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        if (animated) {
            if (value < this.totalWinValue.value) {
                this.totalWinValue.value = 0;
            }
            //To fix the issue when previous tween is not finished yet
            if (engineTween_1.Tweener.isTweening(this.totalWinValue)) {
                engineTween_1.Tweener.removeTweens(this.totalWinValue);
                this.totalWinValue.value = value;
                return;
            }
            const isTurbo = sm.currentGameSpeedLevel === 1;
            this.totalWinValue.setValue(value, {
                countUpDuration: isTurbo ? 0 : 0.6
            });
            // SoundManager.play({
            //     id: SoundList.TOTAL_WIN_APPEARANCE,
            //     volume: 0.4
            // });
            this.winAnimation(isTurbo);
        }
        else {
            this.totalWinValue.value = value;
        }
    }
    changePosition(offset = 0, skipAnimation = false) {
        if (skipAnimation) {
            this.position.y = this._defaultPos + offset;
            return;
        }
        engineTween_1.Tweener.addTween(this.position, {
            y: this._defaultPos + offset,
            time: 0.8,
            transition: 'easeOutQuint'
        });
    }
    // private isVisible(value: boolean): void {
    //     Tweener.addTween(this.totalWinValue, {
    //         alpha: value ? 1 : 0,
    //         time: 0.25,
    //         transition: 'easeInOutQuint',
    //         onStart: () => {
    //             if (value)
    //                 this.totalWinValue.alpha = 0;
    //         }
    //     })
    // }
    winAnimation(isTurbo = false) {
        if (isTurbo) {
            return;
        }
        const totalWinIn = 0.6;
        const totalWinOut = 0.5;
        //Animate the total win
        engineTween_1.Tweener.addTween(this.totalWinValue.scale, {
            x: 1.5,
            y: 1.5,
            time: totalWinIn,
            transition: 'easeOutQuint',
            onComplete: () => {
                engineTween_1.Tweener.addTween(this.totalWinValue.scale, {
                    x: 1,
                    y: 1,
                    time: totalWinOut,
                    transition: 'easeInQuint',
                });
            }
        });
    }
}
exports["default"] = TotalWinFrame;


/***/ }),

/***/ 81616:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntroScreenEvent = void 0;
var IntroScreenEvent;
(function (IntroScreenEvent) {
    IntroScreenEvent["ON_GET_STARTED_CLICKED"] = "onGetStartedClicked";
})(IntroScreenEvent || (exports.IntroScreenEvent = IntroScreenEvent = {}));


/***/ }),

/***/ 52472:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const pixi_spine_1 = __webpack_require__(15091);
const tsyringe_1 = __webpack_require__(659);
const SoundList_1 = __importDefault(__webpack_require__(27310));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const engineTween_1 = __webpack_require__(50381);
class PopupBigWin extends pixi_js_1.Container {
    constructor(level, winValue, scale) {
        super();
        this.levelAnimationNames = ['big', 'grand', 'mega', 'super'];
        this.levelAnimationDurations = [1, 1, 1, 1];
        LayoutBuilder_1.default.create(AssetsManager_1.default.layouts.get('PopupBigWin'), this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.winValue = winValue;
        this.on('added', this.onAdded, this);
        this.level = level;
        this.animations = [
            new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('big_win')),
            new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('grand_win')),
            new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('mega_win')),
            new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('super_win')),
        ];
        this.tfAmount = this['tfAmount'];
        this.tfAmount.anchor.set(0.5, 0.5);
        this.tfAmount.scale.y = -1;
        this.on('removed', this.onRemoved, this);
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
        }
        return instance;
    }
    scaleForLevel(level) {
        switch (level) {
            case 0: return 3;
            case 1: return 1;
            case 2: return 1;
            case 3: return 1;
            default: return 1;
        }
    }
    // PUBLIC API
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.tfAmount.text = wallet.getCurrencyValue(value, true);
    }
    get levelValue() {
        return this.level instanceof Function ? this.level() : this.level;
    }
    // PRIVATE API
    // private customClassElementCreate(le: LayoutElement): unknown {
    //     let instance: unknown = null;
    //     switch (le.customClass) {
    //         case "BigWinAnimation":
    //             switch (this.levelValue) {
    //                 case 0:
    //                     instance = new Spine(AssetsManager.spine.get("good_win"));
    //                     break;
    //                 case 1:
    //                     instance = new Spine(AssetsManager.spine.get("huge_win"));
    //                     break;
    //                 case 2:
    //                     instance = new Spine(AssetsManager.spine.get("great_win"));
    //                     break;
    //                 case 3:
    //                     instance = new Spine(AssetsManager.spine.get("insane_win"));
    //                     break;
    //             }
    //             break;
    //     }
    //     return instance;
    // }
    onAdded() {
        var _a;
        if (this.levelValue == -1) {
            throw new Error('Big win level not set');
        }
        this.removeChild(this.animation);
        this.animation = (_a = this.animations[this.levelValue]) !== null && _a !== void 0 ? _a : this.animations[0];
        this.animation.scale.set(this.scaleForLevel(this.levelValue));
        this.addChild(this.animation);
        const amountContainer = this.animation.slotContainers[this.animation.skeleton.findSlotIndex('rectangle')];
        amountContainer.name = 'AmountContainer';
        amountContainer.addChild(this.tfAmount);
        const levelAnimationDuration = this.levelAnimationDurations[this.levelValue];
        // spec says 5 secs animating, so we put 4 + 1 in + 1 out
        const numLoopAnimations = Math.ceil(5 / levelAnimationDuration);
        // this.animation.pivot.y=-this.animation.height/2;
        this.animation.state.setEmptyAnimations(0);
        const countUpDuration = 4;
        this.animation.state.addListener({
            start: (entry) => {
                if (entry.animation.name.includes('show')) {
                    this.tfAmount.alpha = 0;
                    engineTween_1.Tweener.addTween(this.tfAmount, {
                        alpha: 1,
                        time: 0.3,
                        // angle:-90,
                        transition: 'easeOutQuad',
                        delay: 0.3,
                    });
                    this.tfAmount.scale.set(0.5, 0.5);
                    engineTween_1.Tweener.addTween(this.tfAmount.scale, {
                        x: 1,
                        y: -1,
                        time: countUpDuration / 8,
                        transition: 'easeOutBack',
                        delay: 0.3,
                    });
                }
                else if (entry.animation.name.includes('hide')) {
                    engineTween_1.Tweener.addTween(this.tfAmount, {
                        alpha: 0,
                        time: 1,
                        transition: 'easeInQuad',
                        delay: 0.3
                    });
                }
            },
        });
        this.value = 0;
        engineTween_1.Tweener.addTween(this, {
            value: this.winValue instanceof Function ? this.winValue() : this.winValue,
            time: countUpDuration,
            transition: 'easeInOutQuad',
            onStart: () => {
                this.loopedSound = SoundManager_1.default.loop({
                    id: SoundList_1.default.COUNTER_LOOP,
                    volume: 0.25,
                });
            },
            onComplete: () => {
                this.loopedSound.stop();
                // SoundManager.play({
                //     id: SoundList.COUNTER_END,
                //     volume: 0.4,
                // });
            },
        });
        // this.coinAnimation.state.setAnimation(0, 'animation', true);
        this.animation.stateData.setMix(`show`, `idle`, 0.7);
        this.animation.state.setAnimation(0, `show`, false);
        for (let i = 0; i < numLoopAnimations; i++) {
            this.animation.state.addAnimation(0, `idle`, true, 0);
        }
        // this.animation.state.addAnimation(0, `${levelAnimationName}_win_disappearance`, false, 0);
    }
    onRemoved() {
        if (this.loopedSound)
            this.loopedSound.stop();
        engineTween_1.Tweener.removeTweens(this);
        engineTween_1.Tweener.removeTweens(this.tfAmount);
        engineTween_1.Tweener.removeTweens(this.tfAmount.scale);
        this.animations.forEach((animation) => {
            animation.state.setEmptyAnimations(0);
            animation.state.clearListeners();
            animation['lastTime'] = null;
        });
    }
}
exports["default"] = PopupBigWin;


/***/ }),

/***/ 65058:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Button_1 = __importDefault(__webpack_require__(78386));
const DataSource_1 = __webpack_require__(92907);
class PopupConnectionLost extends pixi_js_1.Container {
    constructor(errorMessage, le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.tfMessage.text = DataSource_1.errorMessageCode[DataSource_1.errorMessageCode.hasOwnProperty(errorMessage) ? errorMessage : 'UNFINISHED_SLOT_GAME_BET_EXISTS'];
        this.icon.on('pointerup', this.onIconClick, this);
        this.btnClose.on('pointerup', this.onIconClick, this);
    }
    onIconClick() {
        location.reload();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
        }
        return instance;
    }
}
exports["default"] = PopupConnectionLost;


/***/ }),

/***/ 70718:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Button_1 = __importDefault(__webpack_require__(78386));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIPanelEvent_1 = __webpack_require__(566);
const Utils_1 = __webpack_require__(63948);
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const SlotGameEventExtension_1 = __webpack_require__(69898);
class PopupFeatureBuy extends pixi_js_1.Container {
    constructor() {
        super();
        LayoutBuilder_1.default.create(AssetsManager_1.default.layouts.get('PopupFeatureBuy'), this, (le) => {
            return this.customClassElementCreate(le);
        });
        if (this.background) {
            this.background.anchor.set(0.5, 0.5);
        }
        if (this['tfMainText']) {
            this['tfMainText'].style.align = 'center';
        }
        this.tfFreespins.style.align = 'center';
        (0, Utils_1.autoscaleText)(this.tfFreespins, this.tfFreespins.style.fontSize, 537, 244.5);
        this.btnStart.on('pointerup', this.onBtnStart, this);
        this.btnCancel.on('pointerup', this.onBtnCancel, false);
        this.on('added', this.onAdded, this);
    }
    onAdded() {
        const gs = tsyringe_1.container.resolve('GameService');
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.tfAmount.text = wallet.getCurrencyValue(gs.featureBuyConfig.Rate * sm.totalBet * wallet.coinValue, true);
        this.btnStart.enabled = true;
        (0, Utils_1.autoscaleText)(this.tfAmount, 25, 500, 120);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
        }
        return instance;
    }
    onBtnStart() {
        this.btnStart.enabled = false;
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.HIDE_POPUP).dispatch();
        new ControlEvent_1.default(SlotGameEventExtension_1.SlotGameEventExtension.BUY_FREESPINS).dispatch();
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
    }
    onBtnCancel() {
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.HIDE_POPUP).dispatch();
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
    }
}
exports["default"] = PopupFeatureBuy;


/***/ }),

/***/ 46656:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_spine_1 = __webpack_require__(15091);
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const Utils_1 = __webpack_require__(63948);
const Translation_1 = __importDefault(__webpack_require__(62231));
class PopupFreeSpinWinning extends pixi_js_1.Container {
    constructor(amount, scale, freeSpinEnd = false, totalFreeSpins) {
        super();
        this.amount = amount;
        // DisplayShortcuts.init();
        LayoutBuilder_1.default.create(AssetsManager_1.default.layouts.get('PopupFreeSpinWinning'), this, (le) => {
            return this.customClassElementCreate(le);
        });
        // const headerContainer: Container = this.animation.slotContainers[this.animation.skeleton.findSlotIndex('in_15_free_spins')];
        // headerContainer.name = 'HeaderContainer';
        // headerContainer.removeChildren();
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.tfAmount.anchor.set(0.5);
        this.tfFreeSpinNumber.anchor.set(0.5);
        this.tfFreespinsHeader.anchor.set(0.5);
        this.tfFreeSpinContinue.anchor.set(0.5);
        this.tfAmount.scale.set(2, -2);
        this.tfAmount.position.set(10, -100);
        this.tfFreeSpinNumber.position.set(0, -230);
        this.tfFreespinsHeader.position.set(0, 25);
        this.tfFreeSpinContinue.position.set(0, -300);
        this.tfFreeSpinContinue.scale.y = -1;
        this.tfFreespinsHeader.scale.y = -1;
        this.tfFreeSpinNumber.scale.y = -1;
        this.tfFreespinsHeader.text = Translation_1.default.t('freeSpin.tfYouHaveWon');
        this.tfFreeSpinContinue.text = Translation_1.default.t('freeSpin.tfFreeSpinContinue');
        this.tfFreeSpinNumber.text = Translation_1.default.t('freeSpin.tfFreeSpinNumber', { count: totalFreeSpins.toString() });
        if (freeSpinEnd) {
            this.tfFreeSpinNumber.text = Translation_1.default.t('freeSpin.tfFreeSpinNumber', { count: totalFreeSpins.toString() });
        }
        this.animation = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('freespins-popup'));
        //   this.animation.scale.set(0.5)
        // this.coinAnimation = new Spine(AssetsManager.spine.get('winning_coins'))
        this.addChild(this.animation);
        for (let i = 0; i < this.animation.skeleton.slots.length; i++) {
            const slot = this.animation.skeleton.slots[i];
            const slotContainer = this.animation.slotContainers[i];
            slotContainer.name = slot.data.name;
        }
        setTimeout(() => {
            const counterContainer = this.animation.slotContainers[this.animation.skeleton.findSlotIndex('rectangle')];
            // counterContainer.removeChildren();
            counterContainer.name = 'counterContainer';
            counterContainer.addChild(this.tfAmount);
            if (freeSpinEnd) {
                const inFreeSpinContainer = this.animation.slotContainers[this.animation.skeleton.findSlotIndex('rectangle')];
                // inFreeSpinContainer.removeChildren();
                inFreeSpinContainer.name = 'inFreeSpinContainer';
                inFreeSpinContainer.addChild(this.tfFreespinsHeader);
                inFreeSpinContainer.addChild(this.tfFreeSpinNumber);
                inFreeSpinContainer.addChild(this.tfFreeSpinContinue);
            }
        }, 100);
        this.on('removed', this.onRemoved, this);
        this.on('added', this.onAdded, this);
        if (scale) {
            this.animation.scale.set(scale);
        }
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            // case 'TransitionAnimation':
            //     instance = new Spine(AssetsManager.spine.get('transition_animation'));
            //     break;
            // case 'FreespinAnimation':
            //     instance = this.animation
            //     break;
        }
        return instance;
    }
    onAdded() {
        let sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.tfAmount.text = wallet.getCurrencyValue(this.amount instanceof Function ? this.amount() : this.amount);
        (0, Utils_1.autoscaleText)(this.tfAmount, 50, 500, 120);
        this.animation.state.setEmptyAnimations(0);
        this.animation.state.setAnimation(0, 'idle', true);
        // this.tfFreeSpinNumber.text = Translation.t('freeSpin.tfFreeSpinNumber', { count: sm.currentSpinResult.freespins.totalCount.toString() });
        // this.coinAnimation.state.setAnimation(0,'animation', true)
    }
    onRemoved() {
        this.animation.state.setEmptyAnimations(0);
        this.animation.state.clearListeners();
        this.animation['lastTime'] = null;
    }
}
exports["default"] = PopupFreeSpinWinning;


/***/ }),

/***/ 69577:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_spine_1 = __webpack_require__(15091);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const Translation_1 = __importDefault(__webpack_require__(62231));
class PopupFreespins extends pixi_js_1.Container {
    constructor(amount, scale) {
        super();
        LayoutBuilder_1.default.create(AssetsManager_1.default.layouts.get('PopupFreespins'), this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.tfFreespinsHeader.anchor.set(0.5);
        this.tfFreeSpinContinue.anchor.set(0.5);
        this.tfFreeSpins.anchor.set(0.5);
        this.tfFreespinsHeader.scale.set(1, -1);
        this.tfFreeSpinContinue.scale.set(1, -1);
        this.tfFreeSpins.scale.set(1, -1);
        this.tfAmount.text = '';
        this.tfAmount.anchor.set(0.5);
        this.tfAmount.scale.set(1, -1);
        this.tfAmount.position.set(10, -100);
        this.tfFreeSpinContinue.position.set(10, -300);
        this.tfFreespinsHeader.position.set(10, 35);
        this.tfFreeSpins.position.set(10, -230);
        const counterContainer = this.animation.slotContainers[this.animation.skeleton.findSlotIndex('rectangle')];
        counterContainer.name = 'AmountContainer';
        counterContainer.addChild(this.tfAmount);
        counterContainer.addChild(this.tfFreespinsHeader);
        counterContainer.addChild(this.tfFreeSpinContinue);
        counterContainer.addChild(this.tfFreeSpins);
        this.on('added', this.onAdded, this);
        this.on('removed', this.onRemoved, this);
        if (scale) {
            this.animation.scale.set(scale);
        }
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'FreespinsAnimation':
                instance = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('freespins-popup'));
                break;
        }
        return instance;
    }
    onAdded() {
        let sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.tfAmount.text = (sm.currentSpinResult.freespins.moreAwarded ? '+' + sm.currentSpinResult.freespins.moreAwarded : sm.currentSpinResult.freespins.remainingCount).toString();
        if (sm.currentSpinResult.freespins.totalCount === sm.currentSpinResult.freespins.remainingCount || sm.currentSpinResult.freespins.moreAwarded) {
            this.tfFreespinsHeader.text = Translation_1.default.t('freeSpin.tfYouHaveWon');
        }
        else {
            this.tfFreespinsHeader.text = Translation_1.default.t('freeSpin.tfYouHaveLeft');
        }
        // this.tfFreespinsHeader.scale.y = -1;
        // this.tfFreespinsHeader.anchor.set(0.5);
        // const headerContainer: Container = this.animation.slotContainers[this.animation.skeleton.findSlotIndex('you_have_won')];
        // headerContainer.name = 'HeaderContainer';
        // headerContainer.removeChildren();
        // headerContainer.addChild(this.tfFreespinsHeader);
        this.animation.state.setEmptyAnimations(0);
        this.animation.state.setAnimation(0, 'show', false);
        this.animation.state.addAnimation(0, 'idle', true, 0);
    }
    onRemoved() {
        this.animation.state.setAnimation(0, 'hide', false);
        this.animation.state.clearListeners();
        this.animation['lastTime'] = null;
    }
}
exports["default"] = PopupFreespins;


/***/ }),

/***/ 25571:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIPanelEvent_1 = __webpack_require__(566);
class PopupNotEnoughBalance extends pixi_js_1.Container {
    constructor() {
        super();
        LayoutBuilder_1.default.create(AssetsManager_1.default.layouts.get('PopupNotEnoughBalance'), this);
        this.interactive = true;
        // Add event listener for click interaction
        this.on('pointerdown', this.onPopupClick);
    }
    onPopupClick() {
        // Dispatch the HIDE_POPUP event when clicked
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.HIDE_POPUP).dispatch();
    }
    destroy() {
        // Cleanup: Remove the event listener
        this.off('pointerdown', this.onPopupClick);
        super.destroy();
    }
}
exports["default"] = PopupNotEnoughBalance;


/***/ }),

/***/ 66672:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const UIEvent_1 = __webpack_require__(77066);
const Panel_1 = __importDefault(__webpack_require__(25056));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const ScreenOrientation_1 = __webpack_require__(81827);
const BetSettings_1 = __importDefault(__webpack_require__(69404));
const ValueText_1 = __importDefault(__webpack_require__(68223));
const StatusComponent_1 = __importDefault(__webpack_require__(24639));
const SlotMachineEvent_1 = __webpack_require__(96421);
const ToggleButton_1 = __webpack_require__(19838);
class AdjustBetPanel extends Panel_1.default {
    constructor(layout) {
        super(layout);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.btnMaxBet.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.onBtnMaxBet, this);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, this.updateView, this);
        this.backgroundWidthDefault = this['background'].width;
        const xSpacer = 15;
        this.updateView();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'BetSettings':
                instance = new BetSettings_1.default(le);
                break;
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
            case "ToggleButton":
                instance = new ToggleButton_1.ToggleButton(le);
                break;
            case 'StatusComponent':
                instance = new StatusComponent_1.default(le);
                break;
            default:
                instance = super.customClassElementCreate(le);
        }
        return instance;
    }
    // PUBLIC API
    updateLayout(desc) {
        super.updateLayout(desc);
        const offsetXToMaskBorders = 10;
        if (desc.orientation == ScreenOrientation_1.ScreenOrientation.VERTICAL) {
            // this.background.width = desc.currentWidth + offsetXToMaskBorders;
        }
        else {
            this.background.width = this.backgroundWidthDefault;
        }
        this.background.pivot.x = this.background.width / 2;
        this.children.forEach((child) => { var _a; return (_a = child['updateLayout']) === null || _a === void 0 ? void 0 : _a.call(child, desc); });
        if (desc.orientation === ScreenOrientation_1.ScreenOrientation.HORIZONTAL) {
            this.scale.set(1);
        }
        else {
            this.scale.set(2);
        }
    }
    updateView() {
        if (this.slotMachine.description.betLimits[0] === this.slotMachine.currentBetValue) {
            if (this.btnMaxBet.getIsStateOn()) {
                this.btnMaxBet.setStateView(false);
            }
        }
        else if (this.slotMachine.description.betLimits[this.slotMachine.description.betLimits.length - 1] === this.slotMachine.currentBetValue) {
            if (!this.btnMaxBet.getIsStateOn()) {
                this.btnMaxBet.setStateView(true);
            }
        }
    }
    // PRIVATE API
    // USER INTERACTION
    onBtnMaxBet() {
        if (this.btnMaxBet.getIsStateOn()) {
            SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
            this.betSettings.currentBetValue = this.betSettings.betLimits[this.betSettings.betLimits.length - 1];
            this.betSettings.onBetValueChanged();
            this.betSettings.updateView();
            new ControlEvent_1.default(UIEvent_1.UIEvent.COIN_VALUE_MAX).dispatch();
            new ControlEvent_1.default(UIEvent_1.UIEvent.BET_QUANTITY_MAX).dispatch();
        }
        else {
            SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
            this.betSettings.currentBetValue = this.betSettings.betLimits[0];
            this.betSettings.onBetValueChanged();
            this.betSettings.updateView();
            new ControlEvent_1.default(UIEvent_1.UIEvent.COIN_VALUE_MIN).dispatch();
            new ControlEvent_1.default(UIEvent_1.UIEvent.BET_QUANTITY_MIN).dispatch();
        }
    }
}
exports["default"] = AdjustBetPanel;


/***/ }),

/***/ 48966:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const tsyringe_1 = __webpack_require__(659);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const GameServiceEvent_1 = __webpack_require__(83363);
const ToggleButton_1 = __webpack_require__(19838);
class AdjustSettings extends pixi_js_1.Container {
    ;
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.gs = tsyringe_1.container.resolve('GameService');
        this.gs.on(GameServiceEvent_1.GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateView();
        }, this);
        this.switch_1 = this.getChildByName('switch_module_1')['switch_1'];
        this.switch_2 = this.getChildByName('switch_module_2')['switch_2'];
        this.switch_3 = this.getChildByName('switch_module_3')['switch_3'];
        this.switch_4 = this.getChildByName('switch_module_4')['switch_4'];
        // this.switch_5 = this.getChildByName('switch_module_5')['switch_5'] as ToggleButton;
        this.switch_1.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.changeQuickSpin, this);
        this.switch_2.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.changeBattery, this);
        this.switch_3.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.changeAmbient, this);
        this.switch_4.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.changeSounds, this);
        // this.switch_5.on(ToggleButton.STATE_CHANGED, this.changeIntroScreen, this);
        this.updateView();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case "ToggleButton":
                instance = new ToggleButton_1.ToggleButton(le);
                break;
        }
        return instance;
    }
    updateView() {
        this.switch_1.setStateView(this.gs.settings.quickSpin);
        this.switch_2.setStateView(this.gs.settings.batterySaver);
        this.switch_3.setStateView(this.gs.settings.ambientMusic);
        this.switch_4.setStateView(this.gs.settings.soundFx);
        // this.switch_5.setStateView(this.gs.settings.introScreen);
    }
    changeQuickSpin() {
        this.gs.settings.quickSpin = !this.gs.settings.quickSpin;
        this.gs.saveSettings();
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentGameSpeedLevel = !this.gs.settings.quickSpin ? 0 : 1;
    }
    changeBattery() {
        this.gs.settings.batterySaver = !this.gs.settings.batterySaver;
        this.gs.saveSettings();
    }
    changeAmbient() {
        this.gs.settings.ambientMusic = !this.gs.settings.ambientMusic;
        this.gs.saveSettings();
        SoundManager_1.default.getChannel('ambient').mute = !this.gs.settings.ambientMusic;
    }
    changeSounds() {
        this.gs.settings.soundFx = !this.gs.settings.soundFx;
        this.gs.saveSettings();
        SoundManager_1.default.getChannel('default').mute = !this.gs.settings.soundFx;
    }
    changeIntroScreen() {
        this.gs.settings.introScreen = !this.gs.settings.introScreen;
        this.gs.saveSettings();
    }
}
exports["default"] = AdjustSettings;


/***/ }),

/***/ 88138:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Button_1 = __importDefault(__webpack_require__(78386));
const ValueText_1 = __importDefault(__webpack_require__(68223));
const SlotMachineEvent_1 = __webpack_require__(96421);
const tsyringe_1 = __webpack_require__(659);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const WalletEvent_1 = __webpack_require__(63035);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const UIEventExtension_1 = __webpack_require__(43022);
class AdjustTotalBet extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.onBetValueChanged();
        this.btnBetDown.on('pointerup', this.onTotalBetDown, this);
        this.btnBetUp.on('pointerup', this.onTotalBetUp, this);
        this.setupButtonOnClickSound();
    }
    onBetValueChanged() {
        this.tfTotalBetValue.tfValue.text = `${this.wallet.getCurrencyValue(this.slotMachine.totalBet * this.wallet.coinValue * Wallet_1.default.denomination)}`;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
        }
        return instance;
    }
    onTotalBetUp() {
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_INCREASE);
        new ControlEvent_1.default(UIEventExtension_1.UIEventExtension.TOTAL_BET_UP).dispatch();
    }
    onTotalBetDown() {
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_DECREASE);
        new ControlEvent_1.default(UIEventExtension_1.UIEventExtension.TOTAL_BET_DOWN).dispatch();
    }
    setupButtonOnClickSound() {
        for (const key in this) {
            const button = this[key];
            if (button instanceof Button_1.default) {
                button.on('pointerup', () => SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK), this);
            }
        }
    }
}
exports["default"] = AdjustTotalBet;


/***/ }),

/***/ 86057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Button_1 = __importDefault(__webpack_require__(78386));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIEvent_1 = __webpack_require__(77066);
const Panel_1 = __importDefault(__webpack_require__(25056));
const ScreenOrientation_1 = __webpack_require__(81827);
const MetricsView_1 = __importDefault(__webpack_require__(35498));
const ui_1 = __webpack_require__(85930);
const tsyringe_1 = __webpack_require__(659);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SwitchView_1 = __importDefault(__webpack_require__(76473));
const ToggleButton_1 = __webpack_require__(19838);
const AdjustTotalBet_1 = __importDefault(__webpack_require__(88138));
const GameServiceEvent_1 = __webpack_require__(83363);
class AutospinPanel extends Panel_1.default {
    constructor(le) {
        super(le);
        this.spinsNumber = 500;
        this.btnConfirm.on('pointerup', this.onBtnConfirm, this);
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.gs = tsyringe_1.container.resolve('GameService');
        this.slider.onUpdate.connect((value) => {
            this.spinsNumber = value;
            this.onAutoPlaySliderChange(value);
            // this.slotMachine.emit("AUTO_PLAY_SLIDER_CHANGE", value);
        });
        // this.slotMachine.on("AUTO_PLAY_SLIDER_CHANGE", this.onAutoPlaySliderChange, this);
        this.slotMachine.on("SKIP_BTN_STATE_CHANGE", this.onSkipBtnStateChange, this);
        this.updateSpinNumbers();
        this.updateView();
        this.gs = tsyringe_1.container.resolve('GameService');
        this.gs.on(GameServiceEvent_1.GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateView();
        }, this);
        this.skipBtn.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.onSkipBtnStateChange, this);
        this.btnTurbo.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.changeQuickSpin, this);
    }
    changeQuickSpin() {
        this.gs.settings.quickSpin = !this.gs.settings.quickSpin;
        this.gs.saveSettings();
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentGameSpeedLevel = !this.gs.settings.quickSpin ? 0 : 1;
    }
    onAutoPlaySliderChange(value) {
        this.spinsNumber = value;
        this.slider.value = value;
        // (this.slider.children[0].children[1] as DisplayObject).width = (((this.slider.children[0] as Container).width - (this.slider.children[1] as Container).width + 1) / 1000) * value;
        this.updateSpinNumbers();
    }
    onSkipBtnStateChange() {
        this.gs.settings.skipScreen = !this.gs.settings.skipScreen;
        this.gs.saveSettings();
    }
    updateView() {
        this.btnTurbo.setStateView(this.gs.settings.quickSpin);
        this.skipBtn.setStateView(this.gs.settings.skipScreen);
    }
    // PUBLIC API
    updateLayout(desc) {
        super.updateLayout(desc);
        if (desc.orientation === ScreenOrientation_1.ScreenOrientation.HORIZONTAL) {
            this.scale.set(1);
        }
        else {
            this.scale.set(2);
        }
    }
    // PRIVATE API
    get settings() {
        const data = {
            spinsLeft: this.spinsNumber,
        };
        return data;
    }
    // USER INTERACTION
    onBtnConfirm() {
        super.onBtnClose();
        new ControlEvent_1.default(UIEvent_1.UIEvent.AUTO_SPIN, this.settings).dispatch();
    }
    updateSpinNumbers() {
        this.tfTotalAutoSpinValue.text = `${this.spinsNumber}`;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'AdjustTotalBet':
                instance = new AdjustTotalBet_1.default(le);
                break;
            case 'MetricsView':
                instance = new MetricsView_1.default(le);
                break;
            case 'SwitchView':
                instance = new SwitchView_1.default(le);
                break;
            case 'SliderPortrait':
                instance = new ui_1.Slider({
                    bg: 'sliderBGPortrait',
                    fill: 'sliderFillPortrait',
                    slider: 'slider',
                    min: 0,
                    max: 1000,
                    value: 500
                });
                break;
            case 'SliderLandscape':
                instance = new ui_1.Slider({
                    bg: 'sliderBGLandscape',
                    fill: 'sliderFillLandscape',
                    slider: 'slider',
                    min: 0,
                    max: 1000,
                    value: 500
                });
                break;
            case "ToggleButton":
                instance = new ToggleButton_1.ToggleButton(le);
                break;
            // case "ToggleButton":
            //     instance=new ToggleButton({
            //     })
        }
        return instance;
    }
}
exports["default"] = AutospinPanel;


/***/ }),

/***/ 69404:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const tsyringe_1 = __webpack_require__(659);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const ValueText_1 = __importDefault(__webpack_require__(68223));
const Button_1 = __importStar(__webpack_require__(78386));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachineEvent_1 = __webpack_require__(96421);
const WalletEvent_1 = __webpack_require__(63035);
const SoundList_1 = __importDefault(__webpack_require__(27310));
class BetSettings extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.betLimits = this.slotMachine.description.betLimits;
        this.currentBetValue = this.slotMachine.currentBetValue;
        this.btnTotalBetUp.on('pointerup', this.onTotalBetUp, this);
        this.btnTotalBetDown.on('pointerup', this.onTotalBetDown, this);
        this.btnCoinDown.on('pointerup', this.onCoinDown, this);
        this.btnCoinUp.on('pointerup', this.onCoinUp, this);
        this.btnBetUp.on('pointerup', this.onBetUp, this);
        this.btnBetDown.on('pointerup', this.onBetDown, this);
        this.setupButtonOnClickSound();
        // this.onBetValueChanged();
        // this.updateView();
        //this.fetchTranslationFile();
    }
    updateLayout(desc) {
        this.updateView();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
        }
        return instance;
    }
    onAdded() {
        this.currentBetValue = tsyringe_1.container.resolve(SlotMachine_1.default).currentBetValue;
        this.updateView();
        this.onBetValueChanged();
    }
    onTotalBetUp() {
        // new ControlEvent(UIEventExtension.TOTAL_BET_UP).dispatch();
        if (this.betLimits.indexOf(this.currentBetValue) < this.betLimits.length - 1) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) + 1];
        }
        this.onBetValueChanged();
        this.updateView();
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_INCREASE);
    }
    onTotalBetDown() {
        // new ControlEvent(UIEventExtension.TOTAL_BET_DOWN).dispatch();
        if (this.betLimits.indexOf(this.currentBetValue) != 0) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) - 1];
        }
        this.onBetValueChanged();
        this.updateView();
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_DECREASE);
    }
    onCoinUp() {
        // new ControlEvent(UIEvent.COIN_VALUE_UP).dispatch();
        if (this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) < this.wallet.coinValueLimits.length - 1) {
            this.wallet.coinValue = this.wallet.coinValueLimits[this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) + 1];
        }
        this.onBetValueChanged();
        this.updateView();
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_INCREASE);
    }
    onCoinDown() {
        // new ControlEvent(UIEvent.COIN_VALUE_DOWN).dispatch();
        if (this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) != 0) {
            this.wallet.coinValue = this.wallet.coinValueLimits[this.wallet.coinValueLimits.indexOf(this.wallet.coinValue) - 1];
        }
        this.onBetValueChanged();
        this.updateView();
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_DECREASE);
    }
    onBetUp() {
        // new ControlEvent(UIEvent.BET_QUANTITY_UP).dispatch();
        if (this.betLimits.indexOf(this.currentBetValue) < this.betLimits.length - 1) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) + 1];
        }
        this.onBetValueChanged();
        this.updateView();
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_INCREASE);
    }
    onBetDown() {
        // new ControlEvent(UIEvent.BET_QUANTITY_DOWN).dispatch();
        if (this.betLimits.indexOf(this.currentBetValue) != 0) {
            this.currentBetValue = this.betLimits[this.betLimits.indexOf(this.currentBetValue) - 1];
        }
        this.onBetValueChanged();
        this.updateView();
        SoundManager_1.default.play(SoundList_1.default.BET_AMOUNT_DECREASE);
    }
    updateView() {
        const btnBetUpActive = this.currentBetValue < this.slotMachine.description.betLimits[this.slotMachine.description.betLimits.length - 1];
        const btnBetDownActive = this.currentBetValue > this.slotMachine.description.betLimits[0];
        const coinValueIndex = this.wallet.coinValueLimits.indexOf(this.wallet.coinValue);
        const btnCoinDownActive = coinValueIndex > 0;
        const btnCoinUpActive = coinValueIndex < this.wallet.coinValueLimits.length - 1;
        const view = new Map([
            [this.btnBetUp, btnBetUpActive],
            [this.btnBetDown, btnBetDownActive],
            [this.btnCoinDown, btnCoinDownActive],
            [this.btnCoinUp, btnCoinUpActive],
            [this.btnTotalBetUp, !(!btnBetUpActive && !btnCoinUpActive)],
            [this.btnTotalBetDown, !(!btnBetDownActive && !btnCoinDownActive)],
        ]);
        view.forEach((active, btn) => {
            btn.setState(active ? Button_1.ButtonState.NORMAL : Button_1.ButtonState.DISABLED);
            btn.enabled = active;
        });
    }
    onBetValueChanged() {
        //console.log(this.currentBetValue)
        const gs = tsyringe_1.container.resolve('GameService');
        this.tfTotalBetValue.tfValue.text = `${this.wallet.getCurrencyValue(this.currentBetValue * ((this.slotMachine.numLines == 0) ? this.slotMachine.combinations : this.slotMachine.numLines) * (gs.doubleUpChance ? 1.25 : 1) * this.wallet.coinValue * Wallet_1.default.denomination)}`;
        this.tfBetValue.tfValue.text = `${this.wallet.getCurrencyValue(this.currentBetValue)}`;
        this.tfCoinValue.tfValue.text = `${this.wallet.coinValue}`;
    }
    setupButtonOnClickSound() {
        for (const key in this) {
            const button = this[key];
            if (button instanceof Button_1.default) {
                button.on('pointerup', () => SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK), this);
            }
        }
    }
}
exports["default"] = BetSettings;


/***/ }),

/***/ 11622:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CascadeHistoryCell = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const SymbolView_1 = __importDefault(__webpack_require__(14462));
const Utils_1 = __webpack_require__(63948);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const tsyringe_1 = __webpack_require__(659);
class CascadeHistoryCell extends pixi_js_1.Container {
    constructor(config) {
        super();
        LayoutBuilder_1.default.create(AssetsManager_1.default.layouts.get('CascadeHistoryCell-cascadeHistoryCell'), this);
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.tfCount.text = config.symbolCount;
        this.tfWin.text = this.wallet.getCurrencyValue(config.payout, true);
        this.tfWin.text = config.payout;
        this.createSymbolInSlot(config.symbol);
        (0, Utils_1.autoscaleText)(this.tfWin, 30, 50, 33);
    }
    createSymbolInSlot(symbolData) {
        this.symbolSlot['area'].visible = false;
        const symbol = new SymbolView_1.default(symbolData);
        symbol.height = this.symbolSlot['area'].height;
        symbol.width = this.symbolSlot['area'].width;
        const scale = Math.min(symbol.scale.y, symbol.scale.x);
        symbol.scale.set(scale);
        this.symbolSlot.addChild(symbol);
    }
}
exports.CascadeHistoryCell = CascadeHistoryCell;


/***/ }),

/***/ 4799:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CascadeHistoryView = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const CascadeHistoryCell_1 = __webpack_require__(11622);
const engineTween_1 = __webpack_require__(50381);
class CascadeHistoryView extends pixi_js_1.Container {
    constructor(le) {
        super();
        this.offset = 50;
        this.maxElements = 4;
        this.fallingTIme = 0.3;
        this.cellCount = 0;
        this.layout = le;
        LayoutBuilder_1.default.create(le, this);
        this.content.mask = this.contentMask;
    }
    addCell(symbol, count, win, multiplier) {
        const cell = new CascadeHistoryCell_1.CascadeHistoryCell({ symbol: symbol, symbolCount: count, payout: win, multiplier: multiplier });
        const previousCells = this.content.children.length;
        this.content.addChild(cell);
        cell.position.y = -this.background.height - this.offset;
        engineTween_1.Tweener.addTween(cell, {
            alpha: 1,
            time: this.fallingTIme,
            transition: 'easeOutSine',
            onStart: () => {
                cell.alpha = 0;
            },
            onComplete: () => {
                if (this.content.children.length > this.maxElements) {
                    this.cellCount = this.content.children.length - this.maxElements;
                    this.removeLastCell(() => { this.moveLower(); });
                    return;
                }
                this.moveLower();
            }
        });
    }
    reset() {
        for (let i = 0; i < this.content.children.length; i++) {
            const cell = this.content.children[i];
            engineTween_1.Tweener.removeTweens(cell);
            engineTween_1.Tweener.addTween(cell, {
                y: cell.y + 10,
                alpha: 0,
                time: this.fallingTIme,
                transition: 'easeOutQuint',
                onComplete: () => {
                    this.removeChild(cell);
                    cell.destroy({ children: true });
                }
            });
        }
    }
    removeLastCell(onComplete) {
        const child = this.content.children[0];
        engineTween_1.Tweener.removeTweens(child);
        engineTween_1.Tweener.addTween(child, {
            y: child.y + 10,
            alpha: 0,
            time: this.fallingTIme,
            transition: 'easeOutQuint',
            onComplete: () => {
                for (let i = 0; i < this.cellCount; i++) {
                    this.content.removeChild(this.content.children[i]);
                    child.destroy({ children: true });
                    //this.moveLower();
                    //this.cellCount -= 1;
                }
                if (onComplete)
                    onComplete();
            }
        });
    }
    moveLower() {
        const offsetBetweenCascades = 2;
        this.content.children.forEach((child, index) => {
            engineTween_1.Tweener.removeTweens(child);
            engineTween_1.Tweener.addTween(child, {
                y: -index * (child['background'].height + offsetBetweenCascades),
                alpha: 1,
                time: this.fallingTIme,
                transition: 'easeOutSine'
            });
        });
    }
}
exports.CascadeHistoryView = CascadeHistoryView;


/***/ }),

/***/ 32181:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DoubleChanceButton = void 0;
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachineEvent_1 = __webpack_require__(96421);
const Button_1 = __importDefault(__webpack_require__(78386));
const WalletEvent_1 = __webpack_require__(63035);
const DoubleChanceSwitch_1 = __webpack_require__(12797);
const Utils_1 = __webpack_require__(63948);
class DoubleChanceButton extends Button_1.default {
    constructor(l) {
        super(l, (le) => {
            let instance = null;
            switch (le.customClass) {
                case 'DoubleChanceSwitch':
                    instance = new DoubleChanceSwitch_1.DoubleChanceSwitch(le);
                    break;
            }
            return instance;
        });
        this.costRate = 1.25;
        this.tfValue = this['normal']['tfValue'];
        this.tfDescription = this['normal']['tfDescription'];
        this.tfDouble = this['normal']['tfDouble'];
        this.tfTitle = this['normal']['tfTitle'];
        this.doubleChanceSwitch = this['normal']['doubleChanceSwitch'];
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        sm.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, () => {
            this.setValue(wallet.getCurrencyValue(this.costRate * sm.totalBet * wallet.coinValue, true));
        }, this);
        wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, () => {
            this.setValue(wallet.getCurrencyValue(this.costRate * sm.totalBet * wallet.coinValue, true));
        }, this);
        this.setValue(wallet.getCurrencyValue(this.costRate * sm.totalBet * wallet.coinValue, true));
        this.setTexts();
        this.on('pointerup', this.onClick, this);
    }
    setValue(value) {
        if (this.tfValue) {
            this.tfValue.text = value;
            (0, Utils_1.autoscaleText)(this.tfValue, 30, 300, 65);
        }
    }
    onClick() {
        const gs = tsyringe_1.container.resolve('GameService');
        gs.doubleUpChance = !gs.doubleUpChance;
    }
    setTexts() {
        if (this.tfDouble)
            (0, Utils_1.autoscaleText)(this.tfDouble, 45, 300, 65);
        if (this.tfDescription) {
            this.tfDescription.style.align = 'center';
            (0, Utils_1.autoscaleText)(this.tfDescription, 20, 195, 64);
        }
        if (this.tfTitle)
            (0, Utils_1.autoscaleText)(this.tfTitle, 35, 300, 100);
    }
}
exports.DoubleChanceButton = DoubleChanceButton;


/***/ }),

/***/ 12797:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DoubleChanceSwitch = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const tsyringe_1 = __webpack_require__(659);
const engineTween_1 = __webpack_require__(50381);
const GameServiceEvent_1 = __webpack_require__(83363);
class DoubleChanceSwitch extends pixi_js_1.Container {
    constructor(le) {
        super();
        this._active = false;
        this.offset = 6;
        LayoutBuilder_1.default.create(le, this);
        this.background.anchor.set(0.5, 0.5);
        this.switchArrow.anchor.set(0.5, 0.5);
        this.switchConfirm.anchor.set(0.5, 0.5);
        const gs = tsyringe_1.container.resolve('GameService');
        gs.on(GameServiceEvent_1.GameServiceEvent.DOUBLE_CHANCE_CHANGED, () => {
            this.active = gs.doubleUpChance;
        }, this);
        this.active = gs.doubleUpChance;
    }
    set active(isActive) {
        this._active = isActive;
        this.updateView();
    }
    updateView() {
        engineTween_1.Tweener.removeTweens(this.switchArrow);
        engineTween_1.Tweener.removeTweens(this.switchConfirm);
        this.switchConfirm.alpha = this._active ? 0.5 : 1;
        this.switchArrow.alpha = this._active ? 0.5 : 1;
        [this.switchConfirm, this.switchArrow].forEach((btn) => {
            engineTween_1.Tweener.addTween(btn, {
                x: this._active ? this.background.width / 2 - btn.width / 2 : -26.5,
                time: 0.25,
                transition: 'easeOutSine'
            });
        });
    }
}
exports.DoubleChanceSwitch = DoubleChanceSwitch;


/***/ }),

/***/ 10554:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FreeSpinButton = void 0;
const Button_1 = __importDefault(__webpack_require__(78386));
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const PopupState_1 = __webpack_require__(57388);
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIPanelEvent_1 = __webpack_require__(566);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotMachineEvent_1 = __webpack_require__(96421);
const WalletEvent_1 = __webpack_require__(63035);
const SlotMachineState_1 = __webpack_require__(77313);
const Translation_1 = __importDefault(__webpack_require__(62231));
const Utils_1 = __webpack_require__(63948);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const GameServiceEvent_1 = __webpack_require__(83363);
const SoundListExtended_1 = __importDefault(__webpack_require__(19402));
class FreeSpinButton extends Button_1.default {
    //private area: Graphics;
    constructor(le) {
        super(le);
        this.tfTitle = this.normal['tfTitle'];
        this.tfValue = this.normal['tfValue'];
        this.featureBuyButtonBg = this.normal['featureBuyButtonBg'];
        this.featureBuyButtonBg.anchor.set(0.5, 0.5);
        //this.area = this.normal['area'];
        //this.area.visible = false;
        this.tfTitle.style.align = 'center';
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const gs = tsyringe_1.container.resolve('GameService');
        sm.on(SlotMachineEvent_1.SlotMachineEvent.STATE_CHANGED, this.onSlotMachineStateChanged, this);
        sm.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, () => {
            this.setTexts(Translation_1.default.t('freeSpins.buy'), wallet.getCurrencyValue(gs.featureBuyConfig.Rate * sm.totalBet * wallet.coinValue, true));
        }, this);
        wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, () => {
            this.setTexts(Translation_1.default.t('freeSpins.buy'), wallet.getCurrencyValue(gs.featureBuyConfig.Rate * sm.totalBet * wallet.coinValue, true));
        }, this);
        gs.on(GameServiceEvent_1.GameServiceEvent.DOUBLE_CHANCE_CHANGED, () => {
            this.enabled = !gs.doubleUpChance;
            this.alpha = this.enabled ? 1 : 0.4;
        }, this);
        this.on('pointerup', this.onClick, this);
        // At this point SlotMachine, Wallet and GameService are fully initialized and contains valid data to be displayed
        this.setTexts(Translation_1.default.t('freeSpins.buy'), wallet.getCurrencyValue(gs.featureBuyConfig.Rate * sm.totalBet * wallet.coinValue, true));
    }
    onSlotMachineStateChanged(currentState) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const gs = tsyringe_1.container.resolve('GameService');
        switch (currentState) {
            case SlotMachineState_1.SlotMachineState.SPIN_RESULT_FREE_SPINS:
                this.setTexts(Translation_1.default.t('freeSpins.left'), sm.currentSpinResult.freespins.totalCount.toString(), false, true);
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_START:
                this.setTexts(Translation_1.default.t('freeSpins.left'), (sm.currentSpinResult.freespins.remainingCount).toString(), false, true);
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS:
                this.setTexts(Translation_1.default.t('freeSpins.left'), (sm.currentSpinResult.freespins.remainingCount - 1).toString(), false);
                break;
            case SlotMachineState_1.SlotMachineState.IDLE:
                this.setTexts(Translation_1.default.t('freeSpins.buy'), wallet.getCurrencyValue(gs.featureBuyConfig.Rate * sm.totalBet * wallet.coinValue, true), true, true);
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_END:
                this.setTexts(Translation_1.default.t('freeSpins.buy'), wallet.getCurrencyValue(gs.featureBuyConfig.Rate * sm.totalBet * wallet.coinValue, true), true, true);
                break;
        }
    }
    onClick() {
        const data = {
            type: PopupState_1.PopupType.FEATURE_BUY,
            hideOnClick: false,
            duration: -1,
            callbacks: null
        };
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.SHOW_POPUP, data).dispatch();
        SoundManager_1.default.play(SoundListExtended_1.default.BUY_FREE_SPIN);
    }
    setTexts(title, value, isActive = true, isNotAlpha = true) {
        this.tfTitle.text = title;
        this.tfValue.text = value;
        (0, Utils_1.autoscaleText)(this.tfTitle, 35, 300, 100);
        (0, Utils_1.autoscaleText)(this.tfValue, 25, 200, 65);
        this.setActive(isActive);
        // isNotAlpha ? this.alpha = 1 : this.alpha = 0.4
    }
    setActive(isActive) {
        this.enabled = isActive;
    }
}
exports.FreeSpinButton = FreeSpinButton;


/***/ }),

/***/ 25070:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryCell = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const tsyringe_1 = __webpack_require__(659);
class HistoryCell extends pixi_js_1.Container {
    constructor(id, panelLayout) {
        super();
        LayoutBuilder_1.default.create(panelLayout == 'HistoryPanel'
            ? AssetsManager_1.default.layouts.get('HistoryCell')
            : AssetsManager_1.default.layouts.get('HistoryCellDesktop'), this);
        this.backgroundDark.visible = id % 2 === 1;
        this.backgroundLight.visible = !this.backgroundDark.visible;
        this.tfDate.style.align = 'center';
    }
    set entry(value) {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.tfDate.text = new Date(value.datetime).toLocaleString().replace(', ', '\n');
        this.tfTotalBet.text = wallet.getCurrencyValue(value.totalBet);
        this.tfWin.text = wallet.getCurrencyValue(value.win);
        this.tfBalance.text = wallet.getCurrencyValue(value.balance);
    }
    updateWidth(width, backgroundX) {
        this.backgroundLight.width = this.backgroundDark.width = width;
        this.backgroundLight.position.x = this.backgroundDark.position.x = backgroundX;
    }
    updateHeight(newHeight) {
        this.backgroundLight.height = this.backgroundDark.height = newHeight;
        [this.tfBalance, this.tfDate, this.tfWin, this.tfTotalBet].forEach((value) => {
            value.y = newHeight / 2;
        });
    }
}
exports.HistoryCell = HistoryCell;


/***/ }),

/***/ 78362:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const HistoryCell_1 = __webpack_require__(25070);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const tsyringe_1 = __webpack_require__(659);
const Panel_1 = __importDefault(__webpack_require__(25056));
const History_1 = __importDefault(__webpack_require__(11703));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const ScreenOrientation_1 = __webpack_require__(81827);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
class HistoryPanel extends Panel_1.default {
    constructor(layout) {
        super(AssetsManager_1.default.layouts.get(layout));
        this.cells = [];
        this._currentPage = 0;
        this.cellsContainer['area'].visible = false;
        this.footer.alpha = 0;
        this.btnPrevious.on('pointerup', this.onBtnPrevious, this);
        this.btnNext.on('pointerup', this.onBtnNext, this);
        this.tableHeaderBackground = this.tableHeader['background'];
        this.history = tsyringe_1.container.resolve(History_1.default);
        this.gameService = tsyringe_1.container.resolve('GameService');
        this.cellsPerPage = Math.ceil(this.cellsAreaHeight / 110);
        // create cells
        for (let i = 0; i < 12; i++) {
            const cell = new HistoryCell_1.HistoryCell(i, layout);
            this.cellsContainer.addChild(cell);
            cell.position.set(0, cell.height * i);
            this.cells.push(cell);
        }
        this.currentPage = 0;
        this.on('added', this.onAdded, this);
    }
    onAdded() {
        this.currentPage = 0;
    }
    // PUBLIC API
    updateLayout(desc) {
        super.updateLayout(desc);
        // if (desc.currentHeight > 1920) {
        //     this.background.height = desc.currentHeight;
        // } else {
        //     this.background.height = 1920;
        // }
        this.cellsPerPage = Math.ceil(this.cellsAreaHeight / 110);
        if (desc.orientation == ScreenOrientation_1.ScreenOrientation.VERTICAL) {
            const offsetXToMaskBorders = 10;
            this.background.width = desc.currentWidth + offsetXToMaskBorders;
            // this.background.pivot.x = this.background.width/2
            this.tableHeaderBackground.width = desc.currentWidth;
            this.cellsContainer.pivot.x = 540;
            this.cellsContainer.x = 540;
            this.cells.forEach((cell) => {
                cell.x = 0;
                cell.backgroundDark.width = desc.currentWidth;
                cell.backgroundLight.width = desc.currentWidth;
            });
        }
        else if (desc.orientation == ScreenOrientation_1.ScreenOrientation.HORIZONTAL) {
            const desktopPanelWidth = 1264;
            const borderOffset = 30;
            this.background.width = desktopPanelWidth;
            this.tableHeaderBackground.width = desktopPanelWidth - borderOffset;
            this.tableHeaderBackground.alpha = 0;
            // this.background.pivot.x = this.background.width/2
            this.cellsContainer.pivot.x = desktopPanelWidth / 2;
            this.cellsContainer.x = desktopPanelWidth / 2;
            this.cells.forEach((cell) => {
                cell.backgroundDark.width = desktopPanelWidth - borderOffset;
                cell.backgroundLight.width = desktopPanelWidth - borderOffset;
                cell.backgroundDark;
            });
        }
    }
    get cellsAreaHeight() {
        return this.footer.y - (this.tableHeader.y + this.tableHeader.height);
    }
    get pagesTotal() {
        return this.history.totalPages;
    }
    get currentPage() {
        return this._currentPage;
    }
    set currentPage(value) {
        this._currentPage = value;
        this.gameService.getHistoryResponse(value + 1, this.cellsPerPage).then((res) => {
            const startPos = this._currentPage * this.cellsPerPage;
            const data = this.history.entries;
            for (let i = 0; i < this.cells.length; i++) {
                const cell = this.cells[i];
                cell.updateHeight(Math.ceil(this.cellsAreaHeight / this.cellsPerPage));
                cell.visible = data[i] !== undefined;
                if (data[i]) {
                    cell.entry = data[i];
                }
            }
            this.updateItemsVertically(this.cells, 0);
            if (!this.history.entries.length) {
                this.btnNext.visible = false;
                this.btnPrevious.visible = false;
                this.tfPages.text = 'No history entries';
            }
            else if (this.history.entries.length >= 1 && this.pagesTotal == 1) {
                this.btnNext.visible = false;
                this.btnPrevious.visible = false;
                this.tfPages.text = `${this.currentPage + 1} / ${this.pagesTotal}`;
            }
            else if (this.pagesTotal > 1) {
                this.btnPrevious.visible = this.currentPage != 0;
                this.btnNext.visible = this.currentPage != this.pagesTotal;
                this.tfPages.text = `${this.currentPage + 1} / ${this.pagesTotal}`;
            }
        });
    }
    // PRIVATE API
    updateLayoutElements(width, backgroundX) {
        super.updateLayoutElements(width, backgroundX);
    }
    // USER INTERACTION
    onBtnNext() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        this.currentPage = this.currentPage < this.pagesTotal ? this.currentPage + 1 : this.currentPage;
    }
    onBtnPrevious() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        this.currentPage = this.currentPage <= 0 ? this.currentPage : this.currentPage - 1;
    }
}
exports["default"] = HistoryPanel;


/***/ }),

/***/ 25212:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Button_1 = __importDefault(__webpack_require__(78386));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIPanelEvent_1 = __webpack_require__(566);
const UIState_1 = __webpack_require__(54572);
class LinkModule extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.btnHistory['hitbox'].alpha = 0;
        this.btnHistory.on('pointerup', this.onBtnHistory, this);
        this.tfGameHistory.alpha = 0.5;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
        }
        return instance;
    }
    onBtnHistory() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.CLOSE_PANEL).dispatch();
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.HISTORY).dispatch();
    }
}
exports["default"] = LinkModule;


/***/ }),

/***/ 56749:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ui_1 = __webpack_require__(85930);
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const Button_1 = __importDefault(__webpack_require__(78386));
const UIPanelEvent_1 = __webpack_require__(566);
const UIState_1 = __webpack_require__(54572);
const SoundList_1 = __importDefault(__webpack_require__(27310));
const Panel_1 = __importDefault(__webpack_require__(25056));
const MetricsView_1 = __importDefault(__webpack_require__(35498));
const SwitchView_1 = __importDefault(__webpack_require__(76473));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class MenuPanel extends Panel_1.default {
    constructor(layout, scale) {
        super(layout);
        this.btnInfo.on('pointerup', this.onBtnPaytable, this);
        this.btnHistory.on('pointerup', this.onBtnHistory, this);
        this.bindHandlers();
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.slotMachine.on("Sfx_Volume_Change", this.onSfxVolumeSliderChange, this);
        this.slotMachine.on("Music_Btn_State_Change", this.onMusicBtnStateChange, this);
        this.on('added', this.onAdded, this);
        this.on('removed', this.onRemoved, this);
        if (scale) {
            this.scale.set(scale);
        }
    }
    onAdded() {
        this.scale.set(this.layout.scaleX, this.layout.scaleY);
    }
    onRemoved() {
        this.scale.set(this.layout.scaleX, this.layout.scaleY);
    }
    updateLayout(desc) {
        super.updateLayout(desc);
    }
    bindHandlers() {
        this.slider.onUpdate.connect((value) => {
            this.slotMachine.emit("Sfx_Volume_Change", value);
            SoundManager_1.default.getChannel('default').volume = value;
        });
        this.musicBtn.onChange.connect((checked) => {
            SoundManager_1.default.getChannel('ambient').mute = !Boolean(checked);
            this.slotMachine.emit("Music_Btn_State_Change");
        });
    }
    onSfxVolumeSliderChange(value) {
        this.slider.value = value;
        this.slider.children[1].x = (this.slider.children[0].width - (this.slider.children[1].width + 1)) * value;
    }
    onMusicBtnStateChange() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        this.musicBtn.checked = !SoundManager_1.default.getChannel('ambient').mute;
    }
    onBtnPaytable() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.PAYTABLE).dispatch();
    }
    onBtnHistory() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.HISTORY).dispatch();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'MetricsView':
                instance = new MetricsView_1.default(le);
                break;
            case 'SwitchView':
                instance = new SwitchView_1.default(le);
                break;
            case 'Slider':
                instance = new ui_1.Slider({
                    bg: 'sliderBar',
                    fill: 'sliderBar',
                    slider: 'sliderDot',
                    min: 0,
                    max: 1,
                    value: SoundManager_1.default.getChannel('default').volume
                });
                break;
            case 'CheckBox':
                instance = new ui_1.CheckBox({
                    style: {
                        checked: "musicON",
                        unchecked: "musicOFF"
                    },
                    checked: !SoundManager_1.default.getChannel('ambient').mute
                });
        }
        return instance;
    }
}
exports["default"] = MenuPanel;


/***/ }),

/***/ 71668:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MeterComponent = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const engineTween_1 = __webpack_require__(50381);
/**
 * Represents a meter component that displays a value and provides methods for updating and animating the value.
 */
class MeterComponent extends pixi_js_1.Container {
    /**
     * Constructor for the MeterComponent class.
     *
     * @param le - The LayoutElement object that contains the text format and initial text value.
     */
    constructor(le) {
        super();
        this.value = 0;
        this.finalValue = 0;
        this.currencyFormatted = false;
        this.numberFormatted = false;
        LayoutBuilder_1.default.create(le, this);
        if (le.extraParam && le.extraParam.debug) {
            this.debugBox = new pixi_js_1.Graphics();
            this.debugBox.lineStyle(2, Math.random() * 16581375);
            this.debugBox.drawRect(0, 0, le.children.get("textField").width, le.children.get("textField").height);
            this.addChild(this.debugBox);
        }
        this.allowedWidth = le.children.get("textField").width;
        this.allowedHeight = le.children.get("textField").height;
        this.textField.x = le.children.get("textField").pivotX;
        this.textField.y = le.children.get("textField").pivotY;
        this.autoFit();
    }
    /**
     * Sets the currency formatted value of the meter component and updates the text representation.
     *
     * @param value - The new value to set for the meter component. This value will be passed to the
     *                `Wallet.getCurrencyFormattedValue` method to obtain the formatted string.
     *
     * @returns {void} - This method does not return any value. It updates the text representation of the meter component.
     */
    setCurrencyFormattedValue(value, pulsate = false) {
        this.value = value;
        this.textField.text = Wallet_1.default.getCurrencyFormattedValue(this.value);
        this.autoFit();
        if (pulsate) {
            this.pulsate();
        }
    }
    /**
     * Sets the formatted value of the meter component and updates the text representation.
     *
     * @param value - The new value to set for the meter component. This value will be passed to the
     *                `Wallet.getFormattedValue` method to obtain the formatted string.
     *
     * @returns {void} - This method does not return any value. It updates the text representation of the meter component.
     */
    setFormattedValue(value, pulsate = false) {
        this.value = value;
        this.textField.text = Wallet_1.default.getFormattedValue(this.value);
        this.autoFit();
        if (pulsate) {
            this.pulsate();
        }
    }
    /**
     * Sets the value of the meter component and updates the text representation.
     *
     * @param value - The new value to set for the meter component.
     *
     * @returns {void}
     */
    setValue(value, pulsate = false) {
        this.value = value;
        this.textField.text = this.value;
        this.autoFit();
        if (pulsate) {
            this.pulsate();
        }
    }
    setStringValue(label, pulsate = false) {
        this.textField.text = label;
        this.autoFit();
        if (pulsate) {
            this.pulsate();
        }
    }
    /**
     * Starts a count-up animation from the current value to the specified value.
     *
     * @param value - The final value to reach during the count-up animation.
     * @param duration - The duration of the count-up animation in milliseconds.
     * @param currencyFormatted - Whether the value should be formatted as currency. Default is true.
     * @param numberFormatted - Whether the value should be formatted as a number. Default is true.
     * @param onComplete - An optional callback function to be executed when the count-up animation completes.
     * @param animParams - An optional object containing parameters for the animation.
     * @param animParams.countUpLoopSoundId - The sound ID to play during the count-up animation loop.
     * @param animParams.countUpEndSoundId - The sound ID to play at the end of the count-up animation.
     */
    startTickup(value, duration, currencyFormatted = true, numberFormatted = true, onComplete, animParams) {
        this.finalValue = value;
        this.currencyFormatted = currencyFormatted;
        this.numberFormatted = numberFormatted;
        currencyFormatted ? this.setCurrencyFormattedValue(this.value) : numberFormatted ? this.setFormattedValue(this.value) : this.setValue(this.value);
        engineTween_1.Tweener.addTween(this, {
            value: value,
            time: duration,
            transition: "easeOutSine",
            onUpdate: () => {
                currencyFormatted ? this.setCurrencyFormattedValue(this.value) : numberFormatted ? this.setFormattedValue(this.value) : this.setValue(this.value);
            },
            onComplete: () => {
                this.value = value;
                currencyFormatted ? this.setCurrencyFormattedValue(this.value) : numberFormatted ? this.setFormattedValue(this.value) : this.setValue(this.value);
                if (onComplete) {
                    onComplete();
                }
            },
        });
    }
    /**
     * Stops the count-up animation and optionally jumps to the final value.
     *
     * @param jumpToFinalValue - If true, the component will jump to the final value after stopping the animation.
     *                          If false (default), the component will reset to the initial value (0).
     *
     * @returns {void}
     */
    stopTickup(jumpToFinalValue = false) {
        engineTween_1.Tweener.removeTweens(this);
        if (jumpToFinalValue) {
            this.value = this.finalValue;
        }
        else {
            this.value = 0;
        }
        this.currencyFormatted ? this.setCurrencyFormattedValue(this.value) : this.numberFormatted ? this.setFormattedValue(this.value) : this.setValue(this.value);
    }
    autoFit() {
        this.textField.scale.x = this.textField.scale.y = 1;
        if (this.textField.width > this.allowedWidth || this.textField.height > this.allowedHeight) {
            const scaleX = this.allowedWidth / this.textField.width;
            const scaleY = this.allowedHeight / this.textField.height;
            const scale = Math.min(scaleX, scaleY);
            this.textField.scale.x = scale;
            this.textField.scale.y = scale;
        }
    }
    /**
     * Retrieves the current value of the meter component.
     *
     * @returns {number} - The current value of the meter component.
     */
    getValue() {
        return this.value;
    }
    pulsate() {
        engineTween_1.Tweener.removeTweens(this.scale);
        engineTween_1.Tweener.addTween(this.scale, {
            x: 1.15,
            y: 1.15,
            transition: "easeInSine",
            time: 0.1,
            onComplete: () => {
                engineTween_1.Tweener.addTween(this.scale, {
                    x: 1,
                    y: 1,
                    time: 0.12,
                    transition: "easeOutSine",
                });
            },
        });
    }
}
exports.MeterComponent = MeterComponent;


/***/ }),

/***/ 35498:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
class MetricsView extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this);
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.balance['text'].text = `${wallet.getCurrencyValue(wallet.balance)}`;
        this.bet['text'].text = `${wallet.getCurrencyValue(slotMachine.totalBet)}`;
        this.win['text'].text = `${wallet.getCurrencyValue((slotMachine.roundResult ? slotMachine.roundResult.totalWinValue : 0))}`;
    }
    updateText(container, value) {
        container['text'].text = value;
    }
}
exports["default"] = MetricsView;


/***/ }),

/***/ 25056:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const Button_1 = __importDefault(__webpack_require__(78386));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const UIPanelEvent_1 = __webpack_require__(566);
const MetricsView_1 = __importDefault(__webpack_require__(35498));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const ScreenOrientation_1 = __webpack_require__(81827);
const SwitchView_1 = __importDefault(__webpack_require__(76473));
class Panel extends pixi_js_1.Container {
    constructor(layout) {
        super();
        LayoutBuilder_1.default.create(layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.layout = layout;
        this.btnClose.on('pointerup', this.onBtnClose, this);
        this.defaultYpivot = this.pivot.y;
        //this.pivot.y = 0;
    }
    // PUBLIC API
    updateLayout(desc) {
        this.layoutDesc = desc;
        if (desc.orientation == ScreenOrientation_1.ScreenOrientation.VERTICAL)
            this.y = desc.baseHeight / 2 + (desc.currentHeight - desc.baseHeight) / 2;
        else
            this.y = 0;
        // if(desc.orientation == ScreenOrientation.VERTICAL)
        //     this.y = desc.baseHeight/2 + (desc.currentHeight - desc.baseHeight) / 2//desc.baseHeight / 2 + (desc.currentHeight - desc.baseHeight) / 2 ;
        //
        // const widthToSet: number = desc.currentWidth;
        // let xToSet: number;
        // if(desc.orientation ==ScreenOrientation.VERTICAL) {
        //     xToSet = -(desc.currentWidth - desc.baseWidth) / 2;
        // } else {
        //     xToSet = -(desc.currentWidth - desc.baseHeight) / 2;
        // }
        //
        //
        // this.updateLayoutElements(widthToSet, xToSet);
    }
    textAlign(tf, style) {
        if (tf instanceof pixi_js_1.Text) {
            tf.style.align = 'center';
        }
        else {
            tf.align = 'center';
        }
    }
    getDefaultYPivot() {
        return this.defaultYpivot;
    }
    get animationConfiguration() {
        return Panel.defaultAdjustBetPanelAnimationConfiguration;
    }
    get animationPaytableConfiguration() {
        return Panel.defaultPaytablePanelAnimationConfiguration;
    }
    // PRIVATE API
    updateLayoutElements(width, x) {
        this.background.width = width;
        this.background.x = x;
    }
    updateItemsGrid(items, maxWidth, spacingX, spacingY, maxItems = 0, reducedSpacingX = 0, maxInRow) {
        let itemX = 0;
        let itemY = 0;
        let itemsInRow = [];
        items.forEach((item, index) => {
            item.position.set(itemX, itemY);
            itemX += (item.width + spacingX);
            itemsInRow.push(item);
            if ((item.position.x + item.width * 2) > maxWidth || index == items.length - 1 || (maxItems > 0 && !((index + 1) % maxItems))) {
                const rowWidth = itemsInRow.reduce((rowWidth, item) => {
                    return rowWidth + item.width + spacingX;
                }, 0) - spacingX;
                itemsInRow.forEach(item => {
                    item.x += (maxWidth - rowWidth) / 2;
                });
                itemsInRow = [];
                itemX = 0;
                itemY += (item.height + spacingY);
            }
            if (maxInRow) {
                if (itemsInRow.length == maxInRow - 1) {
                    spacingX -= reducedSpacingX;
                }
            }
        });
    }
    updateItemsVertically(items, spacingY) {
        let y = 0;
        items.forEach((item) => {
            item.y = y;
            y += (item.height + spacingY);
        });
    }
    // USER INTERACTION
    onBtnClose() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.CLOSE_PANEL).dispatch();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'MetricsView':
                instance = new MetricsView_1.default(le);
                break;
            case 'SwitchView':
                instance = new SwitchView_1.default(le);
                break;
        }
        return instance;
    }
}
Panel.defaultAdjustBetPanelAnimationConfiguration = {
    showPopup: {
        pivotY: {
            value: 380,
            time: 0.55,
            transition: 'easeInOutQuart',
        },
        alpha: {
            value: 1,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        pivotY: {
            value: 0,
            time: 0.3,
            transition: 'easeInQuad',
        },
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.7,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.15,
            transition: 'easeInQuad',
        },
    }
};
Panel.defaultPaytablePanelAnimationConfiguration = {
    showPopup: {
        pivotY: {
            value: 0,
            time: 0.55,
            transition: 'easeInOutQuart',
        },
        alpha: {
            value: 1,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        pivotY: {
            value: 0,
            time: 0.3,
            transition: 'easeInQuad',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.7,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.15,
            transition: 'easeInQuad',
        },
    }
};
exports["default"] = Panel;


/***/ }),

/***/ 93897:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ScrolledContent_1 = __importDefault(__webpack_require__(52087));
const Button_1 = __importDefault(__webpack_require__(78386));
class PaytableContent extends ScrolledContent_1.default {
    constructor(le) {
        super(le, (le) => {
            let instance = null;
            switch (le.customClass) {
                case 'Button':
                    instance = new Button_1.default(le);
                    break;
            }
            return instance;
        });
        // LayoutBuilder.create(le, this, (le)=>{
        //     return this.customClassElementCreate(le);
        // })
    }
}
exports["default"] = PaytableContent;


/***/ }),

/***/ 81956:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const Button_1 = __importDefault(__webpack_require__(78386));
const PaytableSymbolCell_1 = __importDefault(__webpack_require__(76130));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const Panel_1 = __importDefault(__webpack_require__(25056));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundList_1 = __importDefault(__webpack_require__(27310));
class PaytablePanelDesktop extends Panel_1.default {
    constructor(configuration) {
        super(AssetsManager_1.default.layouts.get('PaytablePanelDesktop'));
        this.symbolCells = [];
        this.pages = [];
        this.currentPage = null;
        this._currentPageIndex = -1;
        const numOfPages = 6;
        for (let i = 1; i < numOfPages + 1; i++) {
            let p = this["page_" + i];
            this.removeChild(p);
            this.pages.push(p);
        }
        this.currentPageIndex = 0;
        this.config = configuration;
        this.symbolsContainer = this.pages[0]['item_1'];
        this.max_min_bet_display = this.pages[3]['tf6'];
        this.max_min_bet_display.text = this.max_min_bet_display.text.replace('$0.20', configuration.max_min_bet[0]);
        this.max_min_bet_display.text = this.max_min_bet_display.text.replace('$200.00', configuration.max_min_bet[1]);
        this.createSymbols();
        this.btnPreviousPage.on('pointerup', this.onButtonPrev, this);
        this.btnNextPage.on('pointerup', this.onButtonNext, this);
        this.config.symbolsWithDescription.forEach((desc) => {
            this.createSymbolInProperItem(desc.itemId, this.config.symbolsList.find((symbol) => symbol.id === desc.symbolId));
        });
        this.combineTextSprite();
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                const btn = instance;
                // const radius: number = btn.width / 2;
                // btn.hitArea = new Circle(radius, radius, radius);
                break;
        }
        return instance;
    }
    combineTextSprite() {
        const maxTfInPayTable = 8;
        this.pages.forEach((p) => {
            for (let i = 0; i < maxTfInPayTable; i++) {
                const containerToFit = [];
                const spacingX = 10;
                let sumWidth = 0;
                let startXPos;
                if (p[`tf${i}`]) {
                    this.textAlign(p[`tf${i}`], 'center');
                }
                if (p[`textCombined${i}`]) {
                    p[`textCombined${i}`]['area'].alpha = 0;
                    p[`textCombined${i}`]['content'].children.forEach((child) => {
                        sumWidth += child.width;
                        containerToFit.push(child);
                    });
                    // calculate the sum of all texts/icons and get the start pos
                    sumWidth = sumWidth + (p[`textCombined${i}`]['content'].children.length * spacingX);
                    startXPos = (p[`textCombined${i}`]['area'].width - sumWidth) / 2;
                    for (let j = 0; j < containerToFit.length; j++) {
                        if (j == 0) {
                            containerToFit[j].x = startXPos;
                        }
                        else {
                            containerToFit[j].x = containerToFit[j - 1].x + containerToFit[j - 1].width + spacingX;
                        }
                    }
                }
            }
        });
    }
    createSymbols() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const symbolsCopy = [...this.config.symbolsList];
        const symbolsSorted = symbolsCopy.sort((a, b) => {
            var _a, _b, _c, _d, _e, _f;
            return ((((_c = (_b = (_a = sm === null || sm === void 0 ? void 0 : sm.findRule(a.id, 30)) === null || _a === void 0 ? void 0 : _a.reward) === null || _b === void 0 ? void 0 : _b.line) === null || _c === void 0 ? void 0 : _c.multiplier) > ((_f = (_e = (_d = sm === null || sm === void 0 ? void 0 : sm.findRule(b.id, 30)) === null || _d === void 0 ? void 0 : _d.reward) === null || _e === void 0 ? void 0 : _e.line) === null || _f === void 0 ? void 0 : _f.multiplier)) && a.id) ? -1 : 1;
        });
        const excludedSymbols = this.config.excludedSymbols;
        for (let i = 0; i < this.config.symbolsList.length; i++) {
            // skip excluded symbols
            if (excludedSymbols.includes(symbolsSorted[i].id)) {
                continue;
            }
            const symbolCell = new PaytableSymbolCell_1.default(AssetsManager_1.default.layouts.get('PaytableSymbolCellDesktop'), symbolsSorted[i], {
                setMultipliers: true,
                maxFontSize: 15,
                maxHeight: 60,
                maxWidth: 80
            });
            this.symbolCells.push(symbolCell);
            this.symbolsContainer.addChild(symbolCell);
        }
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        this.updateSymbolsView(this.symbolCells, this['page_1']['item_1']['area'].width, [7], 30);
    }
    updateSymbolsView(symbols, maxWidth, elementsInRow, spacing) {
        let currentId = 0;
        elementsInRow.forEach((elInRow, index) => {
            const offset = (maxWidth - (symbols[currentId].width * elInRow + spacing * (elInRow - 1))) / 2;
            for (let i = 0; i < elInRow; i++) {
                symbols[currentId].x = offset + (symbols[currentId].width + spacing) * i;
                symbols[currentId].y = symbols[currentId].height * index;
                currentId++;
            }
        });
    }
    get currentPageIndex() {
        return this._currentPageIndex;
    }
    set currentPageIndex(value) {
        if (this._currentPageIndex == value) {
            return;
        }
        this._currentPageIndex = value;
        if (this.currentPage) {
            this.removeChild(this.currentPage);
        }
        this.currentPage = this.pages[this._currentPageIndex];
        this.addChild(this.currentPage);
    }
    createSymbolInProperItem(itemId, symbolData) {
        if (!symbolData)
            return;
        const parent = this.pages[0][`item_${itemId}`];
        const symbolIcon = new PaytableSymbolCell_1.default(AssetsManager_1.default.layouts.get('PaytableSymbolCellDesktop'), symbolData, {
            setMultipliers: false,
            maxFontSize: 15,
            maxHeight: 60,
            maxWidth: 120
        });
        if (parent['area']) {
            parent['area'].visible = false;
        }
        parent['iconSlot'].addChild(symbolIcon);
    }
    // USER INTERACTION
    onButtonPrev() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        if (!this.currentPageIndex) {
            this.currentPageIndex = this.pages.length - 1;
        }
        else {
            this.currentPageIndex--;
        }
        this.onChangePageIndex();
    }
    onButtonNext() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        this.currentPageIndex = (this.currentPageIndex + 1) % this.pages.length;
        this.onChangePageIndex();
    }
    onChangePageIndex() {
        this.tfPageNumber.text = `${this.currentPageIndex + 1}/6`;
    }
}
exports["default"] = PaytablePanelDesktop;


/***/ }),

/***/ 49600:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const PaytableSymbolCell_1 = __importDefault(__webpack_require__(76130));
const Panel_1 = __importDefault(__webpack_require__(25056));
const PaytableContent_1 = __importDefault(__webpack_require__(93897));
const Button_1 = __importDefault(__webpack_require__(78386));
const MetricsView_1 = __importDefault(__webpack_require__(35498));
const SwitchView_1 = __importDefault(__webpack_require__(76473));
class PaytablePanelMobile extends Panel_1.default {
    constructor(configuration) {
        super(AssetsManager_1.default.layouts.get('paytablePortait'));
        this.symbolCells = [];
        this.pages = [];
        // LayoutBuilder.create(this.layout, this, (le)=>{
        //     return this.customClassElementCreate(le);
        // });
        this.config = configuration;
        this.content = this.scrollBox['content'];
        const numOfPages = 6;
        for (let i = 1; i < numOfPages + 1; i++) {
            let p = this.content['page_' + i];
            this.removeChild(p);
            this.pages.push(p);
        }
        this.symbolsContainer = this.pages[0]['item_1'];
        this.max_min_bet_display = this.pages[3]['tf6'];
        this.max_min_bet_display.text = this.max_min_bet_display.text.replace('$0.20', configuration.max_min_bet[0]);
        this.max_min_bet_display.text = this.max_min_bet_display.text.replace('$200.00', configuration.max_min_bet[1]);
        this.createSymbols();
        this.scrollBox['area'].visible = this.symbolsContainer['area'].visible = false;
        this.config.symbolsWithDescription.forEach((desc) => {
            this.createSymbolInProperItem(desc.itemId, this.config.symbolsList.find((symbol) => symbol.id === desc.symbolId));
        });
        this.combineTextSprite();
    }
    // PUBLIC API
    updateLayout(desc) {
        super.updateLayout(desc);
        // const arr = this.pages.flatMap(page => page.children);
        // reposition paytable cells
        const xOffset = 100;
        this.updateItemsGrid(this.symbolCells, desc.currentWidth - xOffset - (desc.currentWidth - desc.baseWidth), 21, 150);
        //
        // this.symbolsContainer.x = this.symbolsContainer.pivot.x = (desc.currentWidth - xOffset) / 2;
        const spacing = 40;
        this.pages.forEach((page) => {
            for (let i = 0; i < page.children.length; i++) {
                if (i == 0)
                    page.children[i].position.y = 100;
                else {
                    if (page.children[i].text !== '') // do not add spacing if the Text is empty
                        page.children[i].position.y = page.children[i - 1].position.y + page.children[i - 1].height + spacing;
                    else {
                        page.children[i].position.y = page.children[i - 1].position.y + page.children[i - 1].height;
                    }
                }
            }
        });
        this.updateItemsVertically(this.pages, 100);
        this.symbolsContainer.pivot.x = this.symbolsContainer.width / 2 + xOffset / 2;
        this.symbolsContainer.x = 500;
        this.content['spacerBottom'].y = this.pages[this.pages.length - 1].y + this.pages[this.pages.length - 1].height + 100;
        const offsetXToMaskBorders = 10;
        this.background.width = desc.currentWidth + offsetXToMaskBorders;
        this.background.pivot.x = this.background.width / 2;
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'PaytableContent':
                instance = new PaytableContent_1.default(le);
                break;
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'MetricsView':
                instance = new MetricsView_1.default(le);
                break;
            case 'SwitchView':
                instance = new SwitchView_1.default(le);
                break;
        }
        return instance;
    }
    combineTextSprite() {
        const maxTfInPayTable = 8;
        this.pages.forEach((p) => {
            for (let i = 0; i < maxTfInPayTable; i++) {
                const containerToFit = [];
                const spacingX = 10;
                let sumWidth = 0;
                let startXPos;
                if (p[`tf${i}`]) {
                    this.textAlign(p[`tf${i}`], 'center');
                }
                if (p[`textCombined${i}`]) {
                    p[`textCombined${i}`]['area'].alpha = 0;
                    p[`textCombined${i}`]['content'].children.forEach((child) => {
                        sumWidth += child.width;
                        containerToFit.push(child);
                    });
                    // calculate the sum of all texts/icons and get the start pos
                    sumWidth = sumWidth + (p[`textCombined${i}`]['content'].children.length * spacingX);
                    startXPos = (p[`textCombined${i}`]['area'].width - sumWidth) / 2;
                    for (let j = 0; j < containerToFit.length; j++) {
                        if (j == 0) {
                            containerToFit[j].x = startXPos;
                        }
                        else {
                            containerToFit[j].x = containerToFit[j - 1].x + containerToFit[j - 1].width + spacingX;
                        }
                    }
                    if (p[`textCombined${i}`][`tfUnder`]) {
                        this.textAlign(p[`textCombined${i}`][`tfUnder`], 'center');
                        p[`textCombined${i}`][`tfUnder`].y = p[`textCombined${i}`]['content'].y +
                            p[`textCombined${i}`]['content'].height;
                    }
                    if (p[`textCombined${i}`][`tfAbove`]) {
                        this.textAlign(p[`textCombined${i}`][`tfAbove`], 'center');
                        p[`textCombined${i}`][`tfAbove`].y = p[`textCombined${i}`]['content'].y -
                            p[`textCombined${i}`][`tfAbove`].height;
                        p[`textCombined${i}`].pivot.y = p[`textCombined${i}`][`tfAbove`].y;
                    }
                }
            }
        });
    }
    createSymbols() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const symbolsCopy = [...this.config.symbolsList];
        const symbolsSorted = symbolsCopy.sort((a, b) => {
            var _a, _b, _c, _d, _e, _f;
            return ((((_c = (_b = (_a = sm === null || sm === void 0 ? void 0 : sm.findRule(a.id, 30)) === null || _a === void 0 ? void 0 : _a.reward) === null || _b === void 0 ? void 0 : _b.line) === null || _c === void 0 ? void 0 : _c.multiplier) > ((_f = (_e = (_d = sm === null || sm === void 0 ? void 0 : sm.findRule(b.id, 30)) === null || _d === void 0 ? void 0 : _d.reward) === null || _e === void 0 ? void 0 : _e.line) === null || _f === void 0 ? void 0 : _f.multiplier)) && a.id) ? -1 : 1;
        });
        const excludedSymbols = this.config.excludedSymbols;
        for (let i = 0; i < this.config.symbolsList.length; i++) {
            // skip excluded symbols
            if (excludedSymbols.includes(symbolsSorted[i].id)) {
                continue;
            }
            const symbolCell = new PaytableSymbolCell_1.default(AssetsManager_1.default.layouts.get('PaytableSymbolCellMobile'), symbolsSorted[i], {
                setMultipliers: true,
                maxFontSize: 20,
                maxHeight: 60,
                maxWidth: 120
            });
            this.symbolCells.push(symbolCell);
            this.symbolsContainer.addChild(symbolCell);
        }
    }
    createSymbolInProperItem(itemId, symbolData) {
        if (!symbolData)
            return;
        const parent = this.pages[0][`item_${itemId}`];
        const symbolIcon = new PaytableSymbolCell_1.default(AssetsManager_1.default.layouts.get('PaytableSymbolCellMobile'), symbolData, {
            setMultipliers: false,
            maxFontSize: 20,
            maxHeight: 60,
            maxWidth: 120
        });
        if (parent['area']) {
            parent['area'].visible = false;
        }
        parent['iconSlot'].addChild(symbolIcon);
    }
}
exports["default"] = PaytablePanelMobile;


/***/ }),

/***/ 76130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const tsyringe_1 = __webpack_require__(659);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachineEvent_1 = __webpack_require__(96421);
const WalletEvent_1 = __webpack_require__(63035);
const Utils_1 = __webpack_require__(63948);
class PaytableSymbolCell extends pixi_js_1.Container {
    constructor(le, symbolData, config = null) {
        super();
        this.config = {
            setMultipliers: true,
            maxFontSize: 20,
            maxHeight: 60,
            maxWidth: 120
        };
        LayoutBuilder_1.default.create(le, this);
        if (config)
            this.config = config;
        this.symbolId = symbolData.id;
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, () => { this.setMultipliers(this.symbolId); }, this);
        this.wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, () => { this.setMultipliers(this.symbolId); }, this);
        this.symbolArea.visible = false;
        const staticIcon = new pixi_js_1.Sprite(symbolData.staticIcon.texture);
        staticIcon.anchor.set(0.5, 0.5);
        this.staticIcon.addChild(staticIcon);
        this.tfPays15 = this['multiplierDescription']['tfPays15'];
        this.tfPays14 = this['multiplierDescription']['tfPays14'];
        this.tfPays13 = this['multiplierDescription']['tfPays13'];
        this.tfPays12 = this['multiplierDescription']['tfPays12'];
        this.tfPays11 = this['multiplierDescription']['tfPays11'];
        this.tfPays10 = this['multiplierDescription']['tfPays10'];
        this.tfPays9 = this['multiplierDescription']['tfPays9'];
        this.tfPays8 = this['multiplierDescription']['tfPays8'];
        this.tfPays7 = this['multiplierDescription']['tfPays7'];
        this.tfPays6 = this['multiplierDescription']['tfPays6'];
        this.tfPays5 = this['multiplierDescription']['tfPays5'];
        if (this.config.setMultipliers)
            this.setMultipliers(symbolData.id);
        else
            this.multiplierDescription.visible = false;
    }
    updateView(maxWidth = null, texts = null) {
        // const texts: Text[] =  this['multiplierDescription'].children as Text[];
        [this.tfPays5, this.tfPays6, this.tfPays7, this.tfPays8, this.tfPays9, this.tfPays10, this.tfPays11, this.tfPays12, this.tfPays13, this.tfPays14, this.tfPays15].forEach((text) => {
            (0, Utils_1.autoscaleText)(text, this.config.maxFontSize, this.config.maxWidth, this.config.maxHeight);
        });
        const offset = 12;
        const totalWidth = maxWidth ? maxWidth : this.width;
        for (let i = 0; i < 11; i++) {
            texts[i].x = (totalWidth - (texts[i].width + offset + texts[i + 11].width)) / 2;
            const posX = texts[i].x + texts[i].width + offset;
            texts[i + 11].x = posX + texts[i + 11].width;
        }
    }
    get width() {
        return this.symbolArea.width;
    }
    get height() {
        return this.symbolArea.height;
    }
    setMultipliers(symbolId) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        if (symbolId > 100 && symbolId < 8000) {
            this.tfPays15.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 15).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays14.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 14).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays13.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 13).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays12.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 12).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays11.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 11).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays10.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 10).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays9.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 9).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays8.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 8).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays7.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 7).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays6.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 6).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.tfPays5.text = `${this.wallet.getCurrencyValue(sm.findRule(symbolId, 5).reward.line.multiplier * tsyringe_1.container.resolve(SlotMachine_1.default).totalBet * tsyringe_1.container.resolve(Wallet_1.default).coinValue)}`;
            this.updateView(this.width, this['multiplierDescription'].children);
        }
    }
}
exports["default"] = PaytableSymbolCell;


/***/ }),

/***/ 52087:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const ui_1 = __webpack_require__(85930);
class ScrolledContent extends pixi_js_1.Container {
    constructor(le, classResolver = null) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            if (classResolver) {
                return classResolver(le);
            }
        });
        this.scrollBox = new ui_1.ScrollBox({
            type: 'vertical',
            width: this.area.width,
            height: this.area.height,
            items: [this.content],
            disableDynamicRendering: true,
            disableEasing: true
        });
        this.addChild(this.scrollBox);
        this.area.destroy();
        this.updateScroll();
    }
    addItem(item) {
        this.scrollBox.addItem(item);
    }
    resize(w, h) {
        const oldScrollBox = this.scrollBox;
        this.scrollBox = new ui_1.ScrollBox({
            type: 'vertical',
            width: w,
            height: h,
            items: [this.content],
            disableDynamicRendering: true,
            disableEasing: true
        });
        this.addChild(this.scrollBox);
        this.updateScroll();
        this.removeChild(oldScrollBox);
        oldScrollBox.destroy();
    }
    updateScroll() {
        this.scrollBox.resize();
        this.scrollBox.scrollTop();
    }
}
exports["default"] = ScrolledContent;


/***/ }),

/***/ 77701:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const ValueText_1 = __importDefault(__webpack_require__(68223));
class StatusBar extends pixi_js_1.Container {
    constructor(le, maxFontSize = 26) {
        super();
        this.maxFontSize = maxFontSize;
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        const valueArea = this.text['area'];
        valueArea['visible'] = false;
        //autoscaleText(this.currency, this.maxFontSize, valueArea['width'], valueArea['height']);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
        }
        return instance;
    }
}
exports["default"] = StatusBar;


/***/ }),

/***/ 24639:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const StatusBar_1 = __importDefault(__webpack_require__(77701));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Utils_1 = __webpack_require__(63948);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const WalletEvent_1 = __webpack_require__(63035);
const SlotMachineEvent_1 = __webpack_require__(96421);
const engineTween_1 = __webpack_require__(50381);
class StatusComponent extends pixi_js_1.Container {
    constructor(le, maxFontSize = 20) {
        super();
        this.maxFontSize = maxFontSize;
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent_1.WalletEvent.BALANCE_CHANGED, this.onWalletBalanceChanged, this);
        this.onWalletBalanceChanged();
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.onBetValueChanged();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'StatusBar':
                instance = new StatusBar_1.default(le, this.maxFontSize);
                break;
        }
        return instance;
    }
    set winValue(value) {
        this.statusWin.text.tfValue.text = `${this.wallet.getCurrencyValue(value, false)}`;
        (0, Utils_1.autoscaleText)(this.statusWin.text.tfValue, 26, 200, 52);
    }
    onWalletBalanceChanged() {
        this.statusBalance.text.renderValueFunction = ((tf, value) => {
            tf.text = `${this.wallet.getCurrencyValue(value, true)}`;
        });
        (0, Utils_1.autoscaleText)(this.statusBalance.text.tfValue, 26, 200, 52);
        if (engineTween_1.Tweener.isTweening(this.statusBalance.text)) {
            engineTween_1.Tweener.removeTweens(this.statusBalance.text);
            this.statusBalance.text.value = this.wallet.balance;
            return;
        }
        let balance = Math.max(this.wallet.balance, 0); // Ensure non-negative balance
        const doAnimation = (balance > this.statusBalance.text.value);
        if (doAnimation) {
            this.statusBalance.text.setValue(balance, {
                countUpDuration: 1
            });
        }
        else {
            this.statusBalance.text.value = balance;
        }
    }
    onBetValueChanged() {
        this.statusBet.text.tfValue.text = `${this.wallet.getCurrencyValue(this.slotMachine.totalBet * this.wallet.coinValue * Wallet_1.default.denomination, true)}`;
        (0, Utils_1.autoscaleText)(this.statusBet.text.tfValue, 26, 200, 52);
        this.animateText(this.statusBet.text);
    }
    animateText(tf) {
        engineTween_1.Tweener.removeTweens(tf.scale);
        engineTween_1.Tweener.addTween(tf.scale, {
            x: 1.25,
            y: 1.3,
            transition: 'easeInSine',
            time: 0.1,
            onComplete: () => {
                engineTween_1.Tweener.addTween(tf.scale, {
                    x: 1,
                    y: 1,
                    time: 0.12,
                    transition: 'easeOutSine',
                });
            }
        });
    }
}
exports["default"] = StatusComponent;


/***/ }),

/***/ 92991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SwitchEvent = exports.SwitchState = void 0;
var SwitchState;
(function (SwitchState) {
    SwitchState["OFF"] = "Off";
    SwitchState["ON"] = "On";
})(SwitchState || (exports.SwitchState = SwitchState = {}));
var SwitchEvent;
(function (SwitchEvent) {
    SwitchEvent["STATE_CHANGED"] = "onStateChanged";
})(SwitchEvent || (exports.SwitchEvent = SwitchEvent = {}));


/***/ }),

/***/ 76473:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const SwitchState_1 = __webpack_require__(92991);
class SwitchView extends pixi_js_1.Container {
    constructor(l) {
        super();
        this._state = SwitchState_1.SwitchState.ON;
        LayoutBuilder_1.default.create(l, this);
        this.state = SwitchState_1.SwitchState.OFF;
        this.clickArea.alpha = 0;
        this.clickArea.interactive = true;
        this.clickArea.on('pointerup', this.onClick, this);
    }
    setInitialState(state) {
        this._state = state;
        this.updateView();
    }
    set state(state) {
        if (this._state == state)
            return;
        this._state = state;
        this.updateView();
        this.emit(SwitchState_1.SwitchEvent.STATE_CHANGED, this._state);
    }
    updateView() {
        [this.onView, this.offView].forEach((view) => {
            view.visible = false;
        });
        switch (this._state) {
            case SwitchState_1.SwitchState.ON:
                this.onView.visible = true;
                break;
            case SwitchState_1.SwitchState.OFF:
                this.offView.visible = true;
                break;
        }
    }
    onClick() {
        this.state = this._state == SwitchState_1.SwitchState.ON ? SwitchState_1.SwitchState.OFF : SwitchState_1.SwitchState.ON;
    }
}
exports["default"] = SwitchView;


/***/ }),

/***/ 14188:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Panel_1 = __importDefault(__webpack_require__(25056));
const AdjustSettings_1 = __importDefault(__webpack_require__(48966));
const AdjustTotalBet_1 = __importDefault(__webpack_require__(88138));
const LinkModule_1 = __importDefault(__webpack_require__(25212));
class SystemSettingsPanel extends Panel_1.default {
    constructor(le) {
        super(le);
        //this.fetchTranslationFile()
        this.on('added', () => {
            this.adjustSettings.updateView();
        }, this);
    }
    customClassElementCreate(le) {
        let instance;
        switch (le.customClass) {
            case 'AdjustSettings':
                instance = new AdjustSettings_1.default(le);
                break;
            case 'LinkModule':
                instance = new LinkModule_1.default(le);
                break;
            case 'AdjustTotalBet':
                instance = new AdjustTotalBet_1.default(le);
                break;
            default:
                instance = super.customClassElementCreate(le);
        }
        return instance;
    }
    onQuickSpinChanged(state) {
    }
}
exports["default"] = SystemSettingsPanel;


/***/ }),

/***/ 59071:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const Button_1 = __importDefault(__webpack_require__(78386));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIEvent_1 = __webpack_require__(77066);
const UIPanelEvent_1 = __webpack_require__(566);
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotMachineState_1 = __webpack_require__(77313);
const tsyringe_1 = __webpack_require__(659);
const SlotMachineEvent_1 = __webpack_require__(96421);
const AutoplayEvent_1 = __webpack_require__(71967);
const ValueText_1 = __importDefault(__webpack_require__(68223));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const UIState_1 = __importStar(__webpack_require__(54572));
const ButtonAutospin_1 = __importDefault(__webpack_require__(9352));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const WalletEvent_1 = __webpack_require__(63035);
const SoundList_1 = __importDefault(__webpack_require__(27310));
const ButtonSpin_1 = __importDefault(__webpack_require__(79619));
const ButtonSpinAnimation_1 = __importDefault(__webpack_require__(58553));
const ButtonAutoSpinStop_1 = __importDefault(__webpack_require__(75400));
const engineTween_1 = __webpack_require__(50381);
const ToggleButton_1 = __webpack_require__(19838);
const MeterComponent_1 = __webpack_require__(71668);
const PopupState_1 = __importStar(__webpack_require__(57388));
const TotalWinFrame_1 = __importDefault(__webpack_require__(47010));
const GameServiceEvent_1 = __webpack_require__(83363);
const SoundListExtended_1 = __importDefault(__webpack_require__(19402));
class UIMain extends pixi_js_1.Container {
    constructor(le, config) {
        super();
        this.holdWait = 0.4;
        this.pressAndHoldActivated = false;
        this._config = config;
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.btnSpin.on('pointerup', this.onBtnSpin, this);
        this.btnSpin.on('pointerdown', this.onPressAndHoldHandler, this);
        this.btnAutoSpin.on('pointerup', this.onBtnAutoSpin, this);
        this.btnAutoSpinStop.on('pointerup', this.onBtnAutoSpin, this);
        this.btnBet.on('pointerup', this.onBtnBet, this);
        this.btnSetting.on('pointerup', this.onBtnSettings, this);
        this.btnInfo.on('pointerup', this.onBtnInfo, this);
        this.betMeter = this["betMeterContainer"]["betMeter"];
        this.creditMeter = this["creditMeterContainer"]["creditMeter"];
        this.btnTurbo.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.onQuickSpinHandler, this);
        this.btnSound.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.changeSounds, this);
        document.body.addEventListener('pointerup', (e) => this.removePressAndHold(e));
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.wallet
            .on(WalletEvent_1.WalletEvent.NOT_ENOUGH_BALANCE, () => {
            // this.btnSpin.spinAnimation(ButtonSpinAnimation.LOOP, ButtonSpinAnimation.STOP);
        }, this);
        this.gs = tsyringe_1.container.resolve('GameService');
        this.gs.on(GameServiceEvent_1.GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateView();
        }, this);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedLevelChanged, this);
        this.slotMachine.autoplay.on(AutoplayEvent_1.AutoplayEvent.DISABLED, this.onAutospinDisabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent_1.AutoplayEvent.ENABLED, this.onAutospinEnabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent_1.AutoplayEvent.SPINS_LEFT_CHANGED, this.onAutospinSpinsLeftChange, this);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedLevelChanged, this);
        this.onGameSpeedLevelChanged(this.slotMachine.currentGameSpeedLevel);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.STATE_CHANGED, this.onStateChanged, this);
        this.onBetValueChanged();
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent_1.WalletEvent.BALANCE_CHANGED, this.onWalletBalanceChanged, this);
        this.onWalletBalanceChanged();
        if (!this.slotMachine.autoplay.enabled)
            this.btnAutoSpinStop.visible = false;
        this.on('added', this.onAdded, this);
        this.updateView();
    }
    onStateChanged(currentState, previousState) {
        if (currentState === SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_START) {
            this.btnAutoSpin.visible = false;
            // this.btnAutoSpinStop.visible = false;
            this.btnSpin.visible = false;
            this.btnBet.visible = false;
        }
        else if (this.slotMachine.currentState === SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_END) {
            this.btnAutoSpin.visible = true;
            // this.btnAutoSpinStop.visible = true;
            this.btnSpin.visible = true;
            this.btnBet.visible = true;
        }
    }
    lock() {
        [this.btnSpin, this.btnBet, this.btnAutoSpin, this.btnSetting, this.btnInfo
        ].forEach((btn) => {
            btn.enabled = false;
        });
        if (!this.slotMachine.autoplay.enabled) {
            this.btnAutoSpin.enabled = false;
        }
    }
    unlock() {
        [this.btnSpin, this.btnBet, this.btnAutoSpin, this.btnSetting, this.btnInfo].forEach((btn) => {
            btn.enabled = true;
        });
        this.btnSpin.waitAnimation(ButtonSpinAnimation_1.default.WAIT_DELAY);
    }
    changeSounds() {
        this.gs.settings.sound = !this.gs.settings.sound;
        this.gs.saveSettings();
        SoundManager_1.default.getChannel('default').mute = !this.gs.settings.sound;
        SoundManager_1.default.getChannel('ambient').mute = !this.gs.settings.sound;
    }
    updateView() {
        this.btnSound.setStateView(this.gs.settings.sound);
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        let btn;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'ButtonSpin':
                instance = new ButtonSpin_1.default(le);
                btn = instance;
                btn.hitArea = new pixi_js_1.Circle(105, 105, 110);
                break;
            case 'ButtonAutoSpinStop':
                instance = new ButtonAutoSpinStop_1.default(le);
                btn = instance;
                break;
            case 'ButtonAutospin':
                instance = new ButtonAutospin_1.default(le);
                btn = instance;
                // btn.hitArea = new Circle(90,90,50)
                break;
            case 'ButtonTurbo':
                instance = new Button_1.default(le);
                btn = instance;
                // btn.hitArea = new Circle(90,90,50)
                break;
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
            case "ToggleButton":
                instance = new ToggleButton_1.ToggleButton(le);
                break;
            case 'TotalWinFrame':
                instance = new TotalWinFrame_1.default(le);
                break;
            case "MeterComponent":
                instance = new MeterComponent_1.MeterComponent(le);
                break;
        }
        return instance;
    }
    onAdded() {
        this.onGameSpeedLevelChanged(this.slotMachine.currentGameSpeedLevel);
        this.onAutospinSpinsLeftChange();
    }
    onBtnMenu() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.MENU_SETTING).dispatch();
    }
    onQuickSpinHandler() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        if (this.btnTurbo.getIsStateOn()) {
            new ControlEvent_1.default(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_UP).dispatch();
        }
        else {
            new ControlEvent_1.default(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_DOWN).dispatch();
        }
    }
    onGameSpeedLevelChanged(speedLevel) {
        this.gs.settings.quickSpin = speedLevel != 0;
        this.gs.saveSettings();
        this.btnTurbo.setStateView(speedLevel != 0);
    }
    onBetValueChanged() {
        this.betMeter.setCurrencyFormattedValue(this.slotMachine.totalBet, true);
    }
    onWalletBalanceChanged() {
        this.creditMeter.setCurrencyFormattedValue(this.wallet.balance);
    }
    onAutospinEnabled() {
        // if (this.slotMachine.autoplay.infinite) {
        //     this.btnAutoSpinStop.setAnimation(ButtonAutoSpinStopAnimation.INFINITE_LOOP)
        // } else {
        //     this.btnAutoSpinStop.setAnimation(ButtonAutoSpinStopAnimation.LOOP);
        // }
        // this.btnAutoSpinStop.visible = true;
        // this.btnSpin.visible = false;
        this.btnAutoSpinStop.visible = true;
        this.btnAutoSpin.visible = false;
    }
    onAutospinDisabled() {
        // if (this.slotMachine.currentState != SlotMachineState.IDLE) {
        //     this.btnAutoSpin.enabled = false;
        //     this.btnAutoSpinStop.visible = false;
        //     this.btnSpin.visible = true;
        // }
        this.btnAutoSpinStop.visible = false;
        this.btnAutoSpin.visible = true;
    }
    onAutospinSpinsLeftChange() {
        if (!this.slotMachine.autoplay.infinite) {
            this.btnAutoSpinStop.setAutoPlayLeftValue(this.slotMachine.autoplay.spinsLeft);
        }
        this.btnAutoSpin.autospinChange(this.slotMachine.autoplay.spinsLeft);
    }
    // USER INTERACTION
    onBtnSettings() {
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.SYSTEM_SETTINGS).dispatch();
    }
    onBtnInfo() {
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.PAYTABLE).dispatch();
    }
    onBtnSpin() {
        if (this.slotMachine.currentState !== SlotMachineState_1.SlotMachineState.IDLE) {
            if (this.slotMachine.stopRequested)
                return;
            // SoundManager.play(SoundList.UI_BUTTON_SPIN_STOP);
            this.btnSpin.spinAnimation(ButtonSpinAnimation_1.default.LOOP, ButtonSpinAnimation_1.default.SPIN);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.STOP_REQUESTED).dispatch();
            if (!this.slotMachine.autoplay.enabled) {
                this.btnSpin.enabled = false;
            }
        }
        else {
            SoundManager_1.default.play({
                id: SoundList_1.default.UI_BUTTON_SPIN_START,
                volume: 0.3
            });
            this.btnSpin.spinAnimation(ButtonSpinAnimation_1.default.LOOP, ButtonSpinAnimation_1.default.SPIN, false, this._config.buttonSpinConfig.useRotationInStartAnimation, false);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
            this.btnSpin.enabled = true;
        }
    }
    onPressAndHoldHandler() {
        if (this.slotMachine.autoplay.enabled) {
            return;
        }
        engineTween_1.Tweener.addCaller(this, {
            count: 1,
            time: this.holdWait,
            onComplete: () => {
                this.pressAndHoldActivated = true;
                this.startPressAndHoldSpin();
            },
        });
    }
    startPressAndHoldSpin() {
        if (this.pressAndHoldActivated) {
            const uiState = tsyringe_1.container.resolve(UIState_1.default);
            const popupState = tsyringe_1.container.resolve(PopupState_1.default);
            if (!uiState.activePanel && (!popupState.activePopup || popupState.activeType !== PopupState_1.PopupType.CONNECTION_LOST)) {
                this.onPressAndHoldSpinHandler();
            }
            engineTween_1.Tweener.addCaller(this, {
                count: 1,
                time: 0.1,
                onComplete: () => {
                    this.startPressAndHoldSpin();
                },
            });
        }
    }
    onPressAndHoldSpinHandler() {
        if (this.slotMachine.currentState !== SlotMachineState_1.SlotMachineState.IDLE) {
            if (this.slotMachine.stopRequested)
                return;
            // SoundManager.play(SoundList.UI_BUTTON_SPIN_STOP);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.STOP_REQUESTED).dispatch();
            if (!this.slotMachine.autoplay.enabled) {
                this.btnSpin.enabled = false;
            }
        }
        else {
            SoundManager_1.default.play({
                id: SoundList_1.default.UI_BUTTON_SPIN_START,
                volume: 0.3,
            });
            this.btnSpin.spinAnimation(ButtonSpinAnimation_1.default.LOOP, ButtonSpinAnimation_1.default.SPIN, false, true, false);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
            this.btnSpin.enabled = true;
        }
    }
    removePressAndHold(e) {
        engineTween_1.Tweener.removeTweens(this);
        clearTimeout(this.btnSpin.stopDelay);
        if (this.pressAndHoldActivated) {
            this.pressAndHoldActivated = false;
        }
    }
    onBtnAutoSpin() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        if (this.slotMachine.autoplay.enabled) {
            this.slotMachine.autoplay.infinite = false;
            new ControlEvent_1.default(UIEvent_1.UIEvent.AUTO_SPIN).dispatch();
        }
        else {
            new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.AUTOSPIN_SETTINGS).dispatch();
        }
    }
    onBtnTurboSpinEnable() {
        SoundManager_1.default.play(SoundListExtended_1.default.TURBO_BTN_CLICK);
        new ControlEvent_1.default(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_UP).dispatch();
    }
    onBtnTurboSpinDisable() {
        SoundManager_1.default.play(SoundListExtended_1.default.TURBO_BTN_CLICK);
        new ControlEvent_1.default(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_DOWN).dispatch();
    }
    onBtnBet() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.BET_SETTINGS).dispatch();
    }
}
exports["default"] = UIMain;


/***/ }),

/***/ 51244:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Button_1 = __importDefault(__webpack_require__(78386));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const WalletEvent_1 = __webpack_require__(63035);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotMachineEvent_1 = __webpack_require__(96421);
const tsyringe_1 = __webpack_require__(659);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const ValueText_1 = __importDefault(__webpack_require__(68223));
const UIPanelEvent_1 = __webpack_require__(566);
const UIState_1 = __importStar(__webpack_require__(54572));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const ButtonSpin_1 = __importDefault(__webpack_require__(79619));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const AdjustableLayoutContainer_1 = __importDefault(__webpack_require__(66961));
const ButtonAutospin_1 = __importDefault(__webpack_require__(9352));
const UIEvent_1 = __webpack_require__(77066);
const AutoplayEvent_1 = __webpack_require__(71967);
const SlotMachineState_1 = __webpack_require__(77313);
const ButtonSpinAnimation_1 = __importDefault(__webpack_require__(58553));
const SlotGameEvent_1 = __webpack_require__(19342);
const CascadeHistoryView_1 = __webpack_require__(4799);
const FreeSpinButton_1 = __webpack_require__(10554);
const DoubleChanceButton_1 = __webpack_require__(32181);
const ButtonVolume_1 = __importDefault(__webpack_require__(57861));
const PopupState_1 = __importStar(__webpack_require__(57388));
const GameServiceEvent_1 = __webpack_require__(83363);
const SoundListExtended_1 = __importDefault(__webpack_require__(19402));
const ButtonAutoSpinStop_1 = __importDefault(__webpack_require__(75400));
const TotalWinFrame_1 = __importDefault(__webpack_require__(47010));
const MeterComponent_1 = __webpack_require__(71668);
const ToggleButton_1 = __webpack_require__(19838);
const UISettingsMobileHorizontal_1 = __importDefault(__webpack_require__(89957));
class UIPanelDesktop extends AdjustableLayoutContainer_1.default {
    constructor(config) {
        super(AssetsManager_1.default.layouts.get('uiHorizontal'));
        this._config = config;
        LayoutBuilder_1.default.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.baseYPosition = this.y;
        this.btnSpin = this['btnSpinContainer'].btnSpin;
        this.btnBetUp.on('pointerup', this.onBtnBetUp, this);
        this.btnBetDown.on('pointerup', this.onBtnBetDown, this);
        this.btnAutoSpin.on('pointerup', this.onBtnAutoSpin, this);
        this.btnAutoSpinStop.on('pointerup', this.onBtnAutoSpin, this);
        this.btnInfo.on('pointerup', this.onBtnInfo, this);
        this.btnTurbo.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.onQuickSpinHandler, this);
        this.btnSound.on(ToggleButton_1.ToggleButton.STATE_CHANGED, this.changeSounds, this);
        // --- Spin button listener ---
        this.btnSpin.on('pointerup', this.onBtnSpin, this);
        this.btnSetting.on('pointerup', this.onbtnSetting, this);
        this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
        this.betMeter = this["betMeterContainer"]["betMeter"];
        this.creditMeter = this["creditMeterContainer"]["creditMeter"];
        this.wallet.on(WalletEvent_1.WalletEvent.NOT_ENOUGH_BALANCE, () => {
            // If user has no balance, we can stop the spin animation or handle UI
            this.btnSpin.spinAnimation(ButtonSpinAnimation_1.default.LOOP, ButtonSpinAnimation_1.default.SPIN);
        }, this);
        // Autoplay
        this.slotMachine.autoplay.on(AutoplayEvent_1.AutoplayEvent.ENABLED, this.onAutospinEnabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent_1.AutoplayEvent.DISABLED, this.onAutospinDisabled, this);
        this.slotMachine.autoplay.on(AutoplayEvent_1.AutoplayEvent.SPINS_LEFT_CHANGED, this.onAutospinSpinsLeftChange, this);
        this.onAutospinSpinsLeftChange();
        this.gs = tsyringe_1.container.resolve('GameService');
        // Slot machine events
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this.onGameSpeedLevelChanged, this);
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, this.onBetValueChanged, this);
        this.wallet.on(WalletEvent_1.WalletEvent.BALANCE_CHANGED, this.onWalletBalanceChanged, this);
        // Initialize displayed values
        this.onBetValueChanged();
        this.onWalletBalanceChanged();
        this.onGameSpeedLevelChanged(this.slotMachine.currentGameSpeedLevel);
        // React to game service settings changes
        this.gs.on(GameServiceEvent_1.GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateView();
        }, this);
        this.updateView();
        if (!this.slotMachine.autoplay.enabled) {
            this.btnAutoSpinStop.visible = false;
        }
        // Space key to spin
        document.body.addEventListener('keydown', (e) => this.onSpaceClick(e));
    }
    // PUBLIC API
    lock() {
        [
            this.btnBetDown,
            this.btnBetUp,
            this.btnSpin,
            this.btnSetting,
            this.btnAutoSpin,
            this.btnInfo
        ].forEach((btn) => {
            if (btn) {
                btn.enabled = false;
            }
        });
        if (!this.slotMachine.autoplay.enabled) {
            this.btnAutoSpin.enabled = false;
        }
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.CLOSE_SETTINGS).dispatch();
    }
    onBtnAutoSpin() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        if (this.slotMachine.autoplay.enabled) {
            // If autoplay is on, clicking the button will stop it
            this.slotMachine.autoplay.infinite = false;
            new ControlEvent_1.default(UIEvent_1.UIEvent.AUTO_SPIN).dispatch();
        }
        else {
            // If autoplay is off, clicking the button will open the panel to choose spins
            new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.AUTOSPIN_SETTINGS).dispatch();
        }
    }
    unlock() {
        [
            this.btnAutoSpin,
            this.btnBetDown,
            this.btnBetUp,
            this.btnSpin,
            this.btnSetting,
            this.btnInfo
        ].forEach((btn) => {
            if (btn) {
                btn.enabled = true;
            }
        });
        // Re-enable Spin animations, etc.
        this.btnSpin.waitAnimation(ButtonSpinAnimation_1.default.WAIT_DELAY);
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        let bottomY = desc.baseHeight;
        if (desc.currentHeight > desc.baseHeight) {
            bottomY = desc.baseHeight + (desc.currentHeight - desc.baseHeight) / 2;
        }
        this.y = bottomY - (desc.baseHeight - this.baseYPosition);
    }
    changeSounds() {
        this.gs.settings.sound = !this.gs.settings.sound;
        this.gs.saveSettings();
        SoundManager_1.default.getChannel('default').mute = !this.gs.settings.sound;
        SoundManager_1.default.getChannel('ambient').mute = !this.gs.settings.sound;
    }
    updateView() {
        this.btnSound.setStateView(this.gs.settings.sound);
    }
    onBtnInfo() {
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.PAYTABLE).dispatch();
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        let btn;
        let radius;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'RoundButton':
                instance = new Button_1.default(le);
                btn = instance;
                radius = btn.width / 2;
                btn.hitArea = new pixi_js_1.Circle(radius, radius, radius);
                break;
            case 'ButtonSpin':
                instance = new ButtonSpin_1.default(le);
                btn = instance;
                // Hard-coded hit area
                btn.hitArea = new pixi_js_1.Circle(105, 105, 110);
                break;
            case 'ButtonAutospin':
                instance = new ButtonAutospin_1.default(le);
                btn = instance;
                break;
            case 'ButtonAutoSpinStop':
                instance = new ButtonAutoSpinStop_1.default(le);
                btn = instance;
                break;
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
            case 'UISettingsDesktop':
                instance = new UISettingsMobileHorizontal_1.default(le);
                break;
            case 'CascadeHistoryPanel':
                instance = new CascadeHistoryView_1.CascadeHistoryView(le);
                break;
            case 'FreeSpinButton':
                instance = new FreeSpinButton_1.FreeSpinButton(le);
                break;
            case 'DoubleChanceButton':
                instance = new DoubleChanceButton_1.DoubleChanceButton(le);
                break;
            case 'ButtonVolume':
                instance = new ButtonVolume_1.default(le);
                break;
            case 'TotalWinFrame':
                instance = new TotalWinFrame_1.default(le);
                break;
            case "ToggleButton":
                instance = new ToggleButton_1.ToggleButton(le);
                break;
            case "MeterComponent":
                instance = new MeterComponent_1.MeterComponent(le);
                break;
        }
        return instance;
    }
    onbtnSetting() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.SYSTEM_SETTINGS).dispatch();
    }
    onAutospinEnabled() {
        this.btnAutoSpinStop.visible = true;
        this.btnAutoSpin.visible = false;
        // this.btnSpin.visible = false; // If you need to hide spin when autospin is on
    }
    onAutospinDisabled() {
        this.btnAutoSpinStop.visible = false;
        this.btnAutoSpin.visible = true;
    }
    onAutospinSpinsLeftChange() {
        this.btnAutoSpin.autospinChange(this.slotMachine.autoplay.spinsLeft);
        if (!this.slotMachine.autoplay.infinite) {
            this.btnAutoSpinStop.setAutoPlayLeftValue(this.slotMachine.autoplay.spinsLeft);
        }
    }
    onGameSpeedLevelChanged(speedLevel) {
        this.gs.settings.quickSpin = speedLevel !== 0;
        this.gs.saveSettings();
        this.btnTurbo.setStateView(speedLevel !== 0);
    }
    onBetValueChanged() {
        this.betMeter.setCurrencyFormattedValue(this.slotMachine.totalBet, true);
    }
    onWalletBalanceChanged() {
        this.creditMeter.setCurrencyFormattedValue(this.wallet.balance);
    }
    // USER INTERACTION
    onBtnBetUp() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.BET_SETTINGS).dispatch();
        new ControlEvent_1.default(UIEvent_1.UIEvent.BET_QUANTITY_UP).dispatch();
    }
    onBtnBetDown() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.BET_SETTINGS).dispatch();
        new ControlEvent_1.default(UIEvent_1.UIEvent.BET_QUANTITY_DOWN).dispatch();
    }
    onQuickSpinHandler() {
        SoundManager_1.default.play(SoundListExtended_1.default.UI_BUTTON_CLICK);
        if (this.btnTurbo.getIsStateOn()) {
            new ControlEvent_1.default(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_UP).dispatch();
        }
        else {
            new ControlEvent_1.default(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_DOWN).dispatch();
        }
    }
    /**
     * FIX APPLIED: Immediately disable the button on click,
     * so subsequent fast clicks are ignored until unlock().
     */
    onBtnSpin() {
        // If spin button is already disabled, ignore further clicks
        if (!this.btnSpin.enabled) {
            return;
        }
        // Now handle SPIN vs STOP
        if (this.slotMachine.currentState !== SlotMachineState_1.SlotMachineState.IDLE) {
            // We are in a spinning state, so the user wants to STOP
            if (this.slotMachine.stopRequested) {
                // Already requested a stop; ignore further clicks
                return;
            }
            // Disable immediately to prevent multi-click issues
            this.btnSpin.enabled = false;
            // Play a sound if needed, set spin animation to STOP, etc.
            this.btnSpin.spinAnimation(ButtonSpinAnimation_1.default.LOOP, ButtonSpinAnimation_1.default.SPIN);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.STOP_REQUESTED).dispatch();
        }
        else {
            // We are in IDLE state, so the user wants to SPIN
            SoundManager_1.default.play({
                id: SoundList_1.default.UI_BUTTON_SPIN_START,
                volume: 0.3
            });
            // Start the spin animation
            this.btnSpin.spinAnimation(ButtonSpinAnimation_1.default.LOOP, ButtonSpinAnimation_1.default.SPIN, false, this._config.UIMainConfiguration.buttonSpinConfig.useRotationInStartAnimation, false);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
        }
    }
    onSpaceClick(event) {
        const uiState = tsyringe_1.container.resolve(UIState_1.default);
        const popupState = tsyringe_1.container.resolve(PopupState_1.default);
        if (event.code === 'Space') {
            // If no panel/popup is blocking input, spin
            if (!uiState.activePanel &&
                (!popupState.activePopup || popupState.activeType !== PopupState_1.PopupType.CONNECTION_LOST)) {
                this.onBtnSpin();
            }
        }
    }
}
exports["default"] = UIPanelDesktop;


/***/ }),

/***/ 67758:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Button_1 = __importDefault(__webpack_require__(78386));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const ValueText_1 = __importDefault(__webpack_require__(68223));
const UIPanelEvent_1 = __webpack_require__(566);
const UISettingsMobileVertical_1 = __importDefault(__webpack_require__(58079));
const UIState_1 = __webpack_require__(54572);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const ButtonSpin_1 = __importDefault(__webpack_require__(79619));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const AdjustableLayoutContainer_1 = __importDefault(__webpack_require__(66961));
const FreeSpinButton_1 = __webpack_require__(10554);
const DoubleChanceButton_1 = __webpack_require__(32181);
const TotalWinFrame_1 = __importDefault(__webpack_require__(47010));
const UIMain_1 = __importDefault(__webpack_require__(59071));
class UIPanelMobileVertical extends AdjustableLayoutContainer_1.default {
    constructor(config) {
        super(AssetsManager_1.default.layouts.get('uiPortrait'));
        this._config = config;
        LayoutBuilder_1.default.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
    }
    // PUBLIC API
    lock() {
        this.uiMain.lock();
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.CLOSE_SETTINGS).dispatch();
    }
    unlock() {
        this.uiMain.unlock();
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        this.background.width = desc.currentWidth;
        this.background.x = -(desc.currentWidth - desc.baseWidth) / 2;
        if (desc.baseWidth < desc.currentWidth) {
            this.y = desc.baseHeight;
        }
        else if (desc.baseHeight < desc.currentHeight) {
            this.y = desc.baseHeight + (desc.currentHeight - desc.baseHeight) / 2;
        }
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'ButtonSpin':
                instance = new ButtonSpin_1.default(le);
                break;
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
            case 'UIMain':
                instance = new UIMain_1.default(le, this._config.UIMainConfiguration);
                break;
            case 'UISettingsMobileVertical':
                instance = new UISettingsMobileVertical_1.default(le);
                break;
            case 'FreeSpinButton':
                instance = new FreeSpinButton_1.FreeSpinButton(le);
                break;
            case 'TotalWinFrame':
                instance = new TotalWinFrame_1.default(le);
                break;
            case 'DoubleChanceButton':
                instance = new DoubleChanceButton_1.DoubleChanceButton(le);
                break;
        }
        return instance;
    }
    getUIMain() {
        return this.uiMain;
    }
    // USER INTERACTION
    onBtnBet() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.BET_SETTINGS).dispatch();
    }
    onBtnWin() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.HISTORY).dispatch();
    }
}
exports["default"] = UIPanelMobileVertical;


/***/ }),

/***/ 89957:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const Button_1 = __importDefault(__webpack_require__(78386));
const SoundChannelEvent_1 = __webpack_require__(31329);
const SoundList_1 = __importDefault(__webpack_require__(27310));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIPanelEvent_1 = __webpack_require__(566);
const UIState_1 = __webpack_require__(54572);
const engineTween_1 = __webpack_require__(50381);
class UISettingsMobileHorizontal extends pixi_js_1.Container {
    constructor(le) {
        super();
        this._open = false;
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        // this.btnMenu.on('pointerup', this.onBtnMenu, this);
        this.btnClose.on('pointerup', this.onBtnClose, this);
        // this.btnLobby.on('pointerup', this.onBtnLobby, this);
        this.btnSound.on('pointerup', this.onBtnSfx, this);
        this.btnPaytable.on('pointerup', this.onBtnRPaytable, this);
        // this.btnRules.on('pointerup', this.onBtnRules, this);
        this.btnHistory.on('pointerup', this.onBtnHistory, this);
        this
            .on('added', this.onAdded, this)
            .on('removed', this.onRemoved, this);
        // this.openButtons = [this.btnLobby, this.btnSound, this.btnPaytable, this.btnRules];
        // this.openButtons.forEach((item: DisplayObject) => {
        //     item.visible = false;
        //     item.alpha = 0;
        // });
        // const uiState = container.resolve(UIState);
        // uiState.on(UIStateEvent.SETTINGS_OPEN_CHANGED, this.onUiSettingsOpenChange, this);
        // this.onUiSettingsOpenChange();
    }
    // PUBLIC API
    lock() {
        [].forEach((btn) => {
            btn.enabled = false;
        });
    }
    unlock() {
        [].forEach((btn) => {
            btn.enabled = true;
        });
    }
    get open() {
        return this._open;
    }
    set open(value) {
        this._open = value;
        // this.btnMenu.visible = !this._open;
        this.btnClose.visible = this._open;
        // hardcoded size values
        const newWidth = this._open ? 787 : 170;
        engineTween_1.Tweener.addTween(this.background, {
            width: newWidth,
            time: 0.3,
            transition: 'easeOutQuad'
        });
        this.openButtons.forEach((item, index) => {
            engineTween_1.Tweener.removeTweens(item);
            const itemVisible = this._open;
            if (itemVisible && !item.visible) {
                item.visible = true;
            }
            item.enabled = itemVisible;
            engineTween_1.Tweener.addTween(item, {
                alpha: itemVisible ? 1 : 0,
                time: 0.1,
                transition: 'easeOutQuad',
                onComplete: () => {
                    item.visible = itemVisible;
                    if (!item.visible) {
                        item.alpha = 0;
                    }
                },
                delay: itemVisible ? index * 0.05 : 0
            });
        });
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'RoundButton':
            case 'Button':
                instance = new Button_1.default(le);
                break;
        }
        if (le.customClass == 'RoundButton') {
            const btn = instance;
            const radius = btn.width / 2;
            btn.hitArea = new pixi_js_1.Circle(radius, radius, radius);
        }
        return instance;
    }
    onAdded() {
        const defaultChannel = SoundManager_1.default.getChannel('default');
        defaultChannel.on(SoundChannelEvent_1.SoundChannelEvent.MUTE, this.onSfxMuteChange, this);
        defaultChannel.on(SoundChannelEvent_1.SoundChannelEvent.UNMUTE, this.onSfxMuteChange, this);
        this.onSfxMuteChange();
    }
    onRemoved() {
        const defaultChannel = SoundManager_1.default.getChannel('default');
        defaultChannel.off(SoundChannelEvent_1.SoundChannelEvent.MUTE, this.onSfxMuteChange, this);
        defaultChannel.off(SoundChannelEvent_1.SoundChannelEvent.UNMUTE, this.onSfxMuteChange, this);
    }
    onSfxMuteChange() {
        const soundsEnabled = SoundManager_1.default.getChannel('default').mute;
        this.btnSound.normal['icon-on'].visible = !soundsEnabled;
        this.btnSound.normal['icon-off'].visible = soundsEnabled;
    }
    onUiSettingsOpenChange() {
        // const uiState = container.resolve(UIState);
        // this.open = uiState.settingsOpen;
    }
    // USER INTERACTION
    onBtnMenu() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_SETTINGS).dispatch();
    }
    onBtnClose() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.SET_TYPE, UIState_1.UIType.MAIN).dispatch();
    }
    onBtnLobby() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        const gs = tsyringe_1.container.resolve('GameService');
        gs.lobby();
    }
    onBtnSfx() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        const soundsEnabled = SoundManager_1.default.getChannel('default').mute = SoundManager_1.default.getChannel('ambient').mute = !SoundManager_1.default.getChannel('default').mute;
        this.btnSound.normal['icon-on'].visible = !soundsEnabled;
        this.btnSound.normal['icon-off'].visible = soundsEnabled;
    }
    onBtnRules() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.RULES).dispatch();
    }
    onBtnRPaytable() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.PAYTABLE).dispatch();
    }
    onBtnHistory() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.HISTORY).dispatch();
    }
}
exports["default"] = UISettingsMobileHorizontal;


/***/ }),

/***/ 58079:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const Button_1 = __importDefault(__webpack_require__(78386));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const UIPanelEvent_1 = __webpack_require__(566);
const UIState_1 = __webpack_require__(54572);
const SoundList_1 = __importDefault(__webpack_require__(27310));
const tsyringe_1 = __webpack_require__(659);
const ButtonVolume_1 = __importDefault(__webpack_require__(57861));
const ButtonVolumeEvent_1 = __webpack_require__(55314);
const GameServiceEvent_1 = __webpack_require__(83363);
class UISettingsMobileVertical extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.btnClose.on('pointerup', this.onBtnClose, this);
        if (this.btnHome) {
            this.btnHome.on('pointerup', this.onbtnHome, this);
        }
        this.btnInfo.on('pointerup', this.onBtnPaytable, this);
        // this.btnSettings.on('pointerup', this.onBtnSettings,this)
        this.btnHistory.on('pointerup', this.onBtnHistory, this);
        this.gs = tsyringe_1.container.resolve('GameService');
        this.gs.on(GameServiceEvent_1.GameServiceEvent.SETTINGS_CHANGED, () => {
            this.updateVolume();
        }, this);
        this.btnVolume.on(ButtonVolumeEvent_1.ButtonVolumeEvent.STATE_CHANGED, this.onBtnVolume, this);
        this.updateVolume();
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Button':
                instance = new Button_1.default(le);
                break;
            case 'ButtonVolume':
                instance = new ButtonVolume_1.default(le);
                break;
        }
        return instance;
    }
    onBtnVolume() {
        if (!this.gs.settings.ambientMusic && !this.gs.settings.soundFx) {
            this.gs.settings.ambientMusic = true;
            this.gs.settings.soundFx = true;
        }
        else {
            this.gs.settings.ambientMusic = false;
            this.gs.settings.soundFx = false;
        }
        this.gs.saveSettings();
        SoundManager_1.default.getChannel('ambient').mute = !this.gs.settings.ambientMusic;
        SoundManager_1.default.getChannel('default').mute = !this.gs.settings.soundFx;
    }
    updateVolume() {
        this.btnVolume.setInitialState(this.gs.settings.ambientMusic, this.gs.settings.soundFx);
    }
    onBtnSettings() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.HISTORY).dispatch();
    }
    // USER INTERACTION
    onbtnHome() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        const gs = tsyringe_1.container.resolve('GameService');
        gs.lobby();
    }
    onBtnClose() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.CLOSE_SETTINGS).dispatch();
    }
    onBtnPaytable() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.PAYTABLE).dispatch();
    }
    onBtnHistory() {
        SoundManager_1.default.play(SoundList_1.default.UI_BUTTON_CLICK);
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, UIState_1.UIPanelType.HISTORY).dispatch();
    }
}
exports["default"] = UISettingsMobileVertical;


/***/ }),

/***/ 36353:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AssetsManager {
    static getAnimationTextures(texturePrefix) {
        const animationTextures = [];
        const keys = [];
        AssetsManager.textures.forEach((texture, key) => {
            if (key.indexOf(texturePrefix) === 0) {
                keys.push(key);
            }
        });
        keys.sort();
        for (const key of keys) {
            if (AssetsManager.textures.has(key)) {
                const animationFrameTexture = AssetsManager.textures.get(key);
                animationTextures.push(animationFrameTexture);
            }
        }
        if (animationTextures.length) {
            return animationTextures;
        }
        else {
            return null;
        }
    }
}
AssetsManager.layouts = new Map();
AssetsManager.textures = new Map();
AssetsManager.animatedTextures = new Map();
AssetsManager.spine = new Map();
AssetsManager.videos = new Map();
AssetsManager.sounds = new Map();
AssetsManager.xmls = new Map();
AssetsManager.webFonts = new Map();
AssetsManager.bitmapFonts = new Map();
exports["default"] = AssetsManager;


/***/ }),

/***/ 96066:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlEventDispatcher_1 = __importDefault(__webpack_require__(46490));
const Logger_1 = __importDefault(__webpack_require__(82669));
const Utils_1 = __webpack_require__(63948);
class FrontController {
    constructor() {
        this.controlEventDispatcher = ControlEventDispatcher_1.default.getInstance();
        this.commands = new Map();
    }
    // PUBLIC API
    addCommand(eventType, commandType, ...rest) {
        if (!this.commands.has(eventType)) {
            this.commands.set(eventType, []);
        }
        const associated = this.commands.get(eventType);
        associated.push(commandType);
        if (!this.controlEventDispatcher.hasEventListener(eventType)) {
            this.controlEventDispatcher.addEventListener(eventType, (e) => {
                this.onEvent(e, ...rest);
            });
        }
    }
    removeCommand(eventType, commandType) {
        if (!this.commands.has(eventType)) {
            this.commands.set(eventType, []);
        }
        const associated = this.commands.get(eventType);
        (0, Utils_1.removeArrayElement)(associated, commandType);
    }
    // PRIVATE API
    onEvent(e, ...rest) {
        const associated = this.commands.get(e.type);
        for (const cType of associated) {
            Logger_1.default.debug(cType.name);
            const c = new cType();
            c.execute(e.clone(), ...rest);
        }
    }
}
exports["default"] = FrontController;


/***/ }),

/***/ 5061:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ControlCommand {
}
exports["default"] = ControlCommand;


/***/ }),

/***/ 27638:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationEvent = void 0;
var ApplicationEvent;
(function (ApplicationEvent) {
    ApplicationEvent["INIT"] = "onApplicationInit";
    ApplicationEvent["LOADING_COMPLETE"] = "onApplicationLoadingComplete";
})(ApplicationEvent || (exports.ApplicationEvent = ApplicationEvent = {}));


/***/ }),

/***/ 68659:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Event_1 = __importDefault(__webpack_require__(11945));
const ControlEventDispatcher_1 = __importDefault(__webpack_require__(46490));
class ControlEvent extends Event_1.default {
    constructor(type, data) {
        super(type, data);
        this.controlEventDispatcher = ControlEventDispatcher_1.default.getInstance();
    }
    dispatch() {
        this.controlEventDispatcher.dispatchEvent(this);
    }
}
exports["default"] = ControlEvent;


/***/ }),

/***/ 46490:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const EventDispatcher_1 = __importDefault(__webpack_require__(14164));
class ControlEventDispatcher extends EventDispatcher_1.default {
    constructor() {
        super();
        if (ControlEventDispatcher.instance) {
            throw new Error('You cannot instatiate ControlEventDispatcher directly!');
        }
    }
    /*
     * PUBLIC API
     */
    static getInstance() {
        if (!ControlEventDispatcher.instance) {
            ControlEventDispatcher.instance = new ControlEventDispatcher();
        }
        return ControlEventDispatcher.instance;
    }
}
exports["default"] = ControlEventDispatcher;


/***/ }),

/***/ 11945:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Event {
    constructor(type, data) {
        this.target = null;
        this.type = type;
        this.data = data;
    }
    clone() {
        const e = new Event(this.type, this.data);
        e.target = this.target;
        return e;
    }
}
Event.COMPLETE = 'onComplete';
Event.PROGRESS = 'onProgress';
exports["default"] = Event;


/***/ }),

/***/ 14164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class EventDispatcher {
    constructor() {
        this.listeners = new Map();
    }
    /*
    PUBLIC API
     */
    addEventListener(type, listener, context = null) {
        if (!this.listeners.has(type)) {
            this.listeners.set(type, new Array());
        }
        const typeListeners = this.listeners.get(type);
        const fc = new FunctionContext(listener, context);
        if (this.arrayIndexOf(typeListeners, fc) == -1) {
            typeListeners.push(fc);
        }
    }
    removeEventListener(type, listener, context = null) {
        if (this.listeners.has(type)) {
            const typeListeners = this.listeners.get(type);
            const fc = new FunctionContext(listener, context);
            if (this.arrayIndexOf(typeListeners, fc) != -1) {
                typeListeners.splice(this.arrayIndexOf(typeListeners, fc), 1);
            }
            if (!typeListeners.length) {
                this.listeners.delete(type);
            }
        }
    }
    hasEventListener(type) {
        return this.listeners.has(type);
    }
    dispatchEvent(event) {
        if (this.listeners.has(event.type)) {
            const eventListeners = this.listeners.get(event.type);
            for (const fc of eventListeners) {
                fc.f.apply(fc.c, [event]);
            }
        }
    }
    arrayIndexOf(arr, fc) {
        for (let i = 0; i < arr.length; i++) {
            const el = arr[i];
            if (el.c == fc.c && el.f == fc.f) {
                return i;
            }
        }
        return -1;
    }
}
exports["default"] = EventDispatcher;
class FunctionContext {
    constructor(f, c) {
        this.f = f;
        this.c = c;
    }
}


/***/ }),

/***/ 22128:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssetType = void 0;
var AssetType;
(function (AssetType) {
    AssetType["TEXTURE"] = "texture";
    AssetType["LAYOUT"] = "layout";
    AssetType["VIDEO"] = "video";
    AssetType["SPINE"] = "spine";
    AssetType["XML"] = "xml";
    AssetType["WEB_FONT"] = "webfont";
    AssetType["BITMAP_FONT"] = "bitmapfont";
})(AssetType || (exports.AssetType = AssetType = {}));


/***/ }),

/***/ 93794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(15091);
const Logger_1 = __importDefault(__webpack_require__(82669));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const LayoutElementFactory_1 = __importDefault(__webpack_require__(60515));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const howler_1 = __webpack_require__(94196);
const pixi_js_1 = __webpack_require__(95894);
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const AssetType_1 = __webpack_require__(22128);
class AssetsConfigLoader extends eventemitter3_1.default {
    constructor(configFileUrl, renderer = null, autostart = false) {
        super();
        this.childConfigsBeingLoaded = 0;
        this.configOnly = false;
        this._itemsToLoad = 0;
        this._itemsLoaded = 0;
        this._pixiLoaderProgress = 0;
        this.childLoaders = [];
        this.configFileUrl = configFileUrl;
        this.baseUrl = configFileUrl.substring(0, configFileUrl.lastIndexOf('/') + 1);
        this.bundle = {};
        // Adding a renderer here allows us to preload textures into GPU memory after they load
        this.renderer = renderer;
        pixi_js_1.Assets.add('configFile', configFileUrl);
        if (autostart) {
            this.load();
        }
    }
    // PUBLIC API
    load(configOnly = false) {
        this.configOnly = configOnly;
        pixi_js_1.Assets.load('configFile')
            .then((configFile) => {
            this.onConfigFileLoaded(configFile);
        })
            .catch((reason) => {
            this.onError(reason);
        });
    }
    loadAssets() {
        pixi_js_1.Assets.addBundle(this.configFileUrl, this.bundle);
        pixi_js_1.Assets.loadBundle(this.configFileUrl, (progress) => {
            this._pixiLoaderProgress = progress * 100;
            Logger_1.default.debug(`Loaded ${this.getSharedProgress()}%`);
            this.emit(AssetsConfigLoader.EVENT_LOADING_PROGRESS, this.getSharedProgress());
        })
            .then((resources) => {
            this.onAllAssetsLoaded(resources);
        })
            .catch((reason) => {
            this.onError(reason);
        });
    }
    addAsset(id, type, url) {
        this.bundle[AssetsConfigLoader.assetPrefix(type) + id] = url;
    }
    static assetPrefix(type) {
        return `${type}-`;
    }
    // public addChildLoader(l: AssetsConfigLoader): void {
    //     l.assetsLoader = this.assetsLoader;
    //     this.childLoaders.push(l);
    // }
    //
    // PRIVATE API
    onConfigFileLoaded(configObject) {
        Logger_1.default.debug(`Assets config file: ${this.configFileUrl} loaded.`);
        if (configObject.textures) {
            for (const textureObject of configObject.textures) {
                this.addAsset(textureObject.name, AssetType_1.AssetType.TEXTURE, this.baseUrl + textureObject.url);
            }
        }
        if (configObject.spine) {
            for (const spineObject of configObject.spine) {
                this.addAsset(spineObject.name, AssetType_1.AssetType.SPINE, this.baseUrl + spineObject.url);
            }
        }
        if (configObject.videos) {
            for (const videoObject of configObject.videos) {
                this.addAsset(videoObject.name, AssetType_1.AssetType.VIDEO, this.baseUrl + videoObject.url);
            }
        }
        if (configObject.xmls) {
            for (const xmlObject of configObject.xmls) {
                this.addAsset(xmlObject.name, AssetType_1.AssetType.XML, this.baseUrl + xmlObject.url);
            }
        }
        if (configObject.layouts) {
            for (const layoutObject of configObject.layouts) {
                this.addAsset(layoutObject.name, AssetType_1.AssetType.LAYOUT, this.baseUrl + layoutObject.url);
            }
        }
        if (configObject.scripts) {
            for (const scriptUrl of configObject.scripts) {
                this._itemsToLoad++;
                this.loadScript(this.baseUrl + scriptUrl, () => {
                    this.onScriptLoaded();
                });
            }
        }
        if (configObject.sounds) {
            for (const soundObject of configObject.sounds) {
                this._itemsToLoad++;
                const name = soundObject.name;
                for (let i = 0; i < soundObject.url.length; i++) {
                    soundObject.url[i] = this.baseUrl + soundObject.url[i];
                }
                const sound = new howler_1.Howl({
                    src: soundObject.url,
                });
                sound.once('load', () => {
                    AssetsManager_1.default.sounds.set(name, sound);
                    if (soundObject.channel) {
                        SoundManager_1.default.addSoundToChannel(name, sound, soundObject.channel);
                    }
                    else {
                        SoundManager_1.default.addSoundToChannel(name, sound);
                    }
                    this._itemsLoaded++;
                    this.emit(AssetsConfigLoader.EVENT_LOADING_PROGRESS, this.getSharedProgress());
                });
            }
        }
        if (configObject.fonts) {
            for (const fontObject of configObject.fonts) {
                if (!fontObject.hasOwnProperty('type')) {
                    fontObject.type = 'web';
                }
                switch (fontObject.type) {
                    case 'bitmap':
                        this.addAsset(fontObject.name, AssetType_1.AssetType.BITMAP_FONT, this.baseUrl + fontObject.url);
                        break;
                    case 'web':
                        this.addAsset(fontObject.name, AssetType_1.AssetType.WEB_FONT, this.baseUrl + fontObject.url);
                        break;
                    default:
                        Logger_1.default.warning(`Unknown font type: ${fontObject.type}`);
                        break;
                }
            }
        }
        let loadingChildConfigs = false;
        for (const cl of this.childLoaders) {
            loadingChildConfigs = true;
            this.childConfigsBeingLoaded++;
            cl.once(AssetsConfigLoader.EVENT_CONFIG_LOADED, () => {
                this.onChildConfigLoaded();
            });
            cl.load(true);
        }
        if (!loadingChildConfigs) {
            this.emit(AssetsConfigLoader.EVENT_CONFIG_LOADED);
            if (!this.configOnly) {
                this.loadAssets();
            }
        }
    }
    loadScript(url, callback) {
        const head = document.getElementsByTagName('head')[0];
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = url;
        // Then bind the event to the callback function.
        script.onload = callback;
        // Fire the loading
        head.appendChild(script);
    }
    onScriptLoaded() {
        this._itemsLoaded++;
        Logger_1.default.debug('Loaded script');
        this.emit(AssetsConfigLoader.EVENT_LOADING_PROGRESS, this.getSharedProgress());
    }
    onChildConfigLoaded() {
        this.childConfigsBeingLoaded--;
        if (!this.childConfigsBeingLoaded) {
            this.emit(AssetsConfigLoader.EVENT_CONFIG_LOADED);
            if (!this.configOnly) {
                this.loadAssets();
            }
        }
    }
    getSharedProgress() {
        return this._itemsToLoad > 0 ? this._pixiLoaderProgress * 0.9 + (this._itemsLoaded / this._itemsToLoad) * 10 : this._pixiLoaderProgress;
    }
    onAllAssetsLoaded(resources) {
        if (this.getSharedProgress() >= 100) {
            let preloadingTexturesIntoGPUMemory = false;
            for (const resourceName in resources) {
                const resource = resources[resourceName];
                const assetType = resourceName.substring(0, resourceName.indexOf('-'));
                const assetName = resourceName.substring(resourceName.indexOf('-') + 1);
                switch (assetType) {
                    case AssetType_1.AssetType.LAYOUT:
                        AssetsManager_1.default.layouts.set(assetName, LayoutElementFactory_1.default.parseLayoutDescription(resource));
                        // Logger.debug("Loaded layout: " + assetName);
                        break;
                    case AssetType_1.AssetType.VIDEO:
                        AssetsManager_1.default.videos.set(assetName, resource);
                        break;
                    case AssetType_1.AssetType.TEXTURE:
                        if (resource instanceof pixi_js_1.Spritesheet) {
                            preloadingTexturesIntoGPUMemory = this.checkSpriteSheet(resource);
                            resource.linkedSheets.forEach((spritesheet) => {
                                preloadingTexturesIntoGPUMemory = this.checkSpriteSheet(spritesheet);
                            });
                            if (resource.animations) {
                                for (const animationName in resource.animations) {
                                    AssetsManager_1.default.animatedTextures.set(animationName, resource.animations[animationName]);
                                }
                            }
                        }
                        else {
                            AssetsManager_1.default.textures.set(assetName, resource);
                            Logger_1.default.debug('Loaded texture: ' + assetName);
                            if (this.renderer) {
                                preloadingTexturesIntoGPUMemory = true;
                                this.renderer.prepare.add(resource);
                            }
                        }
                        break;
                    case AssetType_1.AssetType.SPINE:
                        AssetsManager_1.default.spine.set(assetName, resource.spineData);
                        if (this.renderer) {
                            resource.spineAtlas.regions.forEach((tar) => {
                                preloadingTexturesIntoGPUMemory = true;
                                this.renderer.prepare.add(tar.texture);
                            });
                        }
                        break;
                    case AssetType_1.AssetType.XML:
                        const parser = new DOMParser();
                        AssetsManager_1.default.xmls.set(assetName, parser.parseFromString(resource, 'text/xml'));
                        break;
                    case AssetType_1.AssetType.WEB_FONT:
                        const fontFace = resource;
                        AssetsManager_1.default.webFonts.set(assetName, fontFace);
                        break;
                    case AssetType_1.AssetType.BITMAP_FONT:
                        const bitmapFont = resource;
                        AssetsManager_1.default.bitmapFonts.set(bitmapFont.font, bitmapFont);
                        // Logger.debug(`Loaded bitmap font: ${bitmapFont.font}`);
                        break;
                }
            }
            if (preloadingTexturesIntoGPUMemory && this.renderer.rendererLogId != 'Canvas') {
                if (this.renderer) {
                    this.renderer.prepare.upload()
                        .then(() => {
                        pixi_js_1.Assets.reset();
                        this.emit(AssetsConfigLoader.EVENT_LOADING_COMPLETE);
                    });
                    return;
                }
            }
            pixi_js_1.Assets.reset();
            this.emit(AssetsConfigLoader.EVENT_LOADING_COMPLETE);
        }
        else {
            Logger_1.default.debug('Waiting for sounds and script assets to load.');
            setTimeout(() => {
                this.onAllAssetsLoaded(resources);
            }, 1000);
        }
    }
    checkSpriteSheet(spritesheet) {
        let preloadingTexturesIntoGPUMemory = false;
        for (const assetName in spritesheet.textures) {
            AssetsManager_1.default.textures.set(assetName, spritesheet.textures[assetName]);
            Logger_1.default.debug('Loaded texture: ' + assetName);
            // Also add texture without file extension for backward compatibility (e.g., "texture")
            if (assetName.endsWith('.png')) {
                const nameWithoutExtension = assetName.slice(0, -4);
                AssetsManager_1.default.textures.set(nameWithoutExtension, spritesheet.textures[assetName]);
                Logger_1.default.debug('Loaded texture (no ext): ' + nameWithoutExtension);
            }
            if (this.renderer) {
                preloadingTexturesIntoGPUMemory = true;
                this.renderer.prepare.add(spritesheet.textures[assetName]);
            }
        }
        return preloadingTexturesIntoGPUMemory;
    }
    onError(reason) {
        Logger_1.default.error(reason);
    }
}
AssetsConfigLoader.EVENT_CONFIG_LOADED = 'onConfigLoaded';
AssetsConfigLoader.EVENT_LOADING_PROGRESS = 'onLoadingProgress';
AssetsConfigLoader.EVENT_LOADING_COMPLETE = 'onLoadingComplete';
exports["default"] = AssetsConfigLoader;


/***/ }),

/***/ 312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Sound {
    constructor(howl) {
        this._volume = 1;
        this.instanceId = null;
        this.howl = howl;
    }
    play() {
        if (this.instanceId !== null) {
            this.instanceId = this.howl.play(this.instanceId);
        }
        else {
            this.instanceId = this.howl.play();
        }
    }
    stop() {
        this.howl.stop(this.instanceId);
    }
    pause() {
        this.howl.pause(this.instanceId);
    }
    seek(value) {
        this.howl.seek(value, this.instanceId);
    }
    get volume() {
        return this._volume;
    }
    set volume(value) {
        this._volume = value;
        this.howl.volume(this._volume * this.howl.volume(), this.instanceId);
    }
    set mute(value) {
        this.howl.mute(value, this.instanceId);
    }
    get duration() {
        return this.howl.duration(this.instanceId);
    }
    set loop(value) {
        this.howl.loop(value, this.instanceId);
    }
    on(event, callback) {
        this.howl.on(event, callback, this.instanceId);
    }
    off(event, callback) {
        this.howl.off(event, callback, this.instanceId);
    }
}
exports["default"] = Sound;


/***/ }),

/***/ 79689:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Sound_1 = __importDefault(__webpack_require__(312));
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const SoundChannelEvent_1 = __webpack_require__(31329);
class SoundChannel extends eventemitter3_1.default {
    constructor(name) {
        super();
        this._volume = 1;
        this._mute = false;
        this.sounds = new Map();
        this._name = name;
    }
    addSound(soundId, howl) {
        this.sounds.set(soundId, howl);
    }
    getSound(soundId) {
        return this.sounds.get(soundId);
    }
    get name() {
        return this._name;
    }
    get volume() {
        return this._volume;
    }
    set volume(value) {
        this.sounds.forEach((h, key) => {
            h.volume(value);
        });
        this._volume = value;
    }
    get mute() {
        return this._mute;
    }
    set mute(value) {
        this._mute = value;
        this.sounds.forEach((h, key) => {
            h.mute(value);
        });
        if (this._mute) {
            this.emit(SoundChannelEvent_1.SoundChannelEvent.MUTE);
        }
        else {
            this.emit(SoundChannelEvent_1.SoundChannelEvent.UNMUTE);
        }
    }
    play(soundData) {
        var _a;
        const h = this.sounds.get(soundData.id);
        if (!this.sounds.get(soundData.id)) {
            throw new Error(`No sound with id: ${soundData.id} found on channel: ${this._name}`);
        }
        const s = new Sound_1.default(h);
        s.play();
        s.volume = (_a = soundData.volume) !== null && _a !== void 0 ? _a : 1;
        s.mute = this.mute;
        return s;
    }
    loop(soundData) {
        const s = this.play(soundData);
        s.loop = true;
        return s;
    }
}
exports["default"] = SoundChannel;


/***/ }),

/***/ 31329:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SoundChannelEvent = void 0;
var SoundChannelEvent;
(function (SoundChannelEvent) {
    SoundChannelEvent["MUTE"] = "mute";
    SoundChannelEvent["UNMUTE"] = "unmute";
})(SoundChannelEvent || (exports.SoundChannelEvent = SoundChannelEvent = {}));


/***/ }),

/***/ 6881:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const SoundChannel_1 = __importDefault(__webpack_require__(79689));
const Logger_1 = __importDefault(__webpack_require__(82669));
const howler_1 = __webpack_require__(94196);
class SoundManager {
    static getChannel(channelName) {
        if (!SoundManager.channels.get(channelName)) {
            SoundManager.channels.set(channelName, new SoundChannel_1.default(channelName));
        }
        return SoundManager.channels.get(channelName);
    }
    static addSoundToChannel(soundId, sound, channelName = 'default') {
        const sc = SoundManager.getChannel(channelName);
        sc.addSound(soundId, sound);
    }
    static play(sound) {
        var _a;
        let soundData;
        if (typeof sound == 'string') {
            soundData = {
                id: sound
            };
        }
        else {
            soundData = sound;
        }
        Logger_1.default.debug('Play sound: ' + soundData.id);
        const sc = SoundManager.getChannel((_a = soundData.channel) !== null && _a !== void 0 ? _a : 'default');
        return sc.play(soundData);
    }
    static playQueue(soundsIds, volume = 1, gap = 0, channelName = 'default') {
        const s = SoundManager.play({
            id: soundsIds.shift(),
            volume: volume,
            channel: channelName
        });
        const onEnd = function () {
            if (gap > 0) {
                setTimeout(() => {
                    SoundManager.playQueue(soundsIds, volume, gap, channelName);
                }, gap);
            }
            else {
                SoundManager.playQueue(soundsIds, volume, gap, channelName);
            }
            s.off('end', onEnd);
        };
        if (soundsIds.length) {
            s.on('end', onEnd);
        }
    }
    static loop(sound) {
        var _a;
        let soundData;
        if (typeof sound == 'string') {
            soundData = {
                id: sound
            };
        }
        else {
            soundData = sound;
        }
        Logger_1.default.debug('Loop sound: ' + soundData.id);
        const sc = SoundManager.getChannel((_a = soundData.channel) !== null && _a !== void 0 ? _a : 'default');
        return sc.loop(soundData);
    }
    static get mute() {
        return this._mute;
    }
    static set mute(value) {
        this._mute = value;
        Logger_1.default.debug(`Soun mute > ${this._mute}`);
        howler_1.Howler.mute(value);
    }
}
SoundManager.channels = new Map();
SoundManager._mute = false;
exports["default"] = SoundManager;


/***/ }),

/***/ 62231:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: create a proper translation system based on one of the existing libraries instead of this stopgap solution
const Logger_1 = __importDefault(__webpack_require__(82669));
class Translation {
    static addLanguageData(languageId, data) {
        if (Translation.languagesData.has(languageId)) {
            Logger_1.default.warning(`Language with id '${languageId}' already exists`);
            return;
        }
        const map = new Map();
        Translation.processBundle(map, data);
        Translation.languagesData.set(languageId, map);
    }
    static processBundle(map, data, prefix = '') {
        for (const key in data) {
            const entry = data[key];
            if (typeof entry === 'string') {
                // console.log(`${prefix}${key}`, entry);
                map.set(`${prefix}${key}`, entry);
            }
            else {
                Translation.processBundle(map, entry, `${prefix}${key}.`);
            }
        }
    }
    static setCurrentLanguage(languageId) {
        Translation.currentLanguage = languageId;
    }
    static t(key, params) {
        var _a;
        if (!Translation.languagesData.has(Translation.currentLanguage)) {
            Logger_1.default.warning(`No language data for current language '${Translation.currentLanguage}' defined`);
        }
        const data = Translation.languagesData.get(Translation.currentLanguage);
        // return original key string if the translation is not found
        let translation = (_a = data.get(key)) !== null && _a !== void 0 ? _a : key;
        if (params) {
            for (const param in params) {
                translation = translation.replace(`#{${param}}`, params[param]);
            }
        }
        return translation;
    }
}
Translation.languagesData = new Map();
Translation.currentLanguage = 'en';
exports["default"] = Translation;


/***/ }),

/***/ 57976:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
class GraphicUtils {
    static createRectGraphics(graphicSettings) {
        graphicSettings.alpha = typeof graphicSettings.alpha == 'undefined' ? 1 : graphicSettings.alpha;
        graphicSettings.anchor = typeof graphicSettings.anchor == 'undefined' ? { x: 0, y: 0 } : graphicSettings.anchor;
        graphicSettings.color = typeof graphicSettings.color == 'undefined' ? 0x000000 : graphicSettings.color;
        graphicSettings.baseAlpha = typeof graphicSettings.baseAlpha == 'undefined' ? 1 : graphicSettings.baseAlpha;
        graphicSettings.position = typeof graphicSettings.position == 'undefined' ? new pixi_js_1.Point(0, 0) : graphicSettings.position;
        graphicSettings.size = typeof graphicSettings.size == 'undefined' ? new pixi_js_1.Point(100, 100) : graphicSettings.size;
        graphicSettings.eventMode = typeof graphicSettings.eventMode == 'undefined' ? 'none' : graphicSettings.eventMode;
        graphicSettings.cursor = typeof graphicSettings.cursor == 'undefined' ? 'auto' : graphicSettings.cursor;
        const graphics = new pixi_js_1.Graphics();
        graphics.beginFill(graphicSettings.color, graphicSettings.baseAlpha);
        graphics.drawRect(graphicSettings.position.x, graphicSettings.position.y, graphicSettings.size.x, graphicSettings.size.y);
        graphics.endFill();
        graphics.alpha = graphicSettings.alpha;
        graphics.pivot.set(graphics.width * graphicSettings.anchor.x, graphics.height * graphicSettings.anchor.y);
        graphics.eventMode = graphicSettings.eventMode;
        graphics.cursor = graphicSettings.cursor;
        return graphics;
    }
}
exports["default"] = GraphicUtils;


/***/ }),

/***/ 98744:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutElementImage_1 = __importDefault(__webpack_require__(52848));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const LayoutElementTextField_1 = __importDefault(__webpack_require__(33180));
const Logger_1 = __importDefault(__webpack_require__(82669));
const LayoutElement_1 = __importDefault(__webpack_require__(81453));
const LayoutElementQuad_1 = __importDefault(__webpack_require__(506));
const LayoutElementAnimation_1 = __importDefault(__webpack_require__(10963));
const pixi_js_1 = __webpack_require__(95894);
const LayoutElementSpine_1 = __importDefault(__webpack_require__(54034));
const pixi_spine_1 = __webpack_require__(15091);
class LayoutBuilder {
    static create(layout, container, customClassResolver = null) {
        // check if layout element supports layouts and if it does build ALL elements
        // based on the uniqueness of their names
        let children;
        if (layout.layouts.size) {
            children = new Map;
            layout.layouts.forEach((le) => {
                le.children.forEach((le, leName) => {
                    if (!children.has(leName)) {
                        children.set(leName, le);
                    }
                });
            });
        }
        else {
            children = layout.children;
        }
        children.forEach((le, key) => {
            const instance = LayoutBuilder.buildLayoutElement(le, customClassResolver);
            if (instance !== undefined && instance !== null) {
                LayoutBuilder.matchPositionAndRotation(le, instance);
                container[le.name] = instance;
                instance.name = le.name;
                container.addChild(instance);
                if (le.mask != null) {
                    container[le.mask.name] = LayoutBuilder.buildLayoutElement(le.mask);
                    LayoutBuilder.matchPositionAndRotation(le.mask, container[le.mask.name]);
                    container.addChild(container[le.mask.name]);
                    instance.mask = container[le.mask.name];
                }
                if (le.hitArea) {
                    instance.hitArea = new pixi_js_1.Polygon(le.hitArea);
                }
                le.effects.forEach((effect) => {
                    effect.apply(instance);
                });
                if (le.animation) {
                    instance.animation = le.animation;
                }
            }
        });
        if (layout.pivotX) {
            container.pivot.x = layout.pivotX;
        }
        if (layout.pivotY) {
            container.pivot.y = layout.pivotY;
        }
    }
    static buildLayoutElement(le, customClassResolver = null) {
        let instance = undefined;
        if (!le.render) {
            return instance;
        }
        if (le instanceof LayoutElementQuad_1.default) {
            if (!le.customClass) {
                instance = new pixi_js_1.Graphics();
                instance.lineStyle(0);
                instance.beginFill(le.color, le.alpha);
                instance.drawRect(0, 0, le.width, le.height);
                instance.endFill();
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.pivotX) {
                    instance.pivot.x = le.pivotX;
                }
                if (le.pivotY) {
                    instance.pivot.y = le.pivotY;
                }
            }
        }
        else if (le instanceof LayoutElementImage_1.default) {
            let texture = null;
            if (!le.customClass) {
                texture = AssetsManager_1.default.textures.get(le.texture);
                if (texture) {
                    if (le.scale9Grid) {
                        instance = new pixi_js_1.NineSlicePlane(texture, le.scale9Grid.x, le.scale9Grid.y, texture.width - (le.scale9Grid.x + le.scale9Grid.width), texture.height - (le.scale9Grid.y + le.scale9Grid.height));
                    }
                    else if (le.tileGrid) {
                        instance = new pixi_js_1.TilingSprite(texture, le.tileGrid.width, le.tileGrid.height);
                    }
                    else {
                        instance = new pixi_js_1.Sprite(texture);
                    }
                }
                else {
                    Logger_1.default.warning('No texture with name: ' + le.texture);
                }
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.width) {
                    instance.width = le.width;
                }
                if (le.height) {
                    instance.height = le.height;
                }
                if (le.scaleX) {
                    if (texture && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.width = le.scaleX * texture.width;
                    }
                    else {
                        instance.scale.x = le.scaleX;
                    }
                }
                if (le.scaleY) {
                    if (texture && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.height = le.scaleY * texture.height;
                    }
                    else {
                        instance.scale.y = le.scaleY;
                    }
                }
                if (le.pivotX) {
                    if (texture && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.pivot.x = instance.width * le.pivotX / texture.width;
                    }
                    else {
                        instance.pivot.x = le.pivotX;
                    }
                }
                if (le.pivotY) {
                    if (texture && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.pivot.y = instance.height * le.pivotY / texture.height;
                    }
                    else {
                        instance.pivot.y = le.pivotY;
                    }
                }
                instance.alpha = le.alpha;
            }
        }
        else if (le instanceof LayoutElementSpine_1.default) {
            let spineData = null;
            if (!le.customClass) {
                spineData = AssetsManager_1.default.spine.get(le.texture);
                if (spineData) {
                    instance = new pixi_spine_1.Spine(spineData);
                }
                else {
                    Logger_1.default.warning('No spine data with name: ' + le.texture);
                }
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.width) {
                    instance.width = le.width;
                }
                if (le.height) {
                    instance.height = le.height;
                }
                if (le.scaleX) {
                    if (spineData && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.width = le.scaleX * spineData.width;
                    }
                    else {
                        instance.scale.x = le.scaleX;
                    }
                }
                if (le.scaleY) {
                    if (spineData && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.height = le.scaleY * spineData.height;
                    }
                    else {
                        instance.scale.y = le.scaleY;
                    }
                }
                if (le.pivotX) {
                    if (spineData && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.pivot.x = instance.width * le.pivotX / spineData.width;
                    }
                    else {
                        instance.pivot.x = le.pivotX;
                    }
                }
                if (le.pivotY) {
                    if (spineData && instance instanceof pixi_js_1.NineSlicePlane) {
                        instance.pivot.y = instance.height * le.pivotY / spineData.height;
                    }
                    else {
                        instance.pivot.y = le.pivotY;
                    }
                }
                instance.alpha = le.alpha;
            }
        }
        else if (le instanceof LayoutElementAnimation_1.default) {
            if (le.customClass == 'Video') {
                // const video: HTMLVideoElement = AssetsManager.videos.get(le.texturePrefix);
                // if (video) {
                //     instance = new VideoSprite(video, le.fps, le.loop);
                // } else {
                //     Logger.warning('No video with name: ' + le.texturePrefix);
                // }
                Logger_1.default.warning('No video support at this time, please consider reinstating the VideoSprite class.');
            }
            else if (!le.customClass) {
                const textures = AssetsManager_1.default.getAnimationTextures(le.texturePrefix);
                if (textures) {
                    instance = new pixi_js_1.AnimatedSprite(textures);
                    instance.animationSpeed = le.fps / 60;
                    instance.loop = le.loop;
                }
                else {
                    Logger_1.default.warning('No textures with prefix: ' + le.texturePrefix);
                }
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.width) {
                    instance.width = le.width;
                }
                if (le.height) {
                    instance.height = le.height;
                }
                if (le.scaleX) {
                    instance.scale.x = le.scaleX;
                }
                if (le.scaleY) {
                    instance.scale.y = le.scaleY;
                }
                if (le.pivotX) {
                    instance.pivot.x = le.pivotX;
                }
                if (le.pivotY) {
                    instance.pivot.y = le.pivotY;
                }
            }
        }
        else if (le instanceof LayoutElementTextField_1.default) {
            const format = le.textFormat;
            if (AssetsManager_1.default.bitmapFonts.get(format.font)) {
                instance = new pixi_js_1.BitmapText(le.text, {
                    fontName: format.font,
                    fontSize: format.size,
                    tint: format.color
                });
            }
            else {
                let fontFamily = format.font;
                if (AssetsManager_1.default.webFonts.has(format.font)) {
                    fontFamily = AssetsManager_1.default.webFonts.get(format.font).family;
                }
                const textStyle = new pixi_js_1.TextStyle({
                    fontFamily: fontFamily,
                    fontSize: format.size,
                    fill: format.color,
                    fontWeight: format.bold == undefined ? 'normal' : 'bold'
                });
                instance = new pixi_js_1.Text(le.text, textStyle);
            }
            if (le.pivotX) {
                instance.anchor.x = le.pivotX / le.width;
            }
            if (le.pivotY) {
                instance.anchor.y = le.pivotY / le.height;
            }
        }
        else if (le instanceof LayoutElement_1.default) {
            if (!le.customClass) {
                instance = new pixi_js_1.Container();
                LayoutBuilder.create(le, instance, customClassResolver);
            }
            else if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (instance) {
                if (le.width) {
                    instance.width = le.width;
                }
                if (le.height) {
                    instance.height = le.height;
                }
                if (le.scaleX) {
                    instance.scale.x = le.scaleX;
                }
                if (le.scaleY) {
                    instance.scale.y = le.scaleY;
                }
                if (le.pivotX) {
                    instance.pivot.x = le.pivotX;
                }
                if (le.pivotY) {
                    instance.pivot.y = le.pivotY;
                }
            }
        }
        if (!instance && le.customClass) {
            Logger_1.default.warning('Unknown layout element custom class: ' + le.customClass);
        }
        return instance;
    }
    static matchPositionAndRotation(le, dObj) {
        dObj.x = le.x;
        dObj.y = le.y;
        dObj.rotation = le.rotation ? le.rotation : 0;
    }
    static centerFitInRectangle(sprite, rect, padding = 0) {
        const rectX = rect.x + padding;
        const rectY = rect.y + padding;
        const rectW = rect.width - 2 * padding;
        const rectH = rect.height - 2 * padding;
        if (sprite.width < rectW) {
            sprite.width = rectW;
            sprite.scale.y = sprite.scale.x;
        }
        if (sprite.height > rectH) {
            sprite.height = rectH;
            sprite.scale.x = sprite.scale.y;
        }
        sprite.x = rectX + (rectW - sprite.width) / 2;
        sprite.y = rectY + (rectH - sprite.height) / 2;
    }
}
exports["default"] = LayoutBuilder;


/***/ }),

/***/ 82669:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLevel = void 0;
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["ALL"] = 4] = "ALL";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["NONE"] = 0] = "NONE";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
class Logger {
    static debug(...messages) {
        if (Logger.logLevel >= LogLevel.ALL) {
            //  console.log('[DEBUG] ' + Logger.buildMessage(messages));
        }
    }
    static info(...messages) {
        if (Logger.logLevel >= LogLevel.INFO) {
            console.log('%c[INFO] ' + Logger.buildMessage(messages), 'color: #0000FF');
        }
    }
    static warning(...messages) {
        if (Logger.logLevel >= LogLevel.WARNING) {
            console.log('%c[WARNING] ' + Logger.buildMessage(messages), 'color: #FFCC00');
        }
    }
    static error(...messages) {
        if (Logger.logLevel >= LogLevel.ERROR) {
            console.log('%c[ERROR] ' + Logger.buildMessage(messages), 'color: #FF0000');
        }
    }
    static buildMessage(messages) {
        let message = '';
        for (const m of messages) {
            message += m + ' ';
        }
        return message.substring(0, message.length - 1);
    }
}
Logger.logLevel = LogLevel.ALL;
exports["default"] = Logger;


/***/ }),

/***/ 25309:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MobileBrowserLog {
    constructor() {
        this.isOpen = false;
        this.container = document.createElement('div');
        document.body.append(this.container);
        this.container.style.zIndex = '100';
        const ta = document.createElement('textarea');
        this.container.append(ta);
        ta.id = 'log';
        [this.container, ta].forEach(el => {
            el.style.position = 'absolute';
            el.style.width = '100%';
            el.style.height = '100%';
        });
        console.log = (...args) => {
            ta.value += `\n${args}`;
        };
        const btn = document.createElement('div');
        document.body.append(btn);
        btn.style.width = '50px';
        btn.style.height = '50px';
        btn.style.position = 'absolute';
        btn.style.bottom = '0';
        btn.style.right = '0';
        btn.style.backgroundColor = '#FF0000';
        btn.style.zIndex = '101';
        btn.onclick = () => {
            if (this.isOpen) {
                this.close();
            }
            else {
                this.open();
            }
        };
        this.close();
    }
    open() {
        this.container.style.visibility = 'visible';
        this.isOpen = true;
    }
    close() {
        this.container.style.visibility = 'hidden';
        this.isOpen = false;
    }
}
exports["default"] = MobileBrowserLog;


/***/ }),

/***/ 22186:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const pixi_stats_1 = __webpack_require__(59340);
class StatsPanel {
    static create(application) {
        const stats = (0, pixi_stats_1.addStats)(document, application);
        const ticker = pixi_js_1.Ticker.shared;
        stats.stats.domElement.setAttribute('style', 'position: fixed;\n' +
            'top: 0;\n' +
            'left: 0;\n' +
            'z-index: 500;\n' +
            'width: max(100px, 5vw, 5vh);\n' +
            'height: max(60px, 3vh, 3vw);\n' +
            'opacity: 0.8;\n' +
            'user-select: none;');
        Array.from(stats.stats.domElement.children)
            .forEach((el) => {
            el.style.width = '100%';
            el.style.height = '100%';
        });
        ticker.add(stats.update, stats, pixi_js_1.UPDATE_PRIORITY.UTILITY);
    }
}
exports["default"] = StatsPanel;


/***/ }),

/***/ 63948:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autoscaleText = exports.arrayShuffle = exports.randomArrayElement = exports.randomInt = exports.randomRange = exports.arrayUnique = exports.arrayFill = exports.removeArrayElement = exports.getConfigValue = exports.radToDeg = exports.degToRad = void 0;
const pixi_js_1 = __webpack_require__(95894);
const degToRad = function (degrees) {
    return degrees * Math.PI / 180;
};
exports.degToRad = degToRad;
const radToDeg = function radToDeg(radians) {
    return radians * 180 / Math.PI;
};
exports.radToDeg = radToDeg;
const getConfigValue = function (configObject, parameterName, defaultValue = undefined) {
    if (parameterName.indexOf('.') != -1) {
        const firstItem = parameterName.substring(0, parameterName.indexOf('.'));
        const restItem = parameterName.substring(parameterName.indexOf('.') + 1);
        const firstObj = this.getConfigValue(configObject, firstItem);
        if (firstObj) {
            return this.getConfigValue(firstObj, restItem, defaultValue);
        }
    }
    else if (configObject.hasOwnProperty(parameterName) && configObject[parameterName] != '') {
        return configObject[parameterName];
    }
    return defaultValue;
};
exports.getConfigValue = getConfigValue;
const removeArrayElement = function (array, element) {
    if (array.indexOf(element) != -1) {
        array.splice(array.indexOf(element), 1);
    }
    return array;
};
exports.removeArrayElement = removeArrayElement;
const arrayFill = function (array, value) {
    const O = array;
    const len = O.length;
    const start = arguments[1];
    const relativeStart = parseInt(start, 10) || 0;
    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
    const end = arguments[2];
    const relativeEnd = end === undefined ? len : (parseInt(end) || 0);
    const final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
    for (; k < final; k++) {
        O[k] = value;
    }
    return O;
};
exports.arrayFill = arrayFill;
const arrayUnique = function (array) {
    return array.filter((value, index, array) => {
        return array.indexOf(value) === index;
    });
};
exports.arrayUnique = arrayUnique;
const randomRange = function (min, max) {
    return Math.random() * (max - min) + min;
};
exports.randomRange = randomRange;
/**
 * Returns random integer within range <min, max>, both values inclusive
 * @param min
 * @param max
 */
const randomInt = function (min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
exports.randomInt = randomInt;
const randomArrayElement = function (arr) {
    if (arr && arr.length) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
    return null;
};
exports.randomArrayElement = randomArrayElement;
const arrayShuffle = function (array) {
    const inputArray = array;
    for (let i = inputArray.length - 1; i >= 0; i--) {
        const randomIndex = Math.floor(Math.random() * (i + 1));
        const itemAtIndex = inputArray[randomIndex];
        inputArray[randomIndex] = inputArray[i];
        inputArray[i] = itemAtIndex;
    }
    return inputArray;
};
exports.arrayShuffle = arrayShuffle;
function autoscaleText(tf, maxFontSize, maxWidth, maxHeight) {
    if (tf.text.length === 0)
        return;
    if (tf instanceof pixi_js_1.Text) {
        const ts = tf.style;
        let currentFontSize;
        if (typeof ts.fontSize === 'number') {
            currentFontSize = ts.fontSize;
        }
        else if (typeof ts.fontSize === 'string') {
            currentFontSize = parseFloat(ts.fontSize);
        }
        else {
            currentFontSize = maxFontSize; // fallback default
        }
        if (currentFontSize <= 0)
            return;
        const widthScale = maxWidth / tf.width;
        const heightScale = maxHeight / tf.height;
        const scale = Math.min(widthScale, heightScale);
        const adjustedFontSize = Math.max(1, Math.min(maxFontSize, Math.floor(currentFontSize * scale)));
        ts.fontSize = adjustedFontSize;
        tf.style = ts;
    }
    else if (tf instanceof pixi_js_1.BitmapText) {
        let currentFontSize = tf.fontSize;
        let widthScale = maxWidth / tf.width;
        let adjustedFontSize = Math.max(2, Math.min(maxFontSize, Math.floor(currentFontSize * widthScale) - 0.5));
        tf.fontSize = adjustedFontSize;
        //tf.maxWidth = maxWidth;
    }
}
exports.autoscaleText = autoscaleText;


/***/ }),

/***/ 66961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ScreenOrientation_1 = __webpack_require__(81827);
const pixi_js_1 = __webpack_require__(95894);
/**
 * Helper class to simplify adding internal orientation layout and children layout management
 *
 * If an item wants to support automated orientation layouts, it needs to declare it in tweenData:
 * {
 *   "layouts":[
 *     "horizontal",
 *     "vertical"
 *   ]
 * }
  */
class AdjustableLayoutContainer extends pixi_js_1.Container {
    constructor(layout) {
        super();
        this.layout = layout;
    }
    updateLayout(desc) {
        var _a;
        if (((_a = this.layout) === null || _a === void 0 ? void 0 : _a.layouts.size) && this.currentOrientation != desc.orientation) {
            if (!this.currentOrientation) {
                this.currentOrientation = desc.orientation == ScreenOrientation_1.ScreenOrientation.HORIZONTAL ? ScreenOrientation_1.ScreenOrientation.VERTICAL : ScreenOrientation_1.ScreenOrientation.HORIZONTAL;
            }
            const oldLayout = this.layout.layouts.get(this.currentOrientation);
            const newLayout = this.layout.layouts.get(desc.orientation);
            oldLayout.children.forEach((le, leName) => {
                if (!newLayout.children.has(leName)) {
                    if (this[leName]) {
                        const child = this[leName];
                        this.removeChild(child);
                    }
                }
            });
            newLayout.children.forEach((le, leName) => {
                if (this[leName]) {
                    const child = this[leName];
                    child.position.set(le.x, le.y);
                    child.scale.set(le.scaleX, le.scaleY);
                    child.pivot.set(le.pivotX, le.pivotY);
                    // console.warn(leName, le.x, le.y);
                    child.visible = true;
                    this.addChild(child);
                }
            });
            this.currentOrientation = desc.orientation;
        }
        this.children.forEach((child) => {
            if (child['updateLayout']) {
                child['updateLayout'](desc);
            }
        });
    }
}
exports["default"] = AdjustableLayoutContainer;


/***/ }),

/***/ 97427:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ResizeMethod_1 = __webpack_require__(44764);
const pixi_js_1 = __webpack_require__(95894);
const Logger_1 = __importDefault(__webpack_require__(82669));
class Application {
    constructor(config) {
        this.defaultConfig = {
            backgroundColor: 0x000000,
            baseWidth: 1920,
            baseHeight: 1080,
            autoUpdateSizeToOrientation: false,
            fps: 60,
            resizeMethod: ResizeMethod_1.ResizeMethod.NONE,
            debug: true
        };
        this.screens = [];
        // merge config with default values
        config = Object.assign(Object.assign({}, this.defaultConfig), config);
        this.id = config.id;
        this.container = config.container;
        this.baseWidth = config.baseWidth;
        this.baseHeight = config.baseHeight;
        this.autoUpdateSizeToOrientation = config.autoUpdateSizeToOrientation;
        this.defaultResizeMethod = config.resizeMethod;
        this.container.style.backgroundColor = pixi_js_1.Color.shared.setValue(config.backgroundColor).toHex();
        this.container.style.overflow = 'hidden';
        this.container.style.position = 'absolute';
        this.container.style.top = '50%';
        this.container.style.left = '50%';
        this.container.style.transform = 'translate(-50%, -50%)';
        this.container.style.display = 'flex';
        this.container.style.flexDirection = 'column';
        this.container.style.justifyContent = 'center';
        this.container.style.alignItems = 'center';
        // Attach resize listener
        window.addEventListener('resize', () => {
            this.onWindowResize();
        });
        window.addEventListener('orientationchange', () => {
            this.onWindowResize();
        });
        this.onWindowResize();
    }
    addScreen(screen) {
        if (this.getScreen(screen.id)) {
            Logger_1.default.warning(`Screen with id: ${screen.id} already exists!`);
            return;
        }
        this.screens.push(screen);
        this.container.prepend(screen.view);
        this.onWindowResize();
    }
    getScreen(id) {
        return this.screens.find((existingScreen) => {
            return existingScreen.id === id;
        });
    }
    get numScreens() {
        return this.screens.length;
    }
    resize(availableWidth, availableHeight, resizeMethod) {
        resizeMethod = resizeMethod || this.defaultResizeMethod || ResizeMethod_1.ResizeMethod.NONE;
        let applicationWidth;
        let applicationHeight;
        let singleScreenWidth;
        let singleScreenHeight;
        let baseWidth = this.baseWidth;
        let baseHeight = this.baseHeight;
        if (this.autoUpdateSizeToOrientation) {
            if (availableHeight > availableWidth) {
                baseWidth = Math.min(this.baseWidth, this.baseHeight);
                baseHeight = Math.max(this.baseWidth, this.baseHeight);
            }
            else {
                baseWidth = Math.max(this.baseWidth, this.baseHeight);
                baseHeight = Math.min(this.baseWidth, this.baseHeight);
            }
        }
        this.baseWidth = baseWidth;
        this.baseHeight = baseHeight;
        switch (resizeMethod) {
            case ResizeMethod_1.ResizeMethod.DEFAULT:
            case ResizeMethod_1.ResizeMethod.SHOW_ALL:
            case ResizeMethod_1.ResizeMethod.EXACT_FIT:
                applicationWidth = availableWidth;
                applicationHeight = availableHeight;
                singleScreenWidth = availableWidth;
                singleScreenHeight = Math.round(availableHeight / this.numScreens);
                break;
            case ResizeMethod_1.ResizeMethod.CONTAIN:
                let scale = availableWidth / baseWidth;
                if (scale * baseHeight > availableHeight) {
                    scale = availableHeight / baseHeight;
                }
                applicationWidth = Math.round(scale * baseWidth);
                applicationHeight = Math.round(scale * baseHeight);
                singleScreenWidth = applicationWidth;
                singleScreenHeight = Math.round(applicationHeight / this.numScreens);
                break;
            case ResizeMethod_1.ResizeMethod.NONE:
            default:
                applicationWidth = singleScreenWidth = baseWidth;
                applicationHeight = singleScreenHeight = baseHeight;
                break;
        }
        this.container.style.width = `${applicationWidth}px`;
        this.container.style.height = `${applicationHeight}px`;
        this.screens.forEach((screen) => {
            screen.resize(singleScreenWidth, singleScreenHeight, resizeMethod, this.autoUpdateSizeToOrientation);
        });
    }
    onWindowResize() {
        this.resize(window.innerWidth, window.innerHeight, this.defaultResizeMethod);
    }
}
exports["default"] = Application;


/***/ }),

/***/ 32139:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserApplication = void 0;
const Application_1 = __importDefault(__webpack_require__(97427));
const ScreenPixi_1 = __importDefault(__webpack_require__(60497));
class BrowserApplication extends Application_1.default {
    constructor(container, config) {
        super(config);
        const mainScreenConfig = {
            id: 'main',
            backgroundColor: 0x000000,
            baseWidth: config.baseWidth,
            baseHeight: config.baseHeight,
            fps: config.fps,
            debug: config.debug
        };
        // initialize one and only application screen (browser application)
        this.mainScreen = new ScreenPixi_1.default(mainScreenConfig);
        BrowserApplication.mainScreenStage = this.mainScreen;
        this.addScreen(this.mainScreen);
        // this.mainScreen.on('resize', this.onScreenResize, this);
        // this.onScreenResize();
    }
    get width() {
        return this.mainScreen.width;
    }
    get height() {
        return this.mainScreen.height;
    }
    get stage() {
        if (this.mainScreen) {
            return this.mainScreen.stage;
        }
        else {
            return null;
        }
    }
    get pixi() {
        return this.mainScreen.pixi;
    }
    get orientation() {
        return this.mainScreen.orientation;
    }
}
exports.BrowserApplication = BrowserApplication;


/***/ }),

/***/ 44764:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResizeMethod = void 0;
/**
 * Various Screen and Application resize methods
 * @readonly
 * @enum {string}
 */
var ResizeMethod;
(function (ResizeMethod) {
    /**
     * Application keeps its base size and will not resize automatically.
     * Screens will be displayed on top of each other in their base size and will not scale automatically.
     * Any overflowing screens will not be displayed.
     *
     * Useful for: Application where the size is preset and cannot change.
     */
    ResizeMethod[ResizeMethod["NONE"] = 0] = "NONE";
    /**
     * Application resolution will match the available area. Ignores the Application base size.
     * Application will stretch and scale-down similar to CSS object-fit:fill
     * Screens resolution also will match the available area and all screens will be displayed on top of each other. Ignores the Screens base size.
     * Pixi renderer is set to new screen resolution but the stage is not scaled.
     *
     * Useful for: Application where the window can change its size, and Pixi scene should expand its boundaries i.e. visual editor, painting app.
     */
    ResizeMethod[ResizeMethod["DEFAULT"] = 1] = "DEFAULT";
    /**
     * Application will scale to fit in the available area while keeping the aspect ratio.
     * Application will be letterboxed similar to CSS object-fit:contain.
     * Screens will keep the aspect ratio and will all be fitted in the Application available area on top of each other.
     * Pixi renderer is set to new screen resolution and the stage is scaled according to base size to new size ratio.
     *
     * Useful for: Games that do not offer responsive UI, do not have safe area graphics and only aspect ratio has to be kept.
     */
    ResizeMethod[ResizeMethod["CONTAIN"] = 2] = "CONTAIN";
    /**
     * Application resolution will match the available area. Ignores the Application base size.
     * Application will stretch and scale-down similar to CSS object-fit:fill
     * Screens resolution also will match the available area and all screens will be displayed on top of each other. Ignores the Screens base size.
     * Pixi renderer is set to new screen resolution and the stage is scaled accordingly.
     *
     * Useful for: Games that offer responsive UI or have safe area graphics.
     */
    ResizeMethod[ResizeMethod["SHOW_ALL"] = 3] = "SHOW_ALL";
    /**
     * Application resolution will match the available area. Ignores the Application base size.
     * Application will stretch and scale-down similar to CSS object-fit:fill
     * Screens resolution also will match the available area and all screens will be displayed on top of each other. Ignores the Screens base size.
     * Pixi renderer will be stretched to new screen resolution and the stage is scaled accordingly.
     *
     * Useful for: Games that are not responsive and need to fill the entire screen ie. games for cabinets.
     */
    ResizeMethod[ResizeMethod["EXACT_FIT"] = 4] = "EXACT_FIT";
})(ResizeMethod || (exports.ResizeMethod = ResizeMethod = {}));


/***/ }),

/***/ 84641:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ResizeMethod_1 = __webpack_require__(44764);
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const ScreenOrientation_1 = __webpack_require__(81827);
class Screen extends eventemitter3_1.default {
    constructor(config) {
        super();
        this.defaultConfig = {
            backgroundColor: 0x000000,
            baseWidth: 1920,
            baseHeight: 1080,
            fps: 0, // no limit
            debug: true
        };
        // merge config with default values
        config = Object.assign(Object.assign({}, this.defaultConfig), config);
        this.id = config.id;
        this.baseWidth = this._width = config.baseWidth;
        this.baseHeight = this._height = config.baseHeight;
        this.baseOrientation = this._orientation = this.calculateOrientation(this.baseWidth, this.baseHeight);
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get orientation() {
        return this._orientation;
    }
    resize(availableWidth, availableHeight, resizeMethod, autoUpdateSizeToOrientation) {
        // Logger.debug(`Screen ${this.id} resize: ${availableWidth}, ${availableHeight}`);
        resizeMethod = resizeMethod || ResizeMethod_1.ResizeMethod.NONE;
        const oldWidth = this._width;
        const oldHeight = this._height;
        const oldOrientation = this.orientation;
        this._orientation = this.calculateOrientation(availableWidth, availableHeight);
        // each screen type should implement its own resizing logic
        this.doResize(availableWidth, availableHeight, resizeMethod, autoUpdateSizeToOrientation);
        if (oldWidth != this._width || oldHeight != this.height) {
            if (oldOrientation != this.orientation) {
                this.emit('change-orientation', this.orientation);
            }
            this.emit('resize', this.width, this.height);
        }
    }
    calculateOrientation(width, height) {
        return height > width ? ScreenOrientation_1.ScreenOrientation.VERTICAL : ScreenOrientation_1.ScreenOrientation.HORIZONTAL;
    }
}
exports["default"] = Screen;


/***/ }),

/***/ 81827:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScreenOrientation = void 0;
/**
 * Orientation of the screen
 * @readonly
 * @enum {string}
 */
var ScreenOrientation;
(function (ScreenOrientation) {
    /**
     * Horizontal orientation where screen width is bigger than screen height
     */
    ScreenOrientation["HORIZONTAL"] = "horizontal";
    /**
     * Vertical orientation where screen height is bigger than screen width
     */
    ScreenOrientation["VERTICAL"] = "vertical";
})(ScreenOrientation || (exports.ScreenOrientation = ScreenOrientation = {}));


/***/ }),

/***/ 60497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const ResizeMethod_1 = __webpack_require__(44764);
const StatsPanel_1 = __importDefault(__webpack_require__(22186));
const Screen_1 = __importDefault(__webpack_require__(84641));
const Logger_1 = __importDefault(__webpack_require__(82669));
class ScreenPixi extends Screen_1.default {
    constructor(config) {
        super(config);
        // Create PIXI application
        this.pixi = new pixi_js_1.Application({
            backgroundColor: config.backgroundColor,
            width: this.baseWidth,
            height: this.baseHeight,
            autoDensity: true,
            resolution: window.devicePixelRatio || 1,
            hello: true
        });
        Logger_1.default.info(`window.devicePixelRatio: ${window.devicePixelRatio}`);
        pixi_js_1.Ticker.shared.maxFPS = config.fps;
        this.view.id = this.id;
        // Display stats if needed
        if (config.debug) {
            StatsPanel_1.default.create(this.pixi);
        }
    }
    get view() {
        return this.pixi.view;
    }
    get stage() {
        return this.pixi.stage;
    }
    doResize(availableWidth, availableHeight, resizeMethod, autoUpdateSizeToOrientation) {
        const renderer = this.pixi.renderer;
        let baseWidth = this.baseWidth;
        let baseHeight = this.baseHeight;
        let screenWidth;
        let screenHeight;
        let rendererWidth;
        let rendererHeight;
        let stageScaleX = 1;
        let stageScaleY = 1;
        if (autoUpdateSizeToOrientation) {
            if (this._orientation == this.baseOrientation) {
                baseWidth = this.baseWidth;
                baseHeight = this.baseHeight;
            }
            else {
                baseWidth = this.baseHeight;
                baseHeight = this.baseWidth;
            }
        }
        let scale = availableWidth / baseWidth;
        if (scale * baseHeight > availableHeight) {
            scale = availableHeight / baseHeight;
        }
        // Logger.debug(`Base size: ${baseWidth}x${baseHeight}`);
        switch (resizeMethod) {
            case ResizeMethod_1.ResizeMethod.DEFAULT:
                this._width = screenWidth = availableWidth;
                this._height = screenHeight = availableHeight;
                rendererWidth = availableWidth;
                rendererHeight = availableHeight;
                break;
            case ResizeMethod_1.ResizeMethod.CONTAIN:
                this._width = baseWidth;
                this._height = baseHeight;
                screenWidth = rendererWidth = Math.ceil(scale * baseWidth);
                screenHeight = rendererHeight = Math.ceil(scale * baseHeight);
                stageScaleX = stageScaleY = scale;
                break;
            case ResizeMethod_1.ResizeMethod.SHOW_ALL:
                screenWidth = rendererWidth = availableWidth;
                screenHeight = rendererHeight = availableHeight;
                stageScaleX = stageScaleY = scale;
                this._width = rendererWidth / scale;
                this._height = rendererHeight / scale;
                break;
            case ResizeMethod_1.ResizeMethod.EXACT_FIT:
                this._width = baseWidth;
                this._height = baseHeight;
                screenWidth = rendererWidth = availableWidth;
                screenHeight = rendererHeight = availableHeight;
                stageScaleX = availableWidth / baseWidth;
                stageScaleY = availableHeight / baseHeight;
                break;
            case ResizeMethod_1.ResizeMethod.NONE:
            default:
                this._width = screenWidth = rendererWidth = baseWidth;
                this._height = screenHeight = rendererHeight = baseHeight;
                break;
        }
        this.view.style.width = `${screenWidth}px`;
        this.view.style.height = `${screenHeight}px`;
        renderer.resize(rendererWidth, rendererHeight);
        this.stage.scale.set(stageScaleX, stageScaleY);
    }
}
exports["default"] = ScreenPixi;


/***/ }),

/***/ 23239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const Utils_1 = __webpack_require__(63948);
/**
 * Example:
 * {
 *      "effects":[
 *          {
 *              "type":"dropShadow"
 *              "options":{
 *                  "alpha":1,
 *                  "angle":0,
 *                  "blur":6,
 *                  "color":"0x42B0FF",
 *                  distance":0
 *              },
 *          }
 *      ]
 * }
 */
class DropShadowEffect {
    constructor(options) {
        this.options = {
            color: options.color,
            alpha: options.alpha,
            angle: options.angle ? (0, Utils_1.degToRad)(options.angle) : 0,
            blur: options.blur | 0,
            distance: options.distance | 0
        };
    }
    apply(displayObject) {
        if (displayObject instanceof pixi_js_1.Text) {
            const tf = displayObject;
            const ts = tf.style;
            ts.dropShadow = true;
            ts.dropShadowAlpha = this.options.alpha;
            ts.dropShadowAngle = this.options.angle;
            ts.dropShadowBlur = this.options.blur;
            ts.dropShadowColor = this.options.color;
            ts.dropShadowDistance = this.options.distance;
            ts.padding = Math.max(ts.padding, this.options.distance + this.options.blur);
            tf.style = ts;
        }
        else {
            throw new Error('Unsupported DisplayObject for effect DropShadowEffect');
        }
    }
}
exports["default"] = DropShadowEffect;


/***/ }),

/***/ 18302:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __importDefault(__webpack_require__(82669));
const DropShadowEffect_1 = __importDefault(__webpack_require__(23239));
const StrokeEffect_1 = __importDefault(__webpack_require__(58158));
const GradientEffect_1 = __importDefault(__webpack_require__(90374));
class EffectFactory {
    static create(effectData) {
        try {
            switch (effectData.type) {
                case 'dropShadow':
                    return new DropShadowEffect_1.default(effectData.options);
                case 'stroke':
                    return new StrokeEffect_1.default(effectData.options);
                case 'gradient':
                    return new GradientEffect_1.default(effectData.options);
                default:
                    throw new Error(`Unknown effect type: ${effectData.type}`);
            }
        }
        catch (e) {
            Logger_1.default.warning(e.toString());
            return null;
        }
    }
}
exports["default"] = EffectFactory;


/***/ }),

/***/ 90374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
/**
 * Example:
 * {
 *      "effects":[
 *          {
 *              "type":"gradient"
 *              "options":{
 *                  "fill": [
 *                      "0xFFFFFF",
 *                      "0x010101",
 *                  ]
 *              },
 *          }
 *      ]
 * }
 */
class GradientEffect {
    constructor(options) {
        this.options = {
            fill: options.fill
        };
    }
    apply(displayObject) {
        if (displayObject instanceof pixi_js_1.Text) {
            const tf = displayObject;
            const ts = tf.style;
            ts.fill = this.options.fill;
            tf.style = ts;
        }
        else {
            throw new Error('Unsupported DisplayObject for effect StrokeEffect');
        }
    }
}
exports["default"] = GradientEffect;


/***/ }),

/***/ 58158:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
/**
 * Example:
 * {
 *      "effects":[
 *          {
 *              "type":"stroke"
 *              "options":{
 *                  "color":"0xFFFFFF",
 *                  "lineJoin":"round",
 *                  "thickness":1
 *              },
 *          }
 *      ]
 * }
 */
class StrokeEffect {
    constructor(options) {
        this.options = {
            color: options.color,
            thickness: options.thickness,
            lineJoin: options.lineJoin || 'round'
        };
    }
    apply(displayObject) {
        if (displayObject instanceof pixi_js_1.Text) {
            const tf = displayObject;
            const ts = tf.style;
            ts.stroke = this.options.color;
            ts.strokeThickness = this.options.thickness;
            ts.padding = Math.max(ts.padding, this.options.thickness);
            ts.lineJoin = this.options.lineJoin;
            tf.style = ts;
        }
        else {
            throw new Error('Unsupported DisplayObject for effect StrokeEffect');
        }
    }
}
exports["default"] = StrokeEffect;


/***/ }),

/***/ 23999:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const engineTween_1 = __webpack_require__(50381);
const pixi_js_1 = __webpack_require__(95894);
class SwapViewsEffectFadeToBlack {
    constructor(maskRect, fadeOutTime = 0.5, fadeInTime = 0.5) {
        this.fade = new pixi_js_1.Graphics();
        this.fade.clear();
        this.fade.lineStyle(0);
        this.fade.beginFill(0x000000);
        this.fade.drawRect(maskRect.x, maskRect.y, maskRect.width, maskRect.height);
        this.fade.endFill();
        this.fadeOutTime = fadeOutTime;
        this.fadeInTime = fadeInTime;
    }
    // PUBLIC API
    apply(viewOut, viewIn, container, onComplete) {
        const outViewIndex = container.getChildIndex(viewOut);
        container.addChildAt(this.fade, outViewIndex + 1);
        this.fade.alpha = 0;
        engineTween_1.Tweener.addTween(this.fade, { alpha: 1, time: this.fadeOutTime, transition: 'easeOutQuad', onComplete: () => {
                container.removeChild(viewOut);
                container.addChildAt(viewIn, outViewIndex);
            } });
        engineTween_1.Tweener.addTween(this.fade, { alpha: 0, time: this.fadeInTime, transition: 'easeInQuad', delay: this.fadeOutTime, onComplete: () => {
                container.removeChild(this.fade);
                if (onComplete) {
                    onComplete();
                }
            } });
    }
}
exports["default"] = SwapViewsEffectFadeToBlack;


/***/ }),

/***/ 44359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayoutElementType = void 0;
var LayoutElementType;
(function (LayoutElementType) {
    LayoutElementType["SPRITE"] = "starling.display.Sprite";
    LayoutElementType["IMAGE"] = "starling.display.Image";
    LayoutElementType["TEXT_FIELD"] = "starling.text.TextField";
    LayoutElementType["QUAD"] = "starling.display.Quad";
    LayoutElementType["MOVIE_CLIP"] = "starling.display.MovieClip";
    LayoutElementType["SPINE"] = "starling.display.Spine";
})(LayoutElementType || (exports.LayoutElementType = LayoutElementType = {}));


/***/ }),

/***/ 81453:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class LayoutElement {
    constructor(name) {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.scaleX = 0;
        this.scaleY = 0;
        this.pivotX = 0;
        this.pivotY = 0;
        this.rotation = 0;
        this.hitArea = null;
        this.alpha = 1;
        this.children = new Map();
        this.customClass = '';
        this.mask = null;
        this.render = true;
        this.effects = [];
        this.layouts = new Map();
        this.name = name;
    }
}
exports["default"] = LayoutElement;


/***/ }),

/***/ 10963:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutElement_1 = __importDefault(__webpack_require__(81453));
class LayoutElementAnimation extends LayoutElement_1.default {
    constructor(name, texturePrefix, fps, loop) {
        super(name);
        this.texturePrefix = texturePrefix;
        this.fps = fps;
        this.loop = loop;
    }
}
exports["default"] = LayoutElementAnimation;


/***/ }),

/***/ 60515:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutElement_1 = __importDefault(__webpack_require__(81453));
const LayoutElementImage_1 = __importDefault(__webpack_require__(52848));
const LayoutElementTextField_1 = __importDefault(__webpack_require__(33180));
const Logger_1 = __importDefault(__webpack_require__(82669));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const LayoutElementQuad_1 = __importDefault(__webpack_require__(506));
const LayoutElementAnimation_1 = __importDefault(__webpack_require__(10963));
const pixi_js_1 = __webpack_require__(95894);
const EffectFactory_1 = __importDefault(__webpack_require__(18302));
const LayoutDescription_1 = __webpack_require__(44359);
const AnimationFactory_1 = __importDefault(__webpack_require__(21854));
const Translation_1 = __importDefault(__webpack_require__(62231));
const LayoutElementSpine_1 = __importDefault(__webpack_require__(54034));
class LayoutElementFactory {
    static create(descriptionObject) {
        var _a, _b;
        let le;
        switch (descriptionObject.cls) {
            case LayoutDescription_1.LayoutElementType.IMAGE:
                le = new LayoutElementImage_1.default(descriptionObject.params.name, descriptionObject.constructorParams[0].textureName);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                if (descriptionObject.params.hasOwnProperty('scale9Grid')) {
                    const scale9GridParams = descriptionObject.params.scale9Grid.params;
                    if (!scale9GridParams.hasOwnProperty('x')) {
                        scale9GridParams.x = 0;
                    }
                    if (!scale9GridParams.hasOwnProperty('y')) {
                        scale9GridParams.y = 0;
                    }
                    le.scale9Grid = new pixi_js_1.Rectangle(parseInt(scale9GridParams.x), parseInt(scale9GridParams.y), parseInt(scale9GridParams.width), parseInt(scale9GridParams.height));
                }
                if (descriptionObject.params.hasOwnProperty('tileGrid')) {
                    const tileGridParams = descriptionObject.params.tileGrid.params;
                    if (!tileGridParams.hasOwnProperty('x')) {
                        tileGridParams.x = 0;
                    }
                    if (!tileGridParams.hasOwnProperty('y')) {
                        tileGridParams.y = 0;
                    }
                    le.tileGrid = new pixi_js_1.Rectangle(parseInt(tileGridParams.x), parseInt(tileGridParams.y), parseInt(tileGridParams.width), parseInt(tileGridParams.height));
                }
                break;
            case LayoutDescription_1.LayoutElementType.SPINE:
                le = new LayoutElementSpine_1.default(descriptionObject.params.name, descriptionObject.constructorParams[0].textureName);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                break;
            case LayoutDescription_1.LayoutElementType.TEXT_FIELD:
                let text = descriptionObject.params.text;
                if (descriptionObject.hasOwnProperty('tweenData') && descriptionObject.tweenData.hasOwnProperty('translation-key')) {
                    text = Translation_1.default.t(descriptionObject.tweenData['translation-key']);
                }
                le = new LayoutElementTextField_1.default(descriptionObject.params.name, text, descriptionObject.params.format.params);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                le.textFormat.color = le.textFormat.color || 0;
                break;
            case LayoutDescription_1.LayoutElementType.SPRITE:
                le = new LayoutElement_1.default(descriptionObject.params.name);
                le.children = LayoutElementFactory.parseLayoutElementChildren(descriptionObject.children);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                        // tag 'instance' means that the layout should not be redeclared/resaved but initialized as an instance instead
                        if (!descriptionObject.customParams.hasOwnProperty('tag') || (descriptionObject.customParams.hasOwnProperty('tag') && descriptionObject.customParams.tag != 'instance')) {
                            const existingLayout = AssetsManager_1.default.layouts.get(le.customClass);
                            if (existingLayout) {
                                AssetsManager_1.default.layouts.delete(le.customClass);
                                AssetsManager_1.default.layouts.set(le.customClass + '-' + existingLayout.name, existingLayout);
                                AssetsManager_1.default.layouts.set(le.customClass + '-' + le.name, le);
                            }
                            else {
                                AssetsManager_1.default.layouts.set(le.customClass, le);
                            }
                        }
                    }
                }
                break;
            case LayoutDescription_1.LayoutElementType.QUAD:
                let fillColor = 0xFFFFFF;
                if (descriptionObject.params.hasOwnProperty('color')) {
                    fillColor = descriptionObject.params.color;
                }
                le = new LayoutElementQuad_1.default(descriptionObject.params.name, fillColor);
                if (descriptionObject.hasOwnProperty('constructorParams')) {
                    for (const param of descriptionObject.constructorParams) {
                        switch (param.name) {
                            case 'width':
                                const scaleX = descriptionObject.params.scaleX ? descriptionObject.params.scaleX : 1;
                                const pivotX = descriptionObject.params.pivotX ? descriptionObject.params.pivotX : 0;
                                descriptionObject.params.width = Math.round(param.value) * scaleX;
                                descriptionObject.params.pivotX = pivotX * scaleX;
                                descriptionObject.params.scaleX = 1;
                                break;
                            case 'height':
                                const scaleY = descriptionObject.params.scaleY ? descriptionObject.params.scaleY : 1;
                                const pivotY = descriptionObject.params.pivotY ? descriptionObject.params.pivotY : 0;
                                descriptionObject.params.height = Math.round(param.value) * scaleY;
                                descriptionObject.params.pivotY = pivotY * scaleY;
                                descriptionObject.params.scaleY = 1;
                                break;
                        }
                    }
                }
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                break;
            case LayoutDescription_1.LayoutElementType.MOVIE_CLIP:
                const fps = descriptionObject.params.fps ? descriptionObject.params.fps : 30;
                let loop = true;
                if (descriptionObject.params.hasOwnProperty('loop')) {
                    loop = descriptionObject.params.loop;
                }
                le = new LayoutElementAnimation_1.default(descriptionObject.params.name, LayoutElementFactory.getConstructorParamValue(descriptionObject, 'textures'), fps, loop);
                if (descriptionObject.hasOwnProperty('customParams')) {
                    if (descriptionObject.customParams.hasOwnProperty('customComponentClass')) {
                        le.customClass = descriptionObject.customParams.customComponentClass;
                    }
                }
                break;
            default:
                throw new Error('Unknown LayoutElement type: ' + descriptionObject.cls);
        }
        le.x = descriptionObject.params.x ? descriptionObject.params.x : 0;
        le.y = descriptionObject.params.y ? descriptionObject.params.y : 0;
        le.width = descriptionObject.params.width ? descriptionObject.params.width : 0;
        le.height = descriptionObject.params.height ? descriptionObject.params.height : 0;
        le.scaleX = descriptionObject.params.scaleX ? descriptionObject.params.scaleX : 1;
        le.scaleY = descriptionObject.params.scaleY ? descriptionObject.params.scaleY : 1;
        le.pivotX = descriptionObject.params.pivotX ? descriptionObject.params.pivotX : 0;
        le.pivotY = descriptionObject.params.pivotY ? descriptionObject.params.pivotY : 0;
        le.rotation = descriptionObject.params.rotation ? descriptionObject.params.rotation : 0;
        le.alpha = (_a = descriptionObject.params.alpha) !== null && _a !== void 0 ? _a : 1;
        if (descriptionObject.hasOwnProperty('customParams')) {
            if (descriptionObject.customParams.hasOwnProperty('forEditor')) {
                if (descriptionObject.customParams.forEditor == true) {
                    le.render = false;
                }
            }
        }
        if (descriptionObject.hasOwnProperty('tweenData')) {
            if ('hitArea' in descriptionObject.tweenData && descriptionObject.tweenData.hitArea instanceof Array) {
                le.hitArea = descriptionObject.tweenData.hitArea;
            }
            if (descriptionObject.tweenData.hasOwnProperty('effects') && descriptionObject.tweenData.effects instanceof Array) {
                descriptionObject.tweenData.effects.map((effectData) => {
                    const effect = EffectFactory_1.default.create(effectData);
                    if (effect) {
                        le.effects.push(effect);
                    }
                });
            }
            if (descriptionObject.tweenData.hasOwnProperty('animation')) {
                const animation = AnimationFactory_1.default.create(descriptionObject.tweenData.animation);
                if (animation) {
                    le.animation = animation;
                }
            }
        }
        if (descriptionObject.params.hasOwnProperty('mask')) {
            le.mask = LayoutElementFactory.create(descriptionObject.params.mask);
            // in Starling mask position is relative to masked object
            le.mask.x += le.x;
            le.mask.y += le.y;
        }
        const layouts = (_b = descriptionObject === null || descriptionObject === void 0 ? void 0 : descriptionObject.tweenData) === null || _b === void 0 ? void 0 : _b.layouts;
        if (layouts) {
            for (const orientation of layouts) {
                if (!le.children.has(orientation)) {
                    Logger_1.default.warning(`Cannot find layout element for defined screen orientation "${orientation}" on element "${le.name}"!`);
                }
                else {
                    le.layouts.set(orientation, le.children.get(orientation));
                }
            }
        }
        return le;
    }
    static parseLayoutDescription(descriptionFile) {
        return LayoutElementFactory.create(descriptionFile.layout);
    }
    static getConstructorParamValue(descriptionObject, parameterName) {
        if (descriptionObject.hasOwnProperty('constructorParams')) {
            for (const param of descriptionObject.constructorParams) {
                if (param.name == parameterName) {
                    return param.value;
                }
            }
        }
    }
    static parseLayoutElementChildren(childrenDescription) {
        const children = new Map();
        for (const layoutElementDescription of childrenDescription) {
            try {
                const le = LayoutElementFactory.create(layoutElementDescription);
                if (le) {
                    if (children.has(le.name)) {
                        Logger_1.default.warning('LayoutElement ' + le.name + ' already exists! Please use unique identifiers within a single parent!');
                    }
                    else {
                        children.set(le.name, le);
                    }
                }
            }
            catch (e) {
                Logger_1.default.error('LayoutElementFactory: ' + e.toString());
            }
        }
        return children;
    }
}
exports["default"] = LayoutElementFactory;


/***/ }),

/***/ 52848:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutElement_1 = __importDefault(__webpack_require__(81453));
class LayoutElementImage extends LayoutElement_1.default {
    constructor(name, texture) {
        super(name);
        this.scale9Grid = null;
        this.tileGrid = null;
        this.texture = texture;
    }
}
exports["default"] = LayoutElementImage;


/***/ }),

/***/ 506:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutElement_1 = __importDefault(__webpack_require__(81453));
class LayoutElementQuad extends LayoutElement_1.default {
    constructor(name, color) {
        super(name);
        this.color = color;
    }
}
exports["default"] = LayoutElementQuad;


/***/ }),

/***/ 54034:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutElement_1 = __importDefault(__webpack_require__(81453));
class LayoutElementSpine extends LayoutElement_1.default {
    constructor(name, texture) {
        super(name);
        this.texture = texture;
    }
}
exports["default"] = LayoutElementSpine;


/***/ }),

/***/ 33180:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutElement_1 = __importDefault(__webpack_require__(81453));
class LayoutElementTextField extends LayoutElement_1.default {
    constructor(name, text, textFormat) {
        super(name);
        this.text = text;
        if (textFormat) {
            this.textFormat = textFormat;
        }
    }
}
exports["default"] = LayoutElementTextField;


/***/ }),

/***/ 68223:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const pixi_js_1 = __webpack_require__(95894);
const engineTween_1 = __webpack_require__(50381);
class ValueText extends pixi_js_1.Container {
    constructor(le, renderValueFunction = null) {
        super();
        this._value = 0;
        this.countUpSound = null;
        this.renderValueFunction = renderValueFunction;
        LayoutBuilder_1.default.create(le, this);
    }
    // PUBLIC API
    get value() {
        return this._value;
    }
    set value(v) {
        this._value = v;
        if (this.renderValueFunction) {
            this.renderValueFunction(this.tfValue, this._value);
        }
        else {
            this.defaultRender();
        }
    }
    get fontSize() {
        return Number(this.tfValue.style.fontSize);
    }
    reset() {
        engineTween_1.Tweener.removeTweens(this);
        this.value = 0;
    }
    setValue(value, animParams = null) {
        engineTween_1.Tweener.removeTweens(this);
        if (animParams) {
            if (!this.countUpSound && animParams.countUpLoopSoundId) {
                this.countUpSound = SoundManager_1.default.loop(animParams.countUpLoopSoundId);
            }
            engineTween_1.Tweener.addTween(this, {
                value: value,
                time: animParams.countUpDuration,
                transition: 'easeOutSine',
                onComplete: () => {
                    if (this.countUpSound) {
                        this.countUpSound.stop();
                        this.countUpSound = null;
                    }
                    if (animParams.countUpEndSoundId) {
                        SoundManager_1.default.play(animParams.countUpEndSoundId);
                    }
                    if (animParams.onComplete) {
                        animParams.onComplete();
                    }
                },
            });
        }
        else {
            engineTween_1.Tweener.removeTweens(this);
            if (this.countUpSound) {
                this.countUpSound.stop();
                this.countUpSound = null;
            }
            this.value = value;
        }
    }
    // PRIVATE API
    defaultRender() {
        this.tfValue.text = this.value.toString();
    }
}
exports["default"] = ValueText;


/***/ }),

/***/ 21854:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __importDefault(__webpack_require__(82669));
const Bounce_1 = __importDefault(__webpack_require__(72924));
class AnimationFactory {
    static create(animationData) {
        try {
            switch (animationData.type) {
                case 'bounce':
                    return new Bounce_1.default();
                default:
                    throw new Error(`Unknown animation type: ${animationData.type}`);
            }
        }
        catch (e) {
            Logger_1.default.warning(e.toString());
            return null;
        }
    }
}
exports["default"] = AnimationFactory;


/***/ }),

/***/ 78386:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ButtonState = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const Utils_1 = __webpack_require__(63948);
class Button extends pixi_js_1.Container {
    constructor(le, customClassResolver = null, hitArea = null) {
        super();
        this.currentState = ButtonState.DISABLED;
        this.pointerOver = false;
        this.pointerDown = false;
        this._enabled = true;
        this.startScale = 1;
        LayoutBuilder_1.default.create(le, this, (le) => {
            let instance = null;
            if (customClassResolver) {
                instance = customClassResolver(le);
            }
            if (!instance) {
                instance = this.customClassElementCreate(le);
            }
            return instance;
        });
        this.enabled = true;
        if (hitArea) {
            this.hitArea = hitArea;
        }
        else if (this.hitObject) {
            this.hitArea = new pixi_js_1.Rectangle(this.hitObject.x, this.hitObject.y, this.hitObject.width, this.hitObject.height);
            this.removeChild(this.hitObject);
            this.hitObject.destroy();
        }
        this.setState(ButtonState.NORMAL);
        this
            .on('added', this.onAdded, this)
            .on('removed', this.onRemoved, this);
    }
    // PUBLIC API
    setState(state) {
        if (this.currentState == state) {
            return;
        }
        this.currentState = state;
        this.updateView();
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        this._enabled = value;
        if (value) {
            this.cursor = 'pointer';
            this.eventMode = 'dynamic';
            this.setState(ButtonState.NORMAL);
        }
        else {
            this.eventMode = 'auto';
            this.cursor = 'auto';
            this.pointerDown = false;
            this.pointerOver = false;
            this.setState(ButtonState.DISABLED);
        }
    }
    // PRIVATE API
    onAdded() {
        this.startScale = this.scale.x;
        this.on('pointerdown', this.onButtonDown, this)
            .on('pointerup', this.onButtonUp, this)
            .on('pointerupoutside', this.onButtonUpOutside, this)
            .on('pointerover', this.onButtonOver, this)
            .on('pointerout', this.onButtonOut, this);
    }
    onRemoved() {
        this.off('pointerdown', this.onButtonDown, this)
            .off('pointerup', this.onButtonUp, this)
            .off('pointerupoutside', this.onButtonUpOutside, this)
            .off('pointerover', this.onButtonOver, this)
            .off('pointerout', this.onButtonOut, this);
    }
    onButtonDown(e) {
        if (this._enabled) {
            this.pointerDown = true;
            this.setState(ButtonState.DOWN);
        }
    }
    onButtonUp(e) {
        if (this._enabled) {
            this.pointerDown = false;
            if (this.pointerOver) {
                this.setState(ButtonState.HOVER);
            }
            else {
                this.setState(ButtonState.NORMAL);
            }
        }
    }
    onButtonUpOutside(e) {
        if (this._enabled) {
            this.pointerDown = false;
            if (this.pointerOver) {
                this.setState(ButtonState.HOVER);
            }
            else {
                this.setState(ButtonState.NORMAL);
            }
        }
    }
    onButtonOver(e) {
        if (this._enabled) {
            this.pointerOver = true;
            this.setState(ButtonState.HOVER);
        }
    }
    onButtonOut(e) {
        if (this._enabled) {
            this.pointerOver = false;
            this.setState(ButtonState.NORMAL);
        }
    }
    updateView() {
        const itemsToRemove = [this.normal, this.hover, this.down, this.disabled];
        let itemToAdd = null;
        switch (this.currentState) {
            case ButtonState.NORMAL:
                (0, Utils_1.removeArrayElement)(itemsToRemove, this.normal);
                itemToAdd = this.normal;
                break;
            case ButtonState.HOVER:
                (0, Utils_1.removeArrayElement)(itemsToRemove, this.hover);
                itemToAdd = this.hover;
                break;
            case ButtonState.DOWN:
                (0, Utils_1.removeArrayElement)(itemsToRemove, this.down);
                itemToAdd = this.down;
                break;
            case ButtonState.DISABLED:
                (0, Utils_1.removeArrayElement)(itemsToRemove, this.disabled);
                itemToAdd = this.disabled;
                break;
        }
        for (const item of itemsToRemove) {
            if (item && item.parent == this) {
                this.removeChild(item);
            }
        }
        if (!itemToAdd) {
            itemToAdd = this.normal;
        }
        if (itemToAdd) {
            this.addChild(itemToAdd);
        }
    }
    customClassElementCreate(le) {
        return null;
    }
}
exports["default"] = Button;
var ButtonState;
(function (ButtonState) {
    ButtonState[ButtonState["NORMAL"] = 0] = "NORMAL";
    ButtonState[ButtonState["HOVER"] = 1] = "HOVER";
    ButtonState[ButtonState["DOWN"] = 2] = "DOWN";
    ButtonState[ButtonState["DISABLED"] = 3] = "DISABLED";
})(ButtonState || (exports.ButtonState = ButtonState = {}));


/***/ }),

/***/ 72924:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const engineTween_1 = __webpack_require__(50381);
class Bounce {
    invoke(button) {
        const minScale = 0.92;
        const maxScale = 1.03;
        const decreasingTime = 0.07;
        const increasingTime = 0.1;
        engineTween_1.Tweener.addTween(button.scale, {
            x: minScale,
            y: minScale,
            time: decreasingTime,
            transition: 'easeOutSine'
        });
        engineTween_1.Tweener.addTween(button.scale, {
            x: maxScale,
            y: maxScale,
            time: increasingTime,
            delay: decreasingTime,
            transition: 'easeOutSine'
        });
        engineTween_1.Tweener.addTween(button.scale, {
            x: 1,
            y: 1,
            time: increasingTime,
            delay: decreasingTime + increasingTime,
            transition: 'easeOutSine'
        });
    }
}
exports["default"] = Bounce;


/***/ }),

/***/ 19838:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToggleButton = void 0;
const pixi_js_1 = __webpack_require__(95894);
const Button_1 = __importDefault(__webpack_require__(78386));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
class ToggleButton extends pixi_js_1.Container {
    constructor(le) {
        super();
        this.isStateOn = false;
        LayoutBuilder_1.default.create(le, this, (childLe) => {
            return this.customClassElementCreate(childLe);
        });
        this.cursor = "pointer";
        this.eventMode = "dynamic";
        this.on("pointerup", this.toggle, this);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case "Button":
                instance = new Button_1.default(le);
                break;
        }
        return instance;
    }
    toggle() {
        this.changeState(!this.isStateOn);
    }
    setStateView(isOn) {
        if (isOn) {
            this.offState.visible = false;
            this.isStateOn = true;
            this.onState.visible = true;
        }
        else {
            this.onState.visible = false;
            this.isStateOn = false;
            this.offState.visible = true;
        }
    }
    changeState(isOn) {
        this.setStateView(isOn);
        this.emit(ToggleButton.STATE_CHANGED);
    }
    getIsStateOn() {
        return this.isStateOn;
    }
    set enabled(value) {
        if (value) {
            this.cursor = "pointer";
            this.eventMode = "dynamic";
            this.alpha = 1;
        }
        else {
            this.eventMode = "auto";
            this.cursor = "auto";
        }
    }
}
exports.ToggleButton = ToggleButton;
ToggleButton.STATE_CHANGED = "stateChanged";


/***/ }),

/***/ 25590:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const FrontController_1 = __importDefault(__webpack_require__(96066));
const StartGameCommand_1 = __importDefault(__webpack_require__(46906));
const AdjustBetCommand_1 = __importDefault(__webpack_require__(10250));
const AdjustGameSpeedCommand_1 = __importDefault(__webpack_require__(38396));
const UIEvent_1 = __webpack_require__(77066);
const SlotGameEvent_1 = __webpack_require__(19342);
const ApplicationEvent_1 = __webpack_require__(27638);
const AdjustAutoSpinCommand_1 = __importDefault(__webpack_require__(31488));
const ConfirmReelsStartedCommand_1 = __importDefault(__webpack_require__(59462));
const ConfirmSpinTimeLapsedCommand_1 = __importDefault(__webpack_require__(24322));
const SpinStopCommand_1 = __importDefault(__webpack_require__(63492));
const ConfirmMultiWinCommand_1 = __importDefault(__webpack_require__(40755));
const CompleteRoundCommand_1 = __importDefault(__webpack_require__(34607));
const ProcessSpinResultCommand_1 = __importDefault(__webpack_require__(85996));
const ConfirmBigWinCommand_1 = __importDefault(__webpack_require__(29460));
const InitializeCommand_1 = __importDefault(__webpack_require__(33498));
const SpinStartCommand_1 = __importDefault(__webpack_require__(1552));
const InstantSpinStopCommand_1 = __importDefault(__webpack_require__(77495));
const ConfirmScatterWinCommand_1 = __importDefault(__webpack_require__(70740));
const ConfirmFreespinsWinCommand_1 = __importDefault(__webpack_require__(42817));
const ConfirmFreeSpinsRoundStartedCommand_1 = __importDefault(__webpack_require__(38898));
const ConfirmFreeSpinsRoundCompleteCommand_1 = __importDefault(__webpack_require__(13614));
const ConfirmBonusWinCommand_1 = __importDefault(__webpack_require__(47673));
const ConfirmBonusGameCompleteCommand_1 = __importDefault(__webpack_require__(77390));
const FreeSpinStartCommand_1 = __importDefault(__webpack_require__(97610));
const AdjustCoinValueCommand_1 = __importDefault(__webpack_require__(23109));
class SlotGameFrontController extends FrontController_1.default {
    constructor() {
        super();
        this.addCommand(ApplicationEvent_1.ApplicationEvent.INIT, InitializeCommand_1.default);
        this.addCommand(ApplicationEvent_1.ApplicationEvent.LOADING_COMPLETE, StartGameCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.COIN_VALUE_UP, AdjustCoinValueCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.COIN_VALUE_DOWN, AdjustCoinValueCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.COIN_VALUE_MAX, AdjustCoinValueCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.BET_UP, AdjustBetCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.BET_DOWN, AdjustBetCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.BET_SELECT, AdjustBetCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_UP, AdjustGameSpeedCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.GAME_SPEED_LEVEL_DOWN, AdjustGameSpeedCommand_1.default);
        this.addCommand(UIEvent_1.UIEvent.AUTO_SPIN, AdjustAutoSpinCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.SPIN_START, SpinStartCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.REELS_STARTED, ConfirmReelsStartedCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.SPIN_TIME_LAPSED, ConfirmSpinTimeLapsedCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.SPIN_STOP, SpinStopCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.STOP_REQUESTED, InstantSpinStopCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.REELS_STOPPED, ProcessSpinResultCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.MULTI_WIN_SHOWN, ConfirmMultiWinCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.SCATTER_WIN_SHOWN, ConfirmScatterWinCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.CASCADE_WIN_SHOWN, ProcessSpinResultCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.BONUS_GAME_WIN_SHOWN, ConfirmBonusWinCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.BONUS_GAME_COMPLETE, ConfirmBonusGameCompleteCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_WIN_SHOWN, ConfirmFreespinsWinCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_ROUND_STARTED, ConfirmFreeSpinsRoundStartedCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_START, FreeSpinStartCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_ROUND_COMPLETE, ConfirmFreeSpinsRoundCompleteCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.BIG_WIN_SHOWN, ConfirmBigWinCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY, ProcessSpinResultCommand_1.default);
        this.addCommand(SlotGameEvent_1.SlotGameEvent.ROUND_COMPLETE, CompleteRoundCommand_1.default);
    }
}
exports["default"] = SlotGameFrontController;


/***/ }),

/***/ 31488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotGameEvent_1 = __webpack_require__(19342);
const tsyringe_1 = __webpack_require__(659);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const Wallet_1 = __importDefault(__webpack_require__(92162));
class AdjustAutoSpinCommand extends ControlCommand_1.default {
    execute(event) {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const settings = event.data;
        if (!settings) {
            sm.autoplay.enabled = false;
            sm.autoplay.spinsLeft = 0;
        }
        else {
            sm.autoplay.settings = settings;
            if (sm.currentState == SlotMachineState_1.SlotMachineState.IDLE && sm.autoplay.spinsLeft != 0) {
                sm.autoplay.startBalance = wallet.credits;
                sm.autoplay.enabled = true;
                if (sm.autoplay.spinsLeft > 0)
                    sm.autoplay.spinsLeft -= 1;
                new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
            }
        }
    }
}
exports["default"] = AdjustAutoSpinCommand;


/***/ }),

/***/ 10250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const UIEvent_1 = __webpack_require__(77066);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const SlotMachineState_1 = __webpack_require__(77313);
class AdjustBetCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const betLimits = sm.description.betLimits;
        if (event.type == UIEvent_1.UIEvent.BET_UP) {
            if (betLimits.indexOf(sm.currentBetValue) < betLimits.length - 1) {
                sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) + 1];
            }
        }
        else if (event.type == UIEvent_1.UIEvent.BET_DOWN) {
            if (betLimits.indexOf(sm.currentBetValue) != 0) {
                sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) - 1];
            }
        }
        else if (event.type == UIEvent_1.UIEvent.BET_SELECT && sm.currentState == SlotMachineState_1.SlotMachineState.IDLE) {
            const data = event === null || event === void 0 ? void 0 : event.data;
            const id = betLimits.indexOf(data);
            if (betLimits[id] != null) {
                sm.currentBetValue = betLimits[id];
            }
        }
    }
}
exports["default"] = AdjustBetCommand;


/***/ }),

/***/ 23109:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const UIEvent_1 = __webpack_require__(77066);
class AdjustCoinValueCommand extends ControlCommand_1.default {
    execute(event) {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const coinValueLimits = wallet.coinValueLimits;
        if (event.type == UIEvent_1.UIEvent.COIN_VALUE_UP) {
            if (coinValueLimits.indexOf(wallet.coinValue) < coinValueLimits.length - 1) {
                wallet.coinValue = coinValueLimits[coinValueLimits.indexOf(wallet.coinValue) + 1];
            }
        }
        else if (event.type == UIEvent_1.UIEvent.COIN_VALUE_DOWN) {
            if (coinValueLimits.indexOf(wallet.coinValue) != 0) {
                wallet.coinValue = coinValueLimits[coinValueLimits.indexOf(wallet.coinValue) - 1];
            }
        }
        else if (event.type == UIEvent_1.UIEvent.COIN_VALUE_MAX) {
            wallet.coinValue = coinValueLimits[coinValueLimits.length - 1];
        }
    }
}
exports["default"] = AdjustCoinValueCommand;


/***/ }),

/***/ 38396:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const UIEvent_1 = __webpack_require__(77066);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class AdjustGameSpeedCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        if (event.type == UIEvent_1.UIEvent.GAME_SPEED_LEVEL_UP) {
            sm.currentGameSpeedLevel = Math.min(sm.currentGameSpeedLevel + 1, sm.options.gameSpeedLevels - 1);
        }
        else if (event.type == UIEvent_1.UIEvent.GAME_SPEED_LEVEL_DOWN) {
            sm.currentGameSpeedLevel = Math.max(0, sm.currentGameSpeedLevel - 1);
        }
    }
}
exports["default"] = AdjustGameSpeedCommand;


/***/ }),

/***/ 34607:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotGameEvent_1 = __webpack_require__(19342);
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
class CompleteRoundCommand extends ControlCommand_1.default {
    execute() {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.roundResult.complete = true;
        wallet.balance += sm.roundResult.totalWinValue;
        if (sm.autoplay.enabled && sm.autoplay.canAutoSpin(sm.roundResult, wallet.credits)) {
            if (sm.autoplay.spinsLeft > 0)
                sm.autoplay.spinsLeft -= 1;
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
        }
        else {
            sm.autoplay.spinsLeft = 0;
            sm.autoplay.enabled = false;
            sm.currentState = SlotMachineState_1.SlotMachineState.IDLE;
        }
    }
}
exports["default"] = CompleteRoundCommand;


/***/ }),

/***/ 29460:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmBigWinCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.bigWinShown = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmBigWinCommand;


/***/ }),

/***/ 77390:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmBonusGameCompleteCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentSpinResult.bonus.bonusGameComplete = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmBonusGameCompleteCommand;


/***/ }),

/***/ 47673:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmBonusWinCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentSpinResult.bonus.bonusGameShown = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmBonusWinCommand;


/***/ }),

/***/ 13614:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmFreeSpinsRoundCompleteCommand extends ControlCommand_1.default {
    execute() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentSpinResult.freespins.roundComplete = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmFreeSpinsRoundCompleteCommand;


/***/ }),

/***/ 38898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
class ConfirmFreeSpinsRoundStartedCommand extends ControlCommand_1.default {
    execute() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentSpinResult.freespins.roundStarted = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmFreeSpinsRoundStartedCommand;


/***/ }),

/***/ 42817:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmFreespinsWinCommand extends ControlCommand_1.default {
    execute() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentSpinResult.win.freespinWinShown = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmFreespinsWinCommand;


/***/ }),

/***/ 40755:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmMultiWinCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentSpinResult.win.multiWinShown = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmMultiWinCommand;


/***/ }),

/***/ 59462:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmReelsStartedCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.reelsStarted = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_STOP).dispatch();
    }
}
exports["default"] = ConfirmReelsStartedCommand;


/***/ }),

/***/ 70740:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmScatterWinCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentSpinResult.win.scatterWinShown = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_RESULT_READY).dispatch();
    }
}
exports["default"] = ConfirmScatterWinCommand;


/***/ }),

/***/ 24322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class ConfirmSpinTimeLapsedCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.spinTimeLapsed = true;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_STOP).dispatch();
    }
}
exports["default"] = ConfirmSpinTimeLapsedCommand;


/***/ }),

/***/ 97610:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotMachineState_1 = __webpack_require__(77313);
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const Logger_1 = __importDefault(__webpack_require__(82669));
class FreeSpinStartCommand extends ControlCommand_1.default {
    execute() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        sm.roundResult = null;
        sm.currentState = SlotMachineState_1.SlotMachineState.SPINNING;
        const gs = tsyringe_1.container.resolve('GameService');
        gs.spin(sm.currentBetValue, sm.numLines == 0 ? sm.combinations : sm.numLines).then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_STOP).dispatch();
            // sm.previousRoundResult=roundResult
        }).catch((e) => {
            Logger_1.default.error(e);
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            sm.currentState = SlotMachineState_1.SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}
exports["default"] = FreeSpinStartCommand;


/***/ }),

/***/ 33498:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const tsyringe_1 = __webpack_require__(659);
class InitializeCommand extends ControlCommand_1.default {
    execute(event) {
        const gs = tsyringe_1.container.resolve('GameService');
        gs.initialize().then(([wallet, slotMachine]) => {
            tsyringe_1.container.registerInstance(Wallet_1.default, wallet);
            tsyringe_1.container.registerInstance(SlotMachine_1.default, slotMachine);
        });
    }
}
exports["default"] = InitializeCommand;


/***/ }),

/***/ 77495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachineState_1 = __webpack_require__(77313);
class InstantSpinStopCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.stopRequested = true;
        sm.spinTimeLapsed = true;
        if (sm.currentState !== SlotMachineState_1.SlotMachineState.SPINNING)
            return;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_STOP).dispatch();
    }
}
exports["default"] = InstantSpinStopCommand;


/***/ }),

/***/ 85996:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotGameEvent_1 = __webpack_require__(19342);
const tsyringe_1 = __webpack_require__(659);
class ProcessSpinResultCommand extends ControlCommand_1.default {
    execute() {
        var _a, _b;
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const roundResult = sm.roundResult;
        const spinResult = sm.currentSpinResult;
        // show multi win
        if (spinResult.win && !spinResult.win.multiWinShown) {
            sm.currentState = SlotMachineState_1.SlotMachineState.SPIN_RESULT_MULTI_WIN;
            return;
        }
        // show scatter wins
        if (spinResult.win && !spinResult.win.scatterWinShown && spinResult.win.winningPattern) {
            sm.currentState = SlotMachineState_1.SlotMachineState.SPIN_RESULT_SCATTER;
            return;
        }
        // cascade to next spin result
        if (sm.description.reels.regular.cascading) {
            if (sm.nextSpinResult) {
                roundResult.spinIndex++;
                sm.currentState = SlotMachineState_1.SlotMachineState.SPIN_RESULT_CASCADE;
                return;
            }
        }
        // is bonus game won
        if (spinResult.bonus && !spinResult.bonus.bonusGameShown) {
            sm.currentState = SlotMachineState_1.SlotMachineState.SPIN_RESULT_BONUS_GAME;
            return;
        }
        // is bonus game incompleted
        if (spinResult.bonus && !spinResult.bonus.bonusGameComplete) {
            sm.currentState = SlotMachineState_1.SlotMachineState.BONUS_GAME;
            return;
        }
        // show free spins scatter wins
        if (spinResult.freespins && ((_a = spinResult.win) === null || _a === void 0 ? void 0 : _a.freespins) && !((_b = spinResult.win) === null || _b === void 0 ? void 0 : _b.freespinWinShown)) {
            sm.currentState = SlotMachineState_1.SlotMachineState.SPIN_RESULT_FREE_SPINS;
            return;
        }
        if (spinResult.freespins) {
            // show free spins start
            if (!spinResult.freespins.roundStarted) {
                sm.currentState = SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_START;
                return;
            }
            if (sm.freeSpinBigWinLevel(spinResult) != -1 && !sm.bigWinShown) {
                sm.currentState = SlotMachineState_1.SlotMachineState.FREE_SPIN_BIG_WIN;
                return;
            }
            // show free spins award received during freespins round
            if (spinResult.freespins.moreAwarded > 0) {
                sm.currentState = SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_START;
                return;
            }
            // are any freespins remaining
            if (spinResult.freespins.remainingCount) {
                sm.currentState = SlotMachineState_1.SlotMachineState.FREE_SPINS;
                return;
            }
            // show freespin end
            if (!spinResult.freespins.roundComplete) {
                sm.currentState = SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_END;
                return;
            }
        }
        // show big win
        if (!spinResult.freespins && sm.bigWinLevel(roundResult) != -1 && !sm.bigWinShown) {
            sm.currentState = SlotMachineState_1.SlotMachineState.BIG_WIN;
            return;
        }
        //if round result is already completed
        if (sm.roundResult.complete == true)
            return;
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.ROUND_COMPLETE).dispatch();
    }
}
exports["default"] = ProcessSpinResultCommand;


/***/ }),

/***/ 1552:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotMachineState_1 = __webpack_require__(77313);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotGameEvent_1 = __webpack_require__(19342);
const tsyringe_1 = __webpack_require__(659);
const Logger_1 = __importDefault(__webpack_require__(82669));
class SpinStartCommand extends ControlCommand_1.default {
    execute() {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        // if (wallet.balance < sm.totalBet) {
        //     if (sm.autoplay.enabled) {
        //         sm.autoplay.spinsLeft = 0;
        //         sm.autoplay.enabled = false;
        //     }
        //     sm.currentState = SlotMachineState.IDLE;
        //     wallet.emit(WalletEvent.NOT_ENOUGH_BALANCE);
        //     return;
        // }
        wallet.balance -= sm.totalBet;
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        sm.roundResult.totalWinValue = 0;
        sm.roundResult = null;
        sm.currentState = SlotMachineState_1.SlotMachineState.SPINNING;
        const gs = tsyringe_1.container.resolve('GameService');
        gs.spin(sm.currentBetValue, sm.numLines)
            .then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_STOP).dispatch();
        })
            .catch((e) => {
            Logger_1.default.error(e);
            sm.currentError = e;
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            wallet.balance += sm.totalBet;
            sm.currentState = SlotMachineState_1.SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}
exports["default"] = SpinStartCommand;


/***/ }),

/***/ 63492:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class SpinStopCommand extends ControlCommand_1.default {
    execute() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        if (!sm.spinTimeLapsed || !sm.reelsStarted || !sm.roundResult || sm.currentState == SlotMachineState_1.SlotMachineState.COMMUNICATION_ERROR) {
            return;
        }
        sm.currentState = SlotMachineState_1.SlotMachineState.SPIN_END;
    }
}
exports["default"] = SpinStopCommand;


/***/ }),

/***/ 46906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
class StartGameCommand extends ControlCommand_1.default {
    execute() {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        sm.currentState = SlotMachineState_1.SlotMachineState.IDLE;
    }
}
exports["default"] = StartGameCommand;


/***/ }),

/***/ 19342:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlotGameEvent = void 0;
var SlotGameEvent;
(function (SlotGameEvent) {
    SlotGameEvent["SPIN_START"] = "onSlotGameSpinStart";
    SlotGameEvent["REELS_STARTED"] = "onSlotGameReelsStarted";
    SlotGameEvent["SPIN_TIME_LAPSED"] = "onSlotGameSpinTimeLapsed";
    SlotGameEvent["ROUND_RESULT_OBTAINED"] = "onSlotGameRoundresultObtained";
    SlotGameEvent["STOP_REQUESTED"] = "onSlotGameStopRequested";
    SlotGameEvent["SPIN_STOP"] = "onSlotGameSpinStop";
    SlotGameEvent["REELS_STOPPED"] = "onSlotGameReelsStopped";
    SlotGameEvent["MULTI_WIN_SHOWN"] = "onSlotGameMultiWinShown";
    SlotGameEvent["WINLINE_WIN_SHOWN"] = "onSlotGameWinlineWinShown";
    SlotGameEvent["SCATTER_WIN_SHOWN"] = "onSlotGameScatterWinShown";
    SlotGameEvent["CASCADE_WIN_SHOWN"] = "onSlotGameCascadeWinShown";
    SlotGameEvent["BONUS_GAME_WIN_SHOWN"] = "onSlotGameBonusGameWinShown";
    SlotGameEvent["BONUS_GAME_STARTED"] = "onSlotGameBonusGamePlayStarted";
    SlotGameEvent["BONUS_GAME_COMPLETE"] = "onSlotGameBonusGamePlayComplete";
    SlotGameEvent["FREE_SPIN_WIN_SHOWN"] = "onSlotGameFreeSpinWinShown";
    SlotGameEvent["FREE_SPIN_ROUND_STARTED"] = "onSlotGameFreeSpinRoundStarted";
    SlotGameEvent["FREE_SPIN_START"] = "onSlotGameFreeSpinStart";
    SlotGameEvent["FREE_SPIN_ROUND_COMPLETE"] = "onSlotGameFreeSpinRoundComplete";
    SlotGameEvent["BIG_WIN_SHOWN"] = "onSlotGameBigWinShown";
    SlotGameEvent["SPIN_RESULT_READY"] = "onSlotGameSpinResultReady";
    SlotGameEvent["ROUND_COMPLETE"] = "onSlotGameRoundComplete";
})(SlotGameEvent || (exports.SlotGameEvent = SlotGameEvent = {}));


/***/ }),

/***/ 77066:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIEvent = void 0;
var UIEvent;
(function (UIEvent) {
    UIEvent["AUTO_SPIN"] = "onUIAutoSpin";
    UIEvent["BET_QUANTITY_UP"] = "onBetQuantityUp";
    UIEvent["BET_QUANTITY_DOWN"] = "onBetQuantityDown";
    UIEvent["BET_QUANTITY_MAX"] = "onBetQuantityMax";
    UIEvent["BET_QUANTITY_MIN"] = "onBetQuantityMin";
    UIEvent["COIN_VALUE_UP"] = "onCoinValueUp";
    UIEvent["COIN_VALUE_DOWN"] = "onCoinValueDown";
    UIEvent["COIN_VALUE_MAX"] = "onCoinValueMax";
    UIEvent["COIN_VALUE_MIN"] = "onCoinValueMin";
    UIEvent["BET_UP"] = "onUIBetUp";
    UIEvent["BET_DOWN"] = "onUIBetDown";
    UIEvent["BET_SELECT"] = "onUIBetSelect";
    UIEvent["GAME_SPEED_LEVEL_UP"] = "onUIGameSpeedLevelUp";
    UIEvent["GAME_SPEED_LEVEL_DOWN"] = "onUIGameSpeedLevelDown";
})(UIEvent || (exports.UIEvent = UIEvent = {}));


/***/ }),

/***/ 1874:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const AutoplayEvent_1 = __webpack_require__(71967);
const Logger_1 = __importDefault(__webpack_require__(82669));
class Autoplay extends eventemitter3_1.default {
    constructor() {
        super();
        this._spinsLeft = -1;
        this._enabled = false;
        this._infinite = false;
        this._settings = null;
        this._startBalance = 0;
    }
    // PUBLIC API
    get spinsLeft() {
        return this._spinsLeft;
    }
    set spinsLeft(value) {
        if (this._spinsLeft == value) {
            return;
        }
        this._spinsLeft = value;
        if (this.infinite)
            this._spinsLeft = 100;
        this.emit(AutoplayEvent_1.AutoplayEvent.SPINS_LEFT_CHANGED);
    }
    get infinite() {
        return this._infinite;
    }
    set infinite(value) {
        this._infinite = value;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        if (this._enabled == value) {
            return;
        }
        this._enabled = value;
        if (this._enabled) {
            this.emit(AutoplayEvent_1.AutoplayEvent.ENABLED);
        }
        else {
            this.emit(AutoplayEvent_1.AutoplayEvent.DISABLED);
        }
    }
    get settings() {
        return this._settings;
    }
    set settings(value) {
        this.spinsLeft = value.spinsLeft;
        this._settings = value;
    }
    canAutoSpin(latestRound, balance) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // Check if there are spins left
        if (this.spinsLeft === 0) {
            return false;
        }
        // Check if there are settings
        if (!this._settings)
            return true;
        if ((_a = this._settings) === null || _a === void 0 ? void 0 : _a.onAnyWin) {
            if ((latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue) > 0) {
                Logger_1.default.debug('OnAnyWin STOP ' + (latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue));
                return false;
            }
        }
        if ((_b = this.settings) === null || _b === void 0 ? void 0 : _b.onBonusGameWon) {
            if (latestRound.spins[latestRound.spins.length - 1].freespins) {
                Logger_1.default.debug('OnBonusGameWon ' + latestRound);
                return false;
            }
        }
        if ((_c = this._settings) === null || _c === void 0 ? void 0 : _c.onSingleWinExceed) {
            if (this._settings.onSingleWinExceed < (latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue)) {
                Logger_1.default.debug('OnSingleWinExceed STOP ' + this._settings.onSingleWinExceed + ' ' + (latestRound === null || latestRound === void 0 ? void 0 : latestRound.totalWinValue));
                return false;
            }
        }
        if ((_d = this._settings) === null || _d === void 0 ? void 0 : _d.onCashBalanceIncreaseBy) {
            if (balance > this._startBalance + ((_e = this._settings) === null || _e === void 0 ? void 0 : _e.onCashBalanceIncreaseBy)) {
                Logger_1.default.debug('OnCashBalanceIncreaseBy STOP ' + balance + ' ' + (this._startBalance + ((_f = this._settings) === null || _f === void 0 ? void 0 : _f.onCashBalanceIncreaseBy)));
                return false;
            }
        }
        if ((_g = this._settings) === null || _g === void 0 ? void 0 : _g.onCashBalanceDecreaseBy) {
            if (balance < this._startBalance - ((_h = this._settings) === null || _h === void 0 ? void 0 : _h.onCashBalanceDecreaseBy)) {
                Logger_1.default.debug('OnCashBalanceDecreaseBy STOP ' + balance + ' ' + (this._startBalance - ((_j = this._settings) === null || _j === void 0 ? void 0 : _j.onCashBalanceDecreaseBy)));
                return false;
            }
        }
        return true;
    }
    set startBalance(value) {
        this._startBalance = value;
        Logger_1.default.debug('start balance ' + this._startBalance);
    }
}
exports["default"] = Autoplay;


/***/ }),

/***/ 56918:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotMachineEvent_1 = __webpack_require__(96421);
const Autoplay_1 = __importDefault(__webpack_require__(1874));
let SlotMachine = class SlotMachine extends eventemitter3_1.default {
    constructor(description, options = null) {
        super();
        this.defaultDescription = {
            lines: [],
            wildcards: [],
            bigWinMultiplierLevels: []
        };
        this.defaultOptions = {
            gameSpeedLevels: 1
        };
        this._currentState = SlotMachineState_1.SlotMachineState.NOT_INITIALIZED;
        this._currentError = '';
        this._currentGameSpeedLevel = 0;
        this._betQuantity = 1;
        // TODO: Think about moving these to round object
        // RESETTABLE STATUS VARS
        this.reelsStarted = false;
        this.stopRequested = false;
        this.spinTimeLapsed = false;
        this.bigWinShown = false;
        this.round_Result = null;
        this.previousRoundResult = null;
        // merge config with default values
        this.description = Object.assign(Object.assign({}, this.defaultDescription), description);
        this.options = Object.assign(Object.assign({}, this.defaultOptions), options);
        this._currentBetValue = this.description.betLimits[0];
        this.autoplay = new Autoplay_1.default();
    }
    // PUBLIC API
    get roundResult() {
        return this.round_Result;
    }
    set roundResult(value) {
        this.round_Result = value;
    }
    set betQuantity(value) {
        if (this._betQuantity == value || value > 10 || value <= 0) {
            return;
        }
        this._betQuantity = value;
        this.emit(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED);
    }
    get betQuantity() {
        return this._betQuantity;
    }
    get currentState() {
        return this._currentState;
    }
    set currentState(value) {
        if (this._currentState == value) {
            return;
        }
        const previousState = this._currentState;
        this._currentState = value;
        this.emit(SlotMachineEvent_1.SlotMachineEvent.STATE_CHANGED, this._currentState, previousState);
    }
    get numLines() {
        return this.description.lines.length;
    }
    get combinations() {
        return this.description.combinations;
    }
    get currentBetValue() {
        return this._currentBetValue;
    }
    set currentBetValue(value) {
        if (this._currentBetValue == value) {
            return;
        }
        this._currentBetValue = value;
        this.emit(SlotMachineEvent_1.SlotMachineEvent.BET_VALUE_CHANGED, this._currentBetValue);
    }
    get totalBet() {
        return this._currentBetValue * ((this.numLines == 0) ? this.combinations : this.numLines) * this.betQuantity;
    }
    get currentGameSpeedLevel() {
        return this._currentGameSpeedLevel;
    }
    set currentGameSpeedLevel(value) {
        // if (this._currentGameSpeedLevel == value) {
        //     return;
        // }
        this._currentGameSpeedLevel = value;
        this.emit(SlotMachineEvent_1.SlotMachineEvent.GAME_SPEED_LEVEL_CHANGED, this._currentGameSpeedLevel);
    }
    get currentSpinResult() {
        if (this.roundResult) {
            return this.roundResult.spins[this.roundResult.spinIndex];
        }
        else {
            return null;
        }
    }
    get nextSpinResult() {
        if (this.roundResult && this.roundResult.spins.length > this.roundResult.spinIndex + 1) {
            return this.roundResult.spins[this.roundResult.spinIndex + 1];
        }
        else {
            return null;
        }
    }
    get previousSpinResult() {
        if (this.roundResult) {
            return this.roundResult.spins[this.roundResult.spinIndex - 1];
        }
        else {
            return null;
        }
    }
    get currentError() {
        return this._currentError;
    }
    set currentError(error) {
        this._currentError = error;
    }
    multiWinPattern(spinResult) {
        var _a;
        // create empty pattern
        const pattern = [];
        for (let i = 0; i < spinResult.result.length; i++) {
            pattern.push([]);
            for (let j = 0; j < spinResult.result[i].length; j++) {
                pattern[i].push(0);
            }
        }
        // iterate over line wins and mark winning symbols
        if (spinResult.win.lines) {
            for (const win of spinResult.win.lines) {
                for (let i = 0; i < pattern.length; i++) {
                    for (let j = 0; j < pattern[i].length; j++) {
                        pattern[i][j] = pattern[i][j] || win.pattern[i][j];
                    }
                }
            }
        }
        if ((_a = spinResult.win) === null || _a === void 0 ? void 0 : _a.winningPattern) {
            spinResult.win.winningPattern.forEach((value) => {
                value.forEach((cluster) => {
                    const winPattern = cluster.pattern;
                    winPattern.forEach((row, i) => {
                        row.forEach((element, j) => {
                            pattern[i][j] = pattern[i][j] || element;
                        });
                    });
                });
            });
        }
        if (spinResult.win.freespins) {
            // iterate over scatter wins and mark winning symbols
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[i].length; j++) {
                    pattern[i][j] = pattern[i][j] || spinResult.win.freespins.pattern[i][j];
                }
            }
        }
        return pattern;
    }
    lineWinValue(spinResult) {
        return spinResult.win.lines.reduce((totalWin, win) => {
            return totalWin + win.winValue;
        }, 0);
    }
    bigWinLevel(roundResult) {
        const winMultiplierRatio = roundResult.totalWinValue / roundResult.totalBet;
        let level = -1;
        for (let i = 0; i < this.description.bigWinMultiplierLevels.length; i++) {
            if (winMultiplierRatio >= this.description.bigWinMultiplierLevels[i]) {
                level = i;
            }
        }
        return level;
    }
    freeSpinBigWinLevel(spinResult) {
        const winMultiplierRatio = spinResult.currentTotalWinValue / this.roundResult.totalBet;
        let level = -1;
        for (let i = 0; i < this.description.bigWinMultiplierLevels.length; i++) {
            if (winMultiplierRatio >= this.description.bigWinMultiplierLevels[i]) {
                level = i;
            }
        }
        return level;
    }
    findRule(symbolId, symbolCount) {
        return this.description.rules.find((rd) => {
            if (rd.pattern.symbolId == symbolId && rd.pattern.symbolCount.includes(symbolCount)) {
                return true;
            }
            return false;
        });
    }
    //Dummy round result is used for lost connection error when user has no previous data (ERROR -> stop on previous round result)
    getDummyRoundResult(result = null) {
        // create empty pattern
        const pattern = [];
        for (let i = 0; i < this.description.reels.regular.reels.length; i++) {
            pattern.push([]);
            for (let j = 0; j < this.description.reels.regular.reels[0].numRows; j++) {
                pattern[i].push(this.description.symbols[Math.floor(Math.random() * this.description.symbols.length)]);
            }
        }
        return {
            id: 0,
            roundType: 1,
            betLines: 0,
            lineBetValue: 0,
            spinIndex: 0,
            spins: [
                {
                    result: result ? result.spins[result.spins.length - 1].result : pattern,
                    winValue: 0,
                    currentTotalWinValue: 0,
                    multipliers: []
                }
            ],
            totalBet: 0,
            totalWinValue: 0,
            nextType: result ? result.nextType : null,
            complete: false,
            details: {
                betId: '0',
                gameId: 0,
                userId: '00'
            }
        };
    }
};
SlotMachine = __decorate([
    (0, tsyringe_1.injectable)(),
    __metadata("design:paramtypes", [Object, Object])
], SlotMachine);
exports["default"] = SlotMachine;


/***/ }),

/***/ 9130:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PatternType = exports.WildcardType = exports.SlotMachineType = void 0;
var SlotMachineType;
(function (SlotMachineType) {
    SlotMachineType["LINES"] = "lines";
    SlotMachineType["WAYS"] = "ways";
    SlotMachineType["COMBINATIONS"] = "combinations";
})(SlotMachineType || (exports.SlotMachineType = SlotMachineType = {}));
var WildcardType;
(function (WildcardType) {
    WildcardType["REGULAR"] = "regular";
    WildcardType["EXPANDING"] = "expanding";
    WildcardType["EXPANDED"] = "expaneded";
})(WildcardType || (exports.WildcardType = WildcardType = {}));
var PatternType;
(function (PatternType) {
    PatternType["LEFTMOST"] = "leftmost";
    PatternType["BOTH_WAYS"] = "bothWays";
    PatternType["SCATTER"] = "scatter";
})(PatternType || (exports.PatternType = PatternType = {}));


/***/ }),

/***/ 77313:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlotMachineState = void 0;
var SlotMachineState;
(function (SlotMachineState) {
    SlotMachineState["NOT_INITIALIZED"] = "NotInitialized";
    SlotMachineState["IDLE"] = "Idle";
    SlotMachineState["SPINNING"] = "Spinning";
    SlotMachineState["SPIN_END"] = "SpinEnd";
    SlotMachineState["SPIN_RESULT_MULTI_WIN"] = "SpinResultMultiWin";
    SlotMachineState["SPIN_RESULT_SCATTER"] = "SpinResultScatter";
    SlotMachineState["SPIN_RESULT_CASCADE"] = "SpinResultCascade";
    SlotMachineState["SPIN_RESULT_BONUS_GAME"] = "SpinResultBonusGame";
    SlotMachineState["SPIN_RESULT_FREE_SPINS"] = "SpinResultFreeSpins";
    SlotMachineState["BONUS_GAME"] = "BonusGame";
    SlotMachineState["FREE_SPINS_ROUND_START"] = "FreeSpinsRoundStart";
    SlotMachineState["FREE_SPINS"] = "FreeSpins";
    SlotMachineState["FREE_SPINS_ROUND_END"] = "FreeSpinsRoundEnd";
    SlotMachineState["BIG_WIN"] = "BigWin";
    SlotMachineState["FREE_SPIN_BIG_WIN"] = "FreeSpinBigWin";
    SlotMachineState["COMMUNICATION_ERROR"] = "CommunicationError";
    SlotMachineState["WARNING_POPUP"] = "warningPopup";
})(SlotMachineState || (exports.SlotMachineState = SlotMachineState = {}));


/***/ }),

/***/ 92162:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const WalletEvent_1 = __webpack_require__(63035);
class Wallet extends eventemitter3_1.default {
    constructor(denomination, currency, coinValuesLimits, locale = "en", precison = 2) {
        super();
        this._balance = 0;
        if (coinValuesLimits) {
            this.coinValueLimits = coinValuesLimits;
            this._coinValue = this.coinValueLimits[0];
        }
        Wallet._denomination = denomination;
        Wallet._currencyCode = currency.isoCode;
        Wallet.locale = locale;
        Wallet.precison = precison;
        Wallet.currency = currency;
    }
    get credits() {
        return Math.floor(this._balance / Wallet._denomination);
    }
    get balance() {
        return this._balance;
    }
    set balance(value) {
        if (this._balance == value) {
            return;
        }
        this._balance = value;
        this.emit(WalletEvent_1.WalletEvent.BALANCE_CHANGED);
    }
    set coinValue(value) {
        if (this._coinValue == value) {
            return;
        }
        this._coinValue = value;
        this.emit(WalletEvent_1.WalletEvent.COIN_VALUE_CHANGED, this._coinValue);
    }
    get coinValue() {
        return this._coinValue;
    }
    /**
 * Returns the denomination of the currency in the wallet.
 * @returns The denomination.
 */
    static get denomination() {
        return Wallet._denomination;
    }
    /**
     * Returns the ISO 4217 currency code of the wallet.
     * @returns The currency code.
     */
    static get currencyCode() {
        return Wallet._currencyCode;
    }
    /**
     * Returns a formatted string representation of the given value in the wallet's currency.
     * @param value - The value to format.
     * @returns The formatted currency value.
     */
    static getCurrencyFormattedValue(value, minimumFractionDigits = 2) {
        try {
            const formatter = new Intl.NumberFormat(Wallet.locale, {
                style: "currency",
                currency: Wallet.currencyCode,
                currencyDisplay: "symbol",
                minimumFractionDigits: minimumFractionDigits,
            });
            return formatter.format(value);
        }
        catch (e) { }
    }
    /**
     * Returns a formatted string representation of the given value with the wallet's precision.
     * @param value - The value to format.
     * @returns The formatted value.
     */
    static getFormattedValue(value) {
        const formatter = new Intl.NumberFormat(Wallet.locale, {
            minimumFractionDigits: Wallet.precison,
        });
        return formatter.format(value);
    }
    getCurrencyValue(value, showIsoCode = true, minimumFractionDigits = 0) {
        if (showIsoCode) {
            return Wallet.getCurrencyFormattedValue(value, minimumFractionDigits);
        }
        return Wallet.getFormattedValue(value);
    }
}
Wallet._denomination = 100;
exports["default"] = Wallet;


/***/ }),

/***/ 71967:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoplayEvent = void 0;
var AutoplayEvent;
(function (AutoplayEvent) {
    AutoplayEvent["ENABLED"] = "onAutoplayEnabled";
    AutoplayEvent["DISABLED"] = "onAutoplayDisabled";
    AutoplayEvent["SPINS_LEFT_CHANGED"] = "onAutoplaySpinsLeftChanged";
})(AutoplayEvent || (exports.AutoplayEvent = AutoplayEvent = {}));


/***/ }),

/***/ 96421:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlotMachineEvent = void 0;
var SlotMachineEvent;
(function (SlotMachineEvent) {
    SlotMachineEvent["STATE_CHANGED"] = "onSlotMachineStateChanged";
    SlotMachineEvent["BET_VALUE_CHANGED"] = "onSlotMachineBetValueChanged";
    SlotMachineEvent["GAME_SPEED_LEVEL_CHANGED"] = "onSlotMachineGameSpeedLevelChanged";
})(SlotMachineEvent || (exports.SlotMachineEvent = SlotMachineEvent = {}));


/***/ }),

/***/ 63035:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalletEvent = void 0;
var WalletEvent;
(function (WalletEvent) {
    WalletEvent["BALANCE_CHANGED"] = "onWalletBalanceChanged";
    WalletEvent["NOT_ENOUGH_BALANCE"] = "onWalletNotEnoughBalance";
    WalletEvent["COIN_VALUE_CHANGED"] = "onCoinValueChanged";
})(WalletEvent || (exports.WalletEvent = WalletEvent = {}));


/***/ }),

/***/ 17698:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_spine_1 = __webpack_require__(15091);
class GraphicUtils {
    static init(renderer) {
        this.renderer = renderer;
    }
    static processSymbolsData(symbolsData) {
        if (!this.renderer) {
            throw new Error('Please call init function first!');
        }
        let frameCount = 0;
        const processNextSymbol = (resolve) => {
            if (frameCount >= symbolsData.length) {
                return resolve();
            }
            else {
                const sd = symbolsData[frameCount];
                GraphicUtils.generateIconTexture(sd.staticIcon);
                sd.spinIcon = sd.staticIcon;
                if (sd.spineAnimations) {
                    sd.spineAnimations.skeletonData = AssetsManager_1.default.spine.get(sd.spineAnimations.spineAssetName);
                }
                frameCount++;
                requestAnimationFrame(() => {
                    processNextSymbol(resolve);
                });
            }
        };
        return new Promise((resolve) => {
            requestAnimationFrame(() => {
                processNextSymbol(resolve);
            });
        });
    }
    static generateTextureFromSpine(spineAnimation, filters = []) {
        // caculate texture size
        const localBounds = spineAnimation.getLocalBounds();
        let symbolWidth = 0;
        let symbolHeight = 0;
        if (localBounds.x < 0) {
            symbolWidth = Math.round(Math.max(-localBounds.x, localBounds.width / 2)) * 2 + 10;
        }
        else {
            symbolWidth = Math.round(localBounds.x + localBounds.width) + 10;
        }
        if (localBounds.y < 0) {
            symbolHeight = Math.round(Math.max(-localBounds.y, localBounds.height / 2)) * 2 + 10;
        }
        else {
            symbolHeight = Math.round(localBounds.y + localBounds.height) + 10;
        }
        // place spine in the container center
        const oldX = spineAnimation.position.x;
        const oldY = spineAnimation.position.y;
        const oldVisibility = spineAnimation.visible;
        spineAnimation.visible = true;
        spineAnimation.position.set(symbolWidth / 2, symbolHeight / 2);
        const symbolContainer = new pixi_js_1.Container();
        symbolContainer.addChild(spineAnimation);
        // apply filters if any
        symbolContainer.filters = filters;
        // create render texture and render
        const renderTexture = pixi_js_1.RenderTexture.create({
            width: symbolWidth,
            height: symbolHeight,
        });
        GraphicUtils.renderer.render(symbolContainer, {
            renderTexture: renderTexture
        });
        // cleanup
        spineAnimation.position.set(oldX, oldY);
        spineAnimation.visible = oldVisibility;
        symbolContainer.removeChild(spineAnimation);
        symbolContainer.destroy({
            children: true
        });
        return renderTexture;
    }
    static generateIconTexture(iconData) {
        if (!iconData) {
            return;
        }
        switch (iconData.sourceType) {
            case 'texture':
                iconData.texture = AssetsManager_1.default.textures.get(iconData.assetName);
                // apply blur filter
                if (iconData.blurY) {
                    const originalTexture = iconData.texture;
                    const blurTexture = pixi_js_1.RenderTexture.create({
                        width: originalTexture.width,
                        height: originalTexture.height,
                    });
                    const icon = new pixi_js_1.Sprite(originalTexture);
                    const blurFilter = new pixi_js_1.BlurFilter();
                    blurFilter.blurY = iconData.blurY;
                    // blurFilter.quality = 10;
                    icon.filters = [blurFilter];
                    GraphicUtils.renderer.render(icon, {
                        renderTexture: blurTexture
                    });
                    iconData.texture = blurTexture;
                    // cleanup
                    icon.destroy({
                        children: true
                    });
                }
                break;
            case 'spine':
                // create actual symbol
                const spineSymbol = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get(iconData.assetName));
                if (iconData.animationName) {
                    spineSymbol.state.setAnimation(0, iconData.animationName, false);
                }
                // set skin for symbol
                if (iconData.skinName) {
                    spineSymbol.skeleton.setSkinByName(iconData.skinName);
                }
                // apply blur filter
                const filters = [];
                if (iconData.blurY) {
                    const blurFilter = new pixi_js_1.BlurFilter();
                    blurFilter.blurY = iconData.blurY;
                    blurFilter.quality = 10;
                    filters.push(blurFilter);
                }
                iconData.texture = GraphicUtils.generateTextureFromSpine(spineSymbol, filters);
                break;
        }
    }
}
exports["default"] = GraphicUtils;


/***/ }),

/***/ 85928:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupUtils = void 0;
const engineTween_1 = __webpack_require__(50381);
class PopupUtils {
    static DoScale(dp, params, startScale, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        dp.scale.set(startScale);
        engineTween_1.Tweener.addTween(dp.scale, {
            x: params.value,
            y: params.value,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
    static DoAlphaFade(dp, params, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        engineTween_1.Tweener.addTween(dp, {
            alpha: params.value,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
    static DoChangeY(dp, params, startY, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        dp.y = startY;
        engineTween_1.Tweener.addTween(dp, {
            y: params.value,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
    static DoChangePivotY(dp, params, startY, endY, onStart = null, onComplete = null) {
        var _a, _b;
        if (!params)
            return;
        dp.pivot.y = startY;
        engineTween_1.Tweener.addTween(dp.pivot, {
            y: endY,
            time: (_a = params.time) !== null && _a !== void 0 ? _a : 1,
            transition: (_b = params.transition) !== null && _b !== void 0 ? _b : 'easeOutSine',
            onStart: () => {
                if (onStart)
                    onStart();
            },
            onComplete: () => {
                if (onComplete)
                    onComplete();
            }
        });
    }
}
exports.PopupUtils = PopupUtils;


/***/ }),

/***/ 28409:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiplierSymbolView = void 0;
const pixi_js_1 = __webpack_require__(95894);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const engineTween_1 = __webpack_require__(50381);
const SymbolsList_1 = __webpack_require__(36189);
class MultiplierSymbolView extends pixi_js_1.Container {
    constructor(multiplierId) {
        super();
        this.background = new pixi_js_1.Sprite();
        this.multiplier = new pixi_js_1.BitmapText('', {
            fontName: 'ZodiacRushGoldFont',
            fontSize: 35,
            align: 'center'
        });
        this.id = multiplierId;
        this.addChild(this.background, this.multiplier);
        this.on('added', this.onAdded, this);
    }
    onAdded() {
        var _a;
        this.background.texture = AssetsManager_1.default.textures.get((_a = SymbolsList_1.MultiplierSymbolsList.find(symbol => symbol.id === (this.id === 0 ? 1 : this.id))) === null || _a === void 0 ? void 0 : _a.backgroundTexture);
        switch (this.id) {
            case 0:
                this.alpha = 0;
                break;
            case 1:
                this.alpha = 0;
                break;
            default:
                this.alpha = 1;
                this.changeMultiplier(this.id);
        }
        this.background.anchor.set(0.5);
        this.background.scale.set(3);
        this.multiplier.anchor.set(0.5);
        this.multiplier.y = -15;
    }
    changeMultiplier(multiplierId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                if (multiplierId === 1) {
                    resolve();
                    return;
                }
                if (this.multiplier) {
                    engineTween_1.Tweener.addTween(this.multiplier.scale, {
                        x: 0,
                        y: 0,
                        time: 0.1,
                        onComplete: () => {
                            var _a;
                            this.multiplier.text = (_a = SymbolsList_1.MultiplierSymbolsList.find(symbol => symbol.id === multiplierId)) === null || _a === void 0 ? void 0 : _a.text;
                            engineTween_1.Tweener.addTween(this.multiplier.scale, {
                                x: 1,
                                y: 1,
                                time: 0.2,
                                onComplete: resolve
                            });
                        }
                    });
                }
            });
        });
    }
    setMultiplier(multiplierId, delay = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (multiplierId === this.id || multiplierId > 128 || multiplierId < 0)
                return;
            this.id = multiplierId;
            if (multiplierId !== 0) {
                this.alpha = (multiplierId === 1) ? 0 : 1;
                if (multiplierId === 1) {
                    this.multiplier.scale.set(0);
                }
            }
            return new Promise((resolve) => {
                const tweenOptions = multiplierId === 0 ? {
                    x: 0,
                    y: 0,
                    delay: delay,
                    time: 0.3,
                    onComplete: resolve
                } : {
                    x: 1,
                    y: 1,
                    time: 0.3,
                    onComplete: () => {
                        this.changeMultiplier(multiplierId).then(resolve);
                    }
                };
                engineTween_1.Tweener.addTween(this.scale, tweenOptions);
            });
        });
    }
}
exports.MultiplierSymbolView = MultiplierSymbolView;


/***/ }),

/***/ 12874:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const Utils_1 = __webpack_require__(63948);
const SymbolView_1 = __importDefault(__webpack_require__(14462));
const SymbolViewEvent_1 = __webpack_require__(5207);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const engineTween_1 = __webpack_require__(50381);
const MultiplierSymbolView_1 = __webpack_require__(28409);
class ReelView extends pixi_js_1.Container {
    constructor(le, reel, spinResult, multiplierResult, symbols, symbolSize, fallingCascade) {
        super();
        this.startTiltSize = 60;
        this.startTiltTime = 0.3;
        this.blurSpinTime = 0.5;
        this.cascadeTime = 0.6;
        this.gameSpeedLevel = 0;
        this.fallingCascade = false;
        this.tweenPosition = { x: 0, y: 0 };
        this.winValue = '';
        this.multipliervalue = 0;
        this.spinSound = null;
        this.anticipationSound = null;
        LayoutBuilder_1.default.create(le, this);
        this.spinContainer.mask = this.reelMask;
        this.reel = reel;
        this.spinResult = spinResult;
        this.multiplierResult = multiplierResult;
        this.symbols = symbols;
        this.symbolSize = symbolSize;
        this.mainStripe = new pixi_js_1.Container();
        this.spinContainer.addChild(this.mainStripe);
        this.spinStripe1 = new pixi_js_1.Container();
        this.spinContainer.addChild(this.spinStripe1);
        this.spinStripe2 = new pixi_js_1.Container();
        this.spinContainer.addChild(this.spinStripe2);
        if (this.anticipationAnimation)
            this.anticipationAnimation.alpha = 0;
        this.output = [];
        for (let i = 0; i < this.reel.numRows; i++) {
            this.output.push(this.spinResult[i]);
        }
        this.multiplierOutput = [];
        for (let i = 0; i < this.reel.numRows; i++) {
            this.multiplierOutput.push(this.multiplierResult[i]);
        }
        this.fallingCascade = fallingCascade;
        this
            .on('added', this.onAdded, this)
            .on('removed', this.onRemoved, this);
        // // TESTING CODE
        // this.interactive = true;
        // let s: boolean = true;
        // this.on('pointerup', () => {
        //     console.log('hello');
        //     if (s) {
        //         this.spin();
        //     } else {
        //         this.stop([randomArrayElement(this.reel.availableSymbols), randomArrayElement(this.reel.availableSymbols), randomArrayElement(this.reel.availableSymbols)]);
        //     }
        //     s = !s;
        // });
    }
    // PUBLIC API
    spin(gameSpeedLevel = 0, startDelay = 0, spinSound = null) {
        this.reset();
        this.gameSpeedLevel = gameSpeedLevel;
        const startTiltTime = this.gameSpeedLevel == 0 ? this.startTiltTime : 0;
        const multiplierDisappearDelay = this.gameSpeedLevel === 0 ? 1 : 0.2;
        engineTween_1.Tweener.addTween(this.mainStripe, {
            y: this.gameSpeedLevel == 0 ? -this.symbolSize.y - this.startTiltSize : -this.symbolSize.y,
            time: startTiltTime,
            transition: 'easeOutQuad',
            delay: startDelay,
            // onStart:()=>{
            //     if(this.fallingCascade) {
            //         this.visibleSymbols.forEach((symbol, index) => {
            //             symbol.animateY(0, (this.visibleSymbols[this.visibleSymbols.length - 1].y + this.symbolSize.y), 1.2, (this.visibleSymbols.length - (index + 1)) * 0.05);
            //         });
            //     }
            // },
            onComplete: () => {
                if (spinSound) {
                    this.spinSound = SoundManager_1.default.loop(spinSound);
                }
            }
        });
        engineTween_1.Tweener.addTween(this.mainStripe, {
            y: this.symbolSize.y * (this.reel.numRows + 1),
            time: 0.4,
            transition: 'easeInSine',
            delay: startTiltTime + startDelay
        });
        this.buildSpinStripe(this.spinStripe1, this.output.length + 2);
        this.buildSpinStripe(this.spinStripe2, this.output.length + 2);
        this.spinStripe1.y = -this.spinStripe1.height * 2;
        this.spinStripe2.y = -this.spinStripe2.height * 2;
        this.spinContainer.addChild(this.spinStripe1);
        this.spinContainer.addChild(this.spinStripe2);
        this.spinBlur(this.spinStripe1, startTiltTime + 0.1 + startDelay);
    }
    stop(output, stopSound = null) {
        return __awaiter(this, void 0, void 0, function* () {
            engineTween_1.Tweener.removeTweens(this.mainStripe);
            engineTween_1.Tweener.removeTweens(this.spinStripe1);
            engineTween_1.Tweener.removeTweens(this.spinStripe2);
            this.output = output;
            const stopTime = this.gameSpeedLevel == 0 ? 0.3 : 0.2;
            return new Promise((resolve) => {
                engineTween_1.Tweener.addTween(this.spinStripe1, {
                    y: this.symbolSize.y * (this.reel.numRows + 1),
                    time: stopTime,
                    transition: 'easeOutQuad',
                });
                engineTween_1.Tweener.addTween(this.spinStripe2, {
                    y: this.symbolSize.y * (this.reel.numRows + 1),
                    time: stopTime,
                    transition: 'easeOutQuad'
                });
                this.buildMainStripe(this.output.slice());
                this.mainStripe.y = -this.mainStripe.height - this.symbolSize.y;
                const fellPromises = [];
                const fallingCascadeLandAnimationTime = 0.03;
                const finalStopTime = (this.gameSpeedLevel == 0 && this.fallingCascade) ? ((this.visibleSymbols.length + 1) * fallingCascadeLandAnimationTime) : 0.15;
                engineTween_1.Tweener.addTween(this.mainStripe, {
                    // y: this.gameSpeedLevel == 0 ? -this.symbolSize.y + this.startTiltSize:-this.symbolSize.y,
                    y: this.fallingCascade ? -this.symbolSize.y : this.gameSpeedLevel == 0 ? -this.symbolSize.y + this.startTiltSize : -this.symbolSize.y + (this.startTiltSize / 3),
                    time: stopTime,
                    transition: 'easeOutQuad',
                    onStart: () => {
                        if (this.fallingCascade) {
                            this.visibleSymbols.forEach((symbol, index) => {
                                fellPromises.push(symbol.animateY(-300, 0, this.gameSpeedLevel == 0 ? stopTime : 0.01, (this.gameSpeedLevel == 0 ? (this.visibleSymbols.length - (index + 1)) * fallingCascadeLandAnimationTime : 0)));
                            });
                        }
                    }
                });
                Promise.all(fellPromises).then(() => {
                    engineTween_1.Tweener.addTween(this.mainStripe, {
                        y: -this.symbolSize.y,
                        time: finalStopTime,
                        transition: 'easeInOutQuad',
                        delay: stopTime,
                        onStart: () => {
                            if (this.spinSound) {
                                this.spinSound.stop();
                                this.spinSound = null;
                            }
                            this.visibleSymbols.forEach((symbol) => {
                                const landSound = symbol.animateLanding();
                                if (landSound) {
                                    SoundManager_1.default.play(landSound);
                                }
                            });
                            if (stopSound) {
                                SoundManager_1.default.play(stopSound);
                            }
                        },
                        onComplete: () => {
                            this.anticipationVisibility(0);
                            this.spinContainer.removeChild(this.spinStripe1);
                            this.spinContainer.removeChild(this.spinStripe2);
                            resolve();
                        }
                    });
                });
            });
        });
    }
    anticipationVisibility(value, delay = 0, anticipationSound = null) {
        if (!this.anticipationAnimation)
            return;
        engineTween_1.Tweener.removeTweens(this.anticipationAnimation);
        engineTween_1.Tweener.addTween(this.anticipationAnimation, {
            alpha: value,
            delay: delay,
            time: 0.15,
            transition: 'easeOutSine',
            onStart: () => {
                if (value === 1) {
                    this.anticipationAnimation.gotoAndPlay(0);
                    this.anticipationAnimation.visible = true;
                    this.anticipationSound = SoundManager_1.default.play(anticipationSound);
                }
            },
            onComplete: () => {
                if (value === 0) {
                    this.anticipationAnimation.stop();
                    this.anticipationAnimation.visible = false;
                    if (this.anticipationSound)
                        this.anticipationSound.stop();
                }
            }
        });
    }
    get numRows() {
        return this.reel.numRows;
    }
    getVisibleSymbols() {
        return [...this.visibleSymbols];
    }
    changeSymbolVisiblity(symbolIndex, visible, transitionTime = 0) {
        // this.mainStripe.cacheAsBitmap = false;
        const symbol = this.visibleSymbols[symbolIndex];
        engineTween_1.Tweener.addTween(symbol, {
            alpha: visible ? 1 : 0,
            time: transitionTime,
            onComplete: () => {
                symbol.visible = visible;
            }
        });
        // this.mainStripe.cacheAsBitmap = true;
    }
    multiplierAnimation(multiplierTargetOutput) {
        return __awaiter(this, void 0, void 0, function* () {
            const multiplierPromises = [];
            multiplierPromises.push(this.setMultipliers(multiplierTargetOutput));
            yield Promise.all(multiplierPromises);
        });
    }
    cascade(symbolDisappearPattern, targetOutput, winningPattern) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            // Make symbols disappear and show win text for each disappearing symbol
            const destroyedSymbols = [];
            for (let i = 0; i < symbolDisappearPattern.length; i++) {
                if (symbolDisappearPattern[i]) {
                    const destroyedSymbol = this.visibleSymbols[i];
                    // Remove the symbol
                    this.mainStripe.removeChild(destroyedSymbol);
                    destroyedSymbols.push(destroyedSymbol);
                }
            }
            destroyedSymbols.forEach((s) => {
                (0, Utils_1.removeArrayElement)(this.visibleSymbols, s);
                s.destroy();
            });
            // create missing symbols on top
            const numMissingSymbols = targetOutput.length - this.visibleSymbols.length;
            for (let i = numMissingSymbols - 1; i >= 0; i--) {
                const symbolX = Math.floor(this.symbolSize.x / 2);
                const symbolY = (i - numMissingSymbols) * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
                const symbolData = this.symbols.get(targetOutput[i]);
                const symbolView = new SymbolView_1.default(symbolData);
                symbolView.position.set(symbolX, symbolY);
                this.mainStripe.addChildAt(symbolView, 0);
                this.visibleSymbols.unshift(symbolView);
            }
            // drop symbols down
            return new Promise((resolve) => {
                let cascading = false;
                this.visibleSymbols.forEach((symbol, index) => {
                    const targetSymbolY = (index + 1) * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
                    if (symbol.y != targetSymbolY) {
                        cascading = true;
                        engineTween_1.Tweener.addTween(symbol, {
                            y: targetSymbolY,
                            time: this.cascadeTime,
                            transition: 'easeInOutQuad'
                        });
                    }
                });
                if (cascading) {
                    engineTween_1.Tweener.addCaller(this, {
                        count: 1,
                        time: this.cascadeTime,
                        onComplete: () => {
                            resolve();
                        }
                    });
                }
                else {
                    resolve();
                }
            });
        });
    }
    reset() {
        engineTween_1.Tweener.removeTweens(this.mainStripe);
        engineTween_1.Tweener.removeTweens(this.spinStripe1);
        engineTween_1.Tweener.removeTweens(this.spinStripe2);
        for (const s of this.visibleSymbols) {
            s.off(SymbolViewEvent_1.SymbolViewEvent.WIN_ANIMATION_COMPLETE);
            s.reset();
        }
    }
    swapSymbol(symbolInReelId, symbol, transitionTime = 0, delayTime = 0, transitionSound = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const oldSymbol = this.visibleSymbols[symbolInReelId];
            return new Promise((resolve) => {
                this.visibleSymbols[symbolInReelId] = symbol;
                symbol.parent = oldSymbol.parent;
                symbol.originalParentInfo = oldSymbol.originalParentInfo;
                symbol.position = oldSymbol.position;
                symbol.alpha = 0;
                this.mainStripe.addChildAt(symbol, this.mainStripe.getChildIndex(oldSymbol) + 1);
                engineTween_1.Tweener.addTween(symbol, {
                    alpha: 1,
                    time: transitionTime,
                    delay: delayTime,
                    onStart: () => {
                        if (transitionSound) {
                            SoundManager_1.default.play(transitionSound.id);
                        }
                    },
                    onComplete: () => {
                        oldSymbol.visible = false;
                        this.mainStripe.removeChildAt(this.mainStripe.getChildIndex(oldSymbol));
                        oldSymbol.destroy();
                        resolve();
                    }
                });
            });
        });
    }
    // PRIVATE API
    onAdded() {
        this.buildMainStripe(this.output.slice());
        this.createBackgroundMultipliers(this.multiplierOutput.slice());
        this.mainStripe.y = -this.symbolSize.y;
    }
    onRemoved() {
        // implement in derived class if needed
    }
    createBackgroundMultipliers(output) {
        this.multiplierSymbols = [];
        output.forEach((multiplierId, index) => {
            const multiplierSymbolView = new MultiplierSymbolView_1.MultiplierSymbolView(multiplierId % 1000);
            multiplierSymbolView.y = index * this.symbolSize.y;
            this.multiplierSymbols.push(multiplierSymbolView);
            this.multiplierContainer.addChild(multiplierSymbolView);
        });
    }
    setMultipliers(output, delay = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const multiplierPromises = [];
            output.forEach((multiplierId, index) => {
                multiplierPromises.push(this.multiplierSymbols[index].setMultiplier(multiplierId % 1000, delay));
            });
            yield Promise.all(multiplierPromises);
        });
    }
    removeAllMultipliers(delay = 0) {
        this.multiplierSymbols.forEach((ms) => { ms.setMultiplier(0, delay); });
    }
    buildMainStripe(output) {
        // this.mainStripe.cacheAsBitmap = false;
        if (!this.fallingCascade) {
            output.push((0, Utils_1.randomArrayElement)(this.reel.availableSymbols));
            output.unshift((0, Utils_1.randomArrayElement)(this.reel.availableSymbols));
        }
        // clear stripe
        this.visibleSymbols = [];
        while (this.mainStripe.children.length) {
            const symbolIcon = this.mainStripe.removeChildAt(0);
            symbolIcon.destroy();
        }
        for (let i = 0; i < output.length; i++) {
            const symbolData = this.symbols.get(output[i]);
            const symbolX = Math.floor(this.symbolSize.x / 2);
            const symbolY = (i + (this.fallingCascade ? 1 : 0)) * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
            if ((i == 0 || i == this.reel.numRows + 1) && !this.fallingCascade) {
                // build additional textures
                const symbolSprite = new pixi_js_1.Sprite(symbolData.staticIcon.texture);
                symbolSprite.pivot.set(Math.floor(symbolSprite.width / 2), Math.floor(symbolSprite.height / 2));
                symbolSprite.position.set(symbolX, symbolY);
                this.mainStripe.addChild(symbolSprite);
            }
            else {
                // build main SymbolViews
                let symbolView;
                if (symbolData === null || symbolData === void 0 ? void 0 : symbolData.specialViewClass) {
                    symbolView = new symbolData.specialViewClass(symbolData);
                }
                else {
                    symbolView = new SymbolView_1.default(symbolData);
                }
                symbolView.position.set(symbolX, symbolY);
                this.mainStripe.addChild(symbolView);
                this.visibleSymbols.push(symbolView);
                const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
                const symbolMultiplierDescription = sm.description.wildcards.find((multiplierSymbolDesc) => {
                    return multiplierSymbolDesc.symbolId === symbolView.data.id;
                });
                if (!symbolMultiplierDescription)
                    continue;
                const multiplier = this.createMultiplier(symbolMultiplierDescription.multiplier);
                symbolView.addChild(multiplier);
            }
        }
        // this.mainStripe.cacheAsBitmap = true;
    }
    createMultiplier(value) {
        const style = new pixi_js_1.TextStyle({
            fontFamily: AssetsManager_1.default.webFonts.get('LongdonDecorative').family,
            fill: [
                '#FFB200',
                '#FFFF00'
            ],
            fontSize: 40,
            lineJoin: 'round',
            stroke: '#FFD911',
            strokeThickness: 4,
            dropShadow: true,
            dropShadowColor: '#000000',
            dropShadowAlpha: 40,
            dropShadowAngle: 0.2,
            dropShadowDistance: 8
        });
        const multiplier = new pixi_js_1.Text(`${value}x`, style);
        multiplier.name = 'multipliern';
        (0, Utils_1.autoscaleText)(multiplier, 40, 150, 65);
        multiplier.anchor.set(0.5, 0.5);
        multiplier.y += 20;
        // multiplier.scale.set(0, 0);
        return multiplier;
    }
    buildSpinStripe(container, stripeLength) {
        container.cacheAsBitmap = false;
        const symbols = [];
        while (symbols.length != stripeLength) {
            symbols.push((0, Utils_1.randomArrayElement)(this.reel.availableSymbols));
        }
        while (container.children.length < symbols.length) {
            container.addChild(new pixi_js_1.Sprite());
        }
        for (let i = 0; i < symbols.length; i++) {
            const symbolId = symbols[i];
            if (!this.symbols.has(symbolId)) {
                throw new Error(`No SymbolData with id: ${symbolId}`);
            }
            let texture = this.symbols.get(symbolId).staticIcon.texture;
            const symbolData = this.symbols.get(symbolId);
            if (blur && symbolData.spinIcon) {
                if (symbolData.specialViewClass) {
                    const dummySymbol = new symbolData.specialViewClass(symbolData);
                    texture = dummySymbol.spinIconTexture;
                    dummySymbol.destroy();
                }
                else {
                    texture = symbolData.spinIcon.texture;
                }
            }
            const symbolSprite = container.getChildAt(i);
            symbolSprite.texture = texture;
            symbolSprite.pivot.set(Math.floor(symbolSprite.width / 2), Math.floor(symbolSprite.height / 2));
            symbolSprite.x = Math.floor(this.symbolSize.x / 2);
            symbolSprite.y = i * this.symbolSize.y + Math.floor(this.symbolSize.y / 2);
            // container.addChild(symbolSprite);
        }
        container.cacheAsBitmap = true;
    }
    spinBlur(blurStripe, startDelay = 0, startPosition = null) {
        this.buildSpinStripe(blurStripe, this.output.length + 2);
        if (startPosition === null) {
            blurStripe.y = -blurStripe.height - this.symbolSize.y;
        }
        else {
            blurStripe.y = startPosition;
        }
        let trackPosition = true;
        engineTween_1.Tweener.addTween(blurStripe, {
            y: this.symbolSize.y * (this.reel.numRows + 1),
            time: this.blurSpinTime,
            transition: 'linear',
            delay: startDelay,
            onUpdate: () => {
                if (blurStripe.y > -this.symbolSize.y && trackPosition) {
                    trackPosition = false;
                    if (blurStripe == this.spinStripe1) {
                        this.spinBlur(this.spinStripe2, 0, blurStripe.y - this.spinStripe2.height);
                    }
                    else {
                        this.spinBlur(this.spinStripe1, 0, blurStripe.y - this.spinStripe1.height);
                    }
                }
            }
        });
    }
}
exports["default"] = ReelView;


/***/ }),

/***/ 65175:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const ReelView_1 = __importDefault(__webpack_require__(12874));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const ReelsViewEvent_1 = __webpack_require__(21230);
const SymbolViewEvent_1 = __webpack_require__(5207);
const Utils_1 = __webpack_require__(63948);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const engineTween_1 = __webpack_require__(50381);
const pixi_spine_1 = __webpack_require__(15091);
class ReelsView extends pixi_js_1.Container {
    constructor(le, reelDescription, spinResult, symbols, reelConfiguration = ReelsView.defaultReelConfiguration) {
        super();
        this.reelViews = [];
        this.symbols = new Map();
        this.gameSpeedLevel = 0;
        this.symbolWinAnimations = [];
        this.winFrameAnimations = [];
        this.anticipationDelay = 0;
        this.winTextStyle = new pixi_js_1.TextStyle({
            fontFamily: AssetsManager_1.default.webFonts.get('JockeyOne').family, //'Arial', // Or a custom font
            fontSize: 40,
            fill: '#0c1b48',
            stroke: '#FFFFFF',
            strokeThickness: 8,
            // fontWeight: 'bold',
            dropShadow: true,
            dropShadowColor: '#000000',
            dropShadowAlpha: 0.5,
            dropShadowDistance: 3,
            lineJoin: 'round',
        });
        this.reelSetDescription = reelDescription;
        this.spinResult = spinResult;
        this.reelConfiguration = reelConfiguration;
        for (const symbol of symbols) {
            this.symbols.set(symbol.id, symbol);
        }
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.reelsContainer.mask = this.reelsMask;
        if (this.symbolAnimationContainerMask) {
            this.symbolAnimationContainer.mask = this.symbolAnimationContainerMask;
        }
        const winFrameAnimation = this.reelConfiguration.winFrameAnimation;
        if (winFrameAnimation) {
            for (let i = 0; i < this.reelViews.length; i++) {
                const rv = this.reelViews[i];
                this.winFrameAnimations.push([]);
                for (let j = 0; j < rv.numRows; j++) {
                    const winFrameSpine = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('win-frame-animation'));
                    winFrameSpine.visible = false;
                    this.winFrameAnimations[i].push(winFrameSpine);
                    this.winFrameAnimationContainer.addChild(winFrameSpine);
                }
            }
        }
    }
    // PUBLIC API
    spin(gameSpeedLevel, soundData = null) {
        this.reset();
        this.gameSpeedLevel = gameSpeedLevel;
        this.reelViews.forEach((reelView, index) => {
            reelView.spin(this.gameSpeedLevel, (this.reelConfiguration.fallingCascade && this.gameSpeedLevel == 0) ? (0.1 * index) : 0, soundData);
        });
        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.REELS_STARTED).dispatch();
        if (this.gameSpeedLevel == 0) {
            engineTween_1.Tweener.addCaller(this, {
                count: 1,
                time: 1,
                onComplete: () => {
                    if (this.gameSpeedLevel == 0)
                        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_TIME_LAPSED).dispatch();
                }
            });
        }
        else {
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_TIME_LAPSED).dispatch();
        }
    }
    stop(output, sounds, gameSpeedLevel = -1, anticipationReelIds = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (gameSpeedLevel != -1) {
                this.gameSpeedLevel = gameSpeedLevel;
            }
            this.anticipationDelay = 0;
            const stopPromises = [];
            for (let i = 0; i < output.result.length; i++) {
                const triggerAnticipation = (anticipationReelIds && anticipationReelIds.length > 0 && anticipationReelIds.includes(i));
                stopPromises.push(this.stopReel(i, output.result[i], sounds, triggerAnticipation));
            }
            yield Promise.all(stopPromises);
        });
    }
    animateWins(winningSymbols, times = 1, visibleOnComplete = true, wallet) {
        winningSymbols.forEach((winningSymbol) => {
            winningSymbol.forEach((cluster) => {
                const symbolPattern = cluster.pattern;
                const winningSymbolsPos = [];
                const onePositions = [];
                // Step 1: Collect all positions with '1' in symbolPattern
                for (let i = 0; i < symbolPattern.length; i++) {
                    for (let j = 0; j < symbolPattern[i].length; j++) {
                        if (symbolPattern[i][j] === 1) {
                            onePositions.push({ i, j });
                        }
                    }
                }
                // Step 2: Calculate the "center" of the cluster
                const center = onePositions.reduce((acc, pos) => {
                    acc.i += pos.i;
                    acc.j += pos.j;
                    return acc;
                }, { i: 0, j: 0 });
                center.i = Math.round(center.i / onePositions.length);
                center.j = Math.round(center.j / onePositions.length);
                // Step 3: Find the position closest to the calculated center
                let closestIndex = onePositions[0];
                let minDistance = Infinity;
                onePositions.forEach(pos => {
                    const distance = Math.abs(center.i - pos.i) + Math.abs(center.j - pos.j);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = pos;
                    }
                });
                // Step 4: Execute animation logic for symbols in the cluster
                for (let i = 0; i < symbolPattern.length; i++) {
                    const reelView = this.reelViews[i];
                    const reelPattern = symbolPattern[i];
                    const visibleSymbols = reelView.getVisibleSymbols();
                    for (let j = 0; j < reelPattern.length; j++) {
                        if (reelPattern[j] === 1) {
                            const symbol = visibleSymbols[j];
                            this.symbolWinAnimations.push(symbol);
                            winningSymbolsPos.push(symbol.getGlobalPosition());
                            let symbolNewParent = this.symbolAnimationContainer;
                            symbol.reattachTo(symbolNewParent);
                            // Run showWinTextAtSymbol only for the symbol closest to the center
                            if (i === closestIndex.i && j === closestIndex.j && cluster.payout !== 0) {
                                this.showWinTextAtSymbol(symbol, cluster, wallet);
                            }
                            symbol.once(SymbolViewEvent_1.SymbolViewEvent.WIN_ANIMATION_COMPLETE, () => {
                                symbol.setStaticIconVisibility(visibleOnComplete);
                                symbol.reset();
                                this.resetWinFrameSpine(i, j);
                                (0, Utils_1.removeArrayElement)(this.symbolWinAnimations, symbol);
                                if (!this.symbolWinAnimations.length) {
                                    this.emit(ReelsViewEvent_1.ReelsViewEvent.WIN_ANIMATION_COMPLETE);
                                }
                            });
                            symbol.animateWin(times);
                            // Handle win frame animations if enabled
                            if (symbol.isWinFrameEnabled() && this.winFrameAnimations.length) {
                                const winFrameAnimation = this.winFrameAnimations[i][j];
                                winFrameAnimation.position.set(symbol.x, symbol.y);
                                winFrameAnimation.state.setAnimation(0, 'win', false);
                                winFrameAnimation.visible = true;
                            }
                        }
                    }
                }
            });
        });
    }
    showWinTextAtSymbol(symbolView, cluster, wallet) {
        const MultiplierVal = cluster.multiplier === 1 ? '' : ' X ' + cluster.multiplier;
        const winvalue = (Number(cluster.payout) / cluster.multiplier).toString();
        const winText = new pixi_js_1.Text(`${wallet.getCurrencyValue(winvalue, true)}` + `${MultiplierVal}`, Object.assign(Object.assign({}, this.winTextStyle), { fontSize: 48 // Increase font size for visibility
         }));
        winText.anchor.set(0.5, 0.5);
        winText.position.set(symbolView.x, symbolView.y);
        // Add the win text to the main stripe
        this.addChild(winText);
        // Animate the win text
        engineTween_1.Tweener.addTween(winText, {
            y: winText.y - 40,
            time: 0.6,
            transition: 'linear', // Smooth easing for the first animation
            onStart: () => {
                winText.alpha = 1;
            },
            onUpdate: () => {
                winText.alpha -= 0.005;
                if (cluster.multiplier != 1) {
                    winText.scale.x -= 0.005;
                    winText.scale.y -= 0.005;
                }
                else {
                    winText.scale.x += 0.0005;
                    winText.scale.y += 0.0005;
                }
            },
            onComplete: () => {
                // Update the text without delay
                winText.text = wallet.getCurrencyValue((Number(winvalue) * cluster.multiplier).toString(), true);
                // Start the second tween with smooth transition and slight scaling down
                engineTween_1.Tweener.addTween(winText, {
                    y: winText.y - 40,
                    time: 0.9,
                    transition: 'linear',
                    onUpdate: () => {
                        if (cluster.multiplier != 1) {
                            winText.scale.x += 0.005;
                            winText.scale.y += 0.005;
                            winText.alpha += 0.001;
                        }
                    },
                    onComplete: () => {
                        winText.destroy();
                    }
                });
            }
        });
    }
    cascade(symbolDisappearPattern, targetOutput, winningPattern) {
        return __awaiter(this, void 0, void 0, function* () {
            const cascadePromises = [];
            for (let i = 0; i < symbolDisappearPattern.length; i++) {
                cascadePromises.push(this.reelViews[i].cascade(symbolDisappearPattern[i], targetOutput[i], winningPattern));
            }
            yield Promise.all(cascadePromises);
        });
    }
    multiplierAnimation(multiplierTargetOutput) {
        return __awaiter(this, void 0, void 0, function* () {
            const multiplierPromises = [];
            for (let i = 0; i < multiplierTargetOutput.length; i++) {
                multiplierPromises.push(this.reelViews[i].setMultipliers(multiplierTargetOutput[i]));
            }
            yield Promise.all(multiplierPromises);
        });
    }
    reset() {
        for (const symbol of this.symbolWinAnimations) {
            symbol.off(SymbolViewEvent_1.SymbolViewEvent.WIN_ANIMATION_COMPLETE);
            symbol.reset();
        }
        this.symbolWinAnimations = [];
        if (this.winFrameAnimations.length) {
            for (let i = 0; i < this.reelViews.length; i++) {
                const rv = this.reelViews[i];
                for (let j = 0; j < rv.numRows; j++) {
                    this.resetWinFrameSpine(i, j);
                }
            }
        }
    }
    getReelViews() {
        return [...this.reelViews];
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ReelView':
                const reelDescription = this.reelSetDescription.reels[this.reelViews.length];
                const spinResult = this.spinResult.result[this.reelViews.length];
                const multiplierResult = this.spinResult.multipliers[this.reelViews.length];
                instance = new ReelView_1.default(le, reelDescription, spinResult, multiplierResult, this.symbols, this.reelConfiguration.symbolSize, this.reelConfiguration.fallingCascade);
                this.reelViews.push(instance);
                break;
        }
        return instance;
    }
    stopReel(index, output, sounds, anticipation) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const rv = this.reelViews[index];
                let stopDelay = (this.reelConfiguration.fallingCascade && this.gameSpeedLevel == 0) ? index * 0.12 : 0;
                if (anticipation && this.gameSpeedLevel === 0) {
                    rv.anticipationVisibility(1, stopDelay + this.anticipationDelay, sounds.anticipationSoundData);
                    this.anticipationDelay += (stopDelay + this.reelConfiguration.anticipationTime);
                }
                stopDelay += this.anticipationDelay;
                engineTween_1.Tweener.addTween(rv, {
                    time: stopDelay,
                    onComplete: () => {
                        rv.stop(output, sounds.stopSoundData)
                            .then(() => {
                            resolve();
                        });
                    }
                });
            });
        });
    }
    removeMultipliers() {
        this.reelViews.forEach((rv) => {
            rv.removeAllMultipliers(this.gameSpeedLevel === 0 ? 1 : 0.2);
        });
    }
    resetWinFrameSpine(indexX, indexY) {
        if (!this.winFrameAnimations || this.winFrameAnimations.length === 0)
            return;
        const winFrameAnimation = this.winFrameAnimations[indexX][indexY];
        winFrameAnimation.state.setEmptyAnimations(0);
        winFrameAnimation.visible = false;
    }
}
ReelsView.defaultReelConfiguration = {
    symbolSize: new pixi_js_1.Point(212, 212),
    winFrameAnimation: null,
    anticipationTime: 0,
    fallingCascade: false
};
exports["default"] = ReelsView;


/***/ }),

/***/ 14462:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const SymbolViewEvent_1 = __webpack_require__(5207);
const pixi_spine_1 = __webpack_require__(15091);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const engineTween_1 = __webpack_require__(50381);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
class SymbolView extends pixi_js_1.Container {
    constructor(data) {
        var _a, _b, _c, _d;
        super();
        this.winAnimationLoopCount = 0;
        this.winAnimationCompleteLimit = 0;
        this.originalParentInfo = {
            parent: null,
            childIndex: -1
        };
        this.data = data;
        this.staticIcon = new pixi_js_1.Sprite(this.data.staticIcon.texture);
        this.staticIcon.anchor.set(0.5, 0.5);
        this.addChild(this.staticIcon);
        if (this.data.id === 25) {
            this.scale.set(1.4);
        }
        if (this.data.id > 1000) {
            console.log(this.data.id);
        }
        const winAnimationName = (_a = this.data.spineAnimations) === null || _a === void 0 ? void 0 : _a.winAnimationName;
        const idleAnimationName = (_b = this.data.spineAnimations) === null || _b === void 0 ? void 0 : _b.idleAnimationName;
        const stopAnimationName = (_c = this.data.spineAnimations) === null || _c === void 0 ? void 0 : _c.stopAnimationName;
        if (this.data.spineAnimations) {
            this.spineAnimation = new pixi_spine_1.Spine(this.data.spineAnimations.skeletonData);
            this.spineAnimation.visible = false;
            this.addChild(this.spineAnimation);
            if (this.data.spineAnimations.skinName)
                this.spineAnimation.skeleton.setSkinByName(this.data.spineAnimations.skinName);
            const mixTime = (_d = this.data.spineAnimations) === null || _d === void 0 ? void 0 : _d.mixTime;
            if (mixTime > 0) {
                if ((winAnimationName && typeof winAnimationName != 'undefined') && (idleAnimationName && typeof idleAnimationName != 'undefined') && typeof winAnimationName == 'string')
                    this.spineAnimation.state.data.setMix(winAnimationName, idleAnimationName, mixTime ? mixTime : 0.15);
                if ((stopAnimationName && typeof stopAnimationName != 'undefined') && (winAnimationName && typeof winAnimationName != 'undefined') && typeof winAnimationName == 'string')
                    this.spineAnimation.state.data.setMix(stopAnimationName, winAnimationName, mixTime ? mixTime : 0.15);
            }
            this.spineAnimation.state.addListener({
                complete: (entry) => {
                    // nasty hack for faulty spine events system implementation
                    setTimeout(() => {
                        if (!entry.animation)
                            return;
                        if (entry.animation.name == stopAnimationName || entry.animation.name == idleAnimationName)
                            this.playAnimation(this.spineAnimation, idleAnimationName);
                        if (typeof winAnimationName === 'string') {
                            this.onWinAnimationLoop();
                            return;
                        }
                        if (entry.animation.name == winAnimationName[winAnimationName.length - 1]) {
                            this.onWinAnimationLoop();
                        }
                    }, 0);
                }
            });
        }
        if (data.destroyAnimation) {
            this.destroyAnimation = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get(data.destroyAnimation.spineAssetName));
            this.destroyAnimation.state.setEmptyAnimations(0);
            this.destroyAnimation.visible = false;
            this.addChild(this.destroyAnimation);
            this.spineAnimation.state.addListener({
                complete: (entry) => {
                    // Assuming that the last element in spineAnimations is the destroy animation of the Symbol
                    if (entry.animation.name === winAnimationName[winAnimationName.length - 1]) {
                        this.playAnimation(this.destroyAnimation, this.data.destroyAnimation.animationName);
                    }
                }
            });
        }
        if (data.spriteAnimations) {
            // this.winAnimation = this.initializeAnimatedSpriteFromData(this.data.spriteAnimations.winAnimation);
            // this.idleAnimation = this.initializeAnimatedSpriteFromData(this.data.spriteAnimations.idleAnimation);
            // this.stopAnimation = this.initializeAnimatedSpriteFromData(this.data.spriteAnimations.stopAnimation);
            // [this.winAnimation, this.idleAnimation, this.stopAnimation].forEach((animation: AnimatedSprite) => {
            //     if (animation === null)
            //         return;
            //     this.addChild(animation);
            // });
            // [this.winAnimation, this.idleAnimation].forEach((animation: AnimatedSprite) => {
            //     animation.loop = true;
            //     animation.onLoop = () => {
            //         this.onWinAnimationLoop();
            //     };
            // })
        }
    }
    // PUBLIC API
    get spinIconTexture() {
        return this.data.spinIcon.texture;
    }
    animateWin(times = 1) {
        this.staticIcon.visible = false;
        this.winAnimationCompleteLimit = times;
        this.winAnimationLoopCount = 0;
        // this.resetAnimation(this.stopAnimation);
        //Play spine animation
        this.playAnimation(this.spineAnimation, this.data.spineAnimations.winAnimationName, times > 1);
        //Play sprite animation
        //this.playAnimation(this.winAnimation);
        SoundManager_1.default.play(this.data.winSound);
        return this.data.winSound;
    }
    animateY(startOffset, endOffset, time = 0.4, delay = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const defaultPos = this.y;
                this.y = defaultPos + startOffset;
                engineTween_1.Tweener.addTween(this, {
                    y: defaultPos + endOffset,
                    time: time,
                    transition: 'easeOutBack',
                    delay: delay,
                    onComplete: () => {
                        resolve();
                    }
                });
            });
        });
    }
    animateLanding() {
        //Play spine animation
        this.playAnimation(this.spineAnimation, this.data.spineAnimations.stopAnimationName);
        //Play sprite animation
        //this.playAnimation(this.stopAnimation);
        return this.data.landSound;
    }
    reset() {
        engineTween_1.Tweener.removeTweens(this);
        this.staticIcon.visible = true;
        this.winAnimationLoopCount = 0;
        this.winAnimationCompleteLimit = 1;
        //Reset spine if exists
        this.resetAnimation(this.spineAnimation);
        //Reset sprite animations if exists
        // this.resetAnimation(this.stopAnimation);
        // this.resetAnimation(this.winAnimation);
        // this.resetAnimation(this.idleAnimation);
        if (this.originalParentInfo.parent) {
            this.swapParentKeepingGlobalPosition(this.originalParentInfo.parent, this.originalParentInfo.childIndex);
            this.originalParentInfo.parent = null;
            this.originalParentInfo.childIndex = -1;
        }
    }
    destroy(_options) {
        this.reset();
        [this.spineAnimation, this.destroyAnimation].forEach((child) => {
            if (child != null) {
                this.removeChild(child);
                child.destroy();
            }
        });
        super.destroy(_options);
    }
    reattachTo(newParent) {
        if (!this.originalParentInfo.parent) {
            this.originalParentInfo.parent = this.parent;
            this.originalParentInfo.childIndex = this.parent.children.indexOf(this) - 1;
        }
        this.swapParentKeepingGlobalPosition(newParent);
    }
    setStaticIconVisibility(visible) {
        this.staticIcon.alpha = visible ? 1 : 0;
    }
    isWinFrameEnabled() {
        if (typeof this.data.skipWinFrameAnimation === 'undefined') //Take it as default === enabled
            return true;
        return !this.data.skipWinFrameAnimation;
    }
    // PRIVATE API
    onWinAnimationLoop() {
        this.winAnimationLoopCount++;
        if (this.winAnimationCompleteLimit == this.winAnimationLoopCount) {
            this.reset();
            this.emit(SymbolViewEvent_1.SymbolViewEvent.WIN_ANIMATION_COMPLETE);
        }
        else {
            this.emit(SymbolViewEvent_1.SymbolViewEvent.WIN_ANIMATION_LOOP, this.winAnimationLoopCount);
        }
    }
    swapParentKeepingGlobalPosition(newParent, id = -1) {
        const newPosition = newParent.toLocal(new pixi_js_1.Point(0, 0), this);
        this.position.set(newPosition.x, newPosition.y);
        this.removeChild(this.parent);
        (id === -1 || id >= newParent.children.length) ? newParent.addChild(this) : newParent.addChildAt(this, id);
    }
    playAnimation(animation, animationName = '', loop = false) {
        if (animation === null)
            return;
        if (animation instanceof pixi_js_1.AnimatedSprite) {
            animation.visible = true;
            animation.loop = loop;
            animation.gotoAndPlay(0);
        }
        else if (animation instanceof pixi_spine_1.Spine) {
            if (tsyringe_1.container.resolve(SlotMachine_1.default).currentGameSpeedLevel == 1 && Array.isArray(animation)) {
                if (animation.find((animation) => { animation.name === 'destroy'; })) {
                    const name = animation.find((animation) => { animation.name === 'destroy'; });
                    animation.visible = true;
                    animation.state.setAnimation(0, name, loop);
                    animation.state.timeScale = 2;
                    return;
                }
            }
            if (typeof animationName === 'string') {
                if (!animation.skeleton.data.animations.find((animation) => animation.name === animationName) && animationName.length <= 0)
                    return;
                animation.visible = true;
                animation.state.setAnimation(0, animationName, loop);
                animation.state.timeScale = 2;
            }
            else {
                for (let i = 0; i < animationName.length; i++) {
                    if (!animation.skeleton.data.animations.find((animation) => animation.name === animationName[i]) && animationName[i].length <= 0)
                        return;
                }
                animation.visible = true;
                const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
                if (sm.currentGameSpeedLevel != 0) {
                    animation.state.setAnimation(0, animationName[animationName.length - 1], false);
                    return;
                }
                for (let j = 0; j < animationName.length; j++) {
                    if (j == 0) {
                        animation.state.setAnimation(0, animationName[0], false);
                        animation.state.timeScale = 2;
                    }
                    else {
                        animation.state.addAnimation(0, animationName[j], false, animation.skeleton.data.animations.find((animation) => animation.name === animationName[j - 1]).duration);
                        animation.state.timeScale = 2;
                    }
                }
            }
        }
    }
    resetAnimation(animation) {
        if (animation === null)
            return;
        if (animation instanceof pixi_js_1.AnimatedSprite) {
            animation.visible = false;
            animation.gotoAndStop(0);
        }
        else if (animation instanceof pixi_spine_1.Spine) {
            animation.visible = false;
            animation.state.setEmptyAnimations(0);
            animation.skeleton.setToSetupPose();
        }
    }
    initializeAnimatedSpriteFromData(animationData) {
        if (!animationData)
            return;
        const animation = new pixi_js_1.AnimatedSprite(animationData.animationTextures);
        animation.animationSpeed = animationData.fps / 60;
        animation.gotoAndStop(0);
        animation.visible = false;
        animation.anchor.set(0.5, 0.5);
        return animation;
    }
}
exports["default"] = SymbolView;


/***/ }),

/***/ 21230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReelsViewEvent = void 0;
var ReelsViewEvent;
(function (ReelsViewEvent) {
    ReelsViewEvent["WIN_ANIMATION_COMPLETE"] = "onReelsViewWinAnimationComplete";
})(ReelsViewEvent || (exports.ReelsViewEvent = ReelsViewEvent = {}));


/***/ }),

/***/ 5207:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SymbolViewEvent = void 0;
var SymbolViewEvent;
(function (SymbolViewEvent) {
    SymbolViewEvent["WIN_ANIMATION_LOOP"] = "onSymbolViewWinAnimationLoop";
    SymbolViewEvent["WIN_ANIMATION_COMPLETE"] = "onSymbolViewWinAnimationComplete";
})(SymbolViewEvent || (exports.SymbolViewEvent = SymbolViewEvent = {}));


/***/ }),

/***/ 76206:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMaxAnimationTime = void 0;
function getMaxAnimationTime(popupAnimationConfig) {
    const times = getNestedProperty('time', popupAnimationConfig);
    return Math.max(...times);
}
exports.getMaxAnimationTime = getMaxAnimationTime;
function getNestedProperty(keyToFind, object) {
    let times = [];
    for (const key in object) {
        if (key == keyToFind) {
            times.unshift(object[key]);
        }
        const nested = object[key];
        if (typeof nested == "object") {
            times = [...times, ...getNestedProperty(keyToFind, nested)];
        }
    }
    return times;
}


/***/ }),

/***/ 70885:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const PopupAnimationConfig_1 = __webpack_require__(76206);
const GraphicUtils_1 = __importDefault(__webpack_require__(57976));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const AdjustableLayoutContainer_1 = __importDefault(__webpack_require__(66961));
const ScreenOrientation_1 = __webpack_require__(81827);
const PopupUtils_1 = __webpack_require__(85928);
const engineTween_1 = __webpack_require__(50381);
class PopupManager extends AdjustableLayoutContainer_1.default {
    constructor() {
        super(null);
        this.activeAnimationConfigResolver = null;
        this.activeSoundConfig = null;
        this.callbacks = null;
        this.closeOnClick = true;
        this.pivotMap = new Map();
        this.scaleMap = new Map();
        this.overlayUsageCount = 0;
        this.overlay = new pixi_js_1.Container();
        const blackRect = GraphicUtils_1.default.createRectGraphics({
            color: 0x000000,
            alpha: 1,
            size: new pixi_js_1.Point(100, 100),
        });
        blackRect.eventMode = 'auto';
        this.overlay.addChild(blackRect);
        this.overlay.pivot.set(50, 50);
        this.overlay.eventMode = 'static';
        this.overlay.visible = false;
        this.overlay.interactive = false;
        this.addChild(this.overlay);
        this.overlay.eventMode = 'static';
        this.eventMode = 'dynamic';
        this.cursor = 'pointer';
        this.on('pointerup', this.onClick, this);
    }
    updateLayout(desc) {
        var _a, _b, _c, _d;
        this.overlay.width = desc.currentWidth;
        this.overlay.height = desc.currentHeight;
        this.overlay.position.set(0, 0);
        (_b = (_a = this.horizontalPopup) === null || _a === void 0 ? void 0 : _a['updateLayout']) === null || _b === void 0 ? void 0 : _b.call(_a, desc);
        (_d = (_c = this.verticalPopup) === null || _c === void 0 ? void 0 : _c['updateLayout']) === null || _d === void 0 ? void 0 : _d.call(_c, desc);
        super.updateLayout(desc);
        this.currentOrientation = desc.orientation;
        this.updateView();
    }
    updateView() {
        if (this.horizontalPopup)
            this.horizontalPopup.visible = this.currentOrientation == ScreenOrientation_1.ScreenOrientation.HORIZONTAL;
        if (this.verticalPopup)
            this.verticalPopup.visible = this.currentOrientation == ScreenOrientation_1.ScreenOrientation.VERTICAL;
    }
    // PUBLIC API
    show(horizontalPopup, verticalPopup, duration = -1, closeOnClick = false, callbacks = null, animationConfigResolver = () => PopupManager.defaultAnimationConfiguration, soundConfig = PopupManager.defaultSoundConfiguration) {
        // To prevent displaying multiple popups at the same time
        // [this.horizontalPopup, this.verticalPopup].forEach((popup: DisplayObject): void => {
        //     if (popup != null) {
        //         popup.destroy({ children: true });
        //     }
        // });
        //Tweener.removeTweens(this);
        var _a, _b, _c, _d;
        // Clean previous tweens
        engineTween_1.Tweener.removeTweens(this);
        engineTween_1.Tweener.removeTweens(this.overlay);
        this.overlayUsageCount = 0;
        if (this.horizontalPopup) {
            engineTween_1.Tweener.removeTweens(this.horizontalPopup);
        }
        if (this.verticalPopup) {
            engineTween_1.Tweener.removeTweens(this.verticalPopup);
        }
        // Cache initial state for each new popup
        const animationConfig = animationConfigResolver === null || animationConfigResolver === void 0 ? void 0 : animationConfigResolver();
        if (!this.pivotMap.has(horizontalPopup)) {
            this.pivotMap.set(horizontalPopup, horizontalPopup.pivot.y);
            this.scaleMap.set(horizontalPopup, horizontalPopup.scale.x);
        }
        if (!this.pivotMap.has(verticalPopup)) {
            this.pivotMap.set(verticalPopup, verticalPopup.pivot.y);
            this.scaleMap.set(verticalPopup, verticalPopup.scale.x);
        }
        // Force animation resets
        [this.horizontalPopup, this.verticalPopup].forEach((popup) => {
            if (popup) {
                popup.alpha = 1;
                popup.scale.set(this.scaleMap.get(popup));
                popup.pivot.y = this.pivotMap.get(popup);
                this.removeChild(popup);
            }
        });
        // Cache other data
        this.callbacks = callbacks;
        this.closeOnClick = closeOnClick;
        this.cursor = closeOnClick ? 'pointer' : 'auto';
        if (animationConfigResolver) {
            this.activeAnimationConfigResolver = () => {
                var _a;
                return (Object.assign(Object.assign({}, PopupManager.defaultAnimationConfiguration), ((_a = animationConfigResolver()) !== null && _a !== void 0 ? _a : {})));
            };
        }
        else {
            this.activeAnimationConfigResolver = null;
        }
        this.activeSoundConfig = soundConfig ? soundConfig : null;
        this.overlayUsageCount++;
        this.overlay.interactive = true;
        this.overlay.visible = true;
        // Show sound
        if (soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.showSound) {
            this.showSound = SoundManager_1.default.play(soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.showSound);
        }
        // Show overlay
        if (animationConfig.showOverlay) {
            PopupUtils_1.PopupUtils.DoAlphaFade(this.overlay, (_b = (_a = animationConfig.showOverlay) === null || _a === void 0 ? void 0 : _a.alpha) !== null && _b !== void 0 ? _b : null);
            PopupUtils_1.PopupUtils.DoScale(this.overlay, (_d = (_c = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.showOverlay) === null || _c === void 0 ? void 0 : _c.scale) !== null && _d !== void 0 ? _d : null, 0);
        }
        this.overlay.visible = true;
        if (horizontalPopup) {
            this.horizontalPopup = horizontalPopup;
            this.addChild(horizontalPopup);
            horizontalPopup.pivot.y = this.pivotMap.get(horizontalPopup);
            horizontalPopup.scale.set(this.scaleMap.get(horizontalPopup));
        }
        if (verticalPopup) {
            this.verticalPopup = verticalPopup;
            this.addChild(verticalPopup);
            verticalPopup.pivot.y = this.pivotMap.get(verticalPopup);
            verticalPopup.scale.set(this.scaleMap.get(verticalPopup));
        }
        if (!animationConfig) {
            this.updateView();
            return;
        }
        if (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.showPopup) {
            this.updateView();
            [horizontalPopup, verticalPopup].forEach((popup) => {
                PopupUtils_1.PopupUtils.DoAlphaFade(popup, animationConfig.showPopup.alpha, null, () => {
                    popup.filters = [];
                    this.overlay.visible = true;
                });
                PopupUtils_1.PopupUtils.DoScale(popup, animationConfig.showPopup.scale, 0, null, () => {
                    if (callbacks && callbacks.onPopupShown && this.visible) {
                        callbacks.onPopupShown();
                    }
                    if (duration != -1 && this.visible) {
                        engineTween_1.Tweener.addCaller(this, {
                            count: 1,
                            time: duration,
                            onComplete: () => {
                                setTimeout(() => {
                                    this.hide(false);
                                }, 1000);
                            },
                        });
                    }
                });
                PopupUtils_1.PopupUtils.DoChangePivotY(popup, animationConfig.showPopup.pivotY, 0, this.pivotMap.get(popup), null, () => {
                    if (callbacks && callbacks.onPopupShown && this.visible) {
                        callbacks.onPopupShown();
                    }
                    if (duration != -1 && this.visible) {
                        engineTween_1.Tweener.addCaller(this, {
                            count: 1,
                            time: duration,
                            onComplete: () => {
                                setTimeout(() => {
                                    this.hide(false);
                                }, 1000);
                            },
                        });
                    }
                });
            });
        }
    }
    hide(destroy = false) {
        var _a, _b, _c, _d, _e;
        // Clean previous state
        const animationConfig = (_a = this.activeAnimationConfigResolver) === null || _a === void 0 ? void 0 : _a.call(this);
        const soundConfig = this.activeSoundConfig;
        const callbacks = this.callbacks;
        const horizontalPopup = this.horizontalPopup;
        const verticalPopup = this.verticalPopup;
        this.cursor = 'auto';
        this.activeAnimationConfigResolver = null;
        this.activeSoundConfig = null;
        this.callbacks = null;
        if (this.showSound) {
            this.showSound.stop();
        }
        if (soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.hideSound) {
            SoundManager_1.default.play(soundConfig === null || soundConfig === void 0 ? void 0 : soundConfig.hideSound);
        }
        if (!animationConfig) {
            this.removeChild(this.horizontalPopup);
            this.removeChild(this.verticalPopup);
            return;
        }
        if (callbacks && callbacks.onPopupBeforeHide) {
            callbacks.onPopupBeforeHide();
        }
        if (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.hidePopup) {
            [horizontalPopup, verticalPopup].forEach((popup) => {
                PopupUtils_1.PopupUtils.DoAlphaFade(popup, animationConfig.hidePopup.alpha, null, () => {
                    popup.filters = [];
                });
                PopupUtils_1.PopupUtils.DoScale(popup, animationConfig.hidePopup.scale, popup.scale.x, null, null);
                PopupUtils_1.PopupUtils.DoChangePivotY(popup, animationConfig.hidePopup.pivotY, this.pivotMap.get(popup), 0, null, null);
            });
        }
        if (animationConfig.hideOverlay) {
            PopupUtils_1.PopupUtils.DoScale(this.overlay, (_c = (_b = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.hideOverlay) === null || _b === void 0 ? void 0 : _b.scale) !== null && _c !== void 0 ? _c : null, this.overlay.scale.x);
            PopupUtils_1.PopupUtils.DoAlphaFade(this.overlay, (_e = (_d = animationConfig.hideOverlay) === null || _d === void 0 ? void 0 : _d.alpha) !== null && _e !== void 0 ? _e : null, () => {
                if (callbacks && callbacks.onPopupHidden) {
                    callbacks.onPopupHidden();
                }
                // Destroy popups after all animations complete (otherwise popups are destroyed with the animations)
                const animationsMaxTime = (0, PopupAnimationConfig_1.getMaxAnimationTime)(animationConfig);
                engineTween_1.Tweener.addCaller(this, {
                    count: 1,
                    time: animationsMaxTime,
                    onComplete: () => {
                        [horizontalPopup, verticalPopup].forEach((popup) => {
                            if (popup) {
                                this.removeChild(popup);
                                popup.alpha = 1;
                                popup.scale.set(1);
                                popup.pivot.y = this.pivotMap.get(popup);
                                if (destroy) {
                                    popup.destroy();
                                }
                            }
                        });
                        this.overlayUsageCount--;
                        if (this.overlayUsageCount === 0) {
                            this.overlay.interactive = false;
                            this.overlay.visible = false;
                        }
                        //SoundManager.getChannel('ambient').volume = (this.currentGameState === BackgroundType.FREEGAME)? 0.6 : 0.3
                    },
                });
            });
        }
    }
    // USER INTERACTION
    onClick() {
        if (this.verticalPopup && this.horizontalPopup && this.closeOnClick) {
            this.hide(false);
        }
    }
}
PopupManager.defaultAnimationConfiguration = {
    showPopup: {
        scale: {
            value: 1,
            time: 0.3,
            transition: 'easeOutBack',
        },
        alpha: {
            value: 1,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        alpha: {
            value: 0,
            time: 0.3,
            transition: 'easeInQuad',
        },
        scale: {
            value: 0,
            time: 0.3,
            transition: 'easeInBack',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.8,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
    },
};
PopupManager.jumpAnimationConfiguration = {
    showPopup: {
        scale: {
            value: 1,
            time: 0.35,
            transition: 'easeOutBack',
        },
        alpha: {
            value: 1,
            time: 0,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
        scale: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.8,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.15,
            transition: 'easeInQuad',
        },
    },
};
PopupManager.slideAnimationConfiguration = {
    showPopup: {
        pivotY: {
            time: 0.7,
            transition: 'easeOutSine',
        },
        alpha: {
            value: 1,
            time: 0,
            transition: 'easeOutQuad',
        },
    },
    hidePopup: {
        pivotY: {
            time: 0.7,
            transition: 'easeOutSine',
        },
        alpha: {
            value: 0,
            time: 0.2,
            transition: 'easeInQuad',
        },
    },
    showOverlay: {
        alpha: {
            value: 0.8,
            time: 0.2,
            transition: 'easeOutQuad',
        },
    },
    hideOverlay: {
        alpha: {
            value: 0,
            time: 0.15,
            transition: 'easeInQuad',
        },
    },
};
PopupManager.defaultSoundConfiguration = {};
exports["default"] = PopupManager;


/***/ }),

/***/ 61072:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SugarParty = void 0;
__webpack_require__(44741); // required by tsyringe
const ResizeMethod_1 = __webpack_require__(44764);
const AssetsConfigLoader_1 = __importDefault(__webpack_require__(93794));
const Logger_1 = __importDefault(__webpack_require__(82669));
const LoadingScreen_1 = __webpack_require__(20523);
const pixi_js_1 = __webpack_require__(95894);
const SwapViewsEffectFadeToBlack_1 = __importDefault(__webpack_require__(23999));
const MainGameScreen_1 = __importDefault(__webpack_require__(3417));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const ApplicationEvent_1 = __webpack_require__(27638);
const BrowserApplication_1 = __webpack_require__(32139);
const SlotMachineEvent_1 = __webpack_require__(96421);
const SlotMachineState_1 = __webpack_require__(77313);
const PopupManager_1 = __importDefault(__webpack_require__(70885));
const WalletEvent_1 = __webpack_require__(63035);
const PopupNotEnoughBalance_1 = __importDefault(__webpack_require__(25571));
const PopupBigWin_1 = __importDefault(__webpack_require__(52472));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotGameEvent_1 = __webpack_require__(19342);
const GraphicUtils_1 = __importDefault(__webpack_require__(17698));
const SymbolsList_1 = __webpack_require__(36189);
const tsyringe_1 = __webpack_require__(659);
const SlotGameFrontController_1 = __importDefault(__webpack_require__(25590));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SoundListExtended_1 = __importDefault(__webpack_require__(19402));
const PopupConnectionLost_1 = __importDefault(__webpack_require__(65058));
const UIPanelEvent_1 = __webpack_require__(566);
const OpenPanelCommand_1 = __importDefault(__webpack_require__(10558));
const HistoryPanel_1 = __importDefault(__webpack_require__(78362));
const AutospinPanel_1 = __importDefault(__webpack_require__(86057));
const ClosePanelCommand_1 = __importDefault(__webpack_require__(76090));
const History_1 = __importDefault(__webpack_require__(11703));
const CompleteRoundCommand_1 = __importDefault(__webpack_require__(34607));
const CompleteRoundCommandOverride_1 = __importDefault(__webpack_require__(39868));
const AdjustBetPanel_1 = __importDefault(__webpack_require__(66672));
const ChangeUISettingsStateCommand_1 = __importDefault(__webpack_require__(59920));
const UIStateEvent_1 = __webpack_require__(17939);
const PaytablePanelMobile_1 = __importDefault(__webpack_require__(49600));
const UIState_1 = __importStar(__webpack_require__(54572));
const PopupFeatureBuy_1 = __importDefault(__webpack_require__(70718));
const PopupState_1 = __importStar(__webpack_require__(57388));
const ShowPopupCommand_1 = __importDefault(__webpack_require__(58575));
const HidePopupCommand_1 = __importDefault(__webpack_require__(7770));
const PopupFreespins_1 = __importDefault(__webpack_require__(69577));
const IntroScreen_1 = __importDefault(__webpack_require__(7670));
const IntroScreenEvent_1 = __webpack_require__(81616);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const MobileBrowserLog_1 = __importDefault(__webpack_require__(25309));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const PaytablePanelDesktop_1 = __importDefault(__webpack_require__(81956));
const ScreenOrientation_1 = __webpack_require__(81827);
const SystemSettingsPanel_1 = __importDefault(__webpack_require__(14188));
const AdjustBetQuantityCommand_1 = __importDefault(__webpack_require__(1910));
const UIEventExtension_1 = __webpack_require__(43022);
const SpinStartCommandOverride_1 = __importDefault(__webpack_require__(53503));
const SpinStartCommand_1 = __importDefault(__webpack_require__(1552));
const AdjustTotalBetCommand_1 = __webpack_require__(12103);
const GameService_1 = __importDefault(__webpack_require__(18436));
const SlotGameEventExtension_1 = __webpack_require__(69898);
const LocalStorageUtils_1 = __webpack_require__(41087);
const BuyFeatureCommandOverride_1 = __importDefault(__webpack_require__(1899));
const Translation_1 = __importDefault(__webpack_require__(62231));
const engineTween_1 = __webpack_require__(50381);
const MenuPanel_1 = __importDefault(__webpack_require__(56749));
const PopupFreeSpinWinning_1 = __importDefault(__webpack_require__(46656));
const SoundList_1 = __importDefault(__webpack_require__(27310));
const DataSource_1 = __webpack_require__(92907);
class SugarParty extends BrowserApplication_1.BrowserApplication {
    constructor(gameContainer, config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (config.mobileLog && pixi_js_1.utils.isMobile.any) {
            new MobileBrowserLog_1.default();
        }
        if (pixi_js_1.utils.isMobile.any) {
            // window.onblur = () => {
            //     // pause when window focus lost
            //     SoundManager.mute = true;
            // };
            // window.onfocus = () => {
            //     // Unpause when window gains focus
            //     SoundManager.mute = false;
            // };
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // Ticker.shared.stop();
                    SoundManager_1.default.mute = false;
                }
                else {
                    // Ticker.shared.start();
                    SoundManager_1.default.mute = true;
                }
            });
        }
        Logger_1.default.info(`ExaGaming - Zodiac Rush [${"0.0.10"}]`);
        Logger_1.default.logLevel = config.logLevel;
        super(gameContainer, {
            id: 'game',
            container: gameContainer,
            resizeMethod: ResizeMethod_1.ResizeMethod.SHOW_ALL,
            backgroundColor: 0x000000,
            baseWidth: 1920,
            baseHeight: 1080,
            autoUpdateSizeToOrientation: true,
            debug: config.debug,
            fps: (((_b = (_a = (0, LocalStorageUtils_1.getFromLocalStorage)('settings')) === null || _a === void 0 ? void 0 : _a.batterySaver) !== null && _b !== void 0 ? _b : false) == true) ? 20 : 60
        });
        this.currentWidth = 0;
        this.currentHeight = 0;
        this.assetsBaseUrl = '/assets';
        this.language = config.language;
        Logger_1.default.warning(`FPS VALUE - ${(((_d = (_c = (0, LocalStorageUtils_1.getFromLocalStorage)('settings')) === null || _c === void 0 ? void 0 : _c.batterySaver) !== null && _d !== void 0 ? _d : false) == true) ? 20 : 60}`);
        // PixiJS Chrome extension support
        globalThis.__PIXI_APP__ = this.pixi;
        this.gameService = new GameService_1.default(config.serverApiUrl, config.historyApiUrl, config.jwtToken, config.gameId, (_e = config.lobbyUrl) !== null && _e !== void 0 ? _e : '', (_f = config.userLoginUrl) !== null && _f !== void 0 ? _f : ''); /*new DummyGameService(
            config.lobbyUrl ?? '',
            config.startingBalance ?? 0
        );*/
        tsyringe_1.container.registerInstance('GameService', this.gameService);
        this.frontController = new SlotGameFrontController_1.default();
        this.frontController.addCommand(UIPanelEvent_1.UIPanelEvent.OPEN_SETTINGS, ChangeUISettingsStateCommand_1.default);
        this.frontController.addCommand(UIPanelEvent_1.UIPanelEvent.CLOSE_SETTINGS, ChangeUISettingsStateCommand_1.default);
        this.frontController.addCommand(UIPanelEvent_1.UIPanelEvent.OPEN_PANEL, OpenPanelCommand_1.default);
        this.frontController.addCommand(UIPanelEvent_1.UIPanelEvent.CLOSE_PANEL, ClosePanelCommand_1.default);
        this.frontController.removeCommand(SlotGameEvent_1.SlotGameEvent.ROUND_COMPLETE, CompleteRoundCommand_1.default);
        this.frontController.addCommand(SlotGameEvent_1.SlotGameEvent.ROUND_COMPLETE, CompleteRoundCommandOverride_1.default);
        this.frontController.addCommand(UIPanelEvent_1.UIPanelEvent.SHOW_POPUP, ShowPopupCommand_1.default);
        this.frontController.addCommand(UIPanelEvent_1.UIPanelEvent.HIDE_POPUP, HidePopupCommand_1.default);
        this.frontController.addCommand(UIEventExtension_1.UIEventExtension.BET_QUANTITY_UP, AdjustBetQuantityCommand_1.default);
        this.frontController.addCommand(UIEventExtension_1.UIEventExtension.BET_QUANTITY_DOWN, AdjustBetQuantityCommand_1.default);
        this.frontController.addCommand(UIEventExtension_1.UIEventExtension.BET_QUANTITY_MAX, AdjustBetQuantityCommand_1.default);
        this.frontController.addCommand(UIEventExtension_1.UIEventExtension.TOTAL_BET_DOWN, AdjustTotalBetCommand_1.AdjustTotalBetCommand);
        this.frontController.addCommand(UIEventExtension_1.UIEventExtension.TOTAL_BET_UP, AdjustTotalBetCommand_1.AdjustTotalBetCommand);
        this.frontController.removeCommand(SlotGameEvent_1.SlotGameEvent.SPIN_START, SpinStartCommand_1.default);
        this.frontController.addCommand(SlotGameEvent_1.SlotGameEvent.SPIN_START, SpinStartCommandOverride_1.default);
        this.frontController.addCommand(SlotGameEventExtension_1.SlotGameEventExtension.BUY_FREESPINS, BuyFeatureCommandOverride_1.default);
        tsyringe_1.container.registerSingleton(UIState_1.default);
        tsyringe_1.container.registerSingleton(PopupState_1.default);
        tsyringe_1.container.registerSingleton(History_1.default);
        // container.registerSingleton(SlotMachine);
        this.popupManager = new PopupManager_1.default();
        this.popupManager.position.set(this.baseWidth / 2, this.baseHeight / 2);
        this.stage.addChild(this.popupManager);
        if (config.assetsBaseUrl)
            this.assetsBaseUrl = config.assetsBaseUrl + this.assetsBaseUrl;
        const loadingScreenAssetsLoader = new AssetsConfigLoader_1.default(`./assets/loading-screen-assets-config.json`, this.pixi.renderer);
        loadingScreenAssetsLoader.on(AssetsConfigLoader_1.default.EVENT_LOADING_COMPLETE, this.onLoadingScreenAssetsLoaded, this);
        loadingScreenAssetsLoader.on(AssetsConfigLoader_1.default.EVENT_LOADING_PROGRESS, (progress) => {
            // Phase 1: Loading screen assets (0-50% of total progress)
            const totalProgress = progress * 0.5;
            if (this.loadingScreen) {
                this.loadingScreen.setProgress(totalProgress / 100);
            }
        }, this);
        SoundManager_1.default.getChannel('default').mute = !((_h = (_g = (0, LocalStorageUtils_1.getFromLocalStorage)('settings')) === null || _g === void 0 ? void 0 : _g.soundFx) !== null && _h !== void 0 ? _h : true);
        SoundManager_1.default.getChannel('ambient').mute = !((_k = (_j = (0, LocalStorageUtils_1.getFromLocalStorage)('settings')) === null || _j === void 0 ? void 0 : _j.ambientMusic) !== null && _k !== void 0 ? _k : true);
        this.getTranslationFile(DataSource_1.jsonAdress[DataSource_1.jsonAdress[config.language] ? config.language : 'EN']).then(() => {
            loadingScreenAssetsLoader.load();
        });
    }
    getTranslationFile(lang) {
        return __awaiter(this, void 0, void 0, function* () {
            // fetch json file
            const response = yield fetch(`${this.assetsBaseUrl}/translations/${lang}.json`);
            const data = yield response.json();
            Translation_1.default.addLanguageData(lang, data);
            Translation_1.default.setCurrentLanguage(lang);
        });
    }
    set activeMainGameView(value) {
        if (this._activeMainGameView == value) {
            return;
        }
        const oldView = this._activeMainGameView;
        this._activeMainGameView = value;
        this.onWindowResize();
        //
        // const w: number = Math.ceil(this.width);
        // const h: number = Math.ceil(this.height);
        const w = 4000;
        const h = 4000;
        const x = -(w - this.baseWidth) / 2;
        const y = -(h - this.baseHeight) / 2;
        const fadeSize = new pixi_js_1.Rectangle(x, y, w, h);
        if (oldView) {
            const swapEffect = new SwapViewsEffectFadeToBlack_1.default(fadeSize);
            // let swapEffect: ISwapViewsEffect = new SwapViewsEffectFadeOut();
            swapEffect.apply(oldView, this._activeMainGameView, this.stage, () => {
                if (oldView == this.loadingScreen) {
                    oldView.destroy({
                        children: true
                    });
                }
            });
        }
        else {
            this.stage.addChildAt(this._activeMainGameView, 0);
        }
    }
    onLoadingScreenAssetsLoaded() {
        Logger_1.default.info('Loading screen assets loaded');
        this.loadingScreen = new LoadingScreen_1.LoadingScreen(() => {
            if (localStorage.getItem("skipScreen") == 'true' ? true : false) {
                this.onAllAssetsLoaded();
                return;
            }
            this.introScreen = new IntroScreen_1.default();
            this.introScreen.on(IntroScreenEvent_1.IntroScreenEvent.ON_GET_STARTED_CLICKED, this.onAllAssetsLoaded, this);
            this.activeMainGameView = this.introScreen;
        });
        this.loadingScreen.start();
        this.activeMainGameView = this.loadingScreen;
        // const progressBarFill = document.querySelector('.progress-bar-fill') as HTMLElement;
        const gameAssetsLoader = new AssetsConfigLoader_1.default(`./assets/main-game-assets-config.json`, this.pixi.renderer);
        gameAssetsLoader.on(AssetsConfigLoader_1.default.EVENT_LOADING_COMPLETE, this.onGameAssetsLoaded, this);
        gameAssetsLoader.on(AssetsConfigLoader_1.default.EVENT_LOADING_PROGRESS, (progress) => {
            const totalProgress = 50 + (progress * 0.5);
            if (this.loadingScreen) {
                this.loadingScreen.setProgress(totalProgress / 100);
            }
        }, this);
        gameAssetsLoader.load();
        new ControlEvent_1.default(ApplicationEvent_1.ApplicationEvent.INIT).dispatch();
    }
    onGameAssetsLoaded() {
        return __awaiter(this, void 0, void 0, function* () {
            Logger_1.default.info('Game assets loaded');
            GraphicUtils_1.default.init(this.pixi.renderer);
            yield GraphicUtils_1.default.processSymbolsData(SymbolsList_1.SymbolsList);
            this.loadingScreen.stop();
        });
    }
    onAllAssetsLoaded() {
        // check config complete
        if (this.introScreen) {
            this.introScreen.off(IntroScreenEvent_1.IntroScreenEvent.ON_GET_STARTED_CLICKED, this.onAllAssetsLoaded, this);
            this.introScreen = null;
        }
        // check config complete
        if (!tsyringe_1.container.isRegistered(SlotMachine_1.default)) {
            engineTween_1.Tweener.addCaller(this, {
                count: 1,
                time: 0.1,
                onComplete: () => {
                    this.onAllAssetsLoaded();
                }
            });
            return;
        }
        try {
            console.log('Resolving SlotMachine from container');
            this.slotMachine = tsyringe_1.container.resolve(SlotMachine_1.default);
            console.log('SlotMachine resolved successfully:', this.slotMachine);
            this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.STATE_CHANGED, this.onSlotMachineStateChanged, this);
            console.log('Resolving UIState from container');
            const uiState = tsyringe_1.container.resolve(UIState_1.default);
            console.log('UIState resolved successfully');
            uiState.on(UIStateEvent_1.UIStateEvent.ACTIVE_PANEL_CHANGED, this.onUiActivePanelChanged, this);
            console.log('Resolving PopupState from container');
            const popupState = tsyringe_1.container.resolve(PopupState_1.default);
            console.log('PopupState resolved successfully');
            popupState.on(UIStateEvent_1.UIStateEvent.ACTIVE_POPUP_CHANGED, this.onActivePopupChanged, this);
            console.log('Resolving Wallet from container');
            this.wallet = tsyringe_1.container.resolve(Wallet_1.default);
            console.log('Wallet resolved successfully:', {
                balance: this.wallet.balance,
                currency: Wallet_1.default.currency.isoCode
            });
        }
        catch (error) {
            console.error('Error in onAllAssetsLoaded:', error);
        }
        // TODO: uncomment these and remove the bottom line for feature presentation screen
        // this.featurePresentationScreen = new FeaturePresentationScreen();
        // this.featurePresentationScreen.on('continue', this.onFeaturePresentationScreenContinue, this);
        // this.activeMainGameView = this.featurePresentationScreen;
        new ControlEvent_1.default(ApplicationEvent_1.ApplicationEvent.LOADING_COMPLETE).dispatch();
    }
    onFeaturePresentationScreenContinue() {
        new ControlEvent_1.default(ApplicationEvent_1.ApplicationEvent.LOADING_COMPLETE).dispatch();
    }
    onSlotMachineStateChanged(currentState, previousState) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        console.log('onSlotMachineStateChanged', currentState, previousState);
        switch (currentState) {
            case SlotMachineState_1.SlotMachineState.IDLE:
                if (!this.mainGameScreen) {
                    this.mainGameScreen = tsyringe_1.container.resolve(MainGameScreen_1.default);
                    tsyringe_1.container.resolve(Wallet_1.default)
                        .on(WalletEvent_1.WalletEvent.NOT_ENOUGH_BALANCE, this.onNotEnoughBalance, this);
                }
                this.activeMainGameView = this.mainGameScreen;
                // // TEST CODE ONLY
                // this.popupManager.show(
                //     new PopupBigWin(1, 10000, new Text('', {
                //         fontFamily: AssetsManager.webFonts.get('Inter').family,
                //         fill: [
                //             0xffc300
                //         ],
                //         fontSize: 80,
                //         lineJoin: 'round',
                //
                //     })),
                //     new PopupBigWin(1, 10000, new Text('', {
                //         fontFamily: AssetsManager.webFonts.get('Inter').family,
                //         fill: [
                //             0xffc300
                //         ],
                //         fontSize: 80,
                //         lineJoin: 'round',
                //     }))
                //     ,-1,
                //     false,
                //     {},
                //     PopupManager.defaultAnimationConfiguration,
                //     {}
                // );
                // this.popupManager.show(
                //     new PopupFreespins(10),
                //     new PopupFreespins(10),
                //     -1,
                //     false,
                //     {},
                //     PopupManager.jumpAnimationConfiguration,
                //     {}
                // );
                // this.popupManager.show(
                //     new PopupFeatureBuy(),
                //     -1,
                //     false,
                //     {},
                //     PopupManager.jumpAnimationConfiguration,
                //     {}
                // );
                break;
            case SlotMachineState_1.SlotMachineState.BIG_WIN:
                (_b = (_a = this.popupBigWinHorizontal) === null || _a === void 0 ? void 0 : _a['updateLayout']) === null || _b === void 0 ? void 0 : _b.call(_a, this.updateLayoutDescription);
                (_d = (_c = this.popupBigWinVertical) === null || _c === void 0 ? void 0 : _c['updateLayout']) === null || _d === void 0 ? void 0 : _d.call(_c, this.updateLayoutDescription);
                const bigBigWinLevel = this.slotMachine.bigWinLevel(this.slotMachine.roundResult);
                this.popupManager.show((this.popupBigWinHorizontal = new PopupBigWin_1.default(this.slotMachine.bigWinLevel(this.slotMachine.roundResult), this.slotMachine.roundResult.totalWinValue)), (this.popupBigWinVertical = new PopupBigWin_1.default(this.slotMachine.bigWinLevel(this.slotMachine.roundResult), this.slotMachine.roundResult.totalWinValue)), -1, true, {
                    onPopupHidden: () => {
                        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.BIG_WIN_SHOWN).dispatch();
                    },
                }, () => PopupManager_1.default.jumpAnimationConfiguration, {
                    showSound: {
                        id: this.getProperWinSound(bigBigWinLevel),
                        volume: 0.6,
                    }
                });
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_START:
                (_f = (_e = this.popupFreespinsVertical) === null || _e === void 0 ? void 0 : _e['updateLayout']) === null || _f === void 0 ? void 0 : _f.call(_e, this.updateLayoutDescription);
                (_h = (_g = this.popupFreespinsHorizontal) === null || _g === void 0 ? void 0 : _g['updateLayout']) === null || _h === void 0 ? void 0 : _h.call(_g, this.updateLayoutDescription);
                //let tfFreespinsHeader: Text;
                // if(this.slotMachine.currentSpinResult.freespins.totalCount === this.slotMachine.currentSpinResult.freespins.remainingCount || this.slotMachine.currentSpinResult.freespins.moreAwarded) {
                //     tfFreespinsHeader = new Text(`YOU HAVE WON`, {
                //         fontFamily: AssetsManager.webFonts.get('JockeyOne').family,
                //         fill: [0xFFFFFF],
                //         fontSize: 64
                //     })
                // } else {
                //     tfFreespinsHeader = new Text(`YOU HAVE LEFT`, {
                //         fontFamily: AssetsManager.webFonts.get('JockeyOne').family,
                //         fill: [0xFFFFFF],
                //         fontSize: 64
                //     })
                // }
                const freeSpinAmount = this.slotMachine.currentSpinResult.freespins.moreAwarded ? this.slotMachine.currentSpinResult.freespins.moreAwarded : this.slotMachine.currentSpinResult.freespins.remainingCount;
                this.popupManager.show(((_j = this.popupFreespinsHorizontal) !== null && _j !== void 0 ? _j : (this.popupFreespinsHorizontal = new PopupFreespins_1.default(freeSpinAmount, 1.2))), ((_k = this.popupFreespinsVertical) !== null && _k !== void 0 ? _k : (this.popupFreespinsVertical = new PopupFreespins_1.default(freeSpinAmount, 1))), -1, true, {
                    onPopupHidden: () => {
                        var _a, _b;
                        if (this.slotMachine.currentSpinResult.freespins.moreAwarded) {
                            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
                        }
                        else {
                            (_a = this.mainGameScreen.transitionDesktop) === null || _a === void 0 ? void 0 : _a.setTransition('transition').then(() => { new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_ROUND_STARTED).dispatch(); });
                            (_b = this.mainGameScreen.transitionMobile) === null || _b === void 0 ? void 0 : _b.setTransition('transition').then(() => { new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_ROUND_STARTED).dispatch(); });
                            SoundManager_1.default.play(SoundList_1.default.TRANSITION);
                        }
                    },
                }, () => PopupManager_1.default.jumpAnimationConfiguration, {
                    showSound: {
                        id: SoundList_1.default.FREESPIN_AWARD,
                        volume: 0.6,
                    }
                });
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPIN_BIG_WIN:
                (_m = (_l = this.popupBigWinHorizontal) === null || _l === void 0 ? void 0 : _l['updateLayout']) === null || _m === void 0 ? void 0 : _m.call(_l, this.updateLayoutDescription);
                (_p = (_o = this.popupBigWinVertical) === null || _o === void 0 ? void 0 : _o['updateLayout']) === null || _p === void 0 ? void 0 : _p.call(_o, this.updateLayoutDescription);
                const freeSpinBigWinLevel = this.slotMachine.freeSpinBigWinLevel(this.slotMachine.currentSpinResult);
                this.popupManager.show((this.popupBigWinHorizontal = new PopupBigWin_1.default(this.slotMachine.freeSpinBigWinLevel(this.slotMachine.currentSpinResult), this.slotMachine.currentSpinResult.currentTotalWinValue)), (this.popupBigWinVertical = new PopupBigWin_1.default(this.slotMachine.freeSpinBigWinLevel(this.slotMachine.currentSpinResult), this.slotMachine.currentSpinResult.currentTotalWinValue)), -1, true, {
                    onPopupHidden: () => {
                        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.BIG_WIN_SHOWN).dispatch();
                    },
                }, () => PopupManager_1.default.jumpAnimationConfiguration, {
                    showSound: {
                        id: this.getProperWinSound(freeSpinBigWinLevel),
                        volume: 0.6,
                    }
                });
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_END:
                this.popupManager.show(((_q = this.popupFreespinsWinningHorizontal) !== null && _q !== void 0 ? _q : (this.popupFreespinsWinningHorizontal = new PopupFreeSpinWinning_1.default(this.slotMachine.roundResult.totalWinValue, 1, true, this.slotMachine.currentSpinResult.freespins.totalCount))), ((_r = this.popupFreespinsWinningVertical) !== null && _r !== void 0 ? _r : (this.popupFreespinsWinningVertical = new PopupFreeSpinWinning_1.default(this.slotMachine.roundResult.totalWinValue, 1, true, this.slotMachine.currentSpinResult.freespins.totalCount))), -1, true, {
                    onPopupHidden: () => {
                        var _a, _b;
                        (_a = this.mainGameScreen.transitionDesktop) === null || _a === void 0 ? void 0 : _a.setTransition('transition').then(() => { new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_ROUND_COMPLETE).dispatch(); });
                        (_b = this.mainGameScreen.transitionMobile) === null || _b === void 0 ? void 0 : _b.setTransition('transition').then(() => { new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_ROUND_COMPLETE).dispatch(); });
                        SoundManager_1.default.play(SoundList_1.default.TRANSITION);
                    }
                }, () => PopupManager_1.default.jumpAnimationConfiguration, {
                    showSound: {
                        id: SoundListExtended_1.default.FREESPIN_CONG,
                        volume: 0.6
                    }
                });
                break;
            case SlotMachineState_1.SlotMachineState.COMMUNICATION_ERROR:
                const data = {
                    type: PopupState_1.PopupType.CONNECTION_LOST,
                    hideOnClick: false,
                    duration: -1,
                    callbacks: null
                };
                new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.SHOW_POPUP, data).dispatch();
                break;
            case SlotMachineState_1.SlotMachineState.WARNING_POPUP:
                const res = {
                    type: PopupState_1.PopupType.WARNING_POPUP,
                    hideOnClick: true,
                    duration: -1,
                    callbacks: null
                };
                new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.SHOW_POPUP, res).dispatch();
                break;
        }
    }
    resize(availableWidth, availableHeight, resizeMethod) {
        super.resize(availableWidth, availableHeight, resizeMethod);
        if (!this.stage) {
            return;
        }
        this.stage.x = (availableWidth - this.baseWidth * this.stage.scale.x) / 2;
        this.stage.y = (availableHeight - this.baseHeight * this.stage.scale.y) / 2;
        this.currentWidth = availableWidth / this.stage.scale.x;
        this.currentHeight = availableHeight / this.stage.scale.y;
        if (this._activeMainGameView) {
            this._activeMainGameView.updateLayout(this.updateLayoutDescription);
        }
        if (this.popupManager) {
            this.popupManager.updateLayout(this.updateLayoutDescription);
            this.popupManager.position.set(this.baseWidth / 2, this.baseHeight / 2);
        }
    }
    onUiActivePanelChanged() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const uiState = tsyringe_1.container.resolve(UIState_1.default);
        switch (uiState.activePanel) {
            case UIState_1.UIPanelType.HISTORY:
                this.popupVertical = (_a = this.historyPanelVertical) !== null && _a !== void 0 ? _a : (this.historyPanelVertical = new HistoryPanel_1.default('HistoryPanel'));
                this.popupDesktop = (_b = this.historyPanelHorizontal) !== null && _b !== void 0 ? _b : (this.historyPanelHorizontal = new HistoryPanel_1.default('HistoryPanelDesktop'));
                break;
            case UIState_1.UIPanelType.AUTOSPIN_SETTINGS:
                this.popupVertical = (_c = this.autospinPanelVertical) !== null && _c !== void 0 ? _c : (this.autospinPanelVertical = new AutospinPanel_1.default(AssetsManager_1.default.layouts.get('autoplayPortrait')));
                this.popupDesktop = (_d = this.autospinPanelHorizontal) !== null && _d !== void 0 ? _d : (this.autospinPanelHorizontal = new AutospinPanel_1.default(AssetsManager_1.default.layouts.get('autoplayLandscape')));
                break;
            case UIState_1.UIPanelType.BET_SETTINGS:
                this.popupVertical = (_e = this.adjustBetPanelVertical) !== null && _e !== void 0 ? _e : (this.adjustBetPanelVertical = new AdjustBetPanel_1.default(AssetsManager_1.default.layouts.get('adjustBetPanelPortrait')));
                this.popupDesktop = (_f = this.adjustBetPanelHorizontal) !== null && _f !== void 0 ? _f : (this.adjustBetPanelHorizontal = new AdjustBetPanel_1.default(AssetsManager_1.default.layouts.get('adjustBetPanelLandscape')));
                break;
            case UIState_1.UIPanelType.MENU_SETTING:
                this.popupVertical = (_g = this.menuPanelVertical) !== null && _g !== void 0 ? _g : (this.menuPanelVertical = new MenuPanel_1.default(AssetsManager_1.default.layouts.get('MenuPanelMobile'), 2));
                this.popupDesktop = (_h = this.menuPanelHorizontal) !== null && _h !== void 0 ? _h : (this.menuPanelHorizontal = new MenuPanel_1.default(AssetsManager_1.default.layouts.get('MenuPanel')));
                break;
            case UIState_1.UIPanelType.PAYTABLE:
                this.popupVertical = (_j = this.paytablePanelVertical) !== null && _j !== void 0 ? _j : (this.paytablePanelVertical = new PaytablePanelMobile_1.default({
                    symbolsList: SymbolsList_1.SymbolsList,
                    excludedSymbols: [25],
                    symbolsWithDescription: [
                        {
                            itemId: 2,
                            symbolId: 25
                        },
                    ],
                    max_min_bet: [this.wallet.getCurrencyValue(this.slotMachine.description.betLimits[0] * 20, true), this.wallet.getCurrencyValue(this.slotMachine.description.betLimits[this.slotMachine.description.betLimits.length - 1] * 20, true)]
                }));
                this.popupDesktop = (_k = this.paytablePanelHorizontal) !== null && _k !== void 0 ? _k : (this.paytablePanelHorizontal = new PaytablePanelDesktop_1.default({
                    symbolsList: SymbolsList_1.SymbolsList,
                    excludedSymbols: [25],
                    symbolsWithDescription: [
                        {
                            itemId: 2,
                            symbolId: 25
                        }
                    ],
                    max_min_bet: [this.wallet.getCurrencyValue(this.slotMachine.description.betLimits[0] * 20, true), this.wallet.getCurrencyValue(this.slotMachine.description.betLimits[this.slotMachine.description.betLimits.length - 1] * 20, true)]
                }));
                break;
            case UIState_1.UIPanelType.SYSTEM_SETTINGS:
                this.popupDesktop = (_l = this.systemSettingsPanelHorizontal) !== null && _l !== void 0 ? _l : (this.systemSettingsPanelHorizontal = new SystemSettingsPanel_1.default(AssetsManager_1.default.layouts.get('settingslLandscape')));
                this.popupVertical = (_m = this.systemSettingsPanelVertical) !== null && _m !== void 0 ? _m : (this.systemSettingsPanelVertical = new SystemSettingsPanel_1.default(AssetsManager_1.default.layouts.get('settingPortrait')));
                break;
            default:
                this.popupManager.hide();
                return;
        }
        (_o = this.popupVertical) === null || _o === void 0 ? void 0 : _o.updateLayout(this.updateLayoutDescription);
        (_p = this.popupDesktop) === null || _p === void 0 ? void 0 : _p.updateLayout(this.updateLayoutDescription);
        this.popupManager.show(this.popupDesktop, this.popupVertical, -1, false, null, () => this.orientation == ScreenOrientation_1.ScreenOrientation.VERTICAL
            ? PopupManager_1.default.slideAnimationConfiguration
            : PopupManager_1.default.defaultAnimationConfiguration, {
            showSound: {
                id: SoundListExtended_1.default.UI_POPUP_COMMON_WINDOW,
                volume: 0
            }
        });
    }
    get updateLayoutDescription() {
        return {
            orientation: this.orientation,
            baseWidth: this.baseWidth,
            baseHeight: this.baseHeight,
            currentWidth: this.currentWidth,
            currentHeight: this.currentHeight
        };
    }
    onActivePopupChanged() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const popupState = tsyringe_1.container.resolve(PopupState_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        if (popupState.activePopup === null) {
            this.popupManager.hide();
            return;
        }
        let popupHorizontal = null;
        let popupVertical = null;
        let showSound = SoundListExtended_1.default.UI_POPUP_COMMON_WINDOW;
        let reloadOnClick = false;
        switch (popupState.activePopup.type) {
            case PopupState_1.PopupType.NOT_ENOUGH_BALANCE:
                popupHorizontal = (_a = this.popupBalanceVertical) !== null && _a !== void 0 ? _a : (this.popupBalanceVertical = new PopupNotEnoughBalance_1.default());
                popupVertical = (_b = this.popupBalanceHorizontal) !== null && _b !== void 0 ? _b : (this.popupBalanceHorizontal = new PopupNotEnoughBalance_1.default());
                break;
            case PopupState_1.PopupType.CONNECTION_LOST:
                popupVertical = (_c = this.popupConnectionLostVertical) !== null && _c !== void 0 ? _c : (this.popupConnectionLostVertical = new PopupConnectionLost_1.default(sm.currentError, AssetsManager_1.default.layouts.get('popupLostConnectionPortrait')));
                popupHorizontal = (_d = this.popupConnectionLostHorizontal) !== null && _d !== void 0 ? _d : (this.popupConnectionLostHorizontal = new PopupConnectionLost_1.default(sm.currentError, AssetsManager_1.default.layouts.get('popupLostConnectionLandscape')));
                PopupManager_1.default.defaultAnimationConfiguration.showPopup.scale.value = 1.5;
                showSound = SoundListExtended_1.default.UI_ERROR_APPEARANCE;
                break;
            case PopupState_1.PopupType.WARNING_POPUP:
                popupVertical = (_e = this.popupConnectionLostVertical) !== null && _e !== void 0 ? _e : (this.popupConnectionLostVertical = new PopupConnectionLost_1.default(sm.currentError, AssetsManager_1.default.layouts.get('popupLostConnectionPortrait')));
                popupHorizontal = (_f = this.popupConnectionLostHorizontal) !== null && _f !== void 0 ? _f : (this.popupConnectionLostHorizontal = new PopupConnectionLost_1.default(sm.currentError, AssetsManager_1.default.layouts.get('popupLostConnectionLandscape')));
                PopupManager_1.default.defaultAnimationConfiguration.showPopup.scale.value = 1.5;
                showSound = SoundListExtended_1.default.UI_ERROR_APPEARANCE;
                break;
            case PopupState_1.PopupType.FEATURE_BUY:
                popupHorizontal = (_g = this.popupFeatureBuyVertical) !== null && _g !== void 0 ? _g : (this.popupFeatureBuyVertical = new PopupFeatureBuy_1.default());
                popupVertical = (_h = this.popupFeatureBuyHorizontal) !== null && _h !== void 0 ? _h : (this.popupFeatureBuyHorizontal = new PopupFeatureBuy_1.default());
                PopupManager_1.default.defaultAnimationConfiguration.showPopup.scale.value = this.isMobileBrowser() ? 2 : 1.5;
                break;
        }
        (_j = popupHorizontal === null || popupHorizontal === void 0 ? void 0 : popupHorizontal['updateLayout']) === null || _j === void 0 ? void 0 : _j.call(popupHorizontal, this.updateLayoutDescription);
        (_k = popupVertical === null || popupVertical === void 0 ? void 0 : popupVertical['updateLayout']) === null || _k === void 0 ? void 0 : _k.call(popupVertical, this.updateLayoutDescription);
        this.popupManager.show(popupHorizontal, popupVertical, popupState.activePopup.duration, popupState.activePopup.hideOnClick, popupState.activePopup.callbacks, () => PopupManager_1.default.defaultAnimationConfiguration, {
            showSound: {
                id: showSound,
            }
        });
    }
    isMobileBrowser() {
        return BrowserApplication_1.BrowserApplication.mainScreenStage.orientation == ScreenOrientation_1.ScreenOrientation.VERTICAL;
    }
    onNotEnoughBalance() {
        const data = {
            type: PopupState_1.PopupType.NOT_ENOUGH_BALANCE,
            hideOnClick: true,
            duration: -1,
            callbacks: null
        };
        new ControlEvent_1.default(UIPanelEvent_1.UIPanelEvent.SHOW_POPUP, data).dispatch();
    }
    getProperWinSound(winLevel) {
        if (winLevel === 1)
            return SoundListExtended_1.default.GREAT_WIN;
        else if (winLevel === 2)
            return SoundListExtended_1.default.HUGE_WIN;
        else if (winLevel === 3)
            return SoundListExtended_1.default.INSANE_WIN;
        return SoundListExtended_1.default.GOOD_WIN;
    }
}
exports.SugarParty = SugarParty;


/***/ }),

/***/ 1910:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const UIEventExtension_1 = __webpack_require__(43022);
class AdjustBetQuantityCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const betLimits = sm.description.betLimits;
        switch (event.type) {
            case UIEventExtension_1.UIEventExtension.BET_QUANTITY_UP:
                if (betLimits.indexOf(sm.currentBetValue) < betLimits.length - 1) {
                    sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) + 1];
                }
                break;
            case UIEventExtension_1.UIEventExtension.BET_QUANTITY_DOWN:
                if (betLimits.indexOf(sm.currentBetValue) != 0) {
                    sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) - 1];
                }
                break;
            case UIEventExtension_1.UIEventExtension.BET_QUANTITY_MAX:
                sm.currentBetValue = betLimits[betLimits.length - 1];
                break;
            case UIEventExtension_1.UIEventExtension.BET_QUANTITY_MIN:
                sm.currentBetValue = betLimits[0];
                break;
        }
    }
}
exports["default"] = AdjustBetQuantityCommand;


/***/ }),

/***/ 12103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdjustTotalBetCommand = void 0;
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const tsyringe_1 = __webpack_require__(659);
const UIEventExtension_1 = __webpack_require__(43022);
class AdjustTotalBetCommand extends ControlCommand_1.default {
    execute(event) {
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const betLimits = sm.description.betLimits;
        switch (event.type) {
            case UIEventExtension_1.UIEventExtension.TOTAL_BET_UP:
                if (betLimits.indexOf(sm.currentBetValue) < betLimits.length - 1) {
                    sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) + 1];
                }
                break;
            case UIEventExtension_1.UIEventExtension.TOTAL_BET_DOWN:
                if (betLimits.indexOf(sm.currentBetValue) != 0) {
                    sm.currentBetValue = betLimits[betLimits.indexOf(sm.currentBetValue) - 1];
                }
                break;
        }
    }
}
exports.AdjustTotalBetCommand = AdjustTotalBetCommand;


/***/ }),

/***/ 1899:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotGameEvent_1 = __webpack_require__(19342);
const Logger_1 = __importDefault(__webpack_require__(82669));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
class BuyFeatureCommandOverride extends ControlCommand_1.default {
    execute() {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const gs = tsyringe_1.container.resolve('GameService');
        const totalBet = gs.featureBuyConfig.Rate * sm.totalBet * wallet.coinValue;
        // if (wallet.balance < totalBet) {
        //     if (sm.autoplay.enabled) {
        //         sm.autoplay.spinsLeft = 0;
        //         sm.autoplay.enabled = false;
        //     }
        //     sm.currentState = SlotMachineState.IDLE;
        //     // setTimeout: to handle to popups simultaneously, not enough balance on buy free spins popup
        //     setTimeout(() => {
        //         wallet.emit(WalletEvent.NOT_ENOUGH_BALANCE);
        //     }, 600)
        //     return;
        // }
        wallet.balance -= sm.totalBet * sm.description.coinRate;
        ;
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        sm.previousRoundResult = sm.roundResult;
        sm.roundResult.totalWinValue = 0;
        sm.roundResult = null;
        sm.currentState = SlotMachineState_1.SlotMachineState.SPINNING;
        gs.buyFeature()
            .then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_STOP).dispatch();
        })
            .catch((e) => {
            Logger_1.default.error(e);
            sm.currentError = e;
            sm.roundResult = sm.getDummyRoundResult(sm.previousRoundResult);
            wallet.balance += totalBet;
            sm.currentState = SlotMachineState_1.SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}
exports["default"] = BuyFeatureCommandOverride;


/***/ }),

/***/ 39868:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const History_1 = __importDefault(__webpack_require__(11703));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotGameEvent_1 = __webpack_require__(19342);
const SlotMachineState_1 = __webpack_require__(77313);
class CompleteRoundCommandOverride extends ControlCommand_1.default {
    execute() {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const history = tsyringe_1.container.resolve(History_1.default);
        sm.roundResult.complete = true;
        const winValue = sm.roundResult.totalWinValue;
        wallet.balance += winValue;
        // history.entries.unshift({
        //     datetime: Date.now(),
        //     balance: wallet.balance,
        //     win: winValue,
        //     totalBet: sm.roundResult.RoundType === 2 ? sm.roundResult.totalBet * 100 : sm.roundResult.totalBet,
        //     betId: sm.roundResult.betId
        // });
        if (sm.autoplay.enabled && sm.autoplay.canAutoSpin(sm.roundResult, wallet.credits)) {
            if (sm.autoplay.spinsLeft > 0)
                sm.autoplay.spinsLeft -= 1;
            setTimeout(() => {
                new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
            }, 0);
        }
        else {
            sm.autoplay.spinsLeft = 0;
            sm.autoplay.enabled = false;
            sm.currentState = SlotMachineState_1.SlotMachineState.IDLE;
        }
    }
}
exports["default"] = CompleteRoundCommandOverride;


/***/ }),

/***/ 53503:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tsyringe_1 = __webpack_require__(659);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const ControlCommand_1 = __importDefault(__webpack_require__(5061));
const SlotMachineState_1 = __webpack_require__(77313);
const SlotGameEvent_1 = __webpack_require__(19342);
const Logger_1 = __importDefault(__webpack_require__(82669));
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
class SpinStartCommandOverride extends ControlCommand_1.default {
    execute() {
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
        const totalBet = sm.totalBet * wallet.coinValue;
        // if (wallet.balance < totalBet) {
        //     if (sm.autoplay.enabled) {
        //         sm.autoplay.spinsLeft = 0;
        //         sm.autoplay.enabled = false;
        //     }
        //     sm.currentState = SlotMachineState.IDLE;
        //     wallet.emit(WalletEvent.NOT_ENOUGH_BALANCE);
        //     return;
        // }
        wallet.balance -= totalBet;
        sm.spinTimeLapsed = false;
        sm.reelsStarted = false;
        sm.stopRequested = false;
        sm.bigWinShown = false;
        const previousRoundResult = sm.roundResult;
        sm.previousRoundResult = previousRoundResult;
        //sm.roundResult.totalWinValue = 0;
        sm.roundResult = null;
        sm.currentState = SlotMachineState_1.SlotMachineState.SPINNING;
        const gs = tsyringe_1.container.resolve('GameService');
        gs.spin(totalBet, sm.numLines == 0 ? sm.combinations : sm.numLines)
            .then((roundResult) => {
            sm.roundResult = roundResult;
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_STOP).dispatch();
        })
            .catch((e) => {
            Logger_1.default.error("Spin error:", e);
            // Stop autoplay in case of any error
            if (sm.autoplay.enabled) {
                sm.autoplay.spinsLeft = 0;
                sm.autoplay.enabled = false;
            }
            sm.currentError = e;
            sm.roundResult = sm.getDummyRoundResult(previousRoundResult);
            wallet.balance += totalBet;
            sm.currentState = SlotMachineState_1.SlotMachineState.COMMUNICATION_ERROR;
        });
    }
}
exports["default"] = SpinStartCommandOverride;


/***/ }),

/***/ 69898:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlotGameEventExtension = void 0;
var SlotGameEventExtension;
(function (SlotGameEventExtension) {
    SlotGameEventExtension["BUY_FREESPINS"] = "onBuyFreespins";
})(SlotGameEventExtension || (exports.SlotGameEventExtension = SlotGameEventExtension = {}));


/***/ }),

/***/ 43022:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIEventExtension = void 0;
var UIEventExtension;
(function (UIEventExtension) {
    UIEventExtension["BET_QUANTITY_UP"] = "onBetQuantityUp";
    UIEventExtension["BET_QUANTITY_DOWN"] = "onBetQuantityDown";
    UIEventExtension["BET_QUANTITY_MAX"] = "onBetQuantityMax";
    UIEventExtension["TOTAL_BET_UP"] = "onTotalBetUp";
    UIEventExtension["TOTAL_BET_DOWN"] = "onTotalBetDown";
    UIEventExtension["BET_QUANTITY_MIN"] = "onBetQuantityMin";
})(UIEventExtension || (exports.UIEventExtension = UIEventExtension = {}));


/***/ }),

/***/ 41087:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFromLocalStorage = exports.saveToLocalStorage = void 0;
function saveToLocalStorage(key, data) {
    localStorage.setItem(key, JSON.stringify(data));
}
exports.saveToLocalStorage = saveToLocalStorage;
function getFromLocalStorage(key) {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : null;
}
exports.getFromLocalStorage = getFromLocalStorage;


/***/ }),

/***/ 69310:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionType = void 0;
var TransactionType;
(function (TransactionType) {
    TransactionType[TransactionType["REGULAR"] = 1] = "REGULAR";
    TransactionType[TransactionType["FREESPIN"] = 10] = "FREESPIN";
    TransactionType[TransactionType["RESPIN"] = 30] = "RESPIN";
    TransactionType[TransactionType["RESPIN_IN_FREESPIN"] = 31] = "RESPIN_IN_FREESPIN";
})(TransactionType || (exports.TransactionType = TransactionType = {}));


/***/ }),

/***/ 18436:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const axios_1 = __importDefault(__webpack_require__(86425));
const eventemitter3_1 = __importDefault(__webpack_require__(30228));
const jwt_decode_1 = __importDefault(__webpack_require__(6765));
const tsyringe_1 = __webpack_require__(659);
const uuid_1 = __webpack_require__(22831);
const Logger_1 = __importDefault(__webpack_require__(82669));
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotMachineDescription_1 = __webpack_require__(9130);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const LocalStorageUtils_1 = __webpack_require__(41087);
const TransactionType_1 = __webpack_require__(69310);
const GameServiceEvent_1 = __webpack_require__(83363);
const History_1 = __importDefault(__webpack_require__(11703));
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundList_1 = __importDefault(__webpack_require__(27310));
let GameService = class GameService extends eventemitter3_1.default {
    constructor(baseUrl, historyUrl, jwtToken, gameCode, lobbyUrl = '', userLoginUrl = 'https://api-stage.exagaming.com/api/v1/user/login') {
        var _a;
        super();
        // token will refresh if less than X seconds left to expiry
        this.tokenRefreshThreshold = 300;
        this._doubleChanceEnabled = false;
        this.jwtToken = jwtToken;
        this.gameCode = gameCode;
        this.lobbyUrl = lobbyUrl;
        this.userLoginUrl = userLoginUrl;
        this.ax = axios_1.default.create({
            baseURL: baseUrl,
            headers: {
                'Authorization': `Bearer ${this.jwtToken}`
            }
        });
        this.ax.interceptors.request.use((config) => __awaiter(this, void 0, void 0, function* () {
            if (config.url != 'keep-alive') {
                // await this.checkAndUpdateToken();
            }
            return config;
        }), error => {
            Promise.reject(error);
        });
        this.hx = axios_1.default.create({
            baseURL: historyUrl,
            headers: {
                'Authorization': `Bearer ${this.jwtToken}`
            }
        });
        this._settings = (_a = (0, LocalStorageUtils_1.getFromLocalStorage)('settings')) !== null && _a !== void 0 ? _a : {
            quickSpin: false,
            batterySaver: false,
            ambientMusic: true,
            sound: true,
            soundFx: true,
            introScreen: true,
            skipScreen: false,
            turboSpin: false,
            spinButtonLock: false
        };
    }
    // PUBLIC API
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            let data;
            try {
                data = yield this.login();
            }
            catch (e) {
                Logger_1.default.error(e);
                this.emit(GameServiceEvent_1.GameServiceEvent.ERROR);
                throw (e);
            }
            // Adding missing object for handling first time user response
            if (!(data === null || data === void 0 ? void 0 : data.Current)) {
                data.Current = {
                    TotalWin: 0,
                    AccWin: 0,
                    MultiplierMap: {},
                    Result: {
                        R: "102,102,201,103,202,102,104|101,103,101,102,201,101,101|104,201,104,201,201,202,202|202,203,203,104,201,101,101|104,203,203,102,102,202,102|203,101,201,201,102,101,101|101,101,103,103,103,203,203",
                        clusterDetails: []
                    },
                    Round: {
                        RoundType: 1,
                        Bet: 4,
                        BetValue: 1,
                        Line: 20,
                        LineBet: 0.2,
                        Payout: 0
                    },
                    FreeSpin: null
                };
            }
            // Validate and fix currency code
            let currencyCode = data.Player.Currency;
            const denomination = 1;
            // If we received a currency symbol instead of ISO code, convert it
            if (currencyCode === '' || currencyCode === '') {
                currencyCode = 'EUR';
            }
            else if (currencyCode === '$') {
                currencyCode = 'USD';
            }
            else if (currencyCode === '') {
                currencyCode = 'GBP';
            }
            // Validate that it's a proper 3-letter ISO code
            if (!currencyCode || currencyCode.length !== 3 || !/^[A-Z]{3}$/.test(currencyCode)) {
                console.warn('Invalid currency code received:', data.Player.Currency, 'defaulting to EUR');
                currencyCode = 'EUR';
            }
            const wallet = new Wallet_1.default(denomination, {
                isoCode: currencyCode, // Use ISO code directly, not symbol
                precision: 2
            }, [1]);
            const description = {
                rtp: 'unknown',
                coinRate: data.Player.CoinRate,
                type: SlotMachineDescription_1.SlotMachineType.COMBINATIONS,
                betLimits: data.GameInfo.LineBet,
                betMaxQuantity: 10,
                totalWinMultipliers: [
                    1, 2, 3, 4, 5
                ],
                combinations: 20,
                bigWinMultiplierLevels: [10, 20, 30, 40],
                symbols: [25, 104, 103, 102, 101, 203, 202, 201],
                reels: {
                    regular: {
                        cascading: true,
                        reels: [
                            {
                                numRows: 7,
                                availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                            },
                            {
                                numRows: 7,
                                availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                            },
                            {
                                numRows: 7,
                                availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                            },
                            {
                                numRows: 7,
                                availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                            },
                            {
                                numRows: 7,
                                availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                            },
                            {
                                numRows: 7,
                                availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                            },
                            {
                                numRows: 7,
                                availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                            }
                        ]
                    },
                    freeSpins: [
                        {
                            id: 0,
                            cascading: true,
                            reels: [
                                {
                                    numRows: 7,
                                    availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                                },
                                {
                                    numRows: 7,
                                    availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                                },
                                {
                                    numRows: 7,
                                    availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                                },
                                {
                                    numRows: 7,
                                    availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                                },
                                {
                                    numRows: 7,
                                    availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                                },
                                {
                                    numRows: 7,
                                    availableSymbols: [25, 104, 103, 102, 101, 203, 202, 201],
                                }
                            ]
                        },
                    ]
                },
                rules: [
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [5],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.2
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [6],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.25
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [7],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.3
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [8],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.4
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [9],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [10],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [11],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [12],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 2.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [13],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [14],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 10
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 104,
                            symbolCount: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 20
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [5],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.25
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [6],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.3
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [7],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.4
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [8],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [9],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.75
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [10],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.25
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [11],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 2
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [12],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 3
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [13],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 6
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [14],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 12
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 103,
                            symbolCount: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 25
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [5],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.3
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [6],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.4
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [7],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [8],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.75
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [9],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [10],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [11],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 2.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [12],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 3.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [13],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 8
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [14],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 15
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 102,
                            symbolCount: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 30
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [5],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.4
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [6],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [7],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.75
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [8],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [9],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.25
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [10],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 2
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [11],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 3
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [12],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [13],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 10
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [14],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 20
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 101,
                            symbolCount: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 40
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [5],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [6],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [7],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.75
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [8],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 2
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [9],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 2.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [10],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [11],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 7.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [12],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 15
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [13],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 35
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [14],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 70
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 201,
                            symbolCount: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 150
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [5],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.75
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [6],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [7],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.25
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [8],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [9],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 2
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [10],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 4
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [11],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 6
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [12],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 12.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [13],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 30
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [14],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 60
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 202,
                            symbolCount: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 100
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [5],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [6],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 0.75
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [7],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [8],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.25
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [9],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 1.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [10],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 3
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [11],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 4.5
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [12],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 10
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [13],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 20
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [14],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 40
                            }
                        }
                    },
                    {
                        id: 0,
                        pattern: {
                            symbolId: 203,
                            symbolCount: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
                            type: SlotMachineDescription_1.PatternType.BOTH_WAYS
                        },
                        reward: {
                            line: {
                                multiplier: 60
                            }
                        }
                    }
                ]
            };
            wallet.balance = data.Player.Balance;
            const slotMachine = new SlotMachine_1.default(description, {
                gameSpeedLevels: 2
            });
            let roundResult;
            if (data.Current) {
                roundResult = this.parseTransactDataToRoundResult(data, false);
                slotMachine.currentBetValue = this.getLineBetAmount(data.Current.Round.LineBet, data.GameInfo.LineBet) * Wallet_1.default.denomination;
            }
            else {
                roundResult = slotMachine.getDummyRoundResult(null);
                roundResult.nextType = data.Next.Type;
            }
            slotMachine.roundResult = roundResult;
            slotMachine.previousRoundResult = slotMachine.getDummyRoundResult(roundResult);
            this.featureBuy = {
                RoundType: data.GameInfo.BuyFeature ? data.GameInfo.BuyFeature[0].roundType : 1,
                Total: data.GameInfo.BuyFeature ? data.GameInfo.BuyFeature[0].Total : 15,
                Rate: data.GameInfo.BuyFeature ? data.GameInfo.BuyFeature[0].Rate : 100
            };
            slotMachine.currentGameSpeedLevel = !this._settings.quickSpin ? 0 : 1;
            return [wallet, slotMachine];
        });
    }
    getLineBetAmount(lineBet, linebetArray) {
        if (linebetArray.includes(lineBet))
            return lineBet;
        else
            return linebetArray[0];
    }
    get doubleUpChance() {
        return this._doubleChanceEnabled;
    }
    set doubleUpChance(isActive) {
        if (this._doubleChanceEnabled == isActive)
            return;
        this._doubleChanceEnabled = isActive;
        this.emit(GameServiceEvent_1.GameServiceEvent.DOUBLE_CHANCE_CHANGED);
    }
    spin() {
        return __awaiter(this, void 0, void 0, function* () {
            const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
            const wallet = tsyringe_1.container.resolve(Wallet_1.default);
            const totalBet = (sm.totalBet * wallet.coinValue);
            const singleBet = totalBet / sm.combinations;
            return this.getFullRoundResultFromTransact(1, singleBet);
        });
    }
    buyFeature() {
        return __awaiter(this, void 0, void 0, function* () {
            const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
            const wallet = tsyringe_1.container.resolve(Wallet_1.default);
            const totalBet = (sm.totalBet * wallet.coinValue);
            const singleBet = totalBet / sm.combinations;
            return this.getFullRoundResultFromTransact(2, singleBet);
        });
    }
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            Logger_1.default.debug('GameService.login');
            const operatorLogin = yield this.operatorLogin();
            yield this.userLogin(operatorLogin);
            const res = yield this.ax.post('preload', {
                GameCode: this.gameCode
            });
            return res.data.data;
        });
    }
    keepAlive() {
        return __awaiter(this, void 0, void 0, function* () {
            Logger_1.default.debug('GameService.keepAlive');
            const res = yield this.ax.post('keep-alive', {
                GameCode: this.gameCode
            });
            this.jwtToken = res.data.data.Jwt;
            this.ax.defaults.headers.Authorisation = `Bearer ${this.jwtToken}`;
        });
    }
    //Round type: 1 - base game, 2 - feature buy
    transact(lineBet, numLines, type, roundType = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            // const res: AxiosResponse = await this.ax.post('transact', {
            //     Type: type ?? 1,
            //     BetValue: 1,
            //     Line:numLines,
            //     LineBet: lineBet,
            //     RoundType:this.doubleUpChance?3:roundType,
            // });
            // Logger.debug(res.data.data)
            // return res.data.data;
            let res;
            Logger_1.default.debug('GameService.transact');
            try {
                res = yield this.ax.post('transact', {
                    Type: type !== null && type !== void 0 ? type : 1,
                    BetValue: 1,
                    Line: numLines,
                    LineBet: lineBet,
                    RoundType: this.doubleUpChance ? 3 : roundType,
                });
                // @ts-ignore
                if (!res.success && res.status != 200) {
                    throw ('PLEASE_CONTACT_OPERATOR');
                }
            }
            catch (e) {
                if (e === 'PLEASE_CONTACT_OPERATOR') {
                    throw (e);
                }
                else if (e.response.status === 400) {
                    throw (e.response.data.errors[0].description);
                }
                else {
                    throw ('CONNECTION_LOST');
                }
            }
            Logger_1.default.debug(res.data.data);
            return res.data.data;
        });
    }
    lobby() {
        Logger_1.default.debug('GameService.lobby');
        if (typeof this.lobbyUrl != 'undefined' && this.lobbyUrl)
            window.open(this.lobbyUrl, '_self');
        else
            history.back();
    }
    get featureBuyConfig() {
        return this.featureBuy;
    }
    saveSettings() {
        (0, LocalStorageUtils_1.saveToLocalStorage)('settings', this._settings);
        this.emit(GameServiceEvent_1.GameServiceEvent.SETTINGS_CHANGED, this);
    }
    get settings() {
        return this._settings;
    }
    // PRIVATE API
    checkAndUpdateToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const expirationTimestamp = (0, jwt_decode_1.default)(this.jwtToken)['exp'] * 1000;
            const timeLeftSeconds = (expirationTimestamp - Date.now()) / 1000;
            if (timeLeftSeconds < this.tokenRefreshThreshold) {
                yield this.keepAlive();
            }
        });
    }
    getFullRoundResultFromTransact(roundType = 1, bet) {
        return __awaiter(this, void 0, void 0, function* () {
            const sm = tsyringe_1.container.resolve(SlotMachine_1.default);
            const wallet = tsyringe_1.container.resolve(Wallet_1.default);
            let data = null;
            const totalBet = (sm.totalBet * wallet.coinValue);
            const singleBet = totalBet / sm.combinations;
            SoundManager_1.default.play({
                id: SoundList_1.default.UI_BUTTON_SPIN_START,
                volume: 0.3
            });
            try {
                data = yield this.transact(bet, sm.combinations, sm.previousRoundResult.nextType, roundType);
            }
            catch (e) {
                Logger_1.default.error(e);
                this.emit(GameServiceEvent_1.GameServiceEvent.ERROR);
                throw (e);
            }
            let roundResult = this.parseTransactDataToRoundResult(data);
            const previousSpins = roundResult.spins;
            //get cascade spins till its finished
            while (roundResult.nextType && (roundResult.nextType === TransactionType_1.TransactionType.RESPIN || roundResult.nextType === TransactionType_1.TransactionType.RESPIN_IN_FREESPIN)) {
                try {
                    data = yield this.transact(singleBet / Wallet_1.default.denomination, sm.combinations, roundResult.nextType, 1);
                }
                catch (e) {
                    Logger_1.default.error(e);
                    this.emit(GameServiceEvent_1.GameServiceEvent.ERROR);
                    throw (e);
                }
                const newResult = this.parseTransactDataToRoundResult(data);
                newResult.spins.forEach((spinResult) => {
                    previousSpins.push(spinResult);
                });
                roundResult = newResult;
                roundResult.spins = previousSpins;
            }
            return roundResult;
        });
    }
    getHistoryResponse(page, perPage) {
        return __awaiter(this, void 0, void 0, function* () {
            const historyResponse = yield this.getMyBets(page, perPage);
            const history = tsyringe_1.container.resolve(History_1.default);
            history.currentPage = historyResponse.page;
            history.totalPages = historyResponse.totalPages;
            history.entries = [];
            historyResponse.bets.forEach((historyData) => {
                history.entries.push({
                    datetime: historyData.createdAt,
                    balance: historyData.player.Balance,
                    win: historyData.roundType === 2 ? Number(historyData.winningAmount) + Number(historyData.freeSpinWinningAmount) : historyData.winningAmount,
                    totalBet: historyData.roundType === 2 ? historyData.betAmount * 100 : historyData.betAmount,
                    betId: historyData.id
                });
            });
            return historyResponse;
        });
    }
    getMyBets(page, perPage) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("my bets")
            const res = yield this.hx.get('my-bets', {
                params: {
                    page: page ? page : 1,
                    perPage: perPage
                }
            });
            return res.data.data;
        });
    }
    parseTransactDataToRoundResult(data, fullParse = true) {
        var _a, _b, _c, _d;
        const reelsOutput = this.parseReelsOutput(data.Current.Result.R);
        const roundResult = {
            complete: false,
            id: (0, uuid_1.v4)(),
            lineBetValue: data.Current.Round.LineBet * Wallet_1.default.denomination,
            betLines: data.Current.Round.Line,
            totalBet: data.Current.Round.Bet,
            totalWinValue: data.Current.Round.Payout,
            roundType: data.Current.Round.RoundType,
            spinIndex: 0,
            details: data.Details ? {
                betId: data.Details.betId,
                gameId: data.Details.gameId,
                userId: data.Details.userId
            } : null,
            nextType: data.Next.Type,
            spins: [
                {
                    result: reelsOutput,
                    multipliers: this.parseMultipliersOutput(data.Current.MultiplierMap, reelsOutput.length),
                    winValue: data.Current.TotalWin,
                    currentTotalWinValue: data.Current.AccWin,
                    win: (data.Current.Result.clusterDetails.length > 0 || data.Current.Result.scatter) ? {
                        multiWinShown: ((_a = data.Current.Result) === null || _a === void 0 ? void 0 : _a.scatter) ? true : false,
                        scatterWinShown: ((_b = data.Current.Result) === null || _b === void 0 ? void 0 : _b.scatter) ? false : true,
                        winningPattern: ((_c = data.Current.Result) === null || _c === void 0 ? void 0 : _c.scatter) ? this.parseScatterWins(data.Current.Result.scatter, reelsOutput.length) : this.parseWaysWins(data.Current.Result.clusterDetails, reelsOutput.length)
                    } : null,
                    freespins: (data.Next.FreeSpin || data.Current.FreeSpin) ? {
                        freespinId: data.Current.FreeSpin ? data.Current.FreeSpin.Current : 0,
                        moreAwarded: ((_d = data.Next.FreeSpin) === null || _d === void 0 ? void 0 : _d.MoreAwarded) ? data.Next.FreeSpin.MoreAwarded : null,
                        totalCount: data.Next.FreeSpin ? data.Next.FreeSpin.Total : data.Current.FreeSpin.Total,
                        remainingCount: data.Next.FreeSpin ? data.Next.FreeSpin.Total - (data.Next.FreeSpin.Next - 1) : data.Current.FreeSpin ? data.Current.FreeSpin.Total - data.Current.FreeSpin.Current : 0, // (data.Current.FreeSpin ? data.Current.FreeSpin.Total - (data.Current.FreeSpin.Current+1) :(data.Next.FreeSpin?data.Next.FreeSpin.Total:0)),
                        roundStarted: (data.Current.FreeSpin && data.Current.FreeSpin.Current > 0),
                        roundComplete: false,
                    } : null
                }
            ]
        };
        return roundResult;
    }
    parseWaysWins(clusterDetails, reelsLength) {
        const winningSymbols = new Map();
        clusterDetails.forEach((cluster) => {
            var _a;
            let symbolCount = 0;
            let pattern = Array.from({ length: reelsLength }, () => Array(reelsLength).fill(0));
            let payout = 0;
            let multiplier = 0;
            let multipliersPosition = Array.from({ length: reelsLength }, () => Array(reelsLength).fill(0));
            cluster.positions.forEach((pos) => {
                const [row, col] = pos.split(',').map(Number);
                pattern[row][col] = 1;
                symbolCount++;
            });
            payout = cluster.payout;
            multiplier = Number(cluster.multiplier);
            // If the symbol already exists, push to the existing array
            const symbolKey = Number(cluster.symbol);
            if (winningSymbols.has(symbolKey)) {
                (_a = winningSymbols.get(symbolKey)) === null || _a === void 0 ? void 0 : _a.push({
                    symbolCount: symbolCount,
                    pattern: pattern,
                    payout: payout,
                    multiplier: multiplier,
                    multipliersPosition: multipliersPosition
                });
            }
            else {
                winningSymbols.set(symbolKey, [{
                        symbolCount: symbolCount,
                        pattern: pattern,
                        payout: payout,
                        multiplier: multiplier,
                        multipliersPosition: multipliersPosition
                    }]);
            }
        });
        return winningSymbols;
    }
    parseReelsOutput(data) {
        return data.split('|')
            .map((value) => {
            return value.split(',')
                .map((value) => {
                return parseInt(value);
            });
        });
    }
    parseMultipliersOutput(data, reelsLength) {
        const multipliers = Array.from({ length: reelsLength }, () => Array(reelsLength).fill(0));
        if (data) {
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    const [row, col] = key.split(',').map(Number);
                    multipliers[row][col] = Number(data[key]);
                }
            }
        }
        console.log(multipliers);
        return multipliers;
    }
    parseScatterWins(scatterDetails, reelsLength) {
        const winningSymbols = new Map();
        const scatterPattern = Array.from({ length: reelsLength }, () => Array(reelsLength).fill(0));
        let symbolCount = 0;
        scatterDetails.positions.forEach((pos) => {
            const [row, col] = pos.split(',').map(Number);
            scatterPattern[row][col] = 1;
            symbolCount++;
        });
        winningSymbols.set(scatterDetails.symbol, [{
                symbolCount: symbolCount,
                pattern: scatterPattern,
                payout: scatterDetails.payout
            }]);
        return winningSymbols;
    }
    operatorLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ax.post('https://casino.playboo.io/login', {
                username: 'priti16',
                password: 'password'
            });
            return res.data.token;
        });
    }
    userLogin(userToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ax.post('https://api-stage.exagaming.com/api/v1/user/login', {
                operatorId: '1000',
                operatorUserToken: userToken,
                currencyCode: 'USD',
                gameId: 27
            });
            this.ax.defaults.headers.Authorization = `Bearer ${res.data.data.accessToken}`;
        });
    }
};
GameService = __decorate([
    (0, tsyringe_1.singleton)(),
    __metadata("design:paramtypes", [String, String, String, String, String, String])
], GameService);
exports["default"] = GameService;


/***/ }),

/***/ 83363:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GameServiceEvent = void 0;
var GameServiceEvent;
(function (GameServiceEvent) {
    GameServiceEvent["ERROR"] = "on_error_received";
    GameServiceEvent["DOUBLE_CHANCE_CHANGED"] = "onDoubleChanceChanged";
    GameServiceEvent["SETTINGS_CHANGED"] = "onSettingsChanged";
})(GameServiceEvent || (exports.GameServiceEvent = GameServiceEvent = {}));


/***/ }),

/***/ 92907:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorMessageCode = exports.currencyCode = exports.jsonAdress = void 0;
exports.jsonAdress = {
    'EN': 'EN',
    'TR': 'TR',
    'PT': 'PT',
};
exports.currencyCode = {
    'EUR': '',
    'TRY': '',
    'AFN': '',
    'ARS': '$',
    'AWG': '',
    'AUD': '$',
    'AZN': '',
    'BSD': '$',
    'BBD': '$',
    'BYN': 'Br',
    'BZD': 'BZ$',
    'BMD': '$',
    'BOB': '$b',
    'BAM': 'KM',
    'BWP': 'P',
    'BGN': '',
    'BRL': 'R$',
    'BND': '$',
    'KHR': '',
    'CAD': '$',
    'KYD': '$',
    'CLP': '$',
    'CNY': '',
    'COP': '$',
    'CRC': '',
    'HRK': 'kn',
    'CUP': '',
    'CZK': 'K',
    'DKK': 'kr',
    'DOP': 'RD$',
    'XCD': '$',
    'EGP': '',
    'SVC': '$',
    'FKP': '',
    'FJD': '$',
    'GHS': '',
    'GIP': '',
    'GTQ': 'Q',
    'GGP': '',
    'GYD': '$',
    'HNL': 'L',
    'HKD': '$',
    'HUF': 'Ft',
    'ISK': 'kr',
    'INR': '',
    'IDR': 'Rp',
    'IRR': '',
    'IMP': '',
    'ILS': '',
    'JMD': 'J$',
    'JPY': '',
    'JEP': '',
    'KZT': '',
    'KPW': '',
    'KRW': '',
    'KGS': '',
    'LAK': '',
    'LBP': '',
    'LRD': '$',
    'MKD': '',
    'MYR': 'RM',
    'MUR': '',
    'MXN': '$',
    'MNT': '',
    'MZN': 'MT',
    'NAD': '$',
    'NPR': '',
    'ANG': '',
    'NZD': '$',
    'NIO': 'C$',
    'NGN': '',
    'NOK': 'kr',
    'OMR': '',
    'PKR': '',
    'PAB': 'B/.',
    'PYG': 'Gs',
    'PEN': 'S/.',
    'PHP': '',
    'PLN': 'z',
    'QAR': '',
    'RON': 'lei',
    'RUB': '',
    'SHP': '',
    'SAR': '',
    'RSD': '.',
    'SCR': '',
    'SGD': '$',
    'SBD': '$',
    'SOS': 'S',
    'ZAR': 'R',
    'LKR': '',
    'SEK': 'kr',
    'CHF': 'CHF',
    'SRD': '$',
    'SYP': '',
    'TWD': 'NT$',
    'THB': '',
    'TTD': 'TT$',
    'TVD': '$',
    'UAH': '',
    'GBP': '',
    'USD': '$',
    'UYU': '$U',
    'UZS': '',
    'VEF': 'Bs',
    'VND': '',
    'YER': '',
    'ZWD': 'Z$',
};
exports.errorMessageCode = {
    'UNFINISHED_SLOT_GAME_BET_EXISTS': 'SOMETHING WENT WRONG',
    'BASE_SLOT_GAME_BET_NOT_EXISTS': 'BET DOES NOT EXIST',
    'CONNECTION_LOST': 'CONNECTION LOST',
    'NOT_ENOUGH_BALANCE': 'INSUFFICIENT FUNDS',
    'INSUFFICIENT_FUNDS': 'INSUFFICIENT FUNDS',
    'INVALID_TOKEN': 'INVALID TOKEN',
    'UNKNOWN_OPERATOR_ERROR': 'UNKNOWN OPERATOR ERROR',
    'PLEASE_CONTACT_OPERATOR': 'PLEASE CONTACT OPERATOR'
};


/***/ }),

/***/ 19402:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const SoundList_1 = __importDefault(__webpack_require__(27310));
class SoundListExtended extends SoundList_1.default {
}
SoundListExtended.BASEGAME_BACKGROUND = 'basegame_loop';
SoundListExtended.FREEGAME_BACKGROUND = 'freegame_loop';
SoundListExtended.SYMBOL_LOW_PAYOUT_1 = 'symbol_hp1_win';
SoundListExtended.SYMBOL_LOW_PAYOUT_2 = 'symbol_hp1_win';
SoundListExtended.SYMBOL_LOW_PAYOUT_3 = 'symbol_hp1_win';
SoundListExtended.SYMBOL_LOW_PAYOUT_4 = 'symbol_hp2_win';
SoundListExtended.SYMBOL_HIGH_PAYOUT_1 = 'symbol_hp1_win';
SoundListExtended.SYMBOL_HIGH_PAYOUT_2 = 'symbol_hp2_win';
SoundListExtended.SYMBOL_HIGH_PAYOUT_3 = 'symbol_hp1_win';
SoundListExtended.SYMBOL_SCATTER = 'symbol_scatter_win';
SoundListExtended.SYMBOL_SCATTER_LAND = 'symbol_scatter_land';
SoundListExtended.BUY_FREE_SPIN = 'buy_freespin';
SoundListExtended.REEL_MULTIPLIER = 'reel_multiplier';
SoundListExtended.TURBO_BTN_CLICK = 'bet_panel_turbo_icon_click';
exports["default"] = SoundListExtended;


/***/ }),

/***/ 93397:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BetDetails = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const ValueText_1 = __importDefault(__webpack_require__(68223));
class BetDetails extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
        }
        return instance;
    }
    setBetDetails(betDetails) {
        this.tfBetID.tfValue.text = "Bet ID: " + betDetails.betId.toString() + " | Game ID: " + betDetails.gameId.toString() + " | User ID: " + betDetails.userId.toString();
        // this.tfGameID.tfValue.text ="Game ID: "+ betDetails.gameId.toString()
        // this.tfUserID.tfValue.text ="User ID: "+ betDetails.userId.toString()
    }
}
exports.BetDetails = BetDetails;


/***/ }),

/***/ 4567:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_spine_1 = __webpack_require__(15091);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const Utils_1 = __webpack_require__(63948);
class Character extends pixi_spine_1.Spine {
    constructor() {
        super(AssetsManager_1.default.spine.get('character'));
        this.animationChances = [
            {
                animation: 'idle',
                chance: 100,
            }
        ];
        this.totalChances = 0;
        // this is for hide character
        // this.alpha = 0
        this.state.addListener({
            complete: (entry) => {
                const result = (0, Utils_1.randomInt)(1, this.totalChances);
                let counter = 0;
                let animationName;
                for (const ac of this.animationChances) {
                    counter += ac.chance;
                    if (result <= counter) {
                        animationName = ac.animation;
                        break;
                    }
                }
                this.state.setAnimation(0, animationName, false);
            }
        });
        this.on('added', this.onAdded, this);
    }
    onAdded() {
        this.state.setEmptyAnimations(0);
        this.state.setAnimation(0, 'idle', false);
    }
    playWinAnimation(animationName) {
        this.state.data.setMix('idle', animationName, 0.15);
        this.state.data.setMix(animationName, 'idle', 0.15);
        this.state.setAnimation(0, animationName, false);
        //  SoundManager.play(SoundList.HERO_ANIMATION);
    }
}
exports["default"] = Character;


/***/ }),

/***/ 62702:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GamePlayIntro = exports.desc = void 0;
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const ScreenOrientation_1 = __webpack_require__(81827);
const pixi_js_1 = __webpack_require__(95894);
const engineTween_1 = __webpack_require__(50381);
const pixi_spine_1 = __webpack_require__(15091);
const Logger_1 = __importDefault(__webpack_require__(82669));
// Tile mappings
const tileMappings = [
    { id: 101, key: "1", spineFile: "symbol-00" },
    { id: 102, key: "2", spineFile: "symbol-01" },
    { id: 103, key: "3", spineFile: "symbol-02" },
    { id: 104, key: "4", spineFile: "symbol-03" },
    { id: 201, key: "5", spineFile: "symbol-05" },
    { id: 202, key: "6", spineFile: "symbol-06" },
    { id: 203, key: "7", spineFile: "symbol-07" },
    // Add mappings for other multipliers as needed
    // { id: 102, type: "multiplier", value: "100", key: "11", spineFile: "symbol-multiplier-orange" },
];
class GamePlayIntro extends pixi_js_1.Container {
    constructor() {
        super();
        this.simulationRunning = false;
        this.spineDataMap = new Map();
        this.desc = {
            baseWidth: 1920, baseHeight: 1080,
            orientation: ScreenOrientation_1.ScreenOrientation.HORIZONTAL,
            currentWidth: 0,
            currentHeight: 0
        };
    }
    startSimulation() {
        return __awaiter(this, void 0, void 0, function* () {
            if (GamePlayIntro.isSimulationRunning) {
                return;
            }
            GamePlayIntro.isSimulationRunning = true;
            yield this.init();
            setTimeout(() => {
                this.playIntroSimulation();
            }, 2500);
        });
    }
    playIntroSimulation() {
        return __awaiter(this, void 0, void 0, function* () {
            Logger_1.default.debug('playIntroSimulation');
            this.simulationRunning = true;
            while (this.simulationRunning) {
                yield this.simulateGameCycle();
            }
        });
    }
    simulateGameCycle() {
        return __awaiter(this, void 0, void 0, function* () {
            // Step 1: Detect matches
            const matches = this.detectMatches();
            if (matches.length > 0) {
                // Step 2: Process matches
                yield this.processUpdatesSequentially(matches, false);
                // Step 3: Apply gravity
                yield this.applyGravity();
                // Step 4: Add new pieces to empty spots
                const newPieces = this.generateNewPieces();
                yield this.handleNewPieces(newPieces);
                // Add a small delay before the next cycle
                yield this.delay(500);
            }
            else {
                // No matches detected, end cycle
                this.simulationRunning = false; // End simulation if no matches are found
            }
        });
    }
    detectMatches() {
        const keyCounts = {};
        const keyPositions = {};
        // Count occurrences of each key and store their positions
        for (let y = 0; y < this.gridRows; y++) {
            for (let x = 0; x < this.gridCols; x++) {
                const piece = this.grid[y][x];
                if (piece) {
                    const key = piece.key;
                    if (!keyCounts[key]) {
                        keyCounts[key] = 0;
                        keyPositions[key] = [];
                    }
                    keyCounts[key]++;
                    keyPositions[key].push({ x, y });
                }
            }
        }
        // Find the key with the highest count
        let highestKey = null;
        let highestCount = 0;
        for (const key in keyCounts) {
            if (keyCounts[key] > highestCount) {
                highestCount = keyCounts[key];
                highestKey = key;
            }
        }
        if (!highestKey) {
            // No matches found
            return [];
        }
        // Collect all positions for the highest key
        const matches = keyPositions[highestKey].map(pos => ({
            location_x: pos.x,
            location_y: pos.y,
            action: "match",
        }));
        return matches;
    }
    generateNewPieces() {
        const newPieces = [];
        for (let y = 0; y < this.gridRows; y++) {
            for (let x = 0; x < this.gridCols; x++) {
                if (this.grid[y][x] === null) {
                    newPieces.push({
                        location_x: x,
                        location_y: y,
                        item_id: this.getRandomTileId(),
                    });
                }
            }
        }
        return newPieces;
    }
    stopIntroSimulation() {
        this.simulationRunning = false;
    }
    getRandomTileId() {
        // @ts-ignore
        const tiles = tileMappings.filter(tile => tile.type !== "multiplier");
        if (Math.random() < 0.003) {
            this.numOfMultiplierLanded += 1;
            // @ts-ignore
            const multipliers = tileMappings.filter(tile => tile.type === "multiplier");
            if (multipliers.length > 0) {
                return multipliers[Math.floor(Math.random() * multipliers.length)].id;
            }
        }
        return tiles[Math.floor(Math.random() * tiles.length)].id;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.desc.baseWidth = 1920;
            this.desc.baseHeight = 1080;
            this.heightReductionFactor = 0.07;
            this.margin = 50;
            this.dividerSprite = [];
            this.gridRows = 7;
            this.gridCols = 7;
            this.grid = Array.from({ length: this.gridRows }, () => Array(this.gridCols).fill(null));
            const appHeight = this.desc.baseHeight;
            const heightReduction = appHeight * this.heightReductionFactor;
            this.sortableChildren = true;
            this.borderRadiusMask = new pixi_js_1.Graphics();
            this.updateBackgroundAndMask();
            // this.addChild(this.background);
            this.gridContainer = new pixi_js_1.Container();
            this.dividerContainer = new pixi_js_1.Container();
            this.gridContainer.x = this.margin;
            this.gridContainer.y = this.margin + heightReduction;
            this.dividerContainer.x = this.margin;
            this.dividerContainer.y = this.margin + heightReduction;
            this.backgroundContainer = new pixi_js_1.Container();
            this.addChild(this.backgroundContainer);
            this.addChild(this.gridContainer);
            this.addChild(this.dividerContainer);
            // Spin button event listener
            this.spinButton = document.getElementById('spin-button');
            // Load initial assets and data
            yield this.loadInitialData();
        });
    }
    updateBackgroundAndMask() {
        const appWidth = this.desc.baseWidth;
        const appHeight = this.desc.baseHeight;
        const heightReduction = appHeight * this.heightReductionFactor;
        // Clear and redraw the mask
        this.borderRadiusMask.clear();
        this.borderRadiusMask.beginFill(0xFFFFFF);
        this.borderRadiusMask.drawRoundedRect(0, 0, 1881.6, 928.8, 20);
        this.borderRadiusMask.endFill();
        this.borderRadiusMask.position.set(10, 113);
        this.borderRadiusMask.alpha = 0;
        // Apply the mask to the background
        // this.background.mask = this.borderRadiusMask;
        if (!this.borderRadiusMask.parent) {
            this.addChild(this.borderRadiusMask);
        }
    }
    loadInitialData() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Generate random initial board data
                this.initialBoardData = this.generateRandomBoard();
                // Load assets after generating the initial data
                yield this.loadAssets();
            }
            catch (err) {
                console.error('Error loading initial data:', err);
            }
        });
    }
    generateRandomBoard() {
        const board = [];
        // @ts-ignore
        const tiles = tileMappings;
        const tileIds = tiles.map(mapping => mapping.id);
        for (let x = 0; x < this.gridCols; x++) {
            board[x] = [];
            for (let y = 0; y < this.gridRows; y++) {
                const randomId = tileIds[Math.floor(Math.random() * tileIds.length)];
                board[x][y] = randomId;
            }
        }
        return board;
    }
    loadAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Collect unique spine keys from tileMappings
                const spineKeys = Array.from(new Set(tileMappings.map(mapping => mapping.spineFile)));
                // Load all spines using AssetsManager
                for (const key of spineKeys) {
                    const spineData = AssetsManager_1.default.spine.get(key);
                    if (!spineData) {
                        console.warn(`Failed to load spine for key: ${key}`);
                    }
                    else {
                        this.spineDataMap.set(key, spineData);
                    }
                }
                this.calculateTileSizeAndSpacing();
                this.createGrid(this.initialBoardData);
                this.createGridMask();
                // this.addBorder();
            }
            catch (err) {
                console.error('Error loading spine data:', err);
            }
        });
    }
    calculateTileSizeAndSpacing() {
        const appWidth = this.desc.baseWidth;
        const appHeight = this.desc.baseHeight;
        const heightReduction = appHeight * this.heightReductionFactor;
        const availableWidth = appWidth - 2 * this.margin;
        const availableHeight = appHeight - 2 * this.margin - heightReduction;
        this.spacing = Math.min(availableWidth / 50, availableHeight / 50);
        this.tileSize = {
            width: (availableWidth - (this.gridCols - 1) * this.spacing) / this.gridCols,
            height: (availableHeight - (this.gridRows - 1) * this.spacing) / this.gridRows,
        };
    }
    createGridMask() {
        const gridWidth = (this.tileSize.width + this.spacing) * this.gridCols - this.spacing;
        const gridHeight = (this.tileSize.height + this.spacing) * this.gridRows - this.spacing;
        if (this.gridMask) {
            this.gridMask.clear();
        }
        else {
            this.gridMask = new pixi_js_1.Graphics();
        }
        this.gridMask.beginFill(0xFFFFFF);
        this.gridMask.drawRect(0, 0, gridWidth, gridHeight);
        this.gridMask.endFill();
        this.gridMask.x = this.gridContainer.x;
        this.gridMask.y = this.gridContainer.y;
        this.gridContainer.mask = this.gridMask;
        if (!this.gridMask.parent) {
            this.addChild(this.gridMask);
        }
    }
    createGrid(boardData) {
        this.gridContainer.removeChildren().forEach(child => {
            child.destroy({ children: true, texture: true, baseTexture: true });
        });
        this.grid = Array.from({ length: this.gridRows }, () => Array(this.gridCols).fill(null));
        for (let y = 0; y < this.gridRows; y++) {
            for (let x = 0; x < this.gridCols; x++) {
                const itemId = boardData[x][y];
                if (itemId !== null) {
                    const mapping = tileMappings.find(mapping => mapping.id === itemId);
                    if (mapping) {
                        const spineData = this.spineDataMap.get(mapping.spineFile);
                        // Log for debugging purposes
                        if (!spineData) {
                        }
                        else {
                        }
                        if (!spineData) {
                            continue; // Skip invalid or missing spine data
                        }
                        try {
                            const piece = new Piece(this.desc, spineData, mapping.id, mapping.key, this.tileSize, 
                            // @ts-ignore
                            mapping.type || '', 
                            // @ts-ignore
                            mapping.value || '');
                            piece.container.x = x * (this.tileSize.width + this.spacing);
                            piece.container.y = y * (this.tileSize.height + this.spacing);
                            this.gridContainer.addChild(piece.container);
                            this.grid[y][x] = piece;
                        }
                        catch (err) {
                            console.error(`Error creating piece for id: ${mapping.id}, key: ${mapping.key}`, err);
                        }
                    }
                }
            }
        }
    }
    processUpdatesSequentially(updates, endBoard) {
        return __awaiter(this, void 0, void 0, function* () {
            // Detect matches
            const matches = updates.filter(update => typeof update.action === 'string' && update.action.toLowerCase() === "match");
            // Handle matches
            const matchPromises = matches.map(match => this.handleMatch(match.location_x, match.location_y, endBoard));
            yield Promise.all(matchPromises);
            if (this.numOfMultiplierLanded >= 3) {
                this.stopIntroSimulation();
            }
            // Apply gravity and drop new pieces
            if (matches.length > 0) {
                yield this.applyGravity();
            }
        });
    }
    handleNewPieces(newPieces) {
        return __awaiter(this, void 0, void 0, function* () {
            // Sort new pieces by their y-coordinate in descending order (bottom to top)
            newPieces.sort((a, b) => b.location_y - a.location_y);
            const dropPromises = [];
            for (const newPiece of newPieces) {
                const { location_x: x, location_y: y, item_id } = newPiece;
                // Ensure the target position is empty
                if (this.grid[y][x] === null) {
                    const dropPromise = this.handleNew(x, y, item_id);
                    dropPromises.push(dropPromise);
                }
                else {
                    console.warn(`Position (${x}, ${y}) is not empty for new piece.`);
                }
            }
            // Wait for all drop animations to complete
            yield Promise.all(dropPromises);
        });
    }
    handleMatch(x, y, endBoard, reward, showReward = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const piece = this.grid[y][x];
            if (piece) {
                if (showReward && piece.type !== 'multiplier') {
                    if (reward) {
                        this.showRewardText(piece.container.x, piece.container.y, `${reward}`);
                    }
                }
                yield piece.onMatch();
                // Handle multiplier animation
                if (piece.type === 'multiplier' && piece.overlaySprite) {
                    if (endBoard) {
                        // Convert overlay sprite's position to the stage's coordinate space
                        const globalOverlayPosition = piece.overlaySprite.parent.toGlobal(piece.overlaySprite.position);
                        this.addChild(piece.overlaySprite);
                        piece.overlaySprite.position.set(globalOverlayPosition.x, globalOverlayPosition.y);
                        const tumbleCenterPosition = this.tumbleSprite.getGlobalPosition();
                        yield engineTween_1.Tweener.addTween(piece.overlaySprite, {
                            x: tumbleCenterPosition.x,
                            y: tumbleCenterPosition.y,
                            alpha: 1,
                            duration: 1.0,
                            ease: 'power2.out',
                            onStart: () => {
                                engineTween_1.Tweener.addTween(piece.overlaySprite.scale, {
                                    x: piece.overlaySprite.scale.x,
                                    y: piece.overlaySprite.scale.y,
                                    duration: 1.0,
                                    ease: 'power2.out',
                                    repeat: 1,
                                    yoyo: true,
                                });
                            }
                        });
                        yield engineTween_1.Tweener.addTween(piece.overlaySprite, {
                            alpha: 0,
                            duration: 0.5,
                        });
                        if (piece.overlaySprite.parent) {
                            engineTween_1.Tweener.removeTweens(piece.overlaySprite);
                            engineTween_1.Tweener.removeTweens(piece.overlaySprite.scale);
                            piece.overlaySprite.parent.removeChild(piece.overlaySprite);
                        }
                        piece.overlaySprite = null;
                    }
                }
                if (piece.container.parent && piece.type !== 'multiplier') {
                    piece.container.parent.removeChild(piece.container);
                    piece.container = null;
                }
                this.grid[y][x] = null;
            }
            else {
                console.warn(`No piece found at (${x}, ${y}) to match.`);
            }
        });
    }
    showRewardText(x, y, text) {
        const rewardText = new pixi_js_1.Text(text, {
            fontFamily: 'Foo',
            fontSize: 35,
            fill: 0xffffff, // Gold color
            align: 'center',
            fontWeight: '400',
        });
        rewardText.anchor.set(0.5);
        rewardText.position.set(x, y);
        rewardText.alpha = 1;
        rewardText.zIndex = 10;
        this.gridContainer.addChild(rewardText);
        // Animate the text to move up and fade out
        engineTween_1.Tweener.addTween(rewardText, {
            y: y - 50,
            alpha: 0,
            duration: 1.5,
            ease: 'power1.out',
            onComplete: () => {
                // Remove the text from the stage after animation
                if (rewardText.parent) {
                    engineTween_1.Tweener.removeTweens(rewardText);
                    rewardText.destroy();
                }
            }
        });
    }
    handleNew(x, y, itemId) {
        return __awaiter(this, void 0, void 0, function* () {
            const mapping = tileMappings.find(mapping => mapping.id === itemId);
            if (mapping) {
                const spineData = this.spineDataMap.get(mapping.spineFile);
                const piece = new Piece(this.desc, spineData, mapping.id, mapping.key, this.tileSize, 
                // @ts-ignore
                (mapping === null || mapping === void 0 ? void 0 : mapping.type) || '', 
                // @ts-ignore
                (mapping === null || mapping === void 0 ? void 0 : mapping.value) || '');
                const posX = x * (this.tileSize.width + this.spacing);
                const startY = -this.tileSize.height;
                const targetY = y * (this.tileSize.height + this.spacing);
                piece.container.x = posX;
                piece.container.y = startY;
                this.gridContainer.addChild(piece.container);
                this.grid[y][x] = piece;
                // Animate the drop
                yield engineTween_1.Tweener.addTween(piece.container, {
                    y: targetY,
                    time: 0.3,
                    ease: "power2.out",
                });
            }
            else {
                console.warn(`No mapping found for new item ID: ${itemId}`);
                return Promise.resolve();
            }
        });
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    applyGravity() {
        return __awaiter(this, void 0, void 0, function* () {
            const fallPromises = [];
            for (let x = 0; x < this.gridCols; x++) {
                for (let y = this.gridRows - 1; y >= 0; y--) {
                    if (this.grid[y][x] === null) {
                        // Find the nearest piece above
                        for (let k = y - 1; k >= 0; k--) {
                            if (this.grid[k][x]) {
                                // Move piece down to current empty spot
                                const piece = this.grid[k][x];
                                this.grid[k][x] = null;
                                this.grid[y][x] = piece;
                                const posY = y * (this.tileSize.height + this.spacing);
                                const fallPromise = new Promise((resolve) => {
                                    engineTween_1.Tweener.addTween(piece.container, {
                                        y: posY,
                                        time: 0.3,
                                        ease: "power1.inOut",
                                        onComplete: resolve
                                    });
                                });
                                fallPromises.push(fallPromise);
                                break;
                            }
                        }
                    }
                }
            }
            yield Promise.all(fallPromises);
        });
    }
}
exports.GamePlayIntro = GamePlayIntro;
GamePlayIntro.isSimulationRunning = false;
/**
 * Class representing each piece in the game grid.
 */
class Piece {
    constructor(desc, spineData, id, key, tileSize, type = '', value = '') {
        if (!spineData) {
            throw new Error(`Invalid spine data for id: ${id}, key: ${key}`);
        }
        this.container = new pixi_js_1.Container();
        this.id = id;
        this.key = key;
        this.type = type;
        this.value = value;
        this.overlaySprite = null;
        this.spine = new pixi_spine_1.Spine(spineData);
        let scaleFactor;
        if (desc.orientation == "vertical") {
            scaleFactor = Math.min(tileSize.width / this.spine.width, tileSize.height / this.spine.height) * (this.type === 'multiplier' ? .58 : 1.17);
            this.spine.scale.set(scaleFactor * 2, scaleFactor * 4);
        }
        else {
            this.spine.scale.set(1.65, 1.2);
        }
        this.spine.x = tileSize.width / 2;
        this.spine.y = tileSize.height / 2;
        this.container.addChild(this.spine);
        if (this.type === 'multiplier') {
            const multiplierText = new pixi_js_1.BitmapText('X500', {
                fontName: 'DragonCurseGoldFont',
                fontSize: 30,
                align: 'center'
            });
            multiplierText.anchor.set(0.5);
            multiplierText.x = tileSize.width / 2;
            multiplierText.y = tileSize.height / 2;
            this.overlaySprite = multiplierText;
            this.container.addChild(this.overlaySprite);
        }
        this.playAnimation('');
    }
    playAnimation(animationName) {
        return new Promise((resolve) => {
            const anim = animationName ? `${animationName}` : `static`;
            const track = this.spine.state.setAnimation(0, anim, false);
            this.spine.state.timeScale = 1.5;
            // Listen for the 'complete' event
            const listener = {
                complete: (entry) => {
                    var _a, _b;
                    // @ts-ignore
                    if (entry.trackIndex === track.trackIndex &&
                        // @ts-ignore
                        ((_a = entry.animation) === null || _a === void 0 ? void 0 : _a.name) === ((_b = track.animation) === null || _b === void 0 ? void 0 : _b.name)) {
                        // Remove the listener after it fires
                        this.spine.state.removeListener(listener);
                        resolve();
                    }
                },
            };
            this.spine.state.addListener(listener);
        });
    }
    onMatch() {
        return __awaiter(this, void 0, void 0, function* () {
            const animationName = this.type === 'multiplier' ? 'win' : 'match';
            yield this.playAnimation(animationName);
            // Remove the spine animation
            if (this.spine.parent) {
                this.container.removeChild(this.spine);
                this.container.destroy();
                this.spine.state.clearTracks();
                this.spine.destroy({ children: true });
                this.spine = null;
            }
        });
    }
}


/***/ }),

/***/ 56137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GameTransitionAnimation = void 0;
const pixi_spine_1 = __webpack_require__(15091);
const pixi_js_1 = __webpack_require__(95894);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const BrowserApplication_1 = __webpack_require__(32139);
class GameTransitionAnimation extends pixi_js_1.Container {
    constructor() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const aspectRatio = +(width / height).toFixed(2);
        const spineAnimation = AssetsManager_1.default.spine.get(aspectRatio < 1 ? 'transition_mobile' : 'transition_desktop');
        super();
        this.lastAlpha = 0;
        this.transitionTimeScale = 0.8;
        this.lastAnimation = null;
        this.animation = new pixi_spine_1.Spine(spineAnimation);
        this.addChild(this.animation);
        this.on('added', this.onAdded, this);
        this.on('removed', this.onRemoved, this);
        window.addEventListener('resize', this.onResize.bind(this));
        this.alpha = 0;
    }
    onResize() {
        const shouldUseMobile = this.isMobile();
        const desiredKey = shouldUseMobile ? 'transition_mobile' : 'transition_desktop';
        this.animation.angle = shouldUseMobile ? -90 : 0;
        if (!this.animation || this.animation.spineData !== AssetsManager_1.default.spine.get(desiredKey)) {
            if (this.animation) {
                this.removeChild(this.animation);
                this.animation.destroy({ children: true });
            }
            this.animation = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get(desiredKey));
            this.addChildAt(this.animation, 0); // lo mandamos al fondo
            if (this.lastAnimation && this.resolveCallback) {
                const entry = this.animation.state.setAnimation(0, this.lastAnimation, false);
                entry.timeScale = this.transitionTimeScale;
                this.animation.state.addListener({
                    complete: (entry) => {
                        if (entry.animation.name === this.lastAnimation) {
                            this.resolveCallback();
                            this.alpha = 0;
                        }
                    }
                });
            }
        }
        this.scale.set(this.getScaleByAspectRatio());
    }
    /**
     * Determines the aspect ratio type based on screen dimensions
     */
    getAspectRatio() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const aspectRatio = +(width / height).toFixed(2);
        return aspectRatio;
    }
    isMobile() {
        return this.getAspectRatio() < 1;
    }
    /**
     * Determines the aspect ratio type based on screen dimensions
     */
    getScaleByAspectRatio() {
        const scaleMin = Math.min(BrowserApplication_1.BrowserApplication.mainScreenStage.width / 1920, BrowserApplication_1.BrowserApplication.mainScreenStage.height / 1080);
        const scaleMax = Math.max(BrowserApplication_1.BrowserApplication.mainScreenStage.width / 1920, BrowserApplication_1.BrowserApplication.mainScreenStage.height / 1080);
        return this.isMobile() ? scaleMin * 1.8 : scaleMax;
    }
    onAdded() {
        this.alpha = this.lastAlpha;
        this.getAspectRatio() < 1 ? this.position.set(540, 960) : this.position.set(960, 540);
        this.onResize();
    }
    onRemoved() {
        this.lastAlpha = this.alpha;
    }
    setTransition(transitionName) {
        this.lastAnimation = transitionName;
        this.animation.state.setEmptyAnimations(0);
        this['lastTime'] = null;
        return new Promise((resolve) => {
            this.resolveCallback = resolve;
            const entry = this.animation.state.setAnimation(0, transitionName, false);
            entry.timeScale = this.transitionTimeScale;
            this.alpha = 1;
            this.animation.state.addListener({
                complete: (entry) => {
                    if (entry.animation.name === transitionName) {
                        resolve();
                        this.alpha = 0;
                    }
                }
            });
        });
    }
}
exports.GameTransitionAnimation = GameTransitionAnimation;


/***/ }),

/***/ 7670:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// IntroScreen.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ButtonSpin_1 = __importDefault(__webpack_require__(79619));
const IntroScreenEvent_1 = __webpack_require__(81616);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundListExtended_1 = __importDefault(__webpack_require__(19402));
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const AdjustableLayoutContainer_1 = __importDefault(__webpack_require__(66961));
const IntroScreenBackground_1 = __importDefault(__webpack_require__(44170));
const GamePlayIntro_1 = __webpack_require__(62702);
const Logo_1 = __importDefault(__webpack_require__(22452));
const ToggleButton_1 = __webpack_require__(19838);
const Utils_1 = __webpack_require__(63948);
const Translation_1 = __importDefault(__webpack_require__(62231));
const engineTween_1 = __webpack_require__(50381);
const ScreenOrientation_1 = __webpack_require__(81827);
class IntroScreen extends AdjustableLayoutContainer_1.default {
    constructor() {
        super(AssetsManager_1.default.layouts.get("intro-screen"));
        this.messages = [
            "WIN UP TO 5000X BET",
            "RANDOM MULTIPLIERS UP TO 500X",
            "SYMBOL PAY ANYWHERE ON THE SCREEN",
        ];
        this.currentMessageIndex = 0;
        LayoutBuilder_1.default.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        if (this.textBG) {
            this.textBG.alpha = 0;
        }
        this.startTextInterval();
        if (this.background) {
            this.background.anchor.set(0.5, 0.5);
        }
        if (this.backgroundMobile) {
            this.backgroundMobile.anchor.set(0.5, 0.5);
        }
        if (this.gradient) {
            this.gradient.anchor.set(0.5, 1);
        }
        if (this.introCharacter) {
            this.introCharacter.anchor.set(0.5, 0.5);
        }
        // Instantiate GamePlayIntro
        this.tfDoNotShowAgain.anchor.set(0.5, 0.5);
        this.tfDoNotShowAgain.style.align = "center";
        if (this.volatility) {
            this.volatility.anchor.set(0.5, 0.5);
        }
        // Add event listeners
        this.on("added", this.onAdded, this);
        this.on("removed", this.onRemoved, this);
        window.addEventListener("click", this.boundOnGetStartedClicked);
        // Handle button click
        if (this.btnGetStarted) {
            this.btnGetStarted.on("pointerup", this.onGetStartedClicked, this);
        }
        this.tfDoNotShowAgain.text = Translation_1.default.t('tfDoNotShowAgain');
        (0, Utils_1.autoscaleText)(this.tfDoNotShowAgain, 36, 450, 100);
        if (this.doNotShowAgainCheckbox) {
            if (this.doNotShowAgainCheckbox.onState) {
                this.doNotShowAgainCheckbox.onState.removeAllListeners("pointerup");
                this.doNotShowAgainCheckbox.onState.once("pointerup", () => {
                    this.doNotShowAgainCheckbox.changeState(false);
                });
            }
            if (this.doNotShowAgainCheckbox.offState) {
                this.doNotShowAgainCheckbox.offState.removeAllListeners("pointerup");
                this.doNotShowAgainCheckbox.offState.once("pointerup", () => {
                    this.doNotShowAgainCheckbox.changeState(true);
                });
            }
            this.doNotShowAgainCheckbox.removeAllListeners(ToggleButton_1.ToggleButton.STATE_CHANGED);
            this.doNotShowAgainCheckbox.on(ToggleButton_1.ToggleButton.STATE_CHANGED, () => {
                this.onCheckboxClicked(this.doNotShowAgainCheckbox.getIsStateOn());
            }, this);
        }
        // Set up text animations
        setTimeout(() => {
            if (this.tfDoNotShowAgain) {
                engineTween_1.Tweener.addTween(this.tfDoNotShowAgain, {
                    alpha: 1,
                    transition: "easeInSine",
                    time: 0.5,
                });
            }
            if (this.textBG) {
                engineTween_1.Tweener.addTween(this.textBG, {
                    alpha: 0.7,
                    transition: "easeInSine",
                    time: 0.5,
                });
            }
        }, 4000);
    }
    startTextInterval() {
        const updateText = () => {
            if (this.xScatter) {
                // Update to the next message
                this.currentMessageIndex = (this.currentMessageIndex + 1) % this.messages.length;
                this.xScatter.text = this.messages[this.currentMessageIndex];
                // this.xScatter.x = desc.baseWidth / 2 - this.xScatter.width / 2;
            }
            if (this.xScatter2) {
                this.xScatter2.text = this.messages[this.currentMessageIndex];
            }
        };
        // Change text every 4 seconds
        this.textInterval = setInterval(updateText, 4000);
        // Update immediately for the first time
        updateText();
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        if (desc.orientation === ScreenOrientation_1.ScreenOrientation.HORIZONTAL) {
            this.background.visible = true;
            this.backgroundMobile.visible = false;
        }
        else {
            this.background.visible = false;
            this.backgroundMobile.visible = true;
        }
        if (this.fade) {
            this.fade.width = desc.currentWidth;
            this.fade.height = desc.currentHeight;
        }
        if (this.tfDoNotShowAgain) {
            this.doNotShowAgainCheckbox.x = this.tfDoNotShowAgain.x - 260;
        }
    }
    onAdded() {
        if (this.btnGetStarted) {
            // this.btnGetStarted.buttonAnimator.setAnimation("spin_Idle");
        }
        if (this.tfDoNotShowAgain) {
            this.doNotShowAgainCheckbox.x = this.tfDoNotShowAgain.x - 260;
        }
        this.backgroundSound = SoundManager_1.default.loop({
            id: SoundListExtended_1.default.BASEGAME_BACKGROUND,
            volume: 0.3,
            channel: "ambient",
        });
        if (this.gamePlayIntro) {
            this.gamePlayIntro.updateTransform();
            const bounds = this.gamePlayIntro.getBounds();
        }
        if (this.reelBackground) {
            this.reelBackground.anchor.set(0.5, 0.5);
        }
        this.logo.state.setEmptyAnimations(0);
        this.logo.state.setAnimation(0, 'idle', true);
        // this.reelFrame.state.setEmptyAnimations(0);
        // this.reelFrame.state.setAnimation(0, 'idle', true);
        if (this.textFrame) {
            this.textFrame.anchor.set(0.5, 0.5);
            this.textFrame.scale.set(1.5, 1.5);
        }
        this.gamePlayIntro.startSimulation();
    }
    onRemoved() {
        SoundManager_1.default.mute = false;
        engineTween_1.Tweener.removeTweens(this);
        if (this.btnGetStarted) {
            // this.btnGetStarted.buttonAnimator.state.setEmptyAnimations(0);
            // this.btnGetStarted.buttonAnimator.visible = false;
        }
        // Remove GamePlayIntro if needed
        if (this.gamePlayIntro && this.gamePlayIntro.parent) {
            this.gamePlayIntro.parent.removeChild(this.gamePlayIntro);
            this.gamePlayIntro.destroy();
        }
        if (this.doNotShowAgainCheckbox) {
            this.doNotShowAgainCheckbox.destroy();
        }
        window.removeEventListener("click", this.boundOnGetStartedClicked);
        if (this.btnGetStarted) {
            this.btnGetStarted.destroy();
        }
        this.gamePlayIntro.stopIntroSimulation();
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case "ButtonGetStarted":
                instance = new ButtonSpin_1.default(le);
                break;
            case "IntroScreenBackground":
                instance = new IntroScreenBackground_1.default();
                break;
            case "Logo":
                instance = new Logo_1.default();
                break;
            case "ToggleButton":
                instance = new ToggleButton_1.ToggleButton(le);
                break;
            case "GamePlayIntro":
                instance = new GamePlayIntro_1.GamePlayIntro();
                break;
            // Add other custom classes if needed
        }
        return instance;
    }
    onGetStartedClicked() {
        if (this.backgroundSound) {
            this.backgroundSound.stop();
        }
        if (this.btnGetStarted) {
            this.btnGetStarted.enabled = false;
        }
        // SoundManager.play(SoundListExtended.INTRO_SPIN_BTN);
        this.emit(IntroScreenEvent_1.IntroScreenEvent.ON_GET_STARTED_CLICKED);
        if (this.doNotShowAgainCheckbox) {
            this.doNotShowAgainCheckbox.offState.removeAllListeners();
            this.doNotShowAgainCheckbox.onState.removeAllListeners();
            this.doNotShowAgainCheckbox.removeAllListeners();
            this.doNotShowAgainCheckbox.destroy();
        }
    }
    onCheckboxClicked(value) {
        localStorage.setItem('skipScreen', value ? 'true' : 'false');
    }
}
exports["default"] = IntroScreen;


/***/ }),

/***/ 44170:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_js_1 = __webpack_require__(95894);
const ScreenOrientation_1 = __webpack_require__(81827);
class IntroScreenBackground extends pixi_js_1.Sprite {
    constructor() {
        super(AssetsManager_1.default.textures.get('intro-bg-desktop'));
        // this.on('added', () => {
        //     this.state.setAnimation(0, 'idle', true);
        // });
        this.anchor.set(0.5, 0.5);
    }
    // PUBLIC API
    updateLayout(desc) {
        // hardcoded value!
        switch (desc.orientation) {
            case ScreenOrientation_1.ScreenOrientation.HORIZONTAL:
                const xScale = desc.currentWidth / desc.baseWidth;
                const yScale = desc.currentHeight / desc.baseHeight;
                this.scale.set(xScale > yScale ? xScale : yScale);
                break;
            case ScreenOrientation_1.ScreenOrientation.VERTICAL:
                const offsetX = (desc.currentWidth - desc.baseWidth) / 2;
                const backgroundWidth = 1920;
                this.scale.set((desc.currentHeight / desc.baseHeight) * 2);
                this.pivot.x = -(backgroundWidth / 2);
                this.x = 0 - offsetX;
                break;
        }
        if (desc.orientation == ScreenOrientation_1.ScreenOrientation.VERTICAL) {
            const offsetX = (desc.currentWidth - desc.baseWidth) / 2;
            const backgroundWidth = 1920;
            this.pivot.x = -(backgroundWidth / 2);
            this.x = 0 - offsetX;
        }
    }
}
exports["default"] = IntroScreenBackground;


/***/ }),

/***/ 3417:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const ReelsView_1 = __importDefault(__webpack_require__(65175));
const SymbolsList_1 = __webpack_require__(36189);
const SlotMachine_1 = __importDefault(__webpack_require__(56918));
const SlotMachineEvent_1 = __webpack_require__(96421);
const SlotMachineState_1 = __webpack_require__(77313);
const ControlEvent_1 = __importDefault(__webpack_require__(68659));
const SlotGameEvent_1 = __webpack_require__(19342);
const ReelsViewEvent_1 = __webpack_require__(21230);
const MainScreenBackground_1 = __importDefault(__webpack_require__(21443));
const tsyringe_1 = __webpack_require__(659);
const MultiFunctionalButton_1 = __importDefault(__webpack_require__(81887));
const UIPanelMobileVertical_1 = __importDefault(__webpack_require__(67758));
const AdjustableLayoutContainer_1 = __importDefault(__webpack_require__(66961));
const ReelsBackground_1 = __importStar(__webpack_require__(84041));
const UIPanelDesktop_1 = __importDefault(__webpack_require__(51244));
const Character_1 = __importDefault(__webpack_require__(4567));
const CascadeHistoryView_1 = __webpack_require__(4799);
const Wallet_1 = __importDefault(__webpack_require__(92162));
const ReelHeader_1 = __webpack_require__(67111);
const TransactionType_1 = __webpack_require__(69310);
const BetDetails_1 = __webpack_require__(93397);
const Logo_1 = __importDefault(__webpack_require__(22452));
const GameTransitionAnimation_1 = __webpack_require__(56137);
const ButtonSpinAnimation_1 = __importDefault(__webpack_require__(58553));
const FreeSpinButton_1 = __webpack_require__(10554);
let MainGameScreen = class MainGameScreen extends AdjustableLayoutContainer_1.default {
    constructor(slotMachine) {
        super(AssetsManager_1.default.layouts.get('main-screen'));
        this.currentLineWinIndex = -1;
        this.currentLineWinCycles = 0;
        this.maxLineWinCycles = 2;
        this.currentWinval = 0;
        this.currentMultipliervalue = 0;
        this.winMsgCheck = 0;
        this.slotMachine = slotMachine;
        LayoutBuilder_1.default.create(this.layout, this, (le) => {
            return this.customClassElementCreate(le);
        });
        // this.totalWinFrameBaseYPositions = {
        //     desktop: this.messageBox.totalWinFrameDesktop.y,
        //     mobile: this.totalWinFrameMobile.y
        // }
        this.slotMachine.on(SlotMachineEvent_1.SlotMachineEvent.STATE_CHANGED, this.onSlotMachineStateChanged, this);
        this.on('added', this.onAdded, this);
        this.addChild(new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('black-rect')));
        // // TESTING CODE
        // this.eventMode = 'dynamic';
        // this.cursor = 'pointer';
        // let s: number = 0;
        // this.on('pointerup', () => {
        //     switch (s) {
        //         case 0:
        //             this.btnMultiFunctional.setText('FEATURE BUY',true);
        //             this.btnMultiFunctional.state = MultiFunctionalButtonState.FEATURE_BUY;
        //             break;
        //         case 1:
        //             this.btnMultiFunctional.setText('FREESPINS LEFT: 0',true);
        //             this.btnMultiFunctional.state = MultiFunctionalButtonState.FREESPINS_LEFT;
        //             break;
        //         case 2:
        //             this.btnMultiFunctional.state = MultiFunctionalButtonState.INVISIBLE;
        //             break;
        //     }
        //     s = (s + 1) % 3;
        // });
    }
    // PRIVATE API
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ReelsBackground':
                instance = new ReelsBackground_1.default(le);
                break;
            case 'ReelsView':
                instance = new ReelsView_1.default(le, this.slotMachine.description.reels.regular, this.slotMachine.roundResult.spins[0], SymbolsList_1.SymbolsList, {
                    winFrameAnimation: {
                        assetName: 'win-frame-animation',
                        animationName: 'win'
                    },
                    anticipationTime: 1.5,
                    symbolSize: new pixi_js_1.Point(152, 124),
                    fallingCascade: true
                });
                break;
            case 'UIPanelMobileVertical':
                instance = new UIPanelMobileVertical_1.default({
                    UIMainConfiguration: {
                        buttonSpinConfig: {
                            useRotationInStartAnimation: true
                        }
                    }
                });
                break;
            case 'UIPanelDesktop':
                instance = new UIPanelDesktop_1.default({
                    UIMainConfiguration: {
                        buttonSpinConfig: {
                            useRotationInStartAnimation: true
                        }
                    }
                });
                break;
            case 'MainScreenBackground':
                instance = new MainScreenBackground_1.default(le);
                break;
            case 'Logo':
                instance = new Logo_1.default();
                break;
            case 'MultiFunctionalButton':
                instance = new MultiFunctionalButton_1.default(le);
                break;
            case 'Character':
                instance = new Character_1.default();
                break;
            // case 'SecondCharacter':
            //     instance = new SecondCharacter();
            // break
            case 'FreeSpinButton':
                instance = new FreeSpinButton_1.FreeSpinButton(le);
                break;
            case 'CascadeHistoryPanel':
                instance = new CascadeHistoryView_1.CascadeHistoryView(le);
                break;
            case 'ReelHeader':
                instance = new ReelHeader_1.ReelHeader(le);
                break;
            case 'BetDetails':
                instance = new BetDetails_1.BetDetails(le);
                break;
            case 'GameTransitionAnimation':
                instance = new GameTransitionAnimation_1.GameTransitionAnimation();
                break;
        }
        return instance;
    }
    updateLayout(desc) {
        super.updateLayout(desc);
        let bottomY = desc.baseHeight;
        if (desc.currentHeight > desc.baseHeight) {
            bottomY = desc.baseHeight + (desc.currentHeight - desc.baseHeight) / 2;
        }
    }
    onSlotMachineStateChanged(currentState) {
        var _a, _b;
        const sm = this.slotMachine;
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        const gs = tsyringe_1.container.resolve('GameService');
        let gameSpeedLevel;
        switch (currentState) {
            case SlotMachineState_1.SlotMachineState.SPINNING:
                if (((_a = sm.previousRoundResult) === null || _a === void 0 ? void 0 : _a.nextType) === TransactionType_1.TransactionType.REGULAR)
                    this.reels.removeMultipliers();
                this.currentLineWinIndex = -1;
                this.currentLineWinCycles = 0;
                this.reels.off(ReelsViewEvent_1.ReelsViewEvent.WIN_ANIMATION_COMPLETE);
                const lastRound = sm.previousRoundResult.spins[sm.previousRoundResult.spins.length - 1];
                if ((_b = sm.roundResult) === null || _b === void 0 ? void 0 : _b.complete) {
                    this.uiPanelDesktop.totalWinFrame.setValue(0);
                    // this.totalWinFrame.setValue(0);
                }
                if (lastRound.freespins == null || lastRound.freespins.freespinId >= lastRound.freespins.totalCount) {
                    this.uiPanelDesktop.totalWinFrame.setValue(0);
                    // this.totalWinFrame.setValue(0);;
                }
                this.cascadeHistoryPanelHorizontal.reset();
                this.cascadeHistoryPanelVertical.reset();
                this.uiPanelMobileVertical.lock();
                this.uiPanelDesktop.lock();
                gameSpeedLevel = sm.stopRequested ? 1 : this.slotMachine.currentGameSpeedLevel;
                this.reels.spin(sm.currentGameSpeedLevel);
                break;
            case SlotMachineState_1.SlotMachineState.SPIN_END:
            // eslint-disable-next-line no-fallthrough
            case SlotMachineState_1.SlotMachineState.COMMUNICATION_ERROR:
                gameSpeedLevel = sm.stopRequested ? 1 : this.slotMachine.currentGameSpeedLevel;
                const spinResult = sm.currentSpinResult;
                const stopPromises = [
                    this.reels.stop(spinResult, {
                        stopSoundData: {
                            id: 'reel_stop',
                            volume: 1
                        },
                        anticipationSoundData: {
                            id: 'popup_hide',
                            volume: 0
                        },
                    }, gameSpeedLevel, this.getAnticipationReels(spinResult))
                ];
                Promise.all(stopPromises)
                    .then(() => {
                    if (sm.currentSpinResult.winValue > 0) {
                        // this.totalWinFrameMobile.setValue(sm.roundResult.totalWinValue, true);
                    }
                    new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.REELS_STOPPED).dispatch();
                });
                break;
            case SlotMachineState_1.SlotMachineState.SPIN_RESULT_MULTI_WIN:
                this.showMultiWin();
                this.winMsgCheck = 1;
                if (sm.currentSpinResult.freespins) {
                    // if (this.totalWinFrameMobile.getValue() !== sm.roundResult.totalWinValue) {
                    //     this.totalWinFrameMobile.setValue((sm.previousRoundResult.totalWinValue + sm.currentSpinResult.currentTotalWinValue), true);
                    // }
                }
                else {
                    // this.totalWinFrameMobile.setValue(sm.currentSpinResult.currentTotalWinValue, true);
                }
                // if (sm.currentSpinResult.winValue && sm.currentSpinResult.winValue > 0)
                //     this.reelHeader.setHeader(sm.currentSpinResult.winValue, true);
                break;
            case SlotMachineState_1.SlotMachineState.SPIN_RESULT_SCATTER:
                this.showScatterWin();
                break;
            case SlotMachineState_1.SlotMachineState.SPIN_RESULT_CASCADE:
                this.logo.playWinAnimation('active');
                const winningPattern = sm.roundResult.spins;
                // this.currentWinval += sm.currentSpinResult.currentTotalWinValue;
                this.reels.multiplierAnimation(sm.previousSpinResult.multipliers).then(() => {
                    this.reels.cascade(sm.multiWinPattern(sm.previousSpinResult), sm.currentSpinResult.result, winningPattern)
                        .then(() => {
                        this.uiPanelDesktop.totalWinFrame.setValue(sm.roundResult.totalWinValue, true);
                        new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.CASCADE_WIN_SHOWN).dispatch();
                        return;
                    });
                });
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_START:
                this.reelsBackground.playAnimation(ReelsBackground_1.ReelsBackgroundType.FREEGAME, true);
                this.uiPanelDesktop.btnSpin.spinAnimation(ButtonSpinAnimation_1.default.LOOP, ButtonSpinAnimation_1.default.SPIN);
                new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.STOP_REQUESTED).dispatch();
                this.uiPanelDesktop.btnSpin.enabled = false;
                new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.STOP_REQUESTED).dispatch();
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS:
                new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_START).dispatch();
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_END:
                // this.totalWinFrameMobile.setValue(sm.round_Result.totalWinValue, true);
                break;
            case SlotMachineState_1.SlotMachineState.FREE_SPIN_BIG_WIN:
                this.reelsBackground.playAnimation(ReelsBackground_1.ReelsBackgroundType.FREEGAME, true);
                break;
            case SlotMachineState_1.SlotMachineState.BIG_WIN:
                this.reelsBackground.playAnimation(ReelsBackground_1.ReelsBackgroundType.FREEGAME, true);
                break;
            case SlotMachineState_1.SlotMachineState.IDLE:
                this.winMsgCheck = 0;
                this.uiPanelMobileVertical.unlock();
                this.uiPanelDesktop.unlock();
                break;
        }
    }
    showMultiWin() {
        const sm = this.slotMachine;
        const wallet = tsyringe_1.container.resolve(Wallet_1.default);
        this.reels.once(ReelsViewEvent_1.ReelsViewEvent.WIN_ANIMATION_COMPLETE, () => {
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.MULTI_WIN_SHOWN).dispatch();
        });
        const winningSymbols = this.slotMachine.currentSpinResult.win.winningPattern;
        this.reels.animateWins(winningSymbols, 1, false, wallet);
        winningSymbols.forEach((clusters, symbolId) => {
            clusters.forEach((cluster) => {
                [this.cascadeHistoryPanelHorizontal, this.cascadeHistoryPanelVertical].forEach((history) => {
                    history.addCell(SymbolsList_1.SymbolsList.find(symbol => symbolId == symbol.id), cluster.symbolCount, cluster.payout, cluster.multiplier);
                });
            });
        });
    }
    showScatterWin() {
        var _a;
        const sm = this.slotMachine;
        let scatterWin = (_a = sm.currentSpinResult.win) === null || _a === void 0 ? void 0 : _a.winningPattern;
        this.reels.once(ReelsViewEvent_1.ReelsViewEvent.WIN_ANIMATION_COMPLETE, () => {
            this.reels.off(ReelsViewEvent_1.ReelsViewEvent.WIN_ANIMATION_COMPLETE);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SCATTER_WIN_SHOWN).dispatch();
        });
        this.reels.animateWins(scatterWin, 1, true, Wallet_1.default);
    }
    showFreespinsWin() {
        var _a;
        const sm = this.slotMachine;
        const freespinsWin = (_a = sm.currentSpinResult.win) === null || _a === void 0 ? void 0 : _a.winningPattern;
        this.reels.once(ReelsViewEvent_1.ReelsViewEvent.WIN_ANIMATION_COMPLETE, () => {
            this.reels.off(ReelsViewEvent_1.ReelsViewEvent.WIN_ANIMATION_COMPLETE);
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.FREE_SPIN_WIN_SHOWN).dispatch();
        });
        this.reels.animateWins(freespinsWin, 1, false, Wallet_1.default);
    }
    getAnticipationReels(spinResult) {
        // const anticipationReels: number[] = []
        // // 302 free spin scatter - 2 or more
        // let numberOfScatters: number = 0;
        // // check first 4 reels
        // for (let i = 0; i < spinResult.result.length - 1; i++) {
        //     const reelResult: number[] = spinResult.result[i];
        //     numberOfScatters += reelResult.reduce((counter: number, symbolId: number): number => {
        //         if (symbolId == 302) {
        //             return counter + 1;
        //         } else {
        //             return counter;
        //         }
        //     }, 0);
        //     if (numberOfScatters >= 2) {
        //         for (let j = i + 1; j < 5; j++) {
        //             anticipationReels.push(j);
        //         }
        //         break;
        //     }
        // }
        //
        // // 303 bonus - 3 or more
        // numberOfScatters = 0;
        // for (let i = 0; i < spinResult.result.length - 1; i++) {
        //     const reelResult: number[] = spinResult.result[i];
        //     numberOfScatters += reelResult.reduce((counter: number, symbolId: number): number => {
        //         if (symbolId == 303) {
        //             return counter + 1;
        //         } else {
        //             return counter;
        //         }
        //     }, 0);
        //     if (numberOfScatters >= 3) {
        //         for (let j = i + 1; j < 5; j++) {
        //             anticipationReels.push(j);
        //         }
        //         break;
        //     }
        // }
        //
        // return arrayUnique(anticipationReels)
        //     .sort();
        return null;
    }
    onAdded() {
        //Restore previous freespin state
        if (this.slotMachine.roundResult.nextType === 10 || this.slotMachine.roundResult.nextType === 31) {
            // this.totalWinFrameMobile.setValue(this.slotMachine.roundResult.totalWinValue);
            this.slotMachine.currentState = SlotMachineState_1.SlotMachineState.FREE_SPINS_ROUND_START;
        }
        if (this.slotMachine.roundResult.nextType === TransactionType_1.TransactionType.RESPIN) {
            new ControlEvent_1.default(SlotGameEvent_1.SlotGameEvent.SPIN_START).dispatch();
        }
    }
};
MainGameScreen = __decorate([
    (0, tsyringe_1.injectable)(),
    __param(0, (0, tsyringe_1.inject)(SlotMachine_1.default)),
    __metadata("design:paramtypes", [SlotMachine_1.default])
], MainGameScreen);
exports["default"] = MainGameScreen;


/***/ }),

/***/ 21443:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BackgroundType = void 0;
const pixi_js_1 = __webpack_require__(95894);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundListExtended_1 = __importDefault(__webpack_require__(19402));
const ScreenOrientation_1 = __webpack_require__(81827);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
class MainScreenBackground extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.setBackground();
        this.updateBackgroundMusic();
    }
    customClassElementCreate(le) {
        let instance = null;
        return instance;
    }
    setBackground() {
        if (this.base_game_bg)
            this.base_game_bg.visible = true;
        if (this.base_game_bg_mobile)
            this.base_game_bg_mobile.visible = true;
        if (this.base_game_bg)
            this.base_game_bg.state.setAnimation(0, 'idle', true);
        if (this.base_game_bg_mobile)
            this.base_game_bg_mobile.state.setAnimation(0, 'idle', true);
    }
    updateBackgroundMusic() {
        if (this.backgroundMusic) {
            this.backgroundMusic.stop();
        }
        this.backgroundMusic = SoundManager_1.default.loop({
            id: this._theme === BackgroundType.NORMAL ? SoundListExtended_1.default.BASEGAME_BACKGROUND : SoundListExtended_1.default.FREEGAME_BACKGROUND,
            volume: this._theme === BackgroundType.NORMAL ? 0.3 : 0.6,
            channel: MainScreenBackground.DEFAULT_BACKGROUND_CHANNEL
        });
    }
    updateLayout(desc) {
        const xScale = desc.currentWidth / desc.baseWidth;
        const yScale = desc.currentHeight / desc.baseHeight;
        switch (desc.orientation) {
            case ScreenOrientation_1.ScreenOrientation.HORIZONTAL:
                this.scale.set(xScale > yScale ? xScale : yScale);
                break;
            case ScreenOrientation_1.ScreenOrientation.VERTICAL:
                this.scale.set(xScale > yScale ? xScale : yScale);
                break;
        }
    }
}
MainScreenBackground.DEFAULT_BACKGROUND_CHANNEL = 'ambient';
exports["default"] = MainScreenBackground;
var BackgroundType;
(function (BackgroundType) {
    BackgroundType["NORMAL"] = "main-screen-background";
    BackgroundType["FREEGAME"] = "bonus-screen-background";
    BackgroundType["NORMAL_MOBILE"] = "main-screen-background-mobile";
    BackgroundType["FREEGAME_MOBILE"] = "bonus-screen-background-mobile";
    BackgroundType["WINNING"] = "winning";
})(BackgroundType || (exports.BackgroundType = BackgroundType = {}));


/***/ }),

/***/ 67111:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReelHeader = void 0;
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const ValueText_1 = __importDefault(__webpack_require__(68223));
const Wallet_1 = __importDefault(__webpack_require__(92162));
const engineTween_1 = __webpack_require__(50381);
const SoundManager_1 = __importDefault(__webpack_require__(6881));
const SoundList_1 = __importDefault(__webpack_require__(27310));
class ReelHeader extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        this.tfCurrentWinValue.renderValueFunction = (tfText, value) => {
            tfText.text = `${value.toLocaleString('de-DE')} ${Wallet_1.default.currency.isoCode}`;
        };
        if (this.background) {
            this.background.anchor.set(0.5, 0.5);
        }
        this.tfCurrentWinValue.setValue(0);
        this.tfCurrentWinValue.visible = false;
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'ValueText':
                instance = new ValueText_1.default(le);
                break;
        }
        return instance;
    }
    setHeader(value, shake = false) {
        this.tfText.visible = value <= 0;
        this.tfCurrentWinValue.visible = !this.tfText.visible;
        if (!value)
            return;
        if (value <= 0)
            return;
        //To fix the issue when previous tween is not finished yet
        if (engineTween_1.Tweener.isTweening(this.tfCurrentWinValue)) {
            engineTween_1.Tweener.removeTweens(this.tfCurrentWinValue);
            this.tfCurrentWinValue.value = value;
            return;
        }
        if (value < this.tfCurrentWinValue.value) {
            this.tfCurrentWinValue.value = 0;
        }
        this.tfCurrentWinValue.setValue(value, {
            countUpDuration: 1
        });
        if (!shake)
            return;
        this.loopedSound = SoundManager_1.default.loop({
            id: SoundList_1.default.COUNTER_LOOP,
            volume: 0.35,
        });
        engineTween_1.Tweener.addTween(this.tfCurrentWinValue.scale, {
            x: 1.15,
            y: 1.15,
            transition: 'easeOutSine',
            time: 0.35,
            onComplete: () => {
                engineTween_1.Tweener.addTween(this.tfCurrentWinValue.scale, {
                    x: 1,
                    y: 1,
                    transition: 'easeOutElastic',
                    time: 0.3
                });
                if (this.loopedSound)
                    this.loopedSound.stop();
            }
        });
    }
}
exports.ReelHeader = ReelHeader;


/***/ }),

/***/ 84041:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReelsBackgroundType = void 0;
const pixi_spine_1 = __webpack_require__(15091);
const AssetsManager_1 = __importDefault(__webpack_require__(36353));
const pixi_js_1 = __webpack_require__(95894);
const LayoutBuilder_1 = __importDefault(__webpack_require__(98744));
const engineTween_1 = __webpack_require__(50381);
class ReelsBackground extends pixi_js_1.Container {
    constructor(le) {
        super();
        LayoutBuilder_1.default.create(le, this, (le) => {
            return this.customClassElementCreate(le);
        });
        for (let i = 0; i < 6; i++) {
            const divider = new pixi_js_1.Sprite(AssetsManager_1.default.textures.get('reel-divider'));
            divider.anchor.set(0.5, 0.5);
            divider.x = -440 + (i * 180);
            divider.y = -450;
            this.addChild(divider);
        }
        let delayBetweenAnimations = 1;
        this.frame.state.addListener({
            complete: () => {
                engineTween_1.Tweener.addCaller(this, {
                    count: 1,
                    time: delayBetweenAnimations,
                    onComplete: () => {
                        this.onAdded();
                    }
                });
            }
        });
        this.on('added', this.onAdded, this);
    }
    customClassElementCreate(le) {
        let instance = null;
        switch (le.customClass) {
            case 'Frame':
                instance = new pixi_spine_1.Spine(AssetsManager_1.default.spine.get('reel-frame'));
                break;
        }
        return instance;
    }
    onAdded() {
        this.frame.scale.set(1.1);
        this.frame.position.set(0, -423);
        const spineState = this.frame.state;
        const currentTrack = spineState.getCurrent(0);
        if ((currentTrack === null || currentTrack === void 0 ? void 0 : currentTrack.animation.name) === ReelsBackgroundType.NORMAL)
            return;
        this.frame.state.setEmptyAnimations(0);
        this.frame.state.setAnimation(0, ReelsBackgroundType.NORMAL, true);
    }
    // PUBLIC API
    reset() {
        this.frame.state.setEmptyAnimations(0);
    }
    playAnimation(animationName, loop = false) {
        this.frame.state.data.setMix('idle', animationName, 0.15);
        this.frame.state.data.setMix(animationName, 'idle', 0.15);
        this.frame.state.setAnimation(0, animationName, loop);
    }
}
exports["default"] = ReelsBackground;
var ReelsBackgroundType;
(function (ReelsBackgroundType) {
    ReelsBackgroundType["NORMAL"] = "idle";
    ReelsBackgroundType["FREEGAME"] = "free spin";
    ReelsBackgroundType["WIN"] = "match";
})(ReelsBackgroundType || (exports.ReelsBackgroundType = ReelsBackgroundType = {}));


/***/ }),

/***/ 36189:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiplierSymbolsList = exports.SymbolsList = void 0;
const SoundListExtended_1 = __importDefault(__webpack_require__(19402));
exports.SymbolsList = [
    {
        id: 101,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-00',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-00',
            winAnimationName: ['match', 'destroy'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_LOW_PAYOUT_1,
            volume: 0.15
        }
    },
    {
        id: 102,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-01',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-01',
            winAnimationName: ['match', 'destroy'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_LOW_PAYOUT_2,
            volume: 0.15
        }
    },
    {
        id: 103,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-02',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-02',
            winAnimationName: ['match', 'destroy'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_LOW_PAYOUT_3,
            volume: 0.15
        }
    },
    {
        id: 104,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-03',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-03',
            winAnimationName: ['match', 'destroy'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_LOW_PAYOUT_4,
            volume: 0.15
        }
    },
    {
        id: 201,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-05',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-05',
            winAnimationName: ['match', 'destroy'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_HIGH_PAYOUT_1,
            volume: 0.15
        }
    },
    {
        id: 202,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-06',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-06',
            winAnimationName: ['match', 'destroy'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_HIGH_PAYOUT_2,
            volume: 0.15
        }
    },
    {
        id: 203,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-07',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-07',
            winAnimationName: ['match', 'destroy'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_HIGH_PAYOUT_3,
            volume: 0.15
        }
    },
    {
        id: 25,
        staticIcon: {
            sourceType: 'spine',
            assetName: 'symbol-scatter',
            animationName: 'static'
        },
        spinIcon: {
            sourceType: 'texture',
            assetName: 'blank',
            blurY: 20
        },
        spineAnimations: {
            spineAssetName: 'symbol-scatter',
            winAnimationName: ['land', 'match'],
            idleAnimationName: 'static'
        },
        destroyAnimation: {
            spineAssetName: 'symbol-destroy-animation',
            animationName: 'destroy'
        },
        winSound: {
            id: SoundListExtended_1.default.SYMBOL_SCATTER,
            volume: 0.15
        },
        landSound: {
            id: SoundListExtended_1.default.SYMBOL_SCATTER_LAND,
            volume: 0.15
        }
    }
];
exports.MultiplierSymbolsList = [
    {
        id: 1,
        textTexture: 'multiplier-1x',
        text: '1X',
        backgroundTexture: 'multiplier-symbol-bcg'
    },
    {
        id: 2,
        textTexture: 'multiplier-2x',
        text: '2X',
        backgroundTexture: 'multiplier-symbol-bcg'
    },
    {
        id: 4,
        textTexture: 'multiplier-4x',
        text: '4X',
        backgroundTexture: 'multiplier-symbol-bcg'
    },
    {
        id: 8,
        textTexture: 'multiplier-8x',
        text: '8X',
        backgroundTexture: 'multiplier-symbol-bcg'
    },
    {
        id: 16,
        textTexture: 'multiplier-16x',
        text: '16X',
        backgroundTexture: 'multiplier-symbol-bcg'
    },
    {
        id: 32,
        textTexture: 'multiplier-32x',
        text: '32X',
        backgroundTexture: 'multiplier-symbol-bcg'
    },
    {
        id: 64,
        textTexture: 'multiplier-64x',
        text: '64X',
        backgroundTexture: 'multiplier-symbol-bcg'
    },
    {
        id: 128,
        textTexture: 'multiplier-128x',
        text: '128X',
        backgroundTexture: 'multiplier-symbol-bcg'
    }
];


/***/ }),

/***/ 6993:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mixin: () => (/* binding */ Mixin),
/* harmony export */   decorate: () => (/* binding */ decorate),
/* harmony export */   hasMixin: () => (/* binding */ hasMixin),
/* harmony export */   mix: () => (/* binding */ mix),
/* harmony export */   settings: () => (/* binding */ settings)
/* harmony export */ });
/**
 * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives
 * the option to exclude properties by name.
 */
const copyProps = (dest, src, exclude = []) => {
    const props = Object.getOwnPropertyDescriptors(src);
    for (let prop of exclude)
        delete props[prop];
    Object.defineProperties(dest, props);
};
/**
 * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will
 * be closest to farthest in the chain.
 */
const protoChain = (obj, currentChain = [obj]) => {
    const proto = Object.getPrototypeOf(obj);
    if (proto === null)
        return currentChain;
    return protoChain(proto, [...currentChain, proto]);
};
/**
 * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated
 * objects, this function should return Object.prototype.
 */
const nearestCommonProto = (...objs) => {
    if (objs.length === 0)
        return undefined;
    let commonProto = undefined;
    const protoChains = objs.map(obj => protoChain(obj));
    while (protoChains.every(protoChain => protoChain.length > 0)) {
        const protos = protoChains.map(protoChain => protoChain.pop());
        const potentialCommonProto = protos[0];
        if (protos.every(proto => proto === potentialCommonProto))
            commonProto = potentialCommonProto;
        else
            break;
    }
    return commonProto;
};
/**
 * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first
 * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods
 * downstream of this prototype (ONLY downstream) are copied into the new object.
 *
 * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as
 * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may
 * want to use that instead.
 */
const hardMixProtos = (ingredients, constructor, exclude = []) => {
    var _a;
    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
    const mixedProto = Object.create(base);
    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the
    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in
    // when they will already be accessible via prototype access.
    const visitedProtos = protoChain(base);
    for (let prototype of ingredients) {
        let protos = protoChain(prototype);
        // Apply the prototype chain in reverse order so that old methods don't override newer ones.
        for (let i = protos.length - 1; i >= 0; i--) {
            let newProto = protos[i];
            if (visitedProtos.indexOf(newProto) === -1) {
                copyProps(mixedProto, newProto, ['constructor', ...exclude]);
                visitedProtos.push(newProto);
            }
        }
    }
    mixedProto.constructor = constructor;
    return mixedProto;
};
const unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);

/**
 * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient
 * prototypes is required.
 */
const getIngredientWithProp = (prop, ingredients) => {
    const protoChains = ingredients.map(ingredient => protoChain(ingredient));
    // since we search breadth-first, we need to keep track of our depth in the prototype chains
    let protoDepth = 0;
    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'
    // prototype chains has an object at this depth
    let protosAreLeftToSearch = true;
    while (protosAreLeftToSearch) {
        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains
        protosAreLeftToSearch = false;
        // scan through the ingredients right to left
        for (let i = ingredients.length - 1; i >= 0; i--) {
            const searchTarget = protoChains[i][protoDepth];
            if (searchTarget !== undefined && searchTarget !== null) {
                // if we find something, this is proof that this horizontal slice potentially more objects to search
                protosAreLeftToSearch = true;
                // eureka, we found it
                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {
                    return protoChains[i][0];
                }
            }
        }
        protoDepth++;
    }
    return undefined;
};
/**
 * "Mixes" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit
 * downstream of an existing prototype chain.  Note that "properties" cannot be added, deleted, or modified.
 */
const proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
    getPrototypeOf() {
        return prototype;
    },
    setPrototypeOf() {
        throw Error('Cannot set prototype of Proxies created by ts-mixer');
    },
    getOwnPropertyDescriptor(_, prop) {
        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
    },
    defineProperty() {
        throw new Error('Cannot define new properties on Proxies created by ts-mixer');
    },
    has(_, prop) {
        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;
    },
    get(_, prop) {
        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
    },
    set(_, prop, val) {
        const ingredientWithProp = getIngredientWithProp(prop, ingredients);
        if (ingredientWithProp === undefined)
            throw new Error('Cannot set new properties on Proxies created by ts-mixer');
        ingredientWithProp[prop] = val;
        return true;
    },
    deleteProperty() {
        throw new Error('Cannot delete properties on Proxies created by ts-mixer');
    },
    ownKeys() {
        return ingredients
            .map(Object.getOwnPropertyNames)
            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));
    },
});
/**
 * Creates a new proxy-prototype object that is a "soft" mixture of the given prototypes.  The mixing is achieved by
 * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any
 * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.
 */
const softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);

const settings = {
    initFunction: null,
    staticsStrategy: 'copy',
    prototypeStrategy: 'copy',
    decoratorInheritance: 'deep',
};

// Keeps track of constituent classes for every mixin class created by ts-mixer.
const mixins = new Map();
const getMixinsForClass = (clazz) => mixins.get(clazz);
const registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
const hasMixin = (instance, mixin) => {
    if (instance instanceof mixin)
        return true;
    const constructor = instance.constructor;
    const visited = new Set();
    let frontier = new Set();
    frontier.add(constructor);
    while (frontier.size > 0) {
        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier
        if (frontier.has(mixin))
            return true;
        frontier.forEach(item => visited.add(item));
        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item
        const newFrontier = new Set();
        frontier.forEach(item => {
            var _a;
            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(proto => proto.constructor).filter(item => item !== null);
            if (itemConstituents)
                itemConstituents.forEach(constituent => {
                    if (!visited.has(constituent) && !frontier.has(constituent))
                        newFrontier.add(constituent);
                });
        });
        // we have a new frontier, now search again
        frontier = newFrontier;
    }
    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes
    return false;
};

const mergeObjectsOfDecorators = (o1, o2) => {
    var _a, _b;
    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
    const mergedObject = {};
    for (let key of allKeys)
        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);
    return mergedObject;
};
const mergePropertyAndMethodDecorators = (d1, d2) => {
    var _a, _b, _c, _d;
    return ({
        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),
    });
};
const mergeDecorators = (d1, d2) => {
    var _a, _b, _c, _d, _e, _f;
    return ({
        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),
    });
};
const decorators = new Map();
const findAllConstituentClasses = (...classes) => {
    var _a;
    const allClasses = new Set();
    const frontier = new Set([...classes]);
    while (frontier.size > 0) {
        for (let clazz of frontier) {
            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);
            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));
            for (let newClass of newClasses)
                frontier.add(newClass);
            allClasses.add(clazz);
            frontier.delete(clazz);
        }
    }
    return [...allClasses];
};
const deepDecoratorSearch = (...classes) => {
    const decoratorsForClassChain = findAllConstituentClasses(...classes)
        .map(clazz => decorators.get(clazz))
        .filter(decorators => !!decorators);
    if (decoratorsForClassChain.length == 0)
        return {};
    if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const directDecoratorSearch = (...classes) => {
    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));
    if (classDecorators.length === 0)
        return {};
    if (classDecorators.length === 1)
        return classDecorators[0];
    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const getDecoratorsForClass = (clazz) => {
    let decoratorsForClass = decorators.get(clazz);
    if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
    }
    return decoratorsForClass;
};
const decorateClass = (decorator) => ((clazz) => {
    const decoratorsForClass = getDecoratorsForClass(clazz);
    let classDecorators = decoratorsForClass.class;
    if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
    }
    classDecorators.push(decorator);
    return decorator(clazz);
});
const decorateMember = (decorator) => ((object, key, ...otherArgs) => {
    var _a, _b, _c;
    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';
    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';
    const clazz = decoratorTargetType === 'static' ? object : object.constructor;
    const decoratorsForClass = getDecoratorsForClass(clazz);
    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
    decoratorsForTargetType[decoratorType] = decoratorsForType;
    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
    decoratorsForType[key] = decoratorsForKey;
    // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine
    decoratorsForKey.push(decorator);
    // @ts-ignore
    return decorator(object, key, ...otherArgs);
});
const decorate = (decorator) => ((...args) => {
    if (args.length === 1)
        return decorateClass(decorator)(args[0]);
    return decorateMember(decorator)(...args);
});

function Mixin(...constructors) {
    var _a, _b, _c;
    const prototypes = constructors.map(constructor => constructor.prototype);
    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and
    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix
    // similarly to constructors -- not methods, which simply override each other.
    const initFunctionName = settings.initFunction;
    if (initFunctionName !== null) {
        const initFunctions = prototypes
            .map(proto => proto[initFunctionName])
            .filter(func => typeof func === 'function');
        const combinedInitFunction = function (...args) {
            for (let initFunction of initFunctions)
                initFunction.apply(this, args);
        };
        const extraProto = { [initFunctionName]: combinedInitFunction };
        prototypes.push(extraProto);
    }
    function MixedClass(...args) {
        for (const constructor of constructors)
            // @ts-ignore: potentially abstract class
            copyProps(this, new constructor(...args));
        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')
            this[initFunctionName].apply(this, args);
    }
    MixedClass.prototype = settings.prototypeStrategy === 'copy'
        ? hardMixProtos(prototypes, MixedClass)
        : softMixProtos(prototypes, MixedClass);
    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'
        ? hardMixProtos(constructors, null, ['prototype'])
        : proxyMix(constructors, Function.prototype));
    let DecoratedMixedClass = MixedClass;
    if (settings.decoratorInheritance !== 'none') {
        const classDecorators = settings.decoratorInheritance === 'deep'
            ? deepDecoratorSearch(...constructors)
            : directDecoratorSearch(...constructors);
        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
            const result = decorator(DecoratedMixedClass);
            if (result) {
                DecoratedMixedClass = result;
            }
        }
        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
    }
    registerMixins(DecoratedMixedClass, constructors);
    return DecoratedMixedClass;
}
const applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
    const propDecorators = propAndMethodDecorators.property;
    const methodDecorators = propAndMethodDecorators.method;
    if (propDecorators)
        for (let key in propDecorators)
            for (let decorator of propDecorators[key])
                decorator(target, key);
    if (methodDecorators)
        for (let key in methodDecorators)
            for (let decorator of methodDecorators[key])
                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
};
/**
 * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.
 */
const mix = (...ingredients) => decoratedClass => {
    // @ts-ignore
    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
    Object.defineProperty(mixedClass, 'name', {
        value: decoratedClass.name,
        writable: false,
    });
    return mixedClass;
};




/***/ }),

/***/ 659:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Lifecycle: () => (/* reexport */ lifecycle),
  autoInjectable: () => (/* reexport */ auto_injectable),
  container: () => (/* reexport */ instance),
  delay: () => (/* reexport */ delay),
  inject: () => (/* reexport */ decorators_inject),
  injectAll: () => (/* reexport */ inject_all),
  injectAllWithTransform: () => (/* reexport */ inject_all_with_transform),
  injectWithTransform: () => (/* reexport */ inject_with_transform),
  injectable: () => (/* reexport */ decorators_injectable),
  instanceCachingFactory: () => (/* reexport */ instanceCachingFactory),
  instancePerContainerCachingFactory: () => (/* reexport */ instancePerContainerCachingFactory),
  isClassProvider: () => (/* reexport */ isClassProvider),
  isFactoryProvider: () => (/* reexport */ isFactoryProvider),
  isNormalToken: () => (/* reexport */ isNormalToken),
  isTokenProvider: () => (/* reexport */ isTokenProvider),
  isValueProvider: () => (/* reexport */ isValueProvider),
  predicateAwareClassFactory: () => (/* reexport */ predicateAwareClassFactory),
  registry: () => (/* reexport */ decorators_registry),
  scoped: () => (/* reexport */ scoped),
  singleton: () => (/* reexport */ decorators_singleton)
});

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/types/lifecycle.js
var Lifecycle;
(function (Lifecycle) {
    Lifecycle[Lifecycle["Transient"] = 0] = "Transient";
    Lifecycle[Lifecycle["Singleton"] = 1] = "Singleton";
    Lifecycle[Lifecycle["ResolutionScoped"] = 2] = "ResolutionScoped";
    Lifecycle[Lifecycle["ContainerScoped"] = 3] = "ContainerScoped";
})(Lifecycle || (Lifecycle = {}));
/* harmony default export */ const lifecycle = (Lifecycle);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/types/index.js


;// CONCATENATED MODULE: ./node_modules/tsyringe/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/reflection-helpers.js
var INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
function getParamInfo(target) {
    var params = Reflect.getMetadata("design:paramtypes", target) || [];
    var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    Object.keys(injectionTokens).forEach(function (key) {
        params[+key] = injectionTokens[key];
    });
    return params;
}
function defineInjectionTokenMetadata(data, transform) {
    return function (target, _propertyKey, parameterIndex) {
        var descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
        descriptors[parameterIndex] = transform
            ? {
                token: data,
                transform: transform.transformToken,
                transformArgs: transform.args || []
            }
            : data;
        Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);
    };
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/class-provider.js
function isClassProvider(provider) {
    return !!provider.useClass;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/factory-provider.js
function isFactoryProvider(provider) {
    return !!provider.useFactory;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/lazy-helpers.js

var DelayedConstructor = (function () {
    function DelayedConstructor(wrap) {
        this.wrap = wrap;
        this.reflectMethods = [
            "get",
            "getPrototypeOf",
            "setPrototypeOf",
            "getOwnPropertyDescriptor",
            "defineProperty",
            "has",
            "set",
            "deleteProperty",
            "apply",
            "construct",
            "ownKeys"
        ];
    }
    DelayedConstructor.prototype.createProxy = function (createObject) {
        var _this = this;
        var target = {};
        var init = false;
        var value;
        var delayedObject = function () {
            if (!init) {
                value = createObject(_this.wrap());
                init = true;
            }
            return value;
        };
        return new Proxy(target, this.createHandler(delayedObject));
    };
    DelayedConstructor.prototype.createHandler = function (delayedObject) {
        var handler = {};
        var install = function (name) {
            handler[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                args[0] = delayedObject();
                var method = Reflect[name];
                return method.apply(void 0, __spread(args));
            };
        };
        this.reflectMethods.forEach(install);
        return handler;
    };
    return DelayedConstructor;
}());

function delay(wrappedConstructor) {
    if (typeof wrappedConstructor === "undefined") {
        throw new Error("Attempt to `delay` undefined. Constructor must be wrapped in a callback");
    }
    return new DelayedConstructor(wrappedConstructor);
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/injection-token.js

function isNormalToken(token) {
    return typeof token === "string" || typeof token === "symbol";
}
function isTokenDescriptor(descriptor) {
    return (typeof descriptor === "object" &&
        "token" in descriptor &&
        "multiple" in descriptor);
}
function isTransformDescriptor(descriptor) {
    return (typeof descriptor === "object" &&
        "token" in descriptor &&
        "transform" in descriptor);
}
function isConstructorToken(token) {
    return typeof token === "function" || token instanceof DelayedConstructor;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/token-provider.js
function isTokenProvider(provider) {
    return !!provider.useToken;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/value-provider.js
function isValueProvider(provider) {
    return provider.useValue != undefined;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/index.js






;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/providers/provider.js




function isProvider(provider) {
    return (isClassProvider(provider) ||
        isValueProvider(provider) ||
        isTokenProvider(provider) ||
        isFactoryProvider(provider));
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/registry-base.js
var RegistryBase = (function () {
    function RegistryBase() {
        this._registryMap = new Map();
    }
    RegistryBase.prototype.entries = function () {
        return this._registryMap.entries();
    };
    RegistryBase.prototype.getAll = function (key) {
        this.ensure(key);
        return this._registryMap.get(key);
    };
    RegistryBase.prototype.get = function (key) {
        this.ensure(key);
        var value = this._registryMap.get(key);
        return value[value.length - 1] || null;
    };
    RegistryBase.prototype.set = function (key, value) {
        this.ensure(key);
        this._registryMap.get(key).push(value);
    };
    RegistryBase.prototype.setAll = function (key, value) {
        this._registryMap.set(key, value);
    };
    RegistryBase.prototype.has = function (key) {
        this.ensure(key);
        return this._registryMap.get(key).length > 0;
    };
    RegistryBase.prototype.clear = function () {
        this._registryMap.clear();
    };
    RegistryBase.prototype.ensure = function (key) {
        if (!this._registryMap.has(key)) {
            this._registryMap.set(key, []);
        }
    };
    return RegistryBase;
}());
/* harmony default export */ const registry_base = (RegistryBase);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/registry.js


var Registry = (function (_super) {
    __extends(Registry, _super);
    function Registry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Registry;
}(registry_base));
/* harmony default export */ const registry = (Registry);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/resolution-context.js
var ResolutionContext = (function () {
    function ResolutionContext() {
        this.scopedResolutions = new Map();
    }
    return ResolutionContext;
}());
/* harmony default export */ const resolution_context = (ResolutionContext);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/error-helpers.js

function formatDependency(params, idx) {
    if (params === null) {
        return "at position #" + idx;
    }
    var argName = params.split(",")[idx].trim();
    return "\"" + argName + "\" at position #" + idx;
}
function composeErrorMessage(msg, e, indent) {
    if (indent === void 0) { indent = "    "; }
    return __spread([msg], e.message.split("\n").map(function (l) { return indent + l; })).join("\n");
}
function formatErrorCtor(ctor, paramIdx, error) {
    var _a = __read(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b = _a[1], params = _b === void 0 ? null : _b;
    var dep = formatDependency(params, paramIdx);
    return composeErrorMessage("Cannot inject the dependency " + dep + " of \"" + ctor.name + "\" constructor. Reason:", error);
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/types/disposable.js
function isDisposable(value) {
    if (typeof value.dispose !== "function")
        return false;
    var disposeFun = value.dispose;
    if (disposeFun.length > 0) {
        return false;
    }
    return true;
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/interceptors.js


var PreResolutionInterceptors = (function (_super) {
    __extends(PreResolutionInterceptors, _super);
    function PreResolutionInterceptors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PreResolutionInterceptors;
}(registry_base));

var PostResolutionInterceptors = (function (_super) {
    __extends(PostResolutionInterceptors, _super);
    function PostResolutionInterceptors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PostResolutionInterceptors;
}(registry_base));

var Interceptors = (function () {
    function Interceptors() {
        this.preResolution = new PreResolutionInterceptors();
        this.postResolution = new PostResolutionInterceptors();
    }
    return Interceptors;
}());
/* harmony default export */ const interceptors = (Interceptors);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/dependency-container.js











var typeInfo = new Map();
var InternalDependencyContainer = (function () {
    function InternalDependencyContainer(parent) {
        this.parent = parent;
        this._registry = new registry();
        this.interceptors = new interceptors();
        this.disposed = false;
        this.disposables = new Set();
    }
    InternalDependencyContainer.prototype.register = function (token, providerOrConstructor, options) {
        if (options === void 0) { options = { lifecycle: lifecycle.Transient }; }
        this.ensureNotDisposed();
        var provider;
        if (!isProvider(providerOrConstructor)) {
            provider = { useClass: providerOrConstructor };
        }
        else {
            provider = providerOrConstructor;
        }
        if (isTokenProvider(provider)) {
            var path = [token];
            var tokenProvider = provider;
            while (tokenProvider != null) {
                var currentToken = tokenProvider.useToken;
                if (path.includes(currentToken)) {
                    throw new Error("Token registration cycle detected! " + __spread(path, [currentToken]).join(" -> "));
                }
                path.push(currentToken);
                var registration = this._registry.get(currentToken);
                if (registration && isTokenProvider(registration.provider)) {
                    tokenProvider = registration.provider;
                }
                else {
                    tokenProvider = null;
                }
            }
        }
        if (options.lifecycle === lifecycle.Singleton ||
            options.lifecycle == lifecycle.ContainerScoped ||
            options.lifecycle == lifecycle.ResolutionScoped) {
            if (isValueProvider(provider) || isFactoryProvider(provider)) {
                throw new Error("Cannot use lifecycle \"" + lifecycle[options.lifecycle] + "\" with ValueProviders or FactoryProviders");
            }
        }
        this._registry.set(token, { provider: provider, options: options });
        return this;
    };
    InternalDependencyContainer.prototype.registerType = function (from, to) {
        this.ensureNotDisposed();
        if (isNormalToken(to)) {
            return this.register(from, {
                useToken: to
            });
        }
        return this.register(from, {
            useClass: to
        });
    };
    InternalDependencyContainer.prototype.registerInstance = function (token, instance) {
        this.ensureNotDisposed();
        return this.register(token, {
            useValue: instance
        });
    };
    InternalDependencyContainer.prototype.registerSingleton = function (from, to) {
        this.ensureNotDisposed();
        if (isNormalToken(from)) {
            if (isNormalToken(to)) {
                return this.register(from, {
                    useToken: to
                }, { lifecycle: lifecycle.Singleton });
            }
            else if (to) {
                return this.register(from, {
                    useClass: to
                }, { lifecycle: lifecycle.Singleton });
            }
            throw new Error('Cannot register a type name as a singleton without a "to" token');
        }
        var useClass = from;
        if (to && !isNormalToken(to)) {
            useClass = to;
        }
        return this.register(from, {
            useClass: useClass
        }, { lifecycle: lifecycle.Singleton });
    };
    InternalDependencyContainer.prototype.resolve = function (token, context) {
        if (context === void 0) { context = new resolution_context(); }
        this.ensureNotDisposed();
        var registration = this.getRegistration(token);
        if (!registration && isNormalToken(token)) {
            throw new Error("Attempted to resolve unregistered dependency token: \"" + token.toString() + "\"");
        }
        this.executePreResolutionInterceptor(token, "Single");
        if (registration) {
            var result = this.resolveRegistration(registration, context);
            this.executePostResolutionInterceptor(token, result, "Single");
            return result;
        }
        if (isConstructorToken(token)) {
            var result = this.construct(token, context);
            this.executePostResolutionInterceptor(token, result, "Single");
            return result;
        }
        throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
    };
    InternalDependencyContainer.prototype.executePreResolutionInterceptor = function (token, resolutionType) {
        var e_1, _a;
        if (this.interceptors.preResolution.has(token)) {
            var remainingInterceptors = [];
            try {
                for (var _b = __values(this.interceptors.preResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var interceptor = _c.value;
                    if (interceptor.options.frequency != "Once") {
                        remainingInterceptors.push(interceptor);
                    }
                    interceptor.callback(token, resolutionType);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.interceptors.preResolution.setAll(token, remainingInterceptors);
        }
    };
    InternalDependencyContainer.prototype.executePostResolutionInterceptor = function (token, result, resolutionType) {
        var e_2, _a;
        if (this.interceptors.postResolution.has(token)) {
            var remainingInterceptors = [];
            try {
                for (var _b = __values(this.interceptors.postResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var interceptor = _c.value;
                    if (interceptor.options.frequency != "Once") {
                        remainingInterceptors.push(interceptor);
                    }
                    interceptor.callback(token, result, resolutionType);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.interceptors.postResolution.setAll(token, remainingInterceptors);
        }
    };
    InternalDependencyContainer.prototype.resolveRegistration = function (registration, context) {
        this.ensureNotDisposed();
        if (registration.options.lifecycle === lifecycle.ResolutionScoped &&
            context.scopedResolutions.has(registration)) {
            return context.scopedResolutions.get(registration);
        }
        var isSingleton = registration.options.lifecycle === lifecycle.Singleton;
        var isContainerScoped = registration.options.lifecycle === lifecycle.ContainerScoped;
        var returnInstance = isSingleton || isContainerScoped;
        var resolved;
        if (isValueProvider(registration.provider)) {
            resolved = registration.provider.useValue;
        }
        else if (isTokenProvider(registration.provider)) {
            resolved = returnInstance
                ? registration.instance ||
                    (registration.instance = this.resolve(registration.provider.useToken, context))
                : this.resolve(registration.provider.useToken, context);
        }
        else if (isClassProvider(registration.provider)) {
            resolved = returnInstance
                ? registration.instance ||
                    (registration.instance = this.construct(registration.provider.useClass, context))
                : this.construct(registration.provider.useClass, context);
        }
        else if (isFactoryProvider(registration.provider)) {
            resolved = registration.provider.useFactory(this);
        }
        else {
            resolved = this.construct(registration.provider, context);
        }
        if (registration.options.lifecycle === lifecycle.ResolutionScoped) {
            context.scopedResolutions.set(registration, resolved);
        }
        return resolved;
    };
    InternalDependencyContainer.prototype.resolveAll = function (token, context) {
        var _this = this;
        if (context === void 0) { context = new resolution_context(); }
        this.ensureNotDisposed();
        var registrations = this.getAllRegistrations(token);
        if (!registrations && isNormalToken(token)) {
            throw new Error("Attempted to resolve unregistered dependency token: \"" + token.toString() + "\"");
        }
        this.executePreResolutionInterceptor(token, "All");
        if (registrations) {
            var result_1 = registrations.map(function (item) {
                return _this.resolveRegistration(item, context);
            });
            this.executePostResolutionInterceptor(token, result_1, "All");
            return result_1;
        }
        var result = [this.construct(token, context)];
        this.executePostResolutionInterceptor(token, result, "All");
        return result;
    };
    InternalDependencyContainer.prototype.isRegistered = function (token, recursive) {
        if (recursive === void 0) { recursive = false; }
        this.ensureNotDisposed();
        return (this._registry.has(token) ||
            (recursive &&
                (this.parent || false) &&
                this.parent.isRegistered(token, true)));
    };
    InternalDependencyContainer.prototype.reset = function () {
        this.ensureNotDisposed();
        this._registry.clear();
        this.interceptors.preResolution.clear();
        this.interceptors.postResolution.clear();
    };
    InternalDependencyContainer.prototype.clearInstances = function () {
        var e_3, _a;
        this.ensureNotDisposed();
        try {
            for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
                this._registry.setAll(token, registrations
                    .filter(function (registration) { return !isValueProvider(registration.provider); })
                    .map(function (registration) {
                    registration.instance = undefined;
                    return registration;
                }));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    InternalDependencyContainer.prototype.createChildContainer = function () {
        var e_4, _a;
        this.ensureNotDisposed();
        var childContainer = new InternalDependencyContainer(this);
        try {
            for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
                if (registrations.some(function (_a) {
                    var options = _a.options;
                    return options.lifecycle === lifecycle.ContainerScoped;
                })) {
                    childContainer._registry.setAll(token, registrations.map(function (registration) {
                        if (registration.options.lifecycle === lifecycle.ContainerScoped) {
                            return {
                                provider: registration.provider,
                                options: registration.options
                            };
                        }
                        return registration;
                    }));
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return childContainer;
    };
    InternalDependencyContainer.prototype.beforeResolution = function (token, callback, options) {
        if (options === void 0) { options = { frequency: "Always" }; }
        this.interceptors.preResolution.set(token, {
            callback: callback,
            options: options
        });
    };
    InternalDependencyContainer.prototype.afterResolution = function (token, callback, options) {
        if (options === void 0) { options = { frequency: "Always" }; }
        this.interceptors.postResolution.set(token, {
            callback: callback,
            options: options
        });
    };
    InternalDependencyContainer.prototype.dispose = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.disposed = true;
                        promises = [];
                        this.disposables.forEach(function (disposable) {
                            var maybePromise = disposable.dispose();
                            if (maybePromise) {
                                promises.push(maybePromise);
                            }
                        });
                        return [4, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    InternalDependencyContainer.prototype.getRegistration = function (token) {
        if (this.isRegistered(token)) {
            return this._registry.get(token);
        }
        if (this.parent) {
            return this.parent.getRegistration(token);
        }
        return null;
    };
    InternalDependencyContainer.prototype.getAllRegistrations = function (token) {
        if (this.isRegistered(token)) {
            return this._registry.getAll(token);
        }
        if (this.parent) {
            return this.parent.getAllRegistrations(token);
        }
        return null;
    };
    InternalDependencyContainer.prototype.construct = function (ctor, context) {
        var _this = this;
        if (ctor instanceof DelayedConstructor) {
            return ctor.createProxy(function (target) {
                return _this.resolve(target, context);
            });
        }
        var instance = (function () {
            var paramInfo = typeInfo.get(ctor);
            if (!paramInfo || paramInfo.length === 0) {
                if (ctor.length === 0) {
                    return new ctor();
                }
                else {
                    throw new Error("TypeInfo not known for \"" + ctor.name + "\"");
                }
            }
            var params = paramInfo.map(_this.resolveParams(context, ctor));
            return new (ctor.bind.apply(ctor, __spread([void 0], params)))();
        })();
        if (isDisposable(instance)) {
            this.disposables.add(instance);
        }
        return instance;
    };
    InternalDependencyContainer.prototype.resolveParams = function (context, ctor) {
        var _this = this;
        return function (param, idx) {
            var _a, _b, _c;
            try {
                if (isTokenDescriptor(param)) {
                    if (isTransformDescriptor(param)) {
                        return param.multiple
                            ? (_a = _this.resolve(param.transform)).transform.apply(_a, __spread([_this.resolveAll(param.token)], param.transformArgs)) : (_b = _this.resolve(param.transform)).transform.apply(_b, __spread([_this.resolve(param.token, context)], param.transformArgs));
                    }
                    else {
                        return param.multiple
                            ? _this.resolveAll(param.token)
                            : _this.resolve(param.token, context);
                    }
                }
                else if (isTransformDescriptor(param)) {
                    return (_c = _this.resolve(param.transform, context)).transform.apply(_c, __spread([_this.resolve(param.token, context)], param.transformArgs));
                }
                return _this.resolve(param, context);
            }
            catch (e) {
                throw new Error(formatErrorCtor(ctor, idx, e));
            }
        };
    };
    InternalDependencyContainer.prototype.ensureNotDisposed = function () {
        if (this.disposed) {
            throw new Error("This container has been disposed, you cannot interact with a disposed container");
        }
    };
    return InternalDependencyContainer;
}());
var instance = new InternalDependencyContainer();
/* harmony default export */ const dependency_container = ((/* unused pure expression or super */ null && (instance)));

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js





function autoInjectable() {
    return function (target) {
        var paramInfo = getParamInfo(target);
        return (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.apply(this, __spread(args.concat(paramInfo.slice(args.length).map(function (type, index) {
                    var _a, _b, _c;
                    try {
                        if (isTokenDescriptor(type)) {
                            if (isTransformDescriptor(type)) {
                                return type.multiple
                                    ? (_a = instance
                                        .resolve(type.transform)).transform.apply(_a, __spread([instance.resolveAll(type.token)], type.transformArgs)) : (_b = instance
                                    .resolve(type.transform)).transform.apply(_b, __spread([instance.resolve(type.token)], type.transformArgs));
                            }
                            else {
                                return type.multiple
                                    ? instance.resolveAll(type.token)
                                    : instance.resolve(type.token);
                            }
                        }
                        else if (isTransformDescriptor(type)) {
                            return (_c = instance
                                .resolve(type.transform)).transform.apply(_c, __spread([instance.resolve(type.token)], type.transformArgs));
                        }
                        return instance.resolve(type);
                    }
                    catch (e) {
                        var argIndex = index + args.length;
                        throw new Error(formatErrorCtor(target, argIndex, e));
                    }
                })))) || this;
            }
            return class_1;
        }(target));
    };
}
/* harmony default export */ const auto_injectable = (autoInjectable);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/inject.js

function inject(token) {
    return defineInjectionTokenMetadata(token);
}
/* harmony default export */ const decorators_inject = (inject);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/injectable.js


function injectable() {
    return function (target) {
        typeInfo.set(target, getParamInfo(target));
    };
}
/* harmony default export */ const decorators_injectable = (injectable);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/registry.js


function registry_registry(registrations) {
    if (registrations === void 0) { registrations = []; }
    return function (target) {
        registrations.forEach(function (_a) {
            var token = _a.token, options = _a.options, provider = __rest(_a, ["token", "options"]);
            return instance.register(token, provider, options);
        });
        return target;
    };
}
/* harmony default export */ const decorators_registry = (registry_registry);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/singleton.js


function singleton() {
    return function (target) {
        decorators_injectable()(target);
        instance.registerSingleton(target);
    };
}
/* harmony default export */ const decorators_singleton = (singleton);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/inject-all.js

function injectAll(token) {
    var data = { token: token, multiple: true };
    return defineInjectionTokenMetadata(data);
}
/* harmony default export */ const inject_all = (injectAll);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/inject-all-with-transform.js

function injectAllWithTransform(token, transformer) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    var data = {
        token: token,
        multiple: true,
        transform: transformer,
        transformArgs: args
    };
    return defineInjectionTokenMetadata(data);
}
/* harmony default export */ const inject_all_with_transform = (injectAllWithTransform);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/inject-with-transform.js

function injectWithTransform(token, transformer) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return defineInjectionTokenMetadata(token, {
        transformToken: transformer,
        args: args
    });
}
/* harmony default export */ const inject_with_transform = (injectWithTransform);

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/scoped.js


function scoped(lifecycle, token) {
    return function (target) {
        decorators_injectable()(target);
        instance.register(token || target, target, {
            lifecycle: lifecycle
        });
    };
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/decorators/index.js










;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/factories/instance-caching-factory.js
function instanceCachingFactory(factoryFunc) {
    var instance;
    return function (dependencyContainer) {
        if (instance == undefined) {
            instance = factoryFunc(dependencyContainer);
        }
        return instance;
    };
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/factories/instance-per-container-caching-factory.js
function instancePerContainerCachingFactory(factoryFunc) {
    var cache = new WeakMap();
    return function (dependencyContainer) {
        var instance = cache.get(dependencyContainer);
        if (instance == undefined) {
            instance = factoryFunc(dependencyContainer);
            cache.set(dependencyContainer, instance);
        }
        return instance;
    };
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/factories/predicate-aware-class-factory.js
function predicateAwareClassFactory(predicate, trueConstructor, falseConstructor, useCaching) {
    if (useCaching === void 0) { useCaching = true; }
    var instance;
    var previousPredicate;
    return function (dependencyContainer) {
        var currentPredicate = predicate(dependencyContainer);
        if (!useCaching || previousPredicate !== currentPredicate) {
            if ((previousPredicate = currentPredicate)) {
                instance = dependencyContainer.resolve(trueConstructor);
            }
            else {
                instance = dependencyContainer.resolve(falseConstructor);
            }
        }
        return instance;
    };
}

;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/factories/index.js




;// CONCATENATED MODULE: ./node_modules/tsyringe/dist/esm5/index.js
if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
    throw new Error("tsyringe requires a reflect polyfill. Please add 'import \"reflect-metadata\"' to the top of your entry point.");
}








/***/ }),

/***/ 19451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULTS: () => (/* binding */ DEFAULTS),
/* harmony export */   Easing: () => (/* binding */ Easing),
/* harmony export */   Group: () => (/* binding */ Group),
/* harmony export */   Interpolation: () => (/* binding */ Interpolation),
/* harmony export */   NOW: () => (/* binding */ NOW),
/* harmony export */   Tween: () => (/* binding */ Tween),
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
/* eslint-disable */
 
/*!
 * tweedle.js - v2.1.0
 * Compiled Wed, 05 Apr 2023 15:21:25 UTC
 *
 * tweedle.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2021, Milton Candelero <miltoncandelero@gmail.com>, All Rights Reserved
 */
/**
 * Polyfilled function to get the current time in miliseconds.
 * It tries to use `process.hrtime()`, `performance.now()`, `Date.now()` or `new Date().getTime()` in that order.
 */
let NOW;

// Include a performance.now polyfill.
// In node.js, use process.hrtime.

// @ts-ignore
if (typeof self == "undefined" && typeof process !== "undefined" && process.hrtime) {
	NOW = function () {
		// @ts-ignore
		const time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use self.performance.now if it is available.
else if (typeof self !== "undefined" && self.performance !== undefined && self.performance.now !== undefined) {
	// This must be bound, because directly assigning this function
	// leads to an invocation exception in Chrome.
	NOW = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
	NOW = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
	NOW = function () {
		return new Date().getTime();
	};
}

/**
 * A group is a class that allows you to manage many tweens from one place.
 *
 * A tween will ALWAYS belong to a group. If no group is assigned it will default to the static shared group: `Group.shared`.
 */
class Group {constructor() { Group.prototype.__init.call(this);Group.prototype.__init2.call(this);Group.prototype.__init3.call(this);Group.prototype.__init4.call(this); }
	 __init() {this._tweens

 = {};}

	

	/**
	 * A tween without an explicit group will default to this shared static one.
	 */
	 static get shared() {
		if (!Group._shared) {
			Group._shared = new Group();
		}
		return Group._shared;
	}

	 __init2() {this._paused = false;}

	/**
	 * A paused group will skip updating all the asociated tweens.
	 * _To control all tweens, use {@link Group.getAll} to get an array with all tweens._
	 * @returns returns true if this group is paused.
	 */
	 isPaused() {
		return this._paused;
	}

	/**
	 * Pauses this group. If a group was already paused, this has no effect.
	 * A paused group will skip updating all the asociated tweens.
	 * _To control all tweens, use {@link Group.getAll} to get an array with all tweens._
	 */
	 pause() {
		this._paused = true;
	}

	/**
	 * Resumes this group. If a group was not paused, this has no effect.
	 * A paused group will skip updating all the asociated tweens.
	 * _To control all tweens, use {@link Group.getAll} to get an array with all tweens._
	 */
	 resume() {
		this._paused = false;
	}

	 __init3() {this._lastUpdateTime = undefined;}

	/**
	 * Function used by the group to know what time is it.
	 * Used to calculate the deltaTime in case you call update without the parameter.
	 */
	 __init4() {this.now = NOW;} // used to calculate deltatime in case you stop providing one

	/**
	 * Returns all the tweens in this group.
	 *
	 * _note: only **running** tweens are in a group._
	 * @returns all the running tweens.
	 */
	 getAll() {
		return Object.keys(this._tweens).map((tweenId) => this._tweens[tweenId]);
	}

	/**
	 * Removes all the tweens in this group.
	 *
	 * _note: this will not modify the group reference inside the tween object_
	 */
	 removeAll() {
		this._tweens = {};
	}

	/**
	 * Adds a tween to this group.
	 *
	 * _note: this will not modify the group reference inside the tween object_
	 * @param tween Tween to add.
	 */
	 add(tween) {
		this._tweens[tween.getId()] = tween;
	}

	/**
	 * Removes a tween from this group.
	 *
	 * _note: this will not modify the group reference inside the tween object_
	 * @param tween
	 */
	 remove(tween) {
		delete this._tweens[tween.getId()];
	}

	/**
	 * Updates all the tweens in this group.
	 *
	 * If a tween is stopped, paused, finished or non started it will be removed from the group.
	 *
	 *  Tweens are updated in "batches". If you add a new tween during an
	 *  update, then the new tween will be updated in the next batch.
	 *  If you remove a tween during an update, it may or may not be updated.
	 *  However, if the removed tween was added during the current batch,
	 *  then it will not be updated.
	 * @param deltaTime - Amount of **miliseconds** that have passed since last excecution. If not provided it will be calculated using the {@link Group.now} function
	 * @param preserve - Prevent the removal of stopped, paused, finished or non started tweens.
	 * @returns returns true if the group is not empty and it is not paused.
	 */
	 update(deltaTime, preserve = false) {
		// move forward the automatic dt if needed
		if (deltaTime == undefined) {
			// now varies from line to line, that's why I manually use 0 as dt
			if (this._lastUpdateTime == undefined) {
				this._lastUpdateTime = this.now();
				deltaTime = 0;
			} else {
				deltaTime = this.now() - this._lastUpdateTime;
			}
		}
		this._lastUpdateTime = this.now();

		// exit early if the entire group is paused
		if (this._paused) {
			return false;
		}

		const tweenIds = Object.keys(this._tweens);
		if (tweenIds.length == 0) {
			return false;
		}

		for (let i = 0; i < tweenIds.length; i++) {
			const tween = this._tweens[tweenIds[i]];

			// groups call the preserve with true because they like to delete themselves in a different way.
			if (tween && tween.update(deltaTime, true) == false && !preserve) {
				delete this._tweens[tweenIds[i]];
			}
		}

		return true;
	}
}

/**
 * The type for a function that takes a number between 0 and 1 and returns another number between 0 and 1
 */


/**
 * The Ease class provides a collection of easing functions.
 *
 * These functions take in a parameter between 0 and 1 as the ratio and give out a new ratio.
 *
 * These are [Robert Penner](http://www.robertpenner.com/easing_terms_of_use.html)'s optimized formulas.
 *
 * Need help picking one? [Check this out!](https://easings.net/)
 */
const Easing = {
	Step: {
		None(amount) {
			return amount < 0.5 ? 0 : 1;
		},
	},
	Linear: {
		None(amount) {
			return amount;
		},
	},
	Quadratic: {
		In(amount) {
			return amount * amount;
		},
		Out(amount) {
			return amount * (2 - amount);
		},
		InOut(amount) {
			if ((amount *= 2) < 1) {
				return 0.5 * amount * amount;
			}

			return -0.5 * (--amount * (amount - 2) - 1);
		},
	},
	Cubic: {
		In(amount) {
			return amount * amount * amount;
		},
		Out(amount) {
			return --amount * amount * amount + 1;
		},
		InOut(amount) {
			if ((amount *= 2) < 1) {
				return 0.5 * amount * amount * amount;
			}

			return 0.5 * ((amount -= 2) * amount * amount + 2);
		},
	},
	Quartic: {
		In(amount) {
			return amount * amount * amount * amount;
		},
		Out(amount) {
			return 1 - --amount * amount * amount * amount;
		},
		InOut(amount) {
			if ((amount *= 2) < 1) {
				return 0.5 * amount * amount * amount * amount;
			}

			return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
		},
	},
	Quintic: {
		In(amount) {
			return amount * amount * amount * amount * amount;
		},
		Out(amount) {
			return --amount * amount * amount * amount * amount + 1;
		},
		InOut(amount) {
			if ((amount *= 2) < 1) {
				return 0.5 * amount * amount * amount * amount * amount;
			}

			return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
		},
	},
	Sinusoidal: {
		In(amount) {
			return 1 - Math.cos((amount * Math.PI) / 2);
		},
		Out(amount) {
			return Math.sin((amount * Math.PI) / 2);
		},
		InOut(amount) {
			return 0.5 * (1 - Math.cos(Math.PI * amount));
		},
	},
	Exponential: {
		In(amount) {
			return amount == 0 ? 0 : Math.pow(1024, amount - 1);
		},
		Out(amount) {
			return amount == 1 ? 1 : 1 - Math.pow(2, -10 * amount);
		},
		InOut(amount) {
			if (amount == 0) {
				return 0;
			}

			if (amount == 1) {
				return 1;
			}

			if ((amount *= 2) < 1) {
				return 0.5 * Math.pow(1024, amount - 1);
			}

			return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
		},
	},
	Circular: {
		In(amount) {
			return 1 - Math.sqrt(1 - amount * amount);
		},
		Out(amount) {
			return Math.sqrt(1 - --amount * amount);
		},
		InOut(amount) {
			if ((amount *= 2) < 1) {
				return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
		},
	},
	Elastic: {
		In(amount) {
			if (amount == 0) {
				return 0;
			}

			if (amount == 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
		},
		Out(amount) {
			if (amount == 0) {
				return 0;
			}

			if (amount == 1) {
				return 1;
			}

			return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
		},
		InOut(amount) {
			if (amount == 0) {
				return 0;
			}

			if (amount == 1) {
				return 1;
			}

			amount *= 2;

			if (amount < 1) {
				return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
		},
	},
	Back: {
		In(amount) {
			const s = 1.70158;

			return amount * amount * ((s + 1) * amount - s);
		},
		Out(amount) {
			const s = 1.70158;

			return --amount * amount * ((s + 1) * amount + s) + 1;
		},
		InOut(amount) {
			const s = 1.70158 * 1.525;

			if ((amount *= 2) < 1) {
				return 0.5 * (amount * amount * ((s + 1) * amount - s));
			}

			return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
		},
	},
	Bounce: {
		In(amount) {
			return 1 - Easing.Bounce.Out(1 - amount);
		},
		Out(amount) {
			if (amount < 1 / 2.75) {
				return 7.5625 * amount * amount;
			} else if (amount < 2 / 2.75) {
				return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
			} else if (amount < 2.5 / 2.75) {
				return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
			}

			return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
		},
		InOut(amount) {
			if (amount < 0.5) {
				return Easing.Bounce.In(amount * 2) * 0.5;
			}

			return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
		},
	},
};

/**
 * The type for a function that picks a value by interpolating the elements of the array given.
 */


/**
 * Object containing common interpolation functions.
 * These functions can be passed in the {@link Tween.interpolation} argument and **will only affect fields where you gave an array as target value**
 */
const Interpolation = {
	/**
	 * Geometric interpolation functions. Good for interpolating positions in space.
	 */
	Geom: {
		/**
		 * Linear interpolation is like drawing straight lines between the points.
		 */
		Linear(v, k) {
			const m = v.length - 1;
			const f = m * k;
			const i = Math.floor(f);
			const fn = Interpolation.Utils.Linear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
		},

		/**
		 * A Bzier curve is defined by a set of control points P0 through Pn, where n is called its order.
		 * The first and last control points are always the end points of the curve; however, the intermediate control points (if any) generally do not lie on the curve.
		 *
		 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Explicit_definition
		 */
		Bezier(v, k) {
			let b = 0;
			const n = v.length - 1;
			const pw = Math.pow;
			const bn = Interpolation.Utils.Bernstein;

			for (let i = 0; i <= n; i++) {
				b += bn(n, i) * pw(1 - k, n - i) * pw(k, i) * v[i];
			}

			return b;
		},

		/**
		 * Assumes your points are a succession of quadratic bezier curves where the endpoint of one is the start point of the next one.
		 * for example: `[Point in the curve, Control point, Point in the curve, Control point, Point in the curve]`
		 */
		QuadraticBezier(v, k) {
			let b = 0;
			const n = v.length - 1;

			if (k == 1) {
				return v[n];
			}

			const pw = Math.pow;
			const bn = Interpolation.Utils.Bernstein;

			const f = n * k;
			const i = Math.floor(f);
			const t = (f - i) * 0.5 + 0.5 * (i % 2);
			const i0 = i - (i % 2);
			const i1 = i0 + 1;
			const i2 = i0 + 2;

			b += bn(2, 0) * pw(1 - t, 2 - 0) * pw(t, 0) * v[i0];
			b += bn(2, 1) * pw(1 - t, 2 - 1) * pw(t, 1) * v[i1];
			b += bn(2, 2) * pw(1 - t, 2 - 2) * pw(t, 2) * v[i2];

			return b;
		},

		/**
		 * Assumes your points are a succession of cubic bezier curves where the endpoint of one is the start point of the next one.
		 * for example: `[Point in the curve, Control point, Control point, Point in the curve, Control point, Control point, Point in the curve]`
		 */
		CubicBezier(v, k) {
			let b = 0;
			const n = v.length - 1;

			if (k == 1) {
				return v[n];
			}

			const pw = Math.pow;
			const bn = Interpolation.Utils.Bernstein;

			const f = n * k;
			const i = Math.floor(f);

			const t = (f - i) * (1 / 3) + (1 / 3) * (i % 3);

			const i0 = i - (i % 3);
			const i1 = i0 + 1;
			const i2 = i0 + 2;
			const i3 = i0 + 3;

			b += bn(3, 0) * pw(1 - t, 3 - 0) * pw(t, 0) * v[i0];
			b += bn(3, 1) * pw(1 - t, 3 - 1) * pw(t, 1) * v[i1];
			b += bn(3, 2) * pw(1 - t, 3 - 2) * pw(t, 2) * v[i2];
			b += bn(3, 3) * pw(1 - t, 3 - 3) * pw(t, 3) * v[i3];

			return b;
		},

		/**
		 * A Catmullrom spline is a curve where the original set of points is also used as control points.
		 * Usually Catmullrom splines need two extra elements at the beginning and the end of the point set. This function contemplates that and doesn't need them.
		 *
		 * https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull%E2%80%93Rom_spline
		 */
		CatmullRom(v, k) {
			const m = v.length - 1;
			let f = m * k;
			let i = Math.floor(f);
			const fn = Interpolation.Utils.CatmullRom;

			if (v[0] == v[m]) {
				if (k < 0) {
					i = Math.floor((f = m * (1 + k)));
				}

				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
			}
			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
		},
	},
	/**
	 * Given the spinny nature of angles, sometimes it's better to go back to get to the right place earlier.
	 * This functions help with that.
	 */
	Angle: {
		/**
		 * Normalizes angles between 0 and 2pi and then rotates the object in the shortest direction.
		 */
		Radians(v, k) {
			const m = v.length - 1;
			const f = m * k;
			const i = Math.floor(f);
			const fn = Interpolation.Utils.WrapLinear;

			if (k < 0) {
				return fn(v[0], v[1], f, 2 * Math.PI);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f, 2 * Math.PI);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i, 2 * Math.PI);
		},

		/**
		 * Normalizes angles between 0 and 360 and then rotates the object in the shortest direction.
		 */
		Degrees(v, k) {
			const m = v.length - 1;
			const f = m * k;
			const i = Math.floor(f);
			const fn = Interpolation.Utils.WrapLinear;

			if (k < 0) {
				return fn(v[0], v[1], f, 360);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f, 360);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i, 360);
		},
	},

	/**
	 * Even if colors are numbers, interpolating them can be tricky.
	 */
	Color: {
		/**
		 * Interpolates the color by their channels Red, Green, and Blue.
		 */
		RGB(v, k) {
			const m = v.length - 1;
			const f = m * k;
			const i = Math.floor(f);
			const fn = Interpolation.Utils.RGBLinear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
		},

		/**
		 * Interpolates the color by their Hue, Saturation, and Value.
		 */
		HSV(v, k) {
			const m = v.length - 1;
			const f = m * k;
			const i = Math.floor(f);
			const fn = Interpolation.Utils.HSVLinear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
		},

		/**
		 * Interpolates the color by their Hue, Chroma, and Lightness.
		 */
		HCL(v, k) {
			const m = v.length - 1;
			const f = m * k;
			const i = Math.floor(f);
			const fn = Interpolation.Utils.HCLLinear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
		},
	},

	/**
	 * Helper functions used to calculate the different interpolations
	 */
	Utils: {
		RGBsplit(color) {
			// this gets named ARGB but it is actually meaningless. It will work with RGBA just the same.
			const a = (color >> 24) & 0xff;
			const r = (color >> 16) & 0xff;
			const g = (color >> 8) & 0xff;
			const b = color & 0xff;
			return { a, r, g, b };
		},
		HSVsplit(color) {
			const rgb = Interpolation.Utils.RGBsplit(color);

			(rgb.r /= 255), (rgb.g /= 255), (rgb.b /= 255);

			const max = Math.max(rgb.r, rgb.g, rgb.b);
			const min = Math.min(rgb.r, rgb.g, rgb.b);
			let h;
			const v = max;

			const d = max - min;
			const s = max == 0 ? 0 : d / max;

			if (max == min) {
				h = 0; // achromatic
			} else {
				switch (max) {
					case rgb.r:
						h = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6 : 0);
						break;
					case rgb.g:
						h = (rgb.b - rgb.r) / d + 2;
						break;
					case rgb.b:
						h = (rgb.r - rgb.g) / d + 4;
						break;
				}

				h /= 6;
			}

			return { a: rgb.a, h, s, v };
		},
		HSVJoin(color) {
			let r, g, b;

			const i = Math.floor(color.h * 6);
			const f = color.h * 6 - i;
			const p = color.v * (1 - color.s);
			const q = color.v * (1 - f * color.s);
			const t = color.v * (1 - (1 - f) * color.s);

			switch (i % 6) {
				case 0:
					(r = color.v), (g = t), (b = p);
					break;
				case 1:
					(r = q), (g = color.v), (b = p);
					break;
				case 2:
					(r = p), (g = color.v), (b = t);
					break;
				case 3:
					(r = p), (g = q), (b = color.v);
					break;
				case 4:
					(r = t), (g = p), (b = color.v);
					break;
				case 5:
					(r = color.v), (g = p), (b = q);
					break;
			}
			return (color.a << 24) | (r << 16) | (g << 8) | b;
		},

		HCLSplit(color) {
			/* https://www.chilliant.com/rgb2hsv.html */
			const HCLgamma = 3;
			const HCLy0 = 100;
			const HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5

			const RGB = Interpolation.Utils.RGBsplit(color);
			const HCL = { a: RGB.a, h: 0, c: 0, l: 0 };
			let H = 0;
			const U = Math.min(RGB.r, Math.min(RGB.g, RGB.b));
			const V = Math.max(RGB.r, Math.max(RGB.g, RGB.b));
			let Q = HCLgamma / HCLy0;
			HCL.c = V - U;
			if (HCL.c != 0) {
				H = Math.atan2(RGB.g - RGB.b, RGB.r - RGB.g) / Math.PI;
				Q *= U / V;
			}
			Q = Math.exp(Q);
			HCL.h = (H / 2 - Math.min(H % 1, -H % 1) / 6) % 1;
			HCL.c *= Q;
			HCL.l = Interpolation.Utils.Linear(-U, V, Q) / (HCLmaxL * 2);
			return HCL;
		},

		HCLJoin(HCL) {
			/* https://www.chilliant.com/rgb2hsv.html */
			const HCLgamma = 3;
			const HCLy0 = 100;
			const HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
			const RGB = { a: HCL.a, r: 0, g: 0, b: 0 };

			if (HCL.l != 0) {
				let H = HCL.h;
				const C = HCL.c;
				const L = HCL.l * HCLmaxL;
				const Q = Math.exp((1 - C / (2 * L)) * (HCLgamma / HCLy0));
				const U = (2 * L - C) / (2 * Q - 1);
				const V = C / Q;
				const A = (H + Math.min(((2 * H) % 1) / 4, ((-2 * H) % 1) / 8)) * Math.PI * 2;
				let T;
				H *= 6;
				if (H <= 0.999) {
					T = Math.tan(A);
					RGB.r = 1;
					RGB.g = T / (1 + T);
				} else if (H <= 1.001) {
					RGB.r = 1;
					RGB.g = 1;
				} else if (H <= 2) {
					T = Math.tan(A);
					RGB.r = (1 + T) / T;
					RGB.g = 1;
				} else if (H <= 3) {
					T = Math.tan(A);
					RGB.g = 1;
					RGB.b = 1 + T;
				} else if (H <= 3.999) {
					T = Math.tan(A);
					RGB.g = 1 / (1 + T);
					RGB.b = 1;
				} else if (H <= 4.001) {
					RGB.g = 0;
					RGB.b = 1;
				} else if (H <= 5) {
					T = Math.tan(A);
					RGB.r = -1 / T;
					RGB.b = 1;
				} else {
					T = Math.tan(A);
					RGB.r = 1;
					RGB.b = -T;
				}
				RGB.r = RGB.r * V + U;
				RGB.g = RGB.g * V + U;
				RGB.b = RGB.b * V + U;
			}
			return (RGB.a << 24) | (RGB.r << 16) | (RGB.g << 8) | RGB.b;
		},

		WrapLinear(value1, value2, t, maxValue) {
			let retval;

			// this fixes my values to be between 0 and maxvalue.
			value1 = (value1 + maxValue * Math.trunc(Math.abs(value1 / maxValue))) % maxValue;
			value2 = (value2 + maxValue * Math.trunc(Math.abs(value2 / maxValue))) % maxValue;

			if (Math.abs(value1 - value2) <= 0.5 * maxValue) {
				retval = Interpolation.Utils.Linear(value1, value2, t);
			} else {
				if (value1 < value2) {
					retval = Interpolation.Utils.Linear(value1 + maxValue, value2, t);
				} else {
					retval = Interpolation.Utils.Linear(value1, value2 + maxValue, t);
				}
				retval = retval % maxValue;
			}
			return retval;
		},

		RGBLinear(color1, color2, t) {
			const argb1 = Interpolation.Utils.RGBsplit(color1);
			const argb2 = Interpolation.Utils.RGBsplit(color2);
			const a = Interpolation.Utils.Linear(argb1.a, argb2.a, t);
			const r = Interpolation.Utils.Linear(argb1.r, argb2.r, t);
			const g = Interpolation.Utils.Linear(argb1.g, argb2.g, t);
			const b = Interpolation.Utils.Linear(argb1.b, argb2.b, t);
			return (a << 24) | (r << 16) | (g << 8) | b;
		},
		HSVLinear(color1, color2, t) {
			const ahsv1 = Interpolation.Utils.HSVsplit(color1);
			const ahsv2 = Interpolation.Utils.HSVsplit(color2);
			let h;
			if (Math.abs(ahsv1.h - ahsv2.h) <= 0.5) {
				h = Interpolation.Utils.Linear(ahsv1.h, ahsv2.h, t);
			} else {
				if (ahsv1.h < ahsv2.h) {
					h = Interpolation.Utils.Linear(ahsv1.h + 1, ahsv2.h, t);
				} else {
					h = Interpolation.Utils.Linear(ahsv1.h, ahsv2.h + 1, t);
				}
				h = h % 1;
			}
			const s = Interpolation.Utils.Linear(ahsv1.s, ahsv2.s, t);
			const v = Interpolation.Utils.Linear(ahsv1.v, ahsv2.v, t);
			const a = Interpolation.Utils.Linear(ahsv1.a, ahsv2.a, t); // alpha can't be done with hsv
			return Interpolation.Utils.HSVJoin({ a, h, s, v });
		},
		HCLLinear(color1, color2, t) {
			const ahcl1 = Interpolation.Utils.HCLSplit(color1);
			const ahcl2 = Interpolation.Utils.HCLSplit(color2);
			let h;
			if (Math.abs(ahcl1.h - ahcl2.h) <= 0.5) {
				h = Interpolation.Utils.Linear(ahcl1.h, ahcl2.h, t);
			} else {
				if (ahcl1.h < ahcl2.h) {
					h = Interpolation.Utils.Linear(ahcl1.h + 1, ahcl2.h, t);
				} else {
					h = Interpolation.Utils.Linear(ahcl1.h, ahcl2.h + 1, t);
				}
				h = h % 1;
			}
			const s = Interpolation.Utils.Linear(ahcl1.c, ahcl2.c, t);
			const v = Interpolation.Utils.Linear(ahcl1.l, ahcl2.l, t);
			const a = Interpolation.Utils.Linear(ahcl1.a, ahcl2.a, t); // alpha can't be done with hsv
			return Interpolation.Utils.HSVJoin({ a, h, s, v });
		},

		Linear(p0, p1, t) {
			return (p1 - p0) * t + p0;
		},
		Bernstein(n, i) {
			const fc = Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);
		},
		Factorial: (function () {
			const a = [1];

			return function (n) {
				let s = 1;

				if (a[n]) {
					return a[n];
				}

				for (let i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;

				return s;
			};
		})(),

		CatmullRom(p0, p1, p2, p3, t) {
			const v0 = (p2 - p0) * 0.5;
			const v1 = (p3 - p1) * 0.5;
			const t2 = t * t;
			const t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
		},
	},
};

/**
 * ARGB color format
 * Alpha, Red, Green, Blue.
 */

/**
 * Silly class to have a shared number that goes up.
 */
class Sequence {
	 static __initStatic() {this._nextId = 0;}

	 static nextId() {
		return Sequence._nextId++;
	}
} Sequence.__initStatic();

/**
 * Default values used **during tween creation**.
 * Allows to change the default values for all tweens.
 */
const DEFAULTS = {
	safetyCheckFunction: (_) => true,
	easingFunction: Easing.Linear.None,
	yoyoEasingFunction: undefined,
	interpolationFunction: Interpolation.Geom.Linear,
};

/**
 * A Tween is basically an animation command.
 * For example: _Go from here to there in this amount of time._
 *
 * Tweens won't start by themselves. **Remeber to call {@link Tween.start} when you want your tweens to start!**
 *
 * Most methods will return the same object to allow for daisy chaining.
 * @template Target of the tween
 */
class Tween {
	 __init() {this._isPaused = false;}
	 __init2() {this._valuesStart = {};}
	 __init3() {this._valuesEnd = {};}
	 __init4() {this._valuesStartRepeat = {};}
	 __init5() {this._duration = 0;}
	 __init6() {this._repeatCount = 0;}
	 __init7() {this._repeat = 0;}
	
	 __init8() {this._yoyo = false;}
	 __init9() {this._isPlaying = false;}
	 get _reversed() {
		return this.yoyo && this._repeatCount % 2 !== 0;
	}
	 __init10() {this._delayTime = 0;}
	 __init11() {this._startTime = 0;}
	 __init12() {this._elapsedTime = 0;}
	 __init13() {this._timescale = 1;}
	 __init14() {this._safetyCheckFunction = DEFAULTS.safetyCheckFunction;}
	 __init15() {this._easingFunction = DEFAULTS.easingFunction;}
	 __init16() {this._yoyoEasingFunction = DEFAULTS.yoyoEasingFunction;}
	 __init17() {this._interpolationFunction = DEFAULTS.interpolationFunction;}
	 __init18() {this._chainedTweens = [];}
	
	 __init19() {this._onStartCallbackFired = false;}
	
	 __init20() {this._onAfterDelayCallbackFired = false;}
	
	
	
	
	 __init21() {this._id = Sequence.nextId();}
	 __init22() {this._isChainStopped = false;}
	
	
	 get _group() {
		if (this._groupRef) {
			return this._groupRef;
		} else {
			return Group.shared;
		}
	}
	 set _group(value) {
		this._groupRef = value;
	}

	/**
	 * Creates an instance of tween.
	 * @param object - The target object which properties you want to animate
	 * @param group - The {@link Group} this new Tween will belong to. If none is provided it will default to the static {@link Group.shared}
	 */
	constructor(object, group) {Tween.prototype.__init.call(this);Tween.prototype.__init2.call(this);Tween.prototype.__init3.call(this);Tween.prototype.__init4.call(this);Tween.prototype.__init5.call(this);Tween.prototype.__init6.call(this);Tween.prototype.__init7.call(this);Tween.prototype.__init8.call(this);Tween.prototype.__init9.call(this);Tween.prototype.__init10.call(this);Tween.prototype.__init11.call(this);Tween.prototype.__init12.call(this);Tween.prototype.__init13.call(this);Tween.prototype.__init14.call(this);Tween.prototype.__init15.call(this);Tween.prototype.__init16.call(this);Tween.prototype.__init17.call(this);Tween.prototype.__init18.call(this);Tween.prototype.__init19.call(this);Tween.prototype.__init20.call(this);Tween.prototype.__init21.call(this);Tween.prototype.__init22.call(this);
		this._object = object;
		this._group = group;
	}

	/**
	 * Gets the id for this tween. A tween id is a number that increases perpetually with each tween created. It is used inside {@link Group} to keep track of tweens
	 * @returns returns the id for this tween.
	 */
	 getId() {
		return this._id;
	}

	/**
	 * Gets {@link Group} that this tween belongs to.
	 * @returns returns the {@link Group} for this tween.
	 */
	 getGroup() {
		return this._group;
	}

	/**
	 * Gets the timescale for this tween. The timescale is a factor by which each deltatime is multiplied, allowing to speed up or slow down the tween.
	 * @returns returns the timescale for this tween.
	 */
	 getTimescale() {
		return this._timescale;
	}

	/**
	 * A tween is playing when it has been started but hasn't ended yet. This has nothing to do with pausing. For that see {@link Tween.isPaused}.
	 * @returns returns true if this tween is playing.
	 */
	 isPlaying() {
		return this._isPlaying;
	}

	/**
	 * A tween can only be paused if it was playing.
	 * @returns returns true if this tween is paused.
	 */
	 isPaused() {
		return this._isPaused;
	}

	/**
	 * Writes the starting values of the tween.
	 *
	 * **Starting values generated from {@link Tween.start} will be overwritten.**
	 * @param properties - Starting values for this tween.
	 * @returns returns this tween for daisy chaining methods.
	 */
	

	 from(properties) {
		try {
			JSON.stringify(properties);
		} catch (e) {
			throw new Error("The object you provided to the from() method has a circular reference!");
		}
		this._setupProperties(properties, this._valuesStart, properties, this._valuesStartRepeat, true);
		return this;
	}

	/**
	 * Set the final values for the target object's properties by copy.
	 * This will try to create a deep copy of the `properties` parameter.
	 * If you want the tween to keep a reference to the final values use {@link Tween.dynamicTo}.
	 *
	 * If an array value is provided for a value that originally wasn't an array, it will be interpreted as an interpolable curve and the values inside the array will be interpolated using the function provided in {@link Tween.interpolation}
	 *
	 * If a string value that starts with either `+` or `-`is provided it will be taken as a _relative value_ to the start value.
	 * @param properties - final values for the target object.
	 * @param duration - if given it will be used as the duration in **miliseconds**. if not, a call to {@link Tween.duration} will be needed.
	 * @returns returns this tween for daisy chaining methods.
	 */
	

	 to(properties, duration) {
		try {
			this._valuesEnd = JSON.parse(JSON.stringify(properties));
		} catch (e) {
			// recursive object. this gonna crash!
			console.warn("The object you provided to the to() method has a circular reference!. It can't be cloned. Falling back to dynamic targeting");
			return this.dynamicTo(properties, duration);
		}

		if (duration !== undefined) {
			this._duration = duration;
		}

		return this;
	}

	/**
	 * Set the final values for the target object's properties by reference.
	 * This will store a reference to the properties object allowing you to change the final values while the tween is running.
	 * If you want the tween to make a copy of the final values use {@link Tween.to}.
	 * @param properties - final values for the target object.
	 * @param duration - if given it will be used as the duration in **miliseconds**. if not, a call to {@link Tween.duration} will be needed.
	 * @returns returns this tween for daisy chaining methods.
	 */
	

	 dynamicTo(properties, duration) {
		this._valuesEnd = properties; // JSON.parse(JSON.stringify(properties));

		if (duration !== undefined) {
			this._duration = duration;
		}

		return this;
	}

	/**
	 * Sets the duration for this tween in **miliseconds**.
	 * @param d - The duration for this tween in **miliseconds**.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 duration(d) {
		this._duration = d;

		return this;
	}

	/**
	 * Tweens won't start by themselves when created. Call this to start the tween.
	 * Starting values for the animation will be stored at this moment.
	 *
	 * **This function can't overwrite the starting values set by {@link Tween.from}**
	 *
	 * You can call this method on a finished tween to restart it without changing the starting values.
	 * To restart a tween and reset the starting values use {@link Tween.restart}
	 * @param delay - if given it will be used as the delay in **miliseconds**.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 start(delay) {
		if (this._isPlaying) {
			return this;
		}

		if (delay != undefined) {
			this._delayTime = delay;
		}

		this._group.add(this);

		if (this._reversed) {
			this._swapEndStartRepeatValues(this._valuesStartRepeat, this._valuesEnd);
			this._valuesStart = JSON.parse(JSON.stringify(this._valuesStartRepeat));
		}

		this._repeatCount = 0; // This must be after we check for the _reversed flag!!.

		this._isPlaying = true;

		this._isPaused = false;

		this._onStartCallbackFired = false;

		this._onAfterDelayCallbackFired = false;

		this._isChainStopped = false;

		this._startTime = -this._delayTime;

		this._elapsedTime = 0;

		this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, false);

		return this;
	}

	/**
	 * @experimental
	 * Forces a tween to restart.
	 * Starting values for the animation will be stored at this moment.
	 * This literally calls {@link Tween.reset} and then {@link Tween.start}.
	 *
	 * **Starting values will be cleared!. This function will erase all values created from {@link Tween.from} and/or {@link Tween.start}**
	 * @param delay - if given it will be used as the delay in **miliseconds**.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 restart(delay) {
		this.reset();
		return this.start(delay);
	}

	/**
	 * @experimental
	 * Clears the starting and loop starting values.
	 *
	 * **Starting values will be cleared!. This function will erase all values created from {@link Tween.from} and/or {@link Tween.start}**
	 * @returns returns this tween for daisy chaining methods.
	 */
	 reset() {
		if (this._isPlaying) {
			this.stop();
		}
		this._valuesStart = {};
		this._valuesStartRepeat = {};
		return this;
	}

	/**
	 * @experimental
	 * Stops the tween and sets the values to the starting ones.
	 *
	 * @returns returns this tween for daisy chaining methods.
	 */
	 rewind() {
		if (this._isPlaying) {
			this.stop();
		}

		if (this._reversed) {
			// if you rewind from a reversed position, we unreverse.
			this._swapEndStartRepeatValues(this._valuesStartRepeat, this._valuesEnd);
		}

		const value = this._easingFunction(0);

		// properties transformations
		this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);

		return this;
	}

	 _setupProperties(_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overwrite) {
		for (const property in _valuesEnd) {
			const startValue = _object[property];
			const startValueIsArray = Array.isArray(startValue);
			const startValueIsNumber = !Number.isNaN(Number(startValue));
			const propType = startValueIsArray ? "array" : typeof startValue;
			const startValueIsObject = propType == "object";
			const endValueIsObject = typeof _valuesEnd[property] == "object";
			const isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);

			// If to() specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (propType == "undefined" || propType == "function" || _valuesEnd[property] == undefined || (!startValueIsArray && !startValueIsNumber && !startValueIsObject)) {
				continue;
			}

			// handle the deepness of the values
			if ((startValueIsObject || startValueIsArray || endValueIsObject) && startValue && !isInterpolationList) {
				if (typeof _valuesStart[property] == "undefined") {
					_valuesStart[property] = startValueIsArray ? [] : {};
				}
				if (typeof _valuesStartRepeat[property] == "undefined") {
					_valuesStartRepeat[property] = startValueIsArray ? [] : {};
				}

				this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property], overwrite);
			} else {
				// Save the starting value, but only once.
				if (typeof _valuesStart[property] == "undefined" || overwrite) {
					_valuesStart[property] = startValue;
				}

				if (typeof _valuesStartRepeat[property] == "undefined" || overwrite) {
					if (isInterpolationList) {
						_valuesStartRepeat[property] = _valuesEnd[property].slice().reverse()[0];
					} else {
						_valuesStartRepeat[property] = _valuesStart[property] || 0;
					}
				}
			}
		}
	}

	/**
	 * Stops this tween
	 * @returns returns this tween for daisy chaining methods.
	 */
	 stop() {
		if (!this._isChainStopped) {
			this._isChainStopped = true;
			this.stopChainedTweens();
		}

		if (!this._isPlaying) {
			return this;
		}

		this._group.remove(this);

		this._isPlaying = false;

		this._isPaused = false;

		if (this._onStopCallback) {
			this._onStopCallback(this._object, this);
		}

		return this;
	}

	/**
	 * Fastforwards this tween to the end by triggering an update with an infinite value.
	 * This will work even on paused tweens.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 end(endChainedTweens = false) {
		let protectedChainedTweens = [];

		if (!endChainedTweens) {
			protectedChainedTweens = this._chainedTweens;
			this._chainedTweens = [];
		}

		this.resume();
		this.update(Infinity);

		if (!endChainedTweens) {
			this._chainedTweens = protectedChainedTweens;
			for (let i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
				this._chainedTweens[i].start();
			}
		}

		return this;
	}

	/**
	 * @experimental
	 * Skips forward the in the repeats of this tween by triggering a biiiiig update.
	 * Think of this as a less agressive {@link Tween.end}.
	 *
	 * @param amount - The amount of repeats to skip.
	 * @param resetCurrentLoop - If true, the time will become zero and the object will return to the initial value in the next update.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 skip(amount, resetCurrentLoop = false) {
		this.resume();

		this.update(amount * this._duration - (resetCurrentLoop ? this._elapsedTime : 0));

		return this;
	}

	/**
	 * Pauses this tween. Does nothing is if the tween was already paused or wasn't playing.
	 * Paused tweens ignore all update calls.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 pause() {
		if (this._isPaused || !this._isPlaying) {
			return this;
		}

		this._isPaused = true;

		this._group.remove(this);

		return this;
	}

	/**
	 * Resumes this tween. Does nothing if the tween wasn't paused nor running.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 resume() {
		if (!this._isPaused || !this._isPlaying) {
			return this;
		}

		this._isPaused = false;

		this._group.add(this);

		return this;
	}

	/**
	 * @experimental
	 * Stops tweens chained to this tween. To chain a tween see {@link Tween.chain}.
	 *
	 * @returns returns this tween for daisy chaining methods.
	 */
	 stopChainedTweens() {
		for (let i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
			this._chainedTweens[i].stop();
		}

		return this;
	}

	/**
	 * @experimental
	 * Starts all tweens chained to this tween. To chain a tween see {@link Tween.chain}.
	 *
	 * @param stopThis - If true, this tween will be stopped before it starts the chained tweens.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 startChainedTweens(stopThis = false) {
		if (stopThis) {
			this.stop();
		}

		for (let i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
			this._chainedTweens[i].start();
		}

		return this;
	}

	/**
	 * Sets the {@link Group} for this tween.
	 * @param group - the group for this tween. If undefined or null is given, the group will default to {@link Group.shared}.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 group(group) {
		this._group = group;

		return this;
	}

	/**
	 * Sets the delay for this tween.
	 *
	 * This will only be applied at the start of the tween. For delaying the repeating of a tween, see {@link Tween.repeatDelay}
	 *
	 * **This will only work before calling {@link Tween.start}.**
	 * @param amount - the delay for this tween.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 delay(amount) {
		this._delayTime = amount;

		return this;
	}

	/**
	 * Sets the timescale for this tween.
	 * The deltaTime inside the update will be multiplied by this value allowing to speed up or slow down the flow of time.
	 * @param multiplier - the timescale value for this tween.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 timescale(multiplier) {
		this._timescale = multiplier;

		return this;
	}

	/**
	 * Sets the number of times this tween will loop
	 * @param times - the number of loops. For endless loops use `Infinity`
	 * @returns returns this tween for daisy chaining methods.
	 */
	 repeat(times = Infinity) {
		this._repeat = times;

		return this;
	}

	/**
	 * Sets the repeat delay for this tween.
	 *
	 * This will only be applied at the start of every repeat. For delaying only the start, see {@link Tween.delay}
	 * @param amount - the repeat delay for this tween.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 repeatDelay(amount) {
		this._repeatDelayTime = amount;

		return this;
	}

	/**
	 * Sets if this tween should yoyo (reflect) itself when repeating.
	 * @param yoyo - the yoyo value for this tween.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 yoyo(yoyo = true) {
		this._yoyo = yoyo;

		return this;
	}

	/**
	 * Sets the easing function to interpolate the starting values with the final values.
	 *
	 * You can use the functions inside the {@link Easing} object.
	 * @param easingFunction - a function that takes a number between 0 and 1 and returns another number between 0 and 1
	 * @returns returns this tween for daisy chaining methods.
	 */
	 easing(easingFunction) {
		this._easingFunction = easingFunction;

		return this;
	}

	/**
	 * @experimental
	 * Sets the safety check function to test if the tweening object is still valid.
	 * If the function returns a non-truthy value, the tween will skip the update loop.
	 * @param safetyCheckFunction - a function that takes the target object for this tween and returns true if the object is still valid.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 safetyCheck(safetyCheckFunction) {
		this._safetyCheckFunction = safetyCheckFunction;

		return this;
	}

	/**
	 * @experimental
	 * Sets the easing function to interpolate the starting values with the final values on the way back due to a yoyo tween.
	 *
	 * You can use the functions inside the {@link Easing} object.
	 * @param easingFunction - a function that takes a number between 0 and 1 and returns another number between 0 and 1
	 * @returns returns this tween for daisy chaining methods.
	 */
	 yoyoEasing(easingFunction) {
		this._yoyoEasingFunction = easingFunction;

		return this;
	}

	/**
	 * Sets the easing function to interpolate the starting values with the final values when the final value is an array of objects.
	 * Use this to create bezier curves or interpolate colors.
	 *
	 * You can use the functions inside the {@link Interpolation} object.
	 * @param interpolationFunction
	 * @returns returns this tween for daisy chaining methods.
	 */
	 interpolation(interpolationFunction) {
		this._interpolationFunction = interpolationFunction;

		return this;
	}

	/**
	 * Adds tweens to be called when this tween ends.
	 * The tweens here will be called all at the same time.
	 * @param tweens - tweens to be started when this tween ends
	 * @returns returns this tween for daisy chaining methods.
	 */
	 chain(...tweens) {
		this._chainedTweens = tweens;

		return this;
	}

	/**
	 * Sets the onStart callback. This will be called as soon as you call {@link Tween.start}.
	 * @param callback - the function to call on start. It will recieve the target object and this tween as a parameter.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 onStart(callback) {
		this._onStartCallback = callback;

		return this;
	}

	/**
	 * Sets the onAfterDelay callback. This will be called when the delay is over.
	 * @param callback - the function to call on start. It will recieve the target object and this tween as a parameter.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 onAfterDelay(callback) {
		this._onAfterDelayCallback = callback;

		return this;
	}

	/**
	 * Sets the onStart callback
	 * @param callback - the function to call on start. It will recieve the target object, this tween, and a number between 0 and 1 determining the progress as a parameter.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 onUpdate(callback) {
		this._onUpdateCallback = callback;

		return this;
	}

	/**
	 * Sets the onRepeat callback
	 * @param callback - the function to call on repeat. It will recieve the target object and this tween as a parameter.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 onRepeat(callback) {
		this._onRepeatCallback = callback;

		return this;
	}

	/**
	 * Sets the onComplete callback
	 * @param callback - the function to call on complete. It will recieve the target object and this tween as a parameter.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 onComplete(callback) {
		this._onCompleteCallback = callback;

		return this;
	}

	/**
	 * Sets the onStop callback
	 * @param callback - the function to call on stop. It will recieve the target object and this tween as a parameter.
	 * @returns returns this tween for daisy chaining methods.
	 */
	 onStop(callback) {
		this._onStopCallback = callback;

		return this;
	}

	/**
	 * Updates this tween
	 * @param deltaTime - the amount of time that passed since last update in **miliseconds**
	 * @param preserve - Prevent the removal of stopped, paused, finished or non started tweens from their group.
	 * @returns returns true if the tween hasn't finished yet.
	 */
	 update(deltaTime, preserve = false) {
		const retval = this._internalUpdate(deltaTime);
		if (!retval && !preserve) {
			this._group.remove(this);
		}
		return retval;
	}

	 _internalUpdate(deltaTime) {
		if (!this._safetyCheckFunction(this._object)) {
			return false;
		}

		if (this._isPaused) {
			return false;
		}

		deltaTime *= this._timescale;

		let elapsed;

		this._elapsedTime += deltaTime;

		const endTime = this._duration;
		const currentTime = this._startTime + this._elapsedTime;

		if (currentTime > endTime && !this._isPlaying) {
			return false;
		}

		// If the tween was already finished,
		if (!this.isPlaying) {
			this.start();
		}

		if (this._onStartCallbackFired == false) {
			if (this._onStartCallback) {
				this._onStartCallback(this._object, this);
			}

			this._onStartCallbackFired = true;
		}

		if (this._onAfterDelayCallbackFired == false && currentTime >= 0) {
			if (this._onAfterDelayCallback) {
				this._onAfterDelayCallback(this._object, this);
			}

			this._onAfterDelayCallbackFired = true;
		}

		elapsed = currentTime / this._duration;
		// zero duration makes elapsed a NaN. We need to fix this!
		if (this._duration == 0) {
			// positive currentTime means we have no delay to wait for!
			if (currentTime >= 0) {
				elapsed = 1;
			} else {
				elapsed = 0;
			}
		}
		// otherwise, clamp the result
		elapsed = Math.min(1, elapsed);
		elapsed = Math.max(0, elapsed);

		let leftOverTime = Number.isFinite(currentTime) ? currentTime % this._duration : currentTime; // leftover time
		if (Number.isNaN(leftOverTime)) {
			leftOverTime = 0;
		}
		const loopsMade = Math.floor(currentTime / this._duration); // if we overloop, how many loops did we eat?

		// check which easing to use...
		let value;
		if (this._reversed && this._yoyoEasingFunction) {
			value = this._yoyoEasingFunction(elapsed);
		} else {
			value = this._easingFunction(elapsed);
		}

		// properties transformations
		this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);

		// if there is absolutely no chance to loop, call update. we will be done.
		if (this._onUpdateCallback && (elapsed != 1 || this._repeat - this._repeatCount <= 0)) {
			this._onUpdateCallback(this._object, elapsed, this);
		}

		if (elapsed == 1) {
			if (this._repeat - this._repeatCount > 0) {
				// increase loops
				const oldCount = this._repeatCount;
				this._repeatCount = Math.min(this._repeat + 1, this._repeatCount + loopsMade);

				if (this._onUpdateCallback && (this._repeat - this._repeatCount < 0 || leftOverTime <= 0)) {
					this._onUpdateCallback(this._object, elapsed, this);
				}

				// fix starting values for yoyo or relative
				if (this._yoyo) {
					this._swapEndStartRepeatValues(this._valuesStartRepeat, this._valuesEnd);
				} else {
					this._moveForwardStartRepeatValues(this._valuesStartRepeat, this._valuesEnd);
				}

				// Reassign starting values
				this._valuesStart = JSON.parse(JSON.stringify(this._valuesStartRepeat));

				// restart start time
				if (this._repeatDelayTime !== undefined) {
					this._startTime = -this._repeatDelayTime;
				} else {
					this._startTime = 0;
				}

				if (this._onRepeatCallback) {
					// We fallback to only one call.
					let callbackCount = 1;

					if (Number.isFinite(loopsMade)) {
						// if we have a logical number of loops, we trigger the callback that many times
						callbackCount = this._repeatCount - oldCount;
					} else if (Number.isFinite(this._repeat)) {
						// if the amount of loops is infinite, we trigger the callback the amount of loops remaining
						callbackCount = this._repeat - oldCount;
					}

					for (let i = 0; i < callbackCount; i++) {
						this._onRepeatCallback(this._object, oldCount + 1 + i, this);
					}
				}

				this._elapsedTime = 0; // reset the elapsed time

				// if we have more loops to go, then go
				if (this._repeat - this._repeatCount >= 0) {
					// update with the leftover time
					if (leftOverTime > 0 && Number.isFinite(this._repeat)) {
						// only if it is greater than 0 and do not emit onupdate events...
						this._internalUpdate(leftOverTime);
					}
					return true;
				}
			}

			// If we are here, either we are not a looping boi or we are a finished looping boi
			if (this._onCompleteCallback) {
				this._onCompleteCallback(this._object, this);
			}

			for (let i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
				// Make the chained tweens start exactly at the time they should,
				// even if the update method was called way past the duration of the tween
				this._chainedTweens[i].start();
				if (leftOverTime > 0) {
					this._chainedTweens[i].update(leftOverTime);
				}
			}

			this._isPlaying = false;

			return false;
		}

		return true;
	}

	 _updateProperties(_object, _valuesStart, _valuesEnd, value) {
		for (const property in _valuesEnd) {
			// Don't update properties that do not exist in the source object
			if (_valuesStart[property] == undefined) {
				continue;
			}

			const start = _valuesStart[property];
			let end = _valuesEnd[property];
			const startIsArray = Array.isArray(_object[property]);
			const endIsArray = Array.isArray(end);
			const isInterpolationList = !startIsArray && endIsArray;

			if (isInterpolationList) {
				if (this._reversed) {
					_object[property] = this._interpolationFunction(end.concat([start]) , value);
				} else {
					_object[property] = this._interpolationFunction([start].concat(end) , value);
				}
			} else if (typeof end == "object" && end) {
				this._updateProperties(_object[property], start, end, value);
			} else {
				// Parses relative end values with start as base (e.g.: +10, -3)
				end = this._handleRelativeValue(start , end );

				// Protect against non numeric properties.
				if (typeof end == "number" && (typeof start == "number" || typeof start == "string")) {
					// I am certain that start here won't anser NaN or it would have been filtrated on the setupProperties
					_object[property] = Number(start) + (end - Number(start)) * value;

					// if it was originally a string, we make it back to string. keep it tidy
					if (typeof start == "string") {
						_object[property] = String(_object[property]);
					}
				}
			}
		}
	}

	 _handleRelativeValue(start, end) {
		if (typeof end !== "string") {
			return end;
		}

		if (end.charAt(0) == "+" || end.charAt(0) == "-") {
			return start + Number(end);
		}

		return Number(end);
	}

	 _swapEndStartRepeatValues(_valuesStartRepeat, _valuesEnd) {
		for (const property in _valuesStartRepeat) {
			const isInterpolationList = !Array.isArray(_valuesStartRepeat[property]) && Array.isArray(_valuesEnd[property]);

			if (typeof _valuesStartRepeat[property] == "object") {
				this._swapEndStartRepeatValues(_valuesStartRepeat[property], _valuesEnd[property]);
			} else {
				const tmp = _valuesStartRepeat[property];
				if (typeof _valuesEnd[property] == "string") {
					_valuesStartRepeat[property] = Number(_valuesStartRepeat[property]) + Number(_valuesEnd[property]);
					_valuesEnd[property] = tmp;
				} else if (isInterpolationList) {
					const aux = _valuesEnd[property].slice().reverse();
					_valuesStartRepeat[property] = aux[0];
					_valuesEnd[property] = aux;
				} else {
					_valuesStartRepeat[property] = _valuesEnd[property];
					_valuesEnd[property] = tmp;
				}
			}
		}
	}

	 _moveForwardStartRepeatValues(_valuesStartRepeat, _valuesEnd) {
		for (const property in _valuesStartRepeat) {
			if (typeof _valuesEnd[property] == "object") {
				this._moveForwardStartRepeatValues(_valuesStartRepeat[property], _valuesEnd[property]);
			} else {
				if (typeof _valuesEnd[property] == "string") {
					_valuesStartRepeat[property] = Number(_valuesStartRepeat[property]) + Number(_valuesEnd[property]);
				}
			}
		}
	}
}

/**
 * Constant with the hardcoded version of the app
 */
const VERSION = "2.1.0";


//# sourceMappingURL=tweedle.es.js.map


/***/ }),

/***/ 36723:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collector = void 0;
/**
 * Base class for collectors.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class Collector {
    /**
     * Create a new collector.
     *
     * @param signal The signal to emit.
     */
    constructor(signal) {
        // eslint-disable-next-line dot-notation
        this.emit = (...args) => {
            // eslint-disable-next-line dot-notation
            signal["emitCollecting"](this, args);
        };
    }
}
exports.Collector = Collector;


/***/ }),

/***/ 77474:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorArray = void 0;
const Collector_1 = __webpack_require__(36723);
/**
 * Returns the result of the all signal handlers from a signal emission in an array.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorArray extends Collector_1.Collector {
    constructor() {
        super(...arguments);
        this.result = [];
    }
    handleResult(result) {
        this.result.push(result);
        return true;
    }
    /**
     * Get the list of results from the signal handlers.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        this.result.length = 0;
    }
}
exports.CollectorArray = CollectorArray;


/***/ }),

/***/ 5491:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorLast = void 0;
const Collector_1 = __webpack_require__(36723);
/**
 * Returns the result of the last signal handler from a signal emission.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorLast extends Collector_1.Collector {
    handleResult(result) {
        this.result = result;
        return true;
    }
    /**
     * Get the result of the last signal handler.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        delete this.result;
    }
}
exports.CollectorLast = CollectorLast;


/***/ }),

/***/ 67355:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorUntil0 = void 0;
const Collector_1 = __webpack_require__(36723);
/**
 * Keep signal emissions going while all handlers return true.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorUntil0 extends Collector_1.Collector {
    constructor() {
        super(...arguments);
        this.result = false;
    }
    handleResult(result) {
        this.result = result;
        return this.result;
    }
    /**
     * Get the result of the last signal handler.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        this.result = false;
    }
}
exports.CollectorUntil0 = CollectorUntil0;


/***/ }),

/***/ 47696:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectorWhile0 = void 0;
const Collector_1 = __webpack_require__(36723);
/**
 * Keep signal emissions going while all handlers return false.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class CollectorWhile0 extends Collector_1.Collector {
    constructor() {
        super(...arguments);
        this.result = false;
    }
    handleResult(result) {
        this.result = result;
        return !this.result;
    }
    /**
     * Get the result of the last signal handler.
     */
    getResult() {
        return this.result;
    }
    /**
     * Reset the result
     */
    reset() {
        this.result = false;
    }
}
exports.CollectorWhile0 = CollectorWhile0;


/***/ }),

/***/ 36750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Signal = void 0;
const SignalConnection_1 = __webpack_require__(22738);
const SignalLink_1 = __webpack_require__(53290);
/**
 * A signal is a way to publish and subscribe to events.
 *
 * @typeparam THandler The function signature to be implemented by handlers.
 */
class Signal {
    constructor() {
        this.head = new SignalLink_1.SignalLink();
        this.hasNewLinks = false;
        this.emitDepth = 0;
        this.connectionsCount = 0;
    }
    /**
     * @returns The number of connections on this signal.
     */
    getConnectionsCount() {
        return this.connectionsCount;
    }
    /**
     * @returns true if this signal has connections.
     */
    hasConnections() {
        return this.connectionsCount > 0;
    }
    /**
     * Subscribe to this signal.
     *
     * @param callback This callback will be run when emit() is called.
     * @param order Handlers with a higher order value will be called later.
     */
    connect(callback, order = 0) {
        this.connectionsCount++;
        const link = this.head.insert(callback, order);
        if (this.emitDepth > 0) {
            this.hasNewLinks = true;
            link.newLink = true;
        }
        return new SignalConnection_1.SignalConnectionImpl(link, () => this.decrementConnectionCount());
    }
    decrementConnectionCount() {
        this.connectionsCount--;
    }
    /**
     * Unsubscribe from this signal with the original callback instance.
     * While you can use this method, the SignalConnection returned by connect() will not be updated!
     *
     * @param callback The callback you passed to connect().
     */
    disconnect(callback) {
        for (let link = this.head.next; link !== this.head; link = link.next) {
            if (link.callback === callback) {
                this.decrementConnectionCount();
                link.unlink();
                return true;
            }
        }
        return false;
    }
    /**
     * Disconnect all handlers from this signal event.
     */
    disconnectAll() {
        while (this.head.next !== this.head) {
            this.head.next.unlink();
        }
        this.connectionsCount = 0;
    }
    /**
     * Publish this signal event (call all handlers).
     */
    emit(...args) {
        this.emitDepth++;
        for (let link = this.head.next; link !== this.head; link = link.next) {
            if (link.isEnabled() && link.callback)
                link.callback.apply(null, args);
        }
        this.emitDepth--;
        this.unsetNewLink();
    }
    emitCollecting(collector, args) {
        this.emitDepth++;
        for (let link = this.head.next; link !== this.head; link = link.next) {
            if (link.isEnabled() && link.callback) {
                const result = link.callback.apply(null, args);
                if (!collector.handleResult(result))
                    break;
            }
        }
        this.emitDepth--;
        this.unsetNewLink();
    }
    unsetNewLink() {
        if (this.hasNewLinks && this.emitDepth === 0) {
            for (let link = this.head.next; link !== this.head; link = link.next)
                link.newLink = false;
            this.hasNewLinks = false;
        }
    }
}
exports.Signal = Signal;


/***/ }),

/***/ 22738:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalConnectionImpl = void 0;
/**
 * Implementation of SignalConnection, for internal use only.
 * @private
 */
class SignalConnectionImpl {
    /**
     * @param link The actual link of the connection.
     * @param parentCleanup Callback to cleanup the parent signal when a connection is disconnected
     */
    constructor(link, parentCleanup) {
        this.link = link;
        this.parentCleanup = parentCleanup;
    }
    disconnect() {
        if (this.link !== null) {
            this.link.unlink();
            this.link = null;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.parentCleanup();
            this.parentCleanup = null;
            return true;
        }
        return false;
    }
    set enabled(enable) {
        if (this.link)
            this.link.setEnabled(enable);
    }
    get enabled() {
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        return this.link !== null && this.link.isEnabled();
    }
}
exports.SignalConnectionImpl = SignalConnectionImpl;


/***/ }),

/***/ 35473:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalConnections = void 0;
/**
 * Represents a list of connections to a signal for easy disconnect.
 */
class SignalConnections {
    constructor() {
        this.list = [];
    }
    /**
     * Add a connection to the list.
     * @param connection
     */
    add(connection) {
        this.list.push(connection);
    }
    /**
     * Disconnect all connections in the list and empty the list.
     */
    disconnectAll() {
        for (const connection of this.list) {
            connection.disconnect();
        }
        this.list = [];
    }
    /**
     * @returns The number of connections in this list.
     */
    getCount() {
        return this.list.length;
    }
    /**
     * @returns true if this list is empty.
     */
    isEmpty() {
        return this.list.length === 0;
    }
}
exports.SignalConnections = SignalConnections;


/***/ }),

/***/ 53290:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalLink = void 0;
/**
 * SignalLink implements a doubly-linked ring with nodes containing the signal handlers.
 * @private
 */
class SignalLink {
    constructor(prev = null, next = null, order = 0) {
        this.enabled = true;
        this.newLink = false;
        this.callback = null;
        this.prev = prev !== null && prev !== void 0 ? prev : this;
        this.next = next !== null && next !== void 0 ? next : this;
        this.order = order;
    }
    isEnabled() {
        return this.enabled && !this.newLink;
    }
    setEnabled(flag) {
        this.enabled = flag;
    }
    unlink() {
        this.callback = null;
        this.next.prev = this.prev;
        this.prev.next = this.next;
    }
    insert(callback, order) {
        let after = this.prev;
        while (after !== this) {
            if (after.order <= order)
                break;
            after = after.prev;
        }
        const link = new SignalLink(after, after.next, order);
        link.callback = callback;
        after.next = link;
        link.next.prev = link;
        return link;
    }
}
exports.SignalLink = SignalLink;


/***/ }),

/***/ 31852:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalConnections = exports.Signal = exports.CollectorWhile0 = exports.CollectorUntil0 = exports.CollectorLast = exports.CollectorArray = exports.Collector = void 0;
var Collector_1 = __webpack_require__(36723);
Object.defineProperty(exports, "Collector", ({ enumerable: true, get: function () { return Collector_1.Collector; } }));
var CollectorArray_1 = __webpack_require__(77474);
Object.defineProperty(exports, "CollectorArray", ({ enumerable: true, get: function () { return CollectorArray_1.CollectorArray; } }));
var CollectorLast_1 = __webpack_require__(5491);
Object.defineProperty(exports, "CollectorLast", ({ enumerable: true, get: function () { return CollectorLast_1.CollectorLast; } }));
var CollectorUntil0_1 = __webpack_require__(67355);
Object.defineProperty(exports, "CollectorUntil0", ({ enumerable: true, get: function () { return CollectorUntil0_1.CollectorUntil0; } }));
var CollectorWhile0_1 = __webpack_require__(47696);
Object.defineProperty(exports, "CollectorWhile0", ({ enumerable: true, get: function () { return CollectorWhile0_1.CollectorWhile0; } }));
var Signal_1 = __webpack_require__(36750);
Object.defineProperty(exports, "Signal", ({ enumerable: true, get: function () { return Signal_1.Signal; } }));
var SignalConnections_1 = __webpack_require__(35473);
Object.defineProperty(exports, "SignalConnections", ({ enumerable: true, get: function () { return SignalConnections_1.SignalConnections; } }));


/***/ }),

/***/ 61270:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ 95902:
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ 63098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(91207);
var parse = __webpack_require__(60969);
var formats = __webpack_require__(95902);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ 60969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(62795);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');

    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
    );

    if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }

    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key;
        var val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');

            val = utils.maybeMap(
                parseArrayValue(
                    part.slice(pos + 1),
                    options,
                    isArray(obj[key]) ? obj[key].length : 0
                ),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(String(val));
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
        var parentKey = chain.slice(0, -1).join('');
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }

    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : utils.combine([], leaf);
        } else {
            obj = options.plainObjects ? { __proto__: null } : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }

    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? { __proto__: null } : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ 91207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(920);
var utils = __webpack_require__(62795);
var formats = __webpack_require__(95902);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: void undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'
            ? key.value
            : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];

        if (options.skipNulls && value === null) {
            continue;
        }
        pushToArray(keys, stringify(
            value,
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ 62795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(95902);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object' && typeof source !== 'function') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (
                (options && (options.plainObjects || options.allowPrototypes))
                || !has.call(Object.prototype, source)
            ) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ 88835:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(61270);

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(63098);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;


/***/ }),

/***/ 22831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function get() {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function get() {
    return _parse.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function get() {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function get() {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function get() {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function get() {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function get() {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function get() {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function get() {
    return _version.default;
  }
}));

var _v = _interopRequireDefault(__webpack_require__(13518));

var _v2 = _interopRequireDefault(__webpack_require__(14948));

var _v3 = _interopRequireDefault(__webpack_require__(45073));

var _v4 = _interopRequireDefault(__webpack_require__(77186));

var _nil = _interopRequireDefault(__webpack_require__(14808));

var _version = _interopRequireDefault(__webpack_require__(7775));

var _validate = _interopRequireDefault(__webpack_require__(37037));

var _stringify = _interopRequireDefault(__webpack_require__(49910));

var _parse = _interopRequireDefault(__webpack_require__(96792));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 22311:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 46140:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default = {
  randomUUID
};
exports["default"] = _default;

/***/ }),

/***/ 14808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 96792:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__webpack_require__(37037));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 27656:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 2858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ 9042:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 49910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.unsafeStringify = unsafeStringify;

var _validate = _interopRequireDefault(__webpack_require__(37037));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 13518:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__webpack_require__(2858));

var _stringify = __webpack_require__(49910);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.unsafeStringify)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 14948:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__webpack_require__(59025));

var _md = _interopRequireDefault(__webpack_require__(22311));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 59025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
exports["default"] = v35;

var _stringify = __webpack_require__(49910);

var _parse = _interopRequireDefault(__webpack_require__(96792));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;

    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.unsafeStringify)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 45073:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _native = _interopRequireDefault(__webpack_require__(46140));

var _rng = _interopRequireDefault(__webpack_require__(2858));

var _stringify = __webpack_require__(49910);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  if (_native.default.randomUUID && !buf && !options) {
    return _native.default.randomUUID();
  }

  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.unsafeStringify)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 77186:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__webpack_require__(59025));

var _sha = _interopRequireDefault(__webpack_require__(9042));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 37037:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__webpack_require__(27656));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 7775:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__webpack_require__(37037));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.slice(14, 15), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 50381:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_575__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_575__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_575__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_575__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_575__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_575__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_575__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_575__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_575__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_575__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_575__(__nested_webpack_require_575__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AuxFunctions = (function () {
    function AuxFunctions() {
    }
    AuxFunctions.numberToR = function (p_num) {
        return (p_num & 0xff0000) >> 16;
    };
    AuxFunctions.numberToG = function (p_num) {
        return (p_num & 0xff00) >> 8;
    };
    AuxFunctions.numberToB = function (p_num) {
        return (p_num & 0xff);
    };
    AuxFunctions.getObjectLength = function (p_object) {
        var totalProperties = 0;
        for (var pName in p_object)
            totalProperties++;
        return totalProperties;
    };
    AuxFunctions.concatObjects = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var finalObject = {};
        var currentObject;
        for (var i = 0; i < args.length; i++) {
            currentObject = args[i];
            for (var prop in currentObject) {
                if (currentObject[prop] == null) {
                    delete finalObject[prop];
                }
                else {
                    finalObject[prop] = currentObject[prop];
                }
            }
        }
        return finalObject;
    };
    return AuxFunctions;
}());
exports.AuxFunctions = AuxFunctions;


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_4366__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TweenListObj_1 = __nested_webpack_require_4366__(2);
var PropertyInfoObject_1 = __nested_webpack_require_4366__(3);
var AuxFunctions_1 = __nested_webpack_require_4366__(0);
var SpecialPropertySplitter_1 = __nested_webpack_require_4366__(4);
var Equations_1 = __nested_webpack_require_4366__(5);
var SpecialProperty_1 = __nested_webpack_require_4366__(6);
var SpecialPropertyModifier_1 = __nested_webpack_require_4366__(7);
var Tweener = (function () {
    function Tweener() {
        throw new Error("Tweener is a static class and should not be instantiated.");
    }
    Tweener.addTween = function (p_scopes, p_parameters) {
        if (p_scopes === void 0) { p_scopes = null; }
        if (p_parameters === void 0) { p_parameters = null; }
        if (p_scopes === null)
            return false;
        var i, j, istr;
        var rScopes;
        if (p_scopes instanceof Array) {
            rScopes = p_scopes.concat();
        }
        else {
            rScopes = [p_scopes];
        }
        var p_obj = TweenListObj_1.TweenListObj.makePropertiesChain(p_parameters);
        if (!Tweener._inited)
            Tweener.init();
        if (!Tweener._engineExists)
            Tweener.startEngine();
        var rTime = (isNaN(p_obj.time) ? 0 : p_obj.time);
        var rDelay = (isNaN(p_obj.delay) ? 0 : p_obj.delay);
        var rProperties = [];
        var restrictedWords = {
            overwrite: true,
            time: true,
            delay: true,
            useFrames: true,
            skipUpdates: true,
            transition: true,
            transitionParams: true,
            onStart: true,
            onUpdate: true,
            onComplete: true,
            onOverwrite: true,
            onError: true,
            rounded: true,
            onStartParams: true,
            onUpdateParams: true,
            onCompleteParams: true,
            onOverwriteParams: true,
            onStartScope: true,
            onUpdateScope: true,
            onCompleteScope: true,
            onOverwriteScope: true,
            onErrorScope: true
        };
        var modifiedProperties = {};
        for (istr in p_obj) {
            if (!restrictedWords[istr]) {
                if (Tweener._specialPropertySplitterList[istr]) {
                    var splitProperties = Tweener._specialPropertySplitterList[istr].splitValues(p_obj[istr], Tweener._specialPropertySplitterList[istr].parameters);
                    for (i = 0; i < splitProperties.length; i++) {
                        if (Tweener._specialPropertySplitterList[splitProperties[i].name]) {
                            var splitProperties2 = Tweener._specialPropertySplitterList[splitProperties[i].name].splitValues(splitProperties[i].value, Tweener._specialPropertySplitterList[splitProperties[i].name].parameters);
                            for (j = 0; j < splitProperties2.length; j++) {
                                rProperties[splitProperties2[j].name] = {
                                    valueStart: undefined,
                                    valueComplete: splitProperties2[j].value,
                                    arrayIndex: splitProperties2[j].arrayIndex,
                                    isSpecialProperty: false
                                };
                            }
                        }
                        else {
                            rProperties[splitProperties[i].name] = {
                                valueStart: undefined,
                                valueComplete: splitProperties[i].value,
                                arrayIndex: splitProperties[i].arrayIndex,
                                isSpecialProperty: false
                            };
                        }
                    }
                }
                else if (Tweener._specialPropertyModifierList[istr] != undefined) {
                    var tempModifiedProperties = Tweener._specialPropertyModifierList[istr].modifyValues(p_obj[istr]);
                    for (i = 0; i < tempModifiedProperties.length; i++) {
                        modifiedProperties[tempModifiedProperties[i].name] = {
                            modifierParameters: tempModifiedProperties[i].parameters,
                            modifierFunction: Tweener._specialPropertyModifierList[istr].getValue
                        };
                    }
                }
                else {
                    rProperties[istr] = { valueStart: undefined, valueComplete: p_obj[istr] };
                }
            }
        }
        for (istr in rProperties) {
            if (Tweener._specialPropertyList[istr] != undefined) {
                rProperties[istr].isSpecialProperty = true;
            }
            else {
                if (rScopes[0][istr] == undefined) {
                    Tweener.printError("The property '" + istr + "' doesn't seem to be a normal object property of " + rScopes[0] + " or a registered special property.");
                }
            }
        }
        for (istr in modifiedProperties) {
            if (rProperties[istr] != undefined) {
                rProperties[istr].modifierParameters = modifiedProperties[istr].modifierParameters;
                rProperties[istr].modifierFunction = modifiedProperties[istr].modifierFunction;
            }
        }
        var rTransition;
        if (typeof p_obj.transition == "string") {
            var trans = p_obj.transition.toLowerCase();
            rTransition = Tweener._transitionList[trans];
        }
        else {
            rTransition = p_obj.transition;
        }
        if (!(rTransition))
            rTransition = Tweener._transitionList["easeoutexpo"];
        var nProperties;
        var nTween;
        var myT;
        for (i = 0; i < rScopes.length; i++) {
            nProperties = new Object();
            for (istr in rProperties) {
                nProperties[istr] = new PropertyInfoObject_1.PropertyInfoObj(rProperties[istr].valueStart, rProperties[istr].valueComplete, rProperties[istr].valueComplete, rProperties[istr].arrayIndex, {}, rProperties[istr].isSpecialProperty, rProperties[istr].modifierFunction, rProperties[istr].modifierParameters);
            }
            if (p_obj.useFrames == true) {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTimeFrame + (rDelay / Tweener._timeScale), Tweener._currentTimeFrame + ((rDelay + rTime) / Tweener._timeScale), true, rTransition, p_obj.transitionParams);
            }
            else {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTime + ((rDelay * 1000) / Tweener._timeScale), Tweener._currentTime + (((rDelay * 1000) + (rTime * 1000)) / Tweener._timeScale), false, rTransition, p_obj.transitionParams);
            }
            nTween.properties = nProperties;
            nTween.onStart = p_obj.onStart;
            nTween.onUpdate = p_obj.onUpdate;
            nTween.onComplete = p_obj.onComplete;
            nTween.onOverwrite = p_obj.onOverwrite;
            nTween.onError = p_obj.onError;
            nTween.onStartParams = p_obj.onStartParams;
            nTween.onUpdateParams = p_obj.onUpdateParams;
            nTween.onCompleteParams = p_obj.onCompleteParams;
            nTween.onOverwriteParams = p_obj.onOverwriteParams;
            nTween.onStartScope = p_obj.onStartScope;
            nTween.onUpdateScope = p_obj.onUpdateScope;
            nTween.onCompleteScope = p_obj.onCompleteScope;
            nTween.onOverwriteScope = p_obj.onOverwriteScope;
            nTween.onErrorScope = p_obj.onErrorScope;
            nTween.rounded = p_obj.rounded;
            nTween.skipUpdates = p_obj.skipUpdates;
            if (p_obj.overwrite == undefined ? Tweener.autoOverwrite : p_obj.overwrite)
                Tweener.removeTweensByTime(nTween.scope, nTween.properties, nTween.timeStart, nTween.timeComplete);
            Tweener._tweenList.push(nTween);
            if (rTime == 0 && rDelay == 0) {
                myT = Tweener._tweenList.length - 1;
                Tweener.updateTweenByIndex(myT);
                Tweener.removeTweenByIndex(myT);
            }
        }
        return true;
    };
    Tweener.addCaller = function (p_scopes, p_parameters) {
        if (p_scopes === void 0) { p_scopes = null; }
        if (p_parameters === void 0) { p_parameters = null; }
        if (!(p_scopes))
            return false;
        var i;
        var rScopes;
        if (p_scopes instanceof Array) {
            rScopes = p_scopes.concat();
        }
        else {
            rScopes = [p_scopes];
        }
        var p_obj = p_parameters;
        if (!Tweener._inited)
            Tweener.init();
        if (!Tweener._engineExists)
            Tweener.startEngine();
        var rTime = (isNaN(p_obj.time) ? 0 : p_obj.time);
        var rDelay = (isNaN(p_obj.delay) ? 0 : p_obj.delay);
        var rTransition;
        if (typeof p_obj.transition == "string") {
            var trans = p_obj.transition.toLowerCase();
            rTransition = Tweener._transitionList[trans];
        }
        else {
            rTransition = p_obj.transition;
        }
        if (!(rTransition))
            rTransition = Tweener._transitionList["easeoutexpo"];
        var nTween;
        var myT;
        for (i = 0; i < rScopes.length; i++) {
            if (p_obj.useFrames == true) {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTimeFrame + (rDelay / Tweener._timeScale), Tweener._currentTimeFrame + ((rDelay + rTime) / Tweener._timeScale), true, rTransition, p_obj.transitionParams);
            }
            else {
                nTween = new TweenListObj_1.TweenListObj(rScopes[i], Tweener._currentTime + ((rDelay * 1000) / Tweener._timeScale), Tweener._currentTime + (((rDelay * 1000) + (rTime * 1000)) / Tweener._timeScale), false, rTransition, p_obj.transitionParams);
            }
            nTween.properties = null;
            nTween.onStart = p_obj.onStart;
            nTween.onUpdate = p_obj.onUpdate;
            nTween.onComplete = p_obj.onComplete;
            nTween.onOverwrite = p_obj.onOverwrite;
            nTween.onStartParams = p_obj.onStartParams;
            nTween.onUpdateParams = p_obj.onUpdateParams;
            nTween.onCompleteParams = p_obj.onCompleteParams;
            nTween.onOverwriteParams = p_obj.onOverwriteParams;
            nTween.onStartScope = p_obj.onStartScope;
            nTween.onUpdateScope = p_obj.onUpdateScope;
            nTween.onCompleteScope = p_obj.onCompleteScope;
            nTween.onOverwriteScope = p_obj.onOverwriteScope;
            nTween.onErrorScope = p_obj.onErrorScope;
            nTween.isCaller = true;
            nTween.count = p_obj.count;
            nTween.waitFrames = p_obj.waitFrames;
            Tweener._tweenList.push(nTween);
            if (rTime == 0 && rDelay == 0) {
                myT = Tweener._tweenList.length - 1;
                Tweener.updateTweenByIndex(myT);
                Tweener.removeTweenByIndex(myT);
            }
        }
        return true;
    };
    Tweener.removeTweensByTime = function (p_scope, p_properties, p_timeStart, p_timeComplete) {
        var removed = false;
        var removedLocally;
        var i;
        var tl = Tweener._tweenList.length;
        var pName;
        for (i = 0; i < tl; i++) {
            if (Tweener._tweenList[i] && p_scope == Tweener._tweenList[i].scope) {
                if (p_timeComplete > Tweener._tweenList[i].timeStart && p_timeStart < Tweener._tweenList[i].timeComplete) {
                    removedLocally = false;
                    for (pName in Tweener._tweenList[i].properties) {
                        if (p_properties[pName]) {
                            if (Tweener._tweenList[i].onOverwrite) {
                                var eventScope = Tweener._tweenList[i].onOverwriteScope ? Tweener._tweenList[i].onOverwriteScope : Tweener._tweenList[i].scope;
                                try {
                                    Tweener._tweenList[i].onOverwrite.apply(eventScope, Tweener._tweenList[i].onOverwriteParams);
                                }
                                catch (e) {
                                    Tweener.handleError(Tweener._tweenList[i], e, "onOverwrite");
                                }
                            }
                            Tweener._tweenList[i].properties[pName] = undefined;
                            delete Tweener._tweenList[i].properties[pName];
                            removedLocally = true;
                            removed = true;
                        }
                    }
                    if (removedLocally) {
                        if (AuxFunctions_1.AuxFunctions.getObjectLength(Tweener._tweenList[i].properties) == 0)
                            Tweener.removeTweenByIndex(i);
                    }
                }
            }
        }
        return removed;
    };
    Tweener.removeTweens = function (p_scope) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var properties = [];
        var i;
        for (i = 0; i < args.length; i++) {
            if (typeof (args[i]) == "string" && properties.indexOf(args[i]) == -1) {
                if (Tweener._specialPropertySplitterList[args[i]]) {
                    var sps = Tweener._specialPropertySplitterList[args[i]];
                    var specialProps = sps.splitValues(p_scope, null);
                    for (var j = 0; j < specialProps.length; j++) {
                        properties.push(specialProps[j].name);
                    }
                }
                else {
                    properties.push(args[i]);
                }
            }
        }
        return Tweener.affectTweens(Tweener.removeTweenByIndex, p_scope, properties);
    };
    Tweener.removeAllTweens = function () {
        if (!(Tweener._tweenList))
            return false;
        var removed = false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            Tweener.removeTweenByIndex(i);
            removed = true;
        }
        return removed;
    };
    Tweener.pauseTweens = function (p_scope) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var properties = new Array();
        var i;
        for (i = 0; i < args.length; i++) {
            if (typeof (args[i]) == "string" && properties.indexOf(args[i]) == -1)
                properties.push(args[i]);
        }
        return Tweener.affectTweens(Tweener.pauseTweenByIndex, p_scope, properties);
    };
    Tweener.pauseAllTweens = function () {
        if (!(Tweener._tweenList))
            return false;
        var paused = false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            Tweener.pauseTweenByIndex(i);
            paused = true;
        }
        return paused;
    };
    Tweener.resumeTweens = function (p_scope) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var properties = new Array();
        var i;
        for (i = 0; i < args.length; i++) {
            if (typeof (args[i]) == "string" && properties.indexOf(args[i]) == -1)
                properties.push(args[i]);
        }
        return Tweener.affectTweens(Tweener.resumeTweenByIndex, p_scope, properties);
    };
    Tweener.resumeAllTweens = function () {
        if (!(Tweener._tweenList))
            return false;
        var resumed = false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            Tweener.resumeTweenByIndex(i);
            resumed = true;
        }
        return resumed;
    };
    Tweener.affectTweens = function (p_affectFunction, p_scope, p_properties) {
        var affected = false;
        var i;
        if (!(Tweener._tweenList))
            return false;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                if (p_properties.length == 0) {
                    p_affectFunction(i);
                    affected = true;
                }
                else {
                    var affectedProperties = new Array();
                    var j = void 0;
                    for (j = 0; j < p_properties.length; j++) {
                        if (Tweener._tweenList[i].properties[p_properties[j]]) {
                            affectedProperties.push(p_properties[j]);
                        }
                    }
                    if (affectedProperties.length > 0) {
                        var objectProperties = AuxFunctions_1.AuxFunctions.getObjectLength(Tweener._tweenList[i].properties);
                        if (objectProperties == affectedProperties.length) {
                            p_affectFunction(i);
                            affected = true;
                        }
                        else {
                            var slicedTweenIndex = Tweener.splitTweens(i, affectedProperties);
                            p_affectFunction(slicedTweenIndex);
                            affected = true;
                        }
                    }
                }
            }
        }
        return affected;
    };
    Tweener.splitTweens = function (p_tween, p_properties) {
        var originalTween = Tweener._tweenList[p_tween];
        var newTween = originalTween.clone(false);
        var i;
        var pName;
        for (i = 0; i < p_properties.length; i++) {
            pName = p_properties[i];
            if (originalTween.properties[pName]) {
                originalTween.properties[pName] = undefined;
                delete originalTween.properties[pName];
            }
        }
        var found;
        for (pName in newTween.properties) {
            found = false;
            for (i = 0; i < p_properties.length; i++) {
                if (p_properties[i] == pName) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                newTween.properties[pName] = undefined;
                delete newTween.properties[pName];
            }
        }
        Tweener._tweenList.push(newTween);
        return (Tweener._tweenList.length - 1);
    };
    Tweener.updateTweens = function () {
        if (Tweener._tweenList.length == 0)
            return false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] == undefined || !Tweener._tweenList[i].isPaused) {
                if (!Tweener.updateTweenByIndex(i))
                    Tweener.removeTweenByIndex(i);
                if (Tweener._tweenList[i] == null) {
                    Tweener.removeTweenByIndex(i, true);
                    i--;
                }
            }
        }
        return true;
    };
    Tweener.removeTweenByIndex = function (i, p_finalRemoval) {
        if (p_finalRemoval === void 0) { p_finalRemoval = false; }
        Tweener._tweenList[i] = null;
        if (p_finalRemoval)
            Tweener._tweenList.splice(i, 1);
        return true;
    };
    Tweener.pauseTweenByIndex = function (p_tween) {
        var tTweening = Tweener._tweenList[p_tween];
        if (tTweening == null || tTweening.isPaused)
            return false;
        tTweening.timePaused = Tweener.getCurrentTweeningTime(tTweening);
        tTweening.isPaused = true;
        return true;
    };
    Tweener.resumeTweenByIndex = function (p_tween) {
        var tTweening = Tweener._tweenList[p_tween];
        if (tTweening == null || !tTweening.isPaused)
            return false;
        var cTime = Tweener.getCurrentTweeningTime(tTweening);
        tTweening.timeStart += cTime - tTweening.timePaused;
        tTweening.timeComplete += cTime - tTweening.timePaused;
        tTweening.timePaused = undefined;
        tTweening.isPaused = false;
        return true;
    };
    Tweener.updateTweenByIndex = function (i) {
        var tTweening = Tweener._tweenList[i];
        if (tTweening == null || !(tTweening.scope))
            return false;
        var isOver = false;
        var mustUpdate;
        var nv;
        var t;
        var b;
        var c;
        var d;
        var pName;
        var eventScope;
        var tScope;
        var cTime = Tweener.getCurrentTweeningTime(tTweening);
        var tProperty;
        if (cTime >= tTweening.timeStart) {
            tScope = tTweening.scope;
            if (tTweening.isCaller) {
                do {
                    t = ((tTweening.timeComplete - tTweening.timeStart) / tTweening.count) * (tTweening.timesCalled + 1);
                    b = tTweening.timeStart;
                    c = tTweening.timeComplete - tTweening.timeStart;
                    d = tTweening.timeComplete - tTweening.timeStart;
                    nv = tTweening.transition(t, b, c, d);
                    if (cTime >= nv) {
                        if (tTweening.onUpdate) {
                            eventScope = tTweening.onUpdateScope ? tTweening.onUpdateScope : tScope;
                            try {
                                tTweening.onUpdate.apply(eventScope, tTweening.onUpdateParams);
                            }
                            catch (e1) {
                                Tweener.handleError(tTweening, e1, "onUpdate");
                            }
                        }
                        tTweening.timesCalled++;
                        if (tTweening.timesCalled >= tTweening.count) {
                            isOver = true;
                            break;
                        }
                        if (tTweening.waitFrames)
                            break;
                    }
                } while (cTime >= nv);
            }
            else {
                mustUpdate = tTweening.skipUpdates < 1 || !tTweening.skipUpdates || tTweening.updatesSkipped >= tTweening.skipUpdates;
                if (cTime >= tTweening.timeComplete) {
                    isOver = true;
                    mustUpdate = true;
                }
                if (!tTweening.hasStarted) {
                    if (tTweening.onStart) {
                        eventScope = tTweening.onStartScope ? tTweening.onStartScope : tScope;
                        try {
                            tTweening.onStart.apply(eventScope, tTweening.onStartParams);
                        }
                        catch (e2) {
                            Tweener.handleError(tTweening, e2, "onStart");
                        }
                    }
                    var pv = void 0;
                    for (pName in tTweening.properties) {
                        if (tTweening.properties[pName].isSpecialProperty) {
                            if (Tweener._specialPropertyList[pName].preProcess) {
                                tTweening.properties[pName].valueComplete = Tweener._specialPropertyList[pName].preProcess(tScope, Tweener._specialPropertyList[pName].parameters, tTweening.properties[pName].originalValueComplete, tTweening.properties[pName].extra);
                            }
                            pv = Tweener._specialPropertyList[pName].getValue(tScope, Tweener._specialPropertyList[pName].parameters, tTweening.properties[pName].extra);
                        }
                        else {
                            pv = tScope[pName];
                        }
                        tTweening.properties[pName].valueStart = isNaN(pv) ? tTweening.properties[pName].valueComplete : pv;
                    }
                    mustUpdate = true;
                    tTweening.hasStarted = true;
                }
                if (mustUpdate) {
                    for (pName in tTweening.properties) {
                        tProperty = tTweening.properties[pName];
                        if (isOver) {
                            nv = tProperty.valueComplete;
                        }
                        else {
                            if (tProperty.hasModifier) {
                                t = cTime - tTweening.timeStart;
                                d = tTweening.timeComplete - tTweening.timeStart;
                                nv = tTweening.transition(t, 0, 1, d, tTweening.transitionParams);
                                nv = tProperty.modifierFunction(tProperty.valueStart, tProperty.valueComplete, nv, tProperty.modifierParameters);
                            }
                            else {
                                t = cTime - tTweening.timeStart;
                                b = tProperty.valueStart;
                                c = tProperty.valueComplete - tProperty.valueStart;
                                d = tTweening.timeComplete - tTweening.timeStart;
                                nv = tTweening.transition(t, b, c, d, tTweening.transitionParams);
                            }
                        }
                        if (tTweening.rounded)
                            nv = Math.round(nv);
                        if (tProperty.isSpecialProperty) {
                            Tweener._specialPropertyList[pName].setValue(tScope, nv, Tweener._specialPropertyList[pName].parameters, tTweening.properties[pName].extra);
                        }
                        else {
                            tScope[pName] = nv;
                        }
                    }
                    tTweening.updatesSkipped = 0;
                    if (tTweening.onUpdate) {
                        eventScope = tTweening.onUpdateScope ? tTweening.onUpdateScope : tScope;
                        try {
                            tTweening.onUpdate.apply(eventScope, tTweening.onUpdateParams);
                        }
                        catch (e3) {
                            Tweener.handleError(tTweening, e3, "onUpdate");
                        }
                    }
                }
                else {
                    tTweening.updatesSkipped++;
                }
            }
            if (isOver && tTweening.onComplete) {
                eventScope = tTweening.onCompleteScope ? tTweening.onCompleteScope : tScope;
                try {
                    tTweening.onComplete.apply(eventScope, tTweening.onCompleteParams);
                }
                catch (e4) {
                    Tweener.handleError(tTweening, e4, "onComplete");
                }
            }
            return (!isOver);
        }
        return (true);
    };
    Tweener.init = function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        Tweener._inited = true;
        Tweener._transitionList = new Object();
        Equations_1.Equations.init();
        Tweener._specialPropertyList = new Object();
        Tweener._specialPropertyModifierList = new Object();
        Tweener._specialPropertySplitterList = new Object();
    };
    Tweener.registerTransition = function (p_name, p_function) {
        if (!Tweener._inited)
            Tweener.init();
        Tweener._transitionList[p_name] = p_function;
    };
    Tweener.registerSpecialProperty = function (p_name, p_getFunction, p_setFunction, p_parameters, p_preProcessFunction) {
        if (p_parameters === void 0) { p_parameters = null; }
        if (p_preProcessFunction === void 0) { p_preProcessFunction = null; }
        if (!Tweener._inited)
            Tweener.init();
        var sp = new SpecialProperty_1.SpecialProperty(p_getFunction, p_setFunction, p_parameters, p_preProcessFunction);
        Tweener._specialPropertyList[p_name] = sp;
    };
    Tweener.registerSpecialPropertyModifier = function (p_name, p_modifyFunction, p_getFunction) {
        if (!Tweener._inited)
            Tweener.init();
        var spm = new SpecialPropertyModifier_1.SpecialPropertyModifier(p_modifyFunction, p_getFunction);
        Tweener._specialPropertyModifierList[p_name] = spm;
    };
    Tweener.registerSpecialPropertySplitter = function (p_name, p_splitFunction, p_parameters) {
        if (p_parameters === void 0) { p_parameters = null; }
        if (!Tweener._inited)
            Tweener.init();
        var sps = new SpecialPropertySplitter_1.SpecialPropertySplitter(p_splitFunction, p_parameters);
        Tweener._specialPropertySplitterList[p_name] = sps;
    };
    Tweener.startEngine = function () {
        Tweener._engineExists = true;
        Tweener._tweenList = [];
        if (window.requestAnimationFrame == null)
            window.requestAnimationFrame = (function () {
                return window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window["mozRequestAnimationFrame"] ||
                    window["oRequestAnimationFrame"] ||
                    window["msRequestAnimationFrame"] ||
                    function (callback, element) {
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();
        window.requestAnimationFrame(Tweener.onEnterFrame);
        Tweener._currentTimeFrame = 0;
        Tweener.updateTime();
    };
    Tweener.stopEngine = function () {
        Tweener._engineExists = false;
        Tweener._tweenList = null;
        Tweener._currentTime = 0;
        Tweener._currentTimeFrame = 0;
    };
    Tweener.updateTime = function () {
        Tweener._currentTime = new Date().getTime();
    };
    Tweener.updateFrame = function () {
        Tweener._currentTimeFrame++;
    };
    Tweener.onEnterFrame = function () {
        Tweener.updateTime();
        Tweener.updateFrame();
        var hasUpdated = false;
        hasUpdated = Tweener.updateTweens();
        if (!hasUpdated) {
            Tweener.stopEngine();
        }
        else {
            requestAnimationFrame(Tweener.onEnterFrame);
        }
    };
    Tweener.setTimeScale = function (p_time) {
        var i;
        var cTime;
        if (isNaN(p_time))
            p_time = 1;
        if (p_time < 0.00001)
            p_time = 0.00001;
        if (p_time != Tweener._timeScale) {
            if (Tweener._tweenList != null) {
                for (i = 0; i < Tweener._tweenList.length; i++) {
                    cTime = Tweener.getCurrentTweeningTime(Tweener._tweenList[i]);
                    Tweener._tweenList[i].timeStart = cTime - ((cTime - Tweener._tweenList[i].timeStart) * Tweener._timeScale / p_time);
                    Tweener._tweenList[i].timeComplete = cTime - ((cTime - Tweener._tweenList[i].timeComplete) * Tweener._timeScale / p_time);
                    if (Tweener._tweenList[i].timePaused != undefined)
                        Tweener._tweenList[i].timePaused = cTime - ((cTime - Tweener._tweenList[i].timePaused) * Tweener._timeScale / p_time);
                }
            }
            Tweener._timeScale = p_time;
        }
    };
    Tweener.isTweening = function (p_scope) {
        if (!(Tweener._tweenList))
            return false;
        var i;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                return true;
            }
        }
        return false;
    };
    Tweener.getTweens = function (p_scope) {
        if (!(Tweener._tweenList))
            return [];
        var i;
        var pName;
        var tList = new Array();
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                for (pName in Tweener._tweenList[i].properties)
                    tList.push(pName);
            }
        }
        return tList;
    };
    Tweener.getTweenCount = function (p_scope) {
        if (!(Tweener._tweenList))
            return 0;
        var i;
        var c = 0;
        for (i = 0; i < Tweener._tweenList.length; i++) {
            if (Tweener._tweenList[i] && Tweener._tweenList[i].scope == p_scope) {
                c += AuxFunctions_1.AuxFunctions.getObjectLength(Tweener._tweenList[i].properties);
            }
        }
        return c;
    };
    Tweener.handleError = function (pTweening, pError, pCallBackName) {
        if (pTweening.onError && (pTweening.onError instanceof Function)) {
            var eventScope = pTweening.onErrorScope ? pTweening.onErrorScope : pTweening.scope;
            try {
                pTweening.onError.apply(eventScope, [pTweening.scope, pError]);
            }
            catch (metaError) {
                Tweener.printError(pTweening.scope + " raised an error while executing the 'onError' handler. Original error:\n " + pError.stack + "\nonError error: " + metaError.stack);
            }
        }
        else {
            if (!(pTweening.onError)) {
                Tweener.printError(pTweening.scope + " raised an error while executing the '" + pCallBackName + "'handler. \n" + pError.stack);
            }
        }
    };
    Tweener.getCurrentTweeningTime = function (p_tweening) {
        return p_tweening.useFrames ? Tweener._currentTimeFrame : Tweener._currentTime;
    };
    Tweener.getVersion = function () {
        return "JS 0.0.1";
    };
    Tweener.printError = function (p_message) {
        console.log("## [Tweener] Error: " + p_message);
    };
    Tweener._engineExists = false;
    Tweener._inited = false;
    Tweener._timeScale = 1;
    Tweener.autoOverwrite = true;
    return Tweener;
}());
exports.Tweener = Tweener;


/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_38960__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AuxFunctions_1 = __nested_webpack_require_38960__(0);
var TweenListObj = (function () {
    function TweenListObj(p_scope, p_timeStart, p_timeComplete, p_useFrames, p_transition, p_transitionParams) {
        this.scope = p_scope;
        this.timeStart = p_timeStart;
        this.timeComplete = p_timeComplete;
        this.useFrames = p_useFrames;
        this.transition = p_transition;
        this.transitionParams = p_transitionParams;
        this.properties = new Object();
        this.isPaused = false;
        this.timePaused = undefined;
        this.isCaller = false;
        this.updatesSkipped = 0;
        this.timesCalled = 0;
        this.skipUpdates = 0;
        this.hasStarted = false;
    }
    TweenListObj.prototype.clone = function (omitEvents) {
        var nTween = new TweenListObj(this.scope, this.timeStart, this.timeComplete, this.useFrames, this.transition, this.transitionParams);
        nTween.properties = new Array();
        for (var pName in this.properties) {
            nTween.properties[pName] = this.properties[pName].clone();
        }
        nTween.skipUpdates = this.skipUpdates;
        nTween.updatesSkipped = this.updatesSkipped;
        if (!omitEvents) {
            nTween.onStart = this.onStart;
            nTween.onUpdate = this.onUpdate;
            nTween.onComplete = this.onComplete;
            nTween.onOverwrite = this.onOverwrite;
            nTween.onError = this.onError;
            nTween.onStartParams = this.onStartParams;
            nTween.onUpdateParams = this.onUpdateParams;
            nTween.onCompleteParams = this.onCompleteParams;
            nTween.onOverwriteParams = this.onOverwriteParams;
            nTween.onStartScope = this.onStartScope;
            nTween.onUpdateScope = this.onUpdateScope;
            nTween.onCompleteScope = this.onCompleteScope;
            nTween.onOverwriteScope = this.onOverwriteScope;
            nTween.onErrorScope = this.onErrorScope;
        }
        nTween.rounded = this.rounded;
        nTween.isPaused = this.isPaused;
        nTween.timePaused = this.timePaused;
        nTween.isCaller = this.isCaller;
        nTween.count = this.count;
        nTween.timesCalled = this.timesCalled;
        nTween.waitFrames = this.waitFrames;
        nTween.hasStarted = this.hasStarted;
        return nTween;
    };
    TweenListObj.prototype.toString = function () {
        var returnStr = "\n[TweenListObj ";
        returnStr += "scope:" + this.scope;
        returnStr += ", properties:";
        var isFirst = true;
        for (var i in this.properties) {
            if (!isFirst)
                returnStr += ",";
            returnStr += "[name:" + this.properties[i].name;
            returnStr += ",valueStart:" + this.properties[i].valueStart;
            returnStr += ",valueComplete:" + this.properties[i].valueComplete;
            returnStr += "]";
            isFirst = false;
        }
        returnStr += ", timeStart:" + this.timeStart;
        returnStr += ", timeComplete:" + this.timeComplete;
        returnStr += ", useFrames:" + this.useFrames;
        returnStr += ", transition:" + this.transition;
        returnStr += ", transitionParams:" + this.transitionParams;
        if (this.skipUpdates)
            returnStr += ", skipUpdates:" + this.skipUpdates;
        if (this.updatesSkipped)
            returnStr += ", updatesSkipped:" + this.updatesSkipped;
        if (this.onStart !== null)
            returnStr += ", onStart:" + this.onStart;
        if (this.onUpdate !== null)
            returnStr += ", onUpdate:" + this.onUpdate;
        if (this.onComplete !== null)
            returnStr += ", onComplete:" + this.onComplete;
        if (this.onOverwrite !== null)
            returnStr += ", onOverwrite:" + this.onOverwrite;
        if (this.onError !== null)
            returnStr += ", onError:" + this.onError;
        if (this.onStartParams)
            returnStr += ", onStartParams:" + this.onStartParams;
        if (this.onUpdateParams)
            returnStr += ", onUpdateParams:" + this.onUpdateParams;
        if (this.onCompleteParams)
            returnStr += ", onCompleteParams:" + this.onCompleteParams;
        if (this.onOverwriteParams)
            returnStr += ", onOverwriteParams:" + this.onOverwriteParams;
        if (this.onStartScope)
            returnStr += ", onStartScope:" + this.onStartScope;
        if (this.onUpdateScope)
            returnStr += ", onUpdateScope:" + this.onUpdateScope;
        if (this.onCompleteScope)
            returnStr += ", onCompleteScope:" + this.onCompleteScope;
        if (this.onOverwriteScope)
            returnStr += ", onOverwriteScope:" + this.onOverwriteScope;
        if (this.onErrorScope)
            returnStr += ", onErrorScope:" + this.onErrorScope;
        if (this.rounded)
            returnStr += ", rounded:" + this.rounded;
        if (this.isPaused)
            returnStr += ", isPaused:" + this.isPaused;
        if (this.timePaused)
            returnStr += ", timePaused:" + this.timePaused;
        if (this.isCaller)
            returnStr += ", isCaller:" + this.isCaller;
        if (this.count)
            returnStr += ", count:" + this.count;
        if (this.timesCalled)
            returnStr += ", timesCalled:" + this.timesCalled;
        if (this.waitFrames)
            returnStr += ", waitFrames:" + this.waitFrames;
        if (this.hasStarted)
            returnStr += ", hasStarted:" + this.hasStarted;
        returnStr += "]\n";
        return returnStr;
    };
    TweenListObj.makePropertiesChain = function (p_obj) {
        var baseObject = p_obj.base;
        if (baseObject) {
            var chainedObject = {};
            var chain = void 0;
            if (baseObject instanceof Array) {
                chain = [];
                for (var k = 0; k < baseObject.length; k++)
                    chain.push(baseObject[k]);
            }
            else {
                chain = [baseObject];
            }
            chain.push(p_obj);
            var currChainObj = void 0;
            var len = chain.length;
            for (var i = 0; i < len; i++) {
                if (chain[i]["base"]) {
                    currChainObj = AuxFunctions_1.AuxFunctions.concatObjects(this.makePropertiesChain(chain[i]["base"]), chain[i]);
                }
                else {
                    currChainObj = chain[i];
                }
                chainedObject = AuxFunctions_1.AuxFunctions.concatObjects(chainedObject, currChainObj);
            }
            if (chainedObject["base"]) {
                delete chainedObject["base"];
            }
            return chainedObject;
        }
        else {
            return p_obj;
        }
    };
    return TweenListObj;
}());
exports.TweenListObj = TweenListObj;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var PropertyInfoObj = (function () {
    function PropertyInfoObj(p_valueStart, p_valueComplete, p_originalValueComplete, p_arrayIndex, p_extra, p_isSpecialProperty, p_modifierFunction, p_modifierParameters) {
        this.valueStart = p_valueStart;
        this.valueComplete = p_valueComplete;
        this.originalValueComplete = p_originalValueComplete;
        this.arrayIndex = p_arrayIndex;
        this.extra = p_extra;
        this.isSpecialProperty = p_isSpecialProperty;
        this.hasModifier = (p_modifierFunction != null);
        this.modifierFunction = p_modifierFunction;
        this.modifierParameters = p_modifierParameters;
    }
    PropertyInfoObj.prototype.clone = function () {
        var nProperty = new PropertyInfoObj(this.valueStart, this.valueComplete, this.originalValueComplete, this.arrayIndex, this.extra, this.isSpecialProperty, this.modifierFunction, this.modifierParameters);
        return nProperty;
    };
    PropertyInfoObj.prototype.toString = function () {
        var returnStr = "\n[PropertyInfoObj ";
        returnStr += "valueStart:" + this.valueStart;
        returnStr += ", ";
        returnStr += "valueComplete:" + this.valueComplete;
        returnStr += ", ";
        returnStr += "originalValueComplete:" + this.originalValueComplete;
        returnStr += ", ";
        returnStr += "arrayIndex:" + this.arrayIndex;
        returnStr += ", ";
        returnStr += "extra:" + this.extra;
        returnStr += ", ";
        returnStr += "isSpecialProperty:" + this.isSpecialProperty;
        returnStr += ", ";
        returnStr += "hasModifier:" + this.hasModifier;
        returnStr += ", ";
        returnStr += "modifierFunction:" + this.modifierFunction;
        returnStr += ", ";
        returnStr += "modifierParameters:" + this.modifierParameters;
        returnStr += "]\n";
        return returnStr;
    };
    return PropertyInfoObj;
}());
exports.PropertyInfoObj = PropertyInfoObj;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SpecialPropertySplitter = (function () {
    function SpecialPropertySplitter(p_splitFunction, p_parameters) {
        this.splitValues = p_splitFunction;
        this.parameters = p_parameters;
    }
    SpecialPropertySplitter.prototype.toString = function () {
        var value = "";
        value += "[SpecialPropertySplitter ";
        value += "splitValues:" + this.splitValues;
        value += ", ";
        value += "parameters:" + this.parameters;
        value += "]";
        return value;
    };
    return SpecialPropertySplitter;
}());
exports.SpecialPropertySplitter = SpecialPropertySplitter;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_49032__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Tweener_1 = __nested_webpack_require_49032__(1);
var Equations = (function () {
    function Equations() {
        throw new Error("Equations is a static class and should not be instantiated.");
    }
    Equations.init = function () {
        Tweener_1.Tweener.registerTransition("easenone", Equations.easeNone);
        Tweener_1.Tweener.registerTransition("linear", Equations.easeNone);
        Tweener_1.Tweener.registerTransition("easeinquad", Equations.easeInQuad);
        Tweener_1.Tweener.registerTransition("easeoutquad", Equations.easeOutQuad);
        Tweener_1.Tweener.registerTransition("easeinoutquad", Equations.easeInOutQuad);
        Tweener_1.Tweener.registerTransition("easeoutinquad", Equations.easeOutInQuad);
        Tweener_1.Tweener.registerTransition("easeincubic", Equations.easeInCubic);
        Tweener_1.Tweener.registerTransition("easeoutcubic", Equations.easeOutCubic);
        Tweener_1.Tweener.registerTransition("easeinoutcubic", Equations.easeInOutCubic);
        Tweener_1.Tweener.registerTransition("easeoutincubic", Equations.easeOutInCubic);
        Tweener_1.Tweener.registerTransition("easeinquart", Equations.easeInQuart);
        Tweener_1.Tweener.registerTransition("easeoutquart", Equations.easeOutQuart);
        Tweener_1.Tweener.registerTransition("easeinoutquart", Equations.easeInOutQuart);
        Tweener_1.Tweener.registerTransition("easeoutinquart", Equations.easeOutInQuart);
        Tweener_1.Tweener.registerTransition("easeinquint", Equations.easeInQuint);
        Tweener_1.Tweener.registerTransition("easeoutquint", Equations.easeOutQuint);
        Tweener_1.Tweener.registerTransition("easeinoutquint", Equations.easeInOutQuint);
        Tweener_1.Tweener.registerTransition("easeoutinquint", Equations.easeOutInQuint);
        Tweener_1.Tweener.registerTransition("easeinsine", Equations.easeInSine);
        Tweener_1.Tweener.registerTransition("easeoutsine", Equations.easeOutSine);
        Tweener_1.Tweener.registerTransition("easeinoutsine", Equations.easeInOutSine);
        Tweener_1.Tweener.registerTransition("easeoutinsine", Equations.easeOutInSine);
        Tweener_1.Tweener.registerTransition("easeincirc", Equations.easeInCirc);
        Tweener_1.Tweener.registerTransition("easeoutcirc", Equations.easeOutCirc);
        Tweener_1.Tweener.registerTransition("easeinoutcirc", Equations.easeInOutCirc);
        Tweener_1.Tweener.registerTransition("easeoutincirc", Equations.easeOutInCirc);
        Tweener_1.Tweener.registerTransition("easeinexpo", Equations.easeInExpo);
        Tweener_1.Tweener.registerTransition("easeoutexpo", Equations.easeOutExpo);
        Tweener_1.Tweener.registerTransition("easeinoutexpo", Equations.easeInOutExpo);
        Tweener_1.Tweener.registerTransition("easeoutinexpo", Equations.easeOutInExpo);
        Tweener_1.Tweener.registerTransition("easeinelastic", Equations.easeInElastic);
        Tweener_1.Tweener.registerTransition("easeoutelastic", Equations.easeOutElastic);
        Tweener_1.Tweener.registerTransition("easeinoutelastic", Equations.easeInOutElastic);
        Tweener_1.Tweener.registerTransition("easeoutinelastic", Equations.easeOutInElastic);
        Tweener_1.Tweener.registerTransition("easeinback", Equations.easeInBack);
        Tweener_1.Tweener.registerTransition("easeoutback", Equations.easeOutBack);
        Tweener_1.Tweener.registerTransition("easeinoutback", Equations.easeInOutBack);
        Tweener_1.Tweener.registerTransition("easeoutinback", Equations.easeOutInBack);
        Tweener_1.Tweener.registerTransition("easeinbounce", Equations.easeInBounce);
        Tweener_1.Tweener.registerTransition("easeoutbounce", Equations.easeOutBounce);
        Tweener_1.Tweener.registerTransition("easeinoutbounce", Equations.easeInOutBounce);
        Tweener_1.Tweener.registerTransition("easeoutinbounce", Equations.easeOutInBounce);
    };
    Equations.easeNone = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * t / d + b;
    };
    Equations.easeInQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t + b;
    };
    Equations.easeOutQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * (t /= d) * (t - 2) + b;
    };
    Equations.easeInOutQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t + b;
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
    };
    Equations.easeOutInQuad = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutQuad(t * 2, b, c / 2, d, p_params);
        return Equations.easeInQuad((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t * t + b;
    };
    Equations.easeOutCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * ((t = t / d - 1) * t * t + 1) + b;
    };
    Equations.easeInOutCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t + b;
        return c / 2 * ((t -= 2) * t * t + 2) + b;
    };
    Equations.easeOutInCubic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutCubic(t * 2, b, c / 2, d, p_params);
        return Equations.easeInCubic((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t * t * t + b;
    };
    Equations.easeOutQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    };
    Equations.easeInOutQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t * t + b;
        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    };
    Equations.easeOutInQuart = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutQuart(t * 2, b, c / 2, d, p_params);
        return Equations.easeInQuart((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * (t /= d) * t * t * t * t + b;
    };
    Equations.easeOutQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    };
    Equations.easeInOutQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t * t * t + b;
        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    };
    Equations.easeOutInQuint = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutQuint(t * 2, b, c / 2, d, p_params);
        return Equations.easeInQuint((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    };
    Equations.easeOutSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    };
    Equations.easeInOutSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    };
    Equations.easeOutInSine = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutSine(t * 2, b, c / 2, d, p_params);
        return Equations.easeInSine((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
    };
    Equations.easeOutExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return (t == d) ? b + c : c * 1.001 * (-Math.pow(2, -10 * t / d) + 1) + b;
    };
    Equations.easeInOutExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if (t == d)
            return b + c;
        if ((t /= d / 2) < 1)
            return c / 2 * Math.pow(2, 10 * (t - 1)) + b - c * 0.0005;
        return c / 2 * 1.0005 * (-Math.pow(2, -10 * --t) + 2) + b;
    };
    Equations.easeOutInExpo = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutExpo(t * 2, b, c / 2, d, p_params);
        return Equations.easeInExpo((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    };
    Equations.easeOutCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    };
    Equations.easeInOutCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d / 2) < 1)
            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    };
    Equations.easeOutInCirc = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutCirc(t * 2, b, c / 2, d, p_params);
        return Equations.easeInCirc((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        var p = !Boolean(p_params) || isNaN(p_params.period) ? d * .3 : p_params.period;
        var s;
        var a = !Boolean(p_params) || isNaN(p_params.amplitude) ? 0 : p_params.amplitude;
        if (!Boolean(a) || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    };
    Equations.easeOutElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        var p = !Boolean(p_params) || isNaN(p_params.period) ? d * .3 : p_params.period;
        var s;
        var a = !Boolean(p_params) || isNaN(p_params.amplitude) ? 0 : p_params.amplitude;
        if (!Boolean(a) || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
    };
    Equations.easeInOutElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t == 0)
            return b;
        if ((t /= d / 2) == 2)
            return b + c;
        var p = !Boolean(p_params) || isNaN(p_params.period) ? d * (.3 * 1.5) : p_params.period;
        var s;
        var a = !Boolean(p_params) || isNaN(p_params.amplitude) ? 0 : p_params.amplitude;
        if (!Boolean(a) || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        if (t < 1)
            return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
    };
    Equations.easeOutInElastic = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutElastic(t * 2, b, c / 2, d, p_params);
        return Equations.easeInElastic((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        var s = !Boolean(p_params) || isNaN(p_params.overshoot) ? 1.70158 : p_params.overshoot;
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    };
    Equations.easeOutBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        var s = !Boolean(p_params) || isNaN(p_params.overshoot) ? 1.70158 : p_params.overshoot;
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    };
    Equations.easeInOutBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        var s = !Boolean(p_params) || isNaN(p_params.overshoot) ? 1.70158 : p_params.overshoot;
        if ((t /= d / 2) < 1)
            return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    };
    Equations.easeOutInBack = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutBack(t * 2, b, c / 2, d, p_params);
        return Equations.easeInBack((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    Equations.easeInBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        return c - Equations.easeOutBounce(d - t, 0, c, d) + b;
    };
    Equations.easeOutBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if ((t /= d) < (1 / 2.75)) {
            return c * (7.5625 * t * t) + b;
        }
        else if (t < (2 / 2.75)) {
            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
        }
        else if (t < (2.5 / 2.75)) {
            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
        }
        else {
            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        }
    };
    Equations.easeInOutBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeInBounce(t * 2, 0, c, d) * .5 + b;
        else
            return Equations.easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
    };
    Equations.easeOutInBounce = function (t, b, c, d, p_params) {
        if (p_params === void 0) { p_params = null; }
        if (t < d / 2)
            return Equations.easeOutBounce(t * 2, b, c / 2, d, p_params);
        return Equations.easeInBounce((t * 2) - d, b + c / 2, c / 2, d, p_params);
    };
    return Equations;
}());
exports.Equations = Equations;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SpecialProperty = (function () {
    function SpecialProperty(p_getFunction, p_setFunction, p_parameters, p_preProcessFunction) {
        if (p_parameters === void 0) { p_parameters = null; }
        if (p_preProcessFunction === void 0) { p_preProcessFunction = null; }
        this.getValue = p_getFunction;
        this.setValue = p_setFunction;
        this.parameters = p_parameters;
        this.preProcess = p_preProcessFunction;
    }
    SpecialProperty.prototype.toString = function () {
        var value = "";
        value += "[SpecialProperty ";
        value += "getValue:" + this.getValue;
        value += ", ";
        value += "setValue:" + this.setValue;
        value += ", ";
        value += "parameters:" + this.parameters;
        value += ", ";
        value += "preProcess:" + this.preProcess;
        value += "]";
        return value;
    };
    return SpecialProperty;
}());
exports.SpecialProperty = SpecialProperty;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SpecialPropertyModifier = (function () {
    function SpecialPropertyModifier(p_modifyFunction, p_getFunction) {
        this.modifyValues = p_modifyFunction;
        this.getValue = p_getFunction;
    }
    SpecialPropertyModifier.prototype.toString = function () {
        var value = "";
        value += "[SpecialPropertyModifier ";
        value += "modifyValues:" + this.modifyValues;
        value += ", ";
        value += "getValue:" + this.getValue;
        value += "]";
        return value;
    };
    return SpecialPropertyModifier;
}());
exports.SpecialPropertyModifier = SpecialPropertyModifier;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_67167__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Tweener_1 = __nested_webpack_require_67167__(1);
exports.Tweener = Tweener_1.Tweener;
var TweenListObj_1 = __nested_webpack_require_67167__(2);
exports.TweenListObj = TweenListObj_1.TweenListObj;
var PropertyInfoObject_1 = __nested_webpack_require_67167__(3);
exports.PropertyInfoObj = PropertyInfoObject_1.PropertyInfoObj;
var AuxFunctions_1 = __nested_webpack_require_67167__(0);
exports.AuxFunctions = AuxFunctions_1.AuxFunctions;
var SpecialPropertySplitter_1 = __nested_webpack_require_67167__(4);
exports.SpecialPropertySplitter = SpecialPropertySplitter_1.SpecialPropertySplitter;
var Equations_1 = __nested_webpack_require_67167__(5);
exports.Equations = Equations_1.Equations;
var SpecialProperty_1 = __nested_webpack_require_67167__(6);
exports.SpecialProperty = SpecialProperty_1.SpecialProperty;
var SpecialPropertyModifier_1 = __nested_webpack_require_67167__(7);
exports.SpecialPropertyModifier = SpecialPropertyModifier_1.SpecialPropertyModifier;


/***/ })
/******/ ]);
});
//# sourceMappingURL=engineTween.js.map

/***/ }),

/***/ 42634:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 86425:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Axios v1.7.7 Copyright (c) 2024 Matt Zabriskie and contributors


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : __webpack_require__.g)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************

var utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

// eslint-disable-next-line strict
var httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

var InterceptorManager$1 = InterceptorManager;

var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

var platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: hasStandardBrowserEnv,
  navigator: _navigator,
  origin: origin
});

var platform = {
  ...utils,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data) ||
      utils$1.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

var defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$1.isString(value)) return;

  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$1.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$1.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$1.freezeMethods(AxiosHeaders);

var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

var isURLSameOrigin = platform.hasStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

var cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

var resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders$1.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils$1.asap(unsubscribe);

    return signal;
  }
};

var composeSignals$1 = composeSignals;

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$1.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$1.isBlob(body)) {
    return body.size;
  }

  if(utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$1.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

var fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

var adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const VERSION = "1.7.7";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;

        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$1.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

module.exports = axios;
//# sourceMappingURL=axios.cjs.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(61072);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=game.bundle.js.map